#!/usr/bin/env bash

# ===========================================================================
# GLOBALS
# ===========================================================================
# Don't change any globals

# The initial state of the parser
STATE="COMMAND"

# Parser sets these:
COMMAND=
SUBCOMMAND=
CREATE_CLUSTER_NAME=
declare -i CREATE_CLUSTER_NUM_MASTERS=
declare -i CREATE_CLUSTER_NUM_WORKERS=
DELETE_CLUSTER_NAME=

# Directory to unpack the build files
DOCKERBUILDTMPDIR=

# For the spinning progress animation
RUNWITHPROGRESS_OUTPUT=

# Constants
declare -r LABELKEY="MokCluster"
declare -r BASEIMAGENAME="mok-centos-7"
declare -r ERROR=1
declare -r OK=0
declare -r SPINNER=('◐' '◓' '◑' '◒')
declare -r colgreen=`tput setaf 2`
declare -r colred=`tput setaf 1`
declare -r colreset=`tput sgr0`
declare -r success="$colgreen✓$colreset"
declare -r failure="$colred✕$colreset"

# ===========================================================================
main() {
# ===========================================================================
# Execution begins here

  trap cleanup EXIT

  sanity_checks || return $?

  parse_options "$@" || return $?

  case "$COMMAND" in
    create) do_create ;;
    delete) do_delete ;;
    build)  do_build ;;
  esac
}

# ===========================================================================
# MOKCTL BUILD
# ===========================================================================

# ---------------------------------------------------------------------------
do_build() {
# ---------------------------------------------------------------------------
# Calls the correct command/subcommand function

  case $SUBCOMMAND in
    image) do_build_image_sanity_checks || return $?
           do_build_image_mutate
           ;;
  esac
}

# ---------------------------------------------------------------------------
do_build_image_sanity_checks() {
# ---------------------------------------------------------------------------
# No sanity checks required.
# Globals: None
# No args expected

  :
}

# ===========================================================================
# MOKCTL CREATE
# ===========================================================================

# ---------------------------------------------------------------------------
do_create() {
# ---------------------------------------------------------------------------
# Calls the correct command/subcommand function

  case $SUBCOMMAND in
    cluster) do_create_cluster_sanity_checks || return $?
             do_create_cluster_mutate
             ;;
  esac
}

# ---------------------------------------------------------------------------
do_create_cluster_sanity_checks() {
# ---------------------------------------------------------------------------
# Creates a mok cluster. All user vars have been parsed and saved.
# Globals: CREATE_CLUSTER_NAME CREATE_CLUSTER_NUM_MASTERS
#          CREATE_CLUSTER_NUM_WORKERS
# No args expected

  if [[ -z $CREATE_CLUSTER_NAME ]]; then
    usage
    echo "Please provide the Cluster NAME to create."
    return $ERROR
  fi

  if [[ -z $CREATE_CLUSTER_NUM_MASTERS || $CREATE_CLUSTER_NUM_MASTERS -le 0 ]]; then
    usage
    echo "Please provide the number of Masters to create. Must be 1 or more."
    return $ERROR
  fi

  if [[ -z $CREATE_CLUSTER_NUM_WORKERS ]]; then
    usage
    echo "Please provide the number of Workers to create."
    return $ERROR
  fi
}

# ===========================================================================
# MOKCTL DELETE
# ===========================================================================

# ---------------------------------------------------------------------------
do_delete() {
# ---------------------------------------------------------------------------
# Calls the correct command/subcommand function
# No args expected

  case $SUBCOMMAND in
    cluster) do_delete_cluster_sanity_checks || return $?
             do_delete_cluster_mutate
             ;;
  esac
}

# ---------------------------------------------------------------------------
do_delete_cluster_sanity_checks() {
# ---------------------------------------------------------------------------
# Deletes a mok cluster. All user vars have been parsed and saved.
# Globals: DELETE_CLUSTER_NAME
# No args expected

  if [[ -z $DELETE_CLUSTER_NAME ]]; then
    usage
    echo "Please provide the Cluster NAME to delete."
    return $ERROR
  fi
}

# ===========================================================================
#                                MUTATIONS
#                FUNCTIONS IN THIS SECTION CHANGE SYSTEM STATE
# ===========================================================================

# ---------------------------------------------------------------------------
do_create_cluster_mutate() {
# ---------------------------------------------------------------------------
# Mutate functions make system changes.
# Global variables: 
#   CREATE_CLUSTER_NAME        - (string) cluster name
#   CREATE_CLUSTER_NUM_MASTERS - (int) num masters
#   CREATE_CLUSTER_NUM_WORKERS - (int) num workers

  declare -i numnodes=0

  numnodes=$(get_cluster_size $CREATE_CLUSTER_NAME) || return $?

  [[ $numnodes -gt 0 ]] && {
    echo
    echo "ERROR: Cluster, '$CREATE_CLUSTER_NAME', exists! Aborting."
    echo
    return $ERROR
  }

  [[ $CREATE_CLUSTER_NUM_MASTERS -gt 0 ]] && {
    create_master_nodes $CREATE_CLUSTER_NUM_MASTERS || return $?
  }

  [[ $CREATE_CLUSTER_NUM_WORKERS -gt 0 ]] && {
    create_worker_nodes $CREATE_CLUSTER_NUM_WORKERS || return $?
  }

  return $OK
}

# ---------------------------------------------------------------------------
do_delete_cluster_mutate() {
# ---------------------------------------------------------------------------
# Mutate functions make system changes.

  :

  # Delete master node(s)

  # Delete worker node(s)
}

# ---------------------------------------------------------------------------
do_build_image_mutate() {
# ---------------------------------------------------------------------------
# Mutate functions make system changes.
# Builds the $BASEIMAGENAME base image used for masters and workers.
# Globals: None
# No args expected

  local retval=0

  build_container_image
  retval=$?

  if [[ $retval -eq 0 ]]; then
    : # We only need the tick
  else
    echo "Image build failed"
  fi

  return $retval
}

# ===========================================================================
# FUNCTIONS BELOW ARE HELPERS FOR do_create_cluster_mutate()
# ===========================================================================

# ---------------------------------------------------------------------------
get_cluster_size() {
# ---------------------------------------------------------------------------
# Search for an existing cluster using labels. All cluster nodes are
# labelled with $LABELKEY=$CREATE_CLUSTER_NAME
# Args:
#   arg1 - name to search for.

  declare -a nodes

  readarray nodes < <(docker ps -a -f label=$LABELKEY=$1 -q) || return $?

  echo "${#nodes[*]}"
}

# ---------------------------------------------------------------------------
create_master_nodes() {
# ---------------------------------------------------------------------------
# Create the master nodes
# Args:
#   arg1 - number of master nodes to create

  declare -i i=0
  local retval=0

  for i in $(seq 1 $1); do
    run_with_progress \
      "    Creating base container, '$CREATE_CLUSTER_NAME-master-$i'" \
      docker run --privileged \
          -v /sys/fs/cgroup:/sys/fs/cgroup:ro \
          -v /lib/modules:/lib/modules:ro \
          --tmpfs /run --tmpfs /tmp \
          --detach \
          --name $CREATE_CLUSTER_NAME-master-$i \
          --hostname $CREATE_CLUSTER_NAME-master-$i \
          --label $LABELKEY=$CREATE_CLUSTER_NAME \
          local/$BASEIMAGENAME

    retval=$?
    [[ $retval -ne 0 ]] && {
      echo "ERROR: Docker returned an error, shown below"
      echo
      cat $RUNWITHPROGRESS_OUTPUT
      rm $RUNWITHPROGRESS_OUTPUT
      echo
      return $ERROR
    }
  done

  return $retval
}

# ---------------------------------------------------------------------------
create_worker_nodes() {
# ---------------------------------------------------------------------------
# Create the master nodes
# Args:
#   arg1 - number of master nodes to create

  declare -i i=0
  local retval=0

  for i in $(seq 1 $1); do
    run_with_progress \
      "    Creating base container, '$CREATE_CLUSTER_NAME-worker-$i'" \
      docker run --privileged \
          -v /sys/fs/cgroup:/sys/fs/cgroup:ro \
          -v /lib/modules:/lib/modules:ro \
          --tmpfs /run --tmpfs /tmp \
          --detach \
          --name $CREATE_CLUSTER_NAME-worker-$i \
          --hostname $CREATE_CLUSTER_NAME-worker-$i \
          --label $LABELKEY=$CREATE_CLUSTER_NAME \
          local/$BASEIMAGENAME

    retval=$?
    [[ $retval -ne 0 ]] && {
      echo "ERROR: Docker returned an error, shown below"
      echo
      cat $RUNWITHPROGRESS_OUTPUT
      rm $RUNWITHPROGRESS_OUTPUT
      echo
      return $ERROR
    }
  done

  return $retval
}

# ===========================================================================
# FUNCTIONS BELOW ARE HELPERS FOR do_delete_cluster_mutate()
# ===========================================================================

# ===========================================================================
# FUNCTIONS BELOW ARE HELPERS FOR do_build_image_mutate()
# ===========================================================================

# ---------------------------------------------------------------------------
build_container_image() {
# ---------------------------------------------------------------------------
# Creates the docker build directory in $DOCKERBUILDTMPDIR then calls
# docker build to build the image.
# No args expected.

  create_docker_build_dir

  run_with_progress \
      "    Creating base image, '$BASEIMAGENAME'" \
      docker build -t "local/$BASEIMAGENAME" "$DOCKERBUILDTMPDIR/$BASEIMAGENAME"
  
  retval=$?
  [[ $retval -ne 0 ]] && {
    echo "ERROR: Docker returned an error, shown below"
    echo
    cat $RUNWITHPROGRESS_OUTPUT
    echo
    return $ERROR
  }

  return $retval
}

# ---------------------------------------------------------------------------
create_docker_build_dir() {
# ---------------------------------------------------------------------------
# Creates a docker build directory in /var/tmp/tmp.XXXXXXXX
# No args expected

  DOCKERBUILDTMPDIR=`mktemp -d --tmpdir=/var/tmp`

  # The following comments should not be removed or changed.
  # embed-dockerfile.sh adds a base64 encoded tarball and
  #  unpacking code between them.

  #mok-centos-7-tarball-start 
  cat <<EnD | base64 -d | tar xz -C $DOCKERBUILDTMPDIR 
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
Fm3RvpH2P+btZ/wAUAAA
EnD
  #mok-centos-7-tarball-end
}

# ===========================================================================
# FUNCTIONS FOR PARSING THE COMMAND LINE BELOW
# ===========================================================================

# ---------------------------------------------------------------------------
parse_options() {
# ---------------------------------------------------------------------------
# Uses a state machine to check all command line arguments
# Args:
#   arg1 - The arguments given to mokctl by the user on the command line

  set -- "$@"
  local ARGN=$#
  while [ "$ARGN" -ne 0 ]
  do
    case $1 in
      -h) usage
          return $OK
      ;;
      ?*) case "$STATE" in
            COMMAND) check_command_token $1
                   [[ $? -eq $ERROR ]] && {
                     usage
                     echo "Invalid COMMAND, '$1'."
                     echo
                     return $ERROR
                   }
                   COMMAND="$1"
                 ;;
            SUBCOMMAND) check_subcommand_token $1
                   [[ $? -eq $ERROR ]] && {
                     usage
                     echo "Invalid SUBCOMMAND for $COMMAND, '$1'."
                     echo
                     return $ERROR
                   }
                   SUBCOMMAND="$1"
                 ;;
            OPTION) check_option_token $1
                   [[ $? -eq $ERROR ]] && {
                     usage
                     echo "Invalid OPTION for $COMMAND $SUBCOMMAND, '$1'."
                     echo
                     return $ERROR
                   }
                 ;;
            OPTION2) check_option2_token $1
                   [[ $? -eq $ERROR ]] && {
                     usage
                     echo "Invalid OPTION for $COMMAND $SUBCOMMAND, '$1'."
                     echo
                     return $ERROR
                   }
                 ;;
            OPTION3) check_option3_token $1
                   [[ $? -eq $ERROR ]] && {
                     usage
                     echo "Invalid OPTION for $COMMAND $SUBCOMMAND, '$1'."
                     echo
                     return $ERROR
                   }
                 ;;
            END) usage
                 echo -n "ERROR No more options expected, '$1' is unexpected"
                 echo " for '$COMMAND $SUBCOMMAND'"
                 return $ERROR
                 ;;
            ?*) echo "Internal ERROR. Invalid state '$STATE'"
                return $ERROR
          esac
      ;;
    esac
    shift 1
    ARGN=$((ARGN-1))
  done

  [[ -z $COMMAND ]] && {
    usage
    echo "No COMMAND supplied"
    return $ERROR
  }
  [[ -z $SUBCOMMAND ]] && {
    usage
    echo "No SUBCOMMAND supplied"
    return $ERROR
  }

  return $OK
}

# ---------------------------------------------------------------------------
check_command_token() {
# ---------------------------------------------------------------------------
# Check for a valid token in command state
# Args:
#   arg1 - token

  case $1 in
    create) COMMAND=create
      ;;
    delete) COMMAND=delete
      ;;
    build) COMMAND=build
      ;;
    ?*) return $ERROR
      ;;
  esac
  STATE="SUBCOMMAND"
}

# ---------------------------------------------------------------------------
check_subcommand_token() {
# ---------------------------------------------------------------------------
# Check for a valid token in subcommand state
# Args:
#   arg1 - token

  case $COMMAND in
    create) check_create_subcommand_token $1 ;;
    delete) check_delete_subcommand_token $1 ;;
    build) check_build_subcommand_token $1   ;;
  esac
}

# ---------------------------------------------------------------------------
check_create_subcommand_token() {
# ---------------------------------------------------------------------------
# Check for a valid token in subcommand state
# Args:
#   arg1 - token

  case $1 in
    cluster) SUBCOMMAND="cluster"
      ;;
    ?*) return $ERROR
      ;;
  esac

  STATE="OPTION"

  return $OK
}

# ---------------------------------------------------------------------------
check_delete_subcommand_token() {
# ---------------------------------------------------------------------------
# Check for a valid token in subcommand state
# Args:
#   arg1 - token

  case $1 in
    cluster) SUBCOMMAND="cluster"
      ;;
    ?*) return $ERROR
      ;;
  esac

  STATE=OPTION
}

# ---------------------------------------------------------------------------
check_build_subcommand_token() {
# ---------------------------------------------------------------------------
# Check for a valid token in subcommand state
# Args:
#   arg1 - token

  case $1 in
    image) SUBCOMMAND="image"
      ;;
    ?*) return $ERROR
      ;;
  esac

  STATE=END
}

# ---------------------------------------------------------------------------
check_option_token() {
# ---------------------------------------------------------------------------
# Check for a valid token in option state
# Args:
#   arg1 - token

  case $COMMAND in
    create)
      case $SUBCOMMAND in
        cluster) CREATE_CLUSTER_NAME="$1"
          STATE="OPTION2"
          ;;
      esac
      ;;
    delete)
      case $SUBCOMMAND in
        cluster) DELETE_CLUSTER_NAME="$1"
          STATE="END"
          ;;
      esac
      ;;
  esac
}

# ---------------------------------------------------------------------------
check_option2_token() {
# ---------------------------------------------------------------------------
# Check for a valid token in option2 state
# Args:
#   arg1 - token

  case $COMMAND in
    create)
      case $SUBCOMMAND in
        cluster) CREATE_CLUSTER_NUM_MASTERS="$1"
          STATE="OPTION3"
          ;;
      esac
      ;;
    delete)
      case $SUBCOMMAND in
        cluster) return $ERROR
          ;;
      esac
      ;;
  esac
}

# ---------------------------------------------------------------------------
check_option3_token() {
# ---------------------------------------------------------------------------
# Check for a valid token in option3 state
# Args:
#   arg1 - token

  case $COMMAND in
    create)
      case $SUBCOMMAND in
        cluster) CREATE_CLUSTER_NUM_WORKERS="$1"
          STATE="END"
          ;;
      esac
      ;;
    delete)
      case $SUBCOMMAND in
        cluster) return $ERROR
          ;;
      esac
      ;;
  esac
}

# ===========================================================================
# HELPERS
# ===========================================================================

# ---------------------------------------------------------------------------
run_with_progress() {
# ---------------------------------------------------------------------------
# Display a progress spinner, display text, display a tick or cross based
# on the exit code.
# Args:
#   arg1 - the text to display
#   argN - remaining args are the program and its arguments

  local displaytext=$1
  declare -g RUNWITHPROGRESS_OUTPUT=`mktemp --tmpdir=/var/tmp`

  shift
  # Run the command
  $@ &>$RUNWITHPROGRESS_OUTPUT &
  # Turn the cursor off
  tput civis

  # Start the spin animation
  echo -n "$displaytext"
  ( while true; do
    for i in {0..3}; do
      echo -en "\r  ${SPINNER[i]} "
      sleep .1
    done
  done ) & 

  # Wait for the command to finish
  wait %1

  retval=$?
  if [[ $retval -eq 0 ]]; then
    echo -e "\r  $success"
  else
    echo -e "\r  $failure"
  fi

  # Kill the spinner
  kill %2
  # Restore the cursor
  tput cnorm

  return $retval
}

# ---------------------------------------------------------------------------
sanity_checks(){
# ---------------------------------------------------------------------------
# Check our environment
# No args expected

  for binary in tput docker grep sed; do
    if ! which $binary >& /dev/null; then
      echo "ERROR: $binary binary not found in path. Aborting."
      return 1
    fi
  done
}

# ---------------------------------------------------------------------------
usage() {
# ---------------------------------------------------------------------------
# Every tool, no matter how small, should have help text!

  echo
  echo "Usage: mokctl [-h] <COMMAND> <SUBCOMMAND> [SUBCOMMAND_OPTIONS...]"
  echo
  echo "Global options:"
  echo
  echo "  -h - This help text"
  echo
  echo "Where COMMAND can be one of:"
  echo
  echo "  create"
  echo "  delete"
  echo "  build"
  echo
  echo "create SUBCOMMANDs:"
  echo
  echo "  cluster - Create a local kubernetes cluster."
  echo
  echo "create cluster options:"
  echo
  echo " Format:"
  echo "  create cluster NAME NUM_MASTERS NUM_WORKERS"
  echo "  NAME        - The name of the cluster. This will be used as"
  echo "                the prefix in the name for newly created"
  echo "                docker containers."
  echo "  NUM_MASTERS - The number of master containers."
  echo "  NUM_WORKERS - The number of worker containers."
  echo
  echo "delete SUBCOMMANDs:"
  echo
  echo "  cluster - Create a local kubernetes cluster."
  echo
  echo "delete cluster options:"
  echo
  echo " Format:"
  echo "  delete cluster NAME"
  echo "  NAME        - The name of the cluster to delete"
  echo
  echo "build SUBCOMMANDs:"
  echo
  echo "  image - Creates the $BASEIMAGENAME base image."
  echo
  echo "build image options:"
  echo
  echo " Format:"
  echo "  build image"
  echo
  echo "EXAMPLES"
  echo
  echo "Build the image used for masters and workers:"
  echo
  echo "  mokctl build image"
  echo
  echo "Create a single node cluster:"
  echo "Note that the master node will be made schedulable for pods."
  echo
  echo "  mokctl create cluster mycluster 1 0"
  echo
  echo "Create a single master and single node cluster:"
  echo "Note that the master node will NOT be schedulable for pods."
  echo
  echo "  mokctl create cluster mycluster 1 1"
  echo
  echo "Delete a cluster:"
  echo
  echo "  mokctl delete cluster mycluster"
  echo
}

# ---------------------------------------------------------------------------
cleanup() {
# ---------------------------------------------------------------------------
# Called when the script exits.

  [[ -e "$DOCKERBUILDTMPDIR" ]] && \
    [[ $DOCKERBUILDTMPDIR == "/var/tmp/"* ]] && {
    rm -rf "$DOCKERBUILDTMPDIR"
  }

  # If progress spinner crashed make sure the cursor is shown
  tput cnorm

  # Kill the spinny, and anything else, if they're running
  for i in `jobs -p`; do kill $i; echo -e "$colred\r  ✕$colreset" ; done
}

# Calls main() if we're called from the command line
if ([ "$0" = "$BASH_SOURCE" ] || ! [ -n "$BASH_SOURCE" ]);
then
  main "$@"
fi

# vim:ft=bash:sw=2:et:ts=2:
