#!/usr/bin/env bash

# ===========================================================================
# GLOBALS
# ===========================================================================
# Don't change any globals

# Constants
readonly LABELKEY="MokCluster"
readonly BASEIMAGENAME="mok-centos-7"
readonly OK=0
readonly ERROR=1
readonly FALSE=0
readonly TRUE=1
readonly STOP=2
readonly SPINNER=('◐' '◓' '◑' '◒')

colgreen=$(tput setaf 2)
colred=$(tput setaf 1)
colreset=$(tput sgr0)
success="$colgreen✓$colreset"
failure="$colred✕$colreset"

# The initial state of the parser
STATE="COMMAND"

# Parser sets these:
COMMAND=
SUBCOMMAND=
CREATE_CLUSTER_NAME=
BUILD_IMAGE_K8SVER=
CREATE_CLUSTER_K8SVER=
CREATE_CLUSTER_WITH_LB=
CREATE_CLUSTER_SKIPLBSETUP=
CREATE_CLUSTER_NUM_MASTERS=
CREATE_CLUSTER_NUM_WORKERS=
CREATE_CLUSTER_SKIPMASTERSETUP=
CREATE_CLUSTER_SKIPWORKERSETUP=
DELETE_CLUSTER_NAME=
GET_CLUSTER_NAME=
GET_CLUSTER_SHOW_HEADER=
EXEC_CONTAINER_NAME=

# For outputting errors
E="/dev/stderr"

# Directory to unpack the build files
DOCKERBUILDTMPDIR=

# For the spinning progress animation
RUNWITHPROGRESS_OUTPUT=

# ---------------------------------------------------------------------------
main() {

  # Execution begins here

  local r=$OK

  trap cleanup EXIT

  set_globals || return

  sanity_checks || return

  parse_options "$@" || r=$?

  if [[ $r -eq $ERROR ]]; then
    return $ERROR
  elif [[ $r -eq $STOP ]]; then
    return $OK
  fi

  case "$COMMAND" in
  create) do_create ;;
  delete) do_delete ;;
  build) do_build ;;
  get) do_get ;;
  exec) do_exec ;;
  esac
}

# ---------------------------------------------------------------------------
set_globals() {

  COMMAND=
  SUBCOMMAND=
  CREATE_CLUSTER_NAME=
  BUILD_IMAGE_K8SVER="1.18.2"
  CREATE_CLUSTER_K8SVER="1.18.2"
  CREATE_CLUSTER_NUM_MASTERS=
  CREATE_CLUSTER_NUM_WORKERS=
  CREATE_CLUSTER_SKIPMASTERSETUP=
  CREATE_CLUSTER_SKIPWORKERSETUP=
  DELETE_CLUSTER_NAME=
  GET_CLUSTER_NAME=
  GET_CLUSTER_SHOW_HEADER=$TRUE
}

# ===========================================================================
# MOKCTL EXEC
# ===========================================================================

# ---------------------------------------------------------------------------
do_exec() {

  do_exec_sanity_checks || return
  do_exec_nomutate "$EXEC_CONTAINER_NAME"
}

# ---------------------------------------------------------------------------
do_exec_sanity_checks() {

  # No sanity checks required.
  # Globals: None
  # No args expected

  :
}

# ===========================================================================
# MOKCTL GET
# ===========================================================================

# ---------------------------------------------------------------------------
do_get() {

  # Calls the correct command/subcommand function

  case $SUBCOMMAND in
  cluster)
    do_get_clusters_sanity_checks || return
    do_get_clusters_nomutate "$GET_CLUSTER_NAME"
    ;;
  esac
}

# ---------------------------------------------------------------------------
do_get_clusters_sanity_checks() {

  # No sanity checks required.
  # Globals: None
  # No args expected

  :
}

# ===========================================================================
# MOKCTL BUILD
# ===========================================================================

# ---------------------------------------------------------------------------
do_build() {

  # Calls the correct command/subcommand function

  case $SUBCOMMAND in
  image)
    do_build_image_sanity_checks || return
    do_build_image_mutate
    ;;
  esac
}

# ---------------------------------------------------------------------------
do_build_image_sanity_checks() {

  # No sanity checks required.
  # Globals: None
  # No args expected

  :
}

# ===========================================================================
# MOKCTL CREATE
# ===========================================================================

# ---------------------------------------------------------------------------
do_create() {

  # Calls the correct command/subcommand function

  case $SUBCOMMAND in
  cluster)
    do_create_cluster_sanity_checks || return
    do_create_cluster_mutate
    ;;
  esac
}

# ---------------------------------------------------------------------------
do_create_cluster_sanity_checks() {

  # Creates a mok cluster. All user vars have been parsed and saved.
  # Globals: CREATE_CLUSTER_NAME CREATE_CLUSTER_NUM_MASTERS
  #          CREATE_CLUSTER_NUM_WORKERS
  # No args expected

  if [[ -z $CREATE_CLUSTER_NAME ]]; then
    usage
    printf 'Please provide the Cluster NAME to create.\n' >"$E"
    return $ERROR
  fi

  if [[ -z $CREATE_CLUSTER_NUM_MASTERS || $CREATE_CLUSTER_NUM_MASTERS -le 0 ]]; then
    usage
    printf 'Please provide the number of Masters to create. Must be 1 or more.\n' >"$E"
    return $ERROR
  fi

  if [[ -z $CREATE_CLUSTER_NUM_WORKERS ]]; then
    usage
    printf 'Please provide the number of Workers to create.\n' >"$E"
    return $ERROR
  fi
}

# ===========================================================================
# MOKCTL DELETE
# ===========================================================================

# ---------------------------------------------------------------------------
do_delete() {

  # Calls the correct command/subcommand function
  # No args expected

  case $SUBCOMMAND in
  cluster)
    do_delete_cluster_sanity_checks || return
    do_delete_cluster_mutate
    ;;
  esac
}

# ---------------------------------------------------------------------------
do_delete_cluster_sanity_checks() {

  # Deletes a mok cluster. All user vars have been parsed and saved.
  # Globals: DELETE_CLUSTER_NAME
  # No args expected

  if [[ -z $DELETE_CLUSTER_NAME ]]; then
    usage
    printf 'Please provide the Cluster NAME to delete.\n' >"$E"
    return $ERROR
  fi
}

# ===========================================================================
#                                MUTATIONS
#                FUNCTIONS IN THIS SECTION CHANGE SYSTEM STATE
# ===========================================================================

# ---------------------------------------------------------------------------
do_create_cluster_mutate() {

  # Mutate functions make system changes.
  # Global variables:
  #   CREATE_CLUSTER_NAME        - (string) cluster name
  #   CREATE_CLUSTER_NUM_MASTERS - (int) num masters
  #   CREATE_CLUSTER_NUM_WORKERS - (int) num workers

  declare -i numnodes=0

  numnodes=$(get_cluster_size $CREATE_CLUSTER_NAME) || return

  [[ $numnodes -gt 0 ]] && {
    printf '\nERROR: Cluster, "%s", exists! Aborting.\n\n' "$CREATE_CLUSTER_NAME" >"$E"
    return $ERROR
  }

  printf '\n'

  [[ $CREATE_CLUSTER_NUM_MASTERS -gt 0 ]] && {
    create_master_nodes $CREATE_CLUSTER_NUM_MASTERS || return
  }

  #[[ -z $CREATE_CLUSTER_SKIPMASTERSETUP ]] && {
  #  # TODO Query the server for all pods ready instead
  #  run_with_progress \
  #    "    Waiting for master to be ready." \
  #    sleep 40
  #}

  [[ $CREATE_CLUSTER_WITH_LB -gt 0 ]] && {
    create_lb_node $CREATE_CLUSTER_NUM_MASTERS || return
  }

  [[ $CREATE_CLUSTER_NUM_WORKERS -gt 0 ]] && {
    create_worker_nodes "$CREATE_CLUSTER_NUM_WORKERS" || return
  }

  printf '\n'

  [[ -z $CREATE_CLUSTER_SKIPMASTERSETUP ]] && {
    printf 'Cluster, "%s", can be accessed using:\n\n' "$CREATE_CLUSTER_NAME"
    printf 'export KUBECONFIG=~/.mok/admin.conf\n\n'
  }

  return $OK
}

# ---------------------------------------------------------------------------
get_cluster_size() {

  # Search for an existing cluster using labels. All cluster nodes are
  # labelled with $LABELKEY=$CREATE_CLUSTER_NAME
  # Args:
  #   arg1 - name to search for.

  local output
  declare -a nodes

  output=$(get_docker_ids_for_cluster "$1") || err || return

  # readarray will read null as an array item so don't run
  # through readarray if it's null
  [[ -z $output ]] && {
    printf '0'
    return $OK
  }

  # read the nodes array and delete blank lines
  readarray -t nodes <<<"$output"

  printf '%d' "${#nodes[*]}"
}

# ---------------------------------------------------------------------------
get_docker_ids_for_cluster() {

  # Get all cluster ids for labelled containers
  # Args:
  #   arg1 - Cluster name

  local value output

  [[ -n $1 ]] && value="=$1"

  output=$(docker ps -a -f label="$LABELKEY$value" -q) || {
    printf 'ERROR: Docker command failed\n\n' >"$E"
    err || return
  }

  output=$(printf '%s' "$output" | sed 's/$//')

  printf '%s' "$output"

  return $OK
}

# ---------------------------------------------------------------------------
create_lb_node() {

  # Create the load balancer nodes
  # Args:

  # Ceate container
  run_with_progress \
    "    Creating LB container, '$CREATE_CLUSTER_NAME-lb'" \
    create_docker_container \
    "$CREATE_CLUSTER_NAME-lb" \
    "$LABELKEY=$CREATE_CLUSTER_NAME"

  # Set up
  [[ -z $CREATE_CLUSTER_SKIPLBSETUP ]] && {
    run_with_progress \
      "    Setting up '$CREATE_CLUSTER_NAME-lb'" \
      set_up_lb_node "$CREATE_CLUSTER_NAME-lb"
    r=$?

    [[ $r -ne 0 ]] && {
      printf '\n' >"$E"
      cat $RUNWITHPROGRESS_OUTPUT >"$E"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"$E"
      printf '%s\n' "$RUNWITHPROGRESS_OUTPUT" >"$E"
      return $ERROR
    }
  }

  return $OK
}

# ---------------------------------------------------------------------------
set_up_lb_node() {

  # Call the correct set up function based on the version
  # Args
  #   arg1 - the container ID to set up

  local setupfile

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"$E"
    return $ERROR
  }

  # Use:
  #get_docker_container_ip ID/NAME

  cat <<'EnD' >"$setupfile"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

systemctl stop kubelet crio
systemctl disable kubelet crio
EnD

  docker cp "$setupfile" "$1":/root/setup.sh || err || {
    rm -f "$setupfile"
    return $ERROR
  }

  docker exec "$1" bash /root/setup.sh || err
}

# ---------------------------------------------------------------------------
create_master_nodes() {

  # Create the master nodes
  # Args:
  #   arg1 - number of master nodes to create

  declare -i int=0 r

  for int in $(seq 1 "$1"); do
    run_with_progress \
      "    Creating master container, '$CREATE_CLUSTER_NAME-master-$int'" \
      create_docker_container \
      "$CREATE_CLUSTER_NAME-master-$int" \
      "$LABELKEY=$CREATE_CLUSTER_NAME"
    r=$?

    [[ $r -ne 0 ]] && {
      printf '\n'
      cat $RUNWITHPROGRESS_OUTPUT >"$E"
      rm $RUNWITHPROGRESS_OUTPUT
      printf '\nERROR: Docker failed.\n' >"$E"
      return $ERROR
    }

    [[ -z $CREATE_CLUSTER_SKIPMASTERSETUP ]] && {
      run_with_progress \
        "    Setting up '$CREATE_CLUSTER_NAME-master-$int'" \
        set_up_master_node "$CREATE_CLUSTER_NAME-master-$int"
      r=$?

      [[ $r -ne 0 ]] && {
        printf '\n' >"$E"
        cat $RUNWITHPROGRESS_OUTPUT >"$E"
        printf '\nERROR: Set up failed. See above, and also in the file:' >"$E"
        printf '%s\n' "$RUNWITHPROGRESS_OUTPUT" >"$E"
        return $ERROR
      }
    }
  done

  # For now, copy admin.conf from master to ~/.mok/admin.conf

  mkdir -p ~/.mok/

  [[ -z $CREATE_CLUSTER_SKIPMASTERSETUP ]] && {
    docker cp "$CREATE_CLUSTER_NAME-master-$int":/etc/kubernetes/admin.conf \
      ~/.mok/admin.conf
    chmod 666 ~/.mok/admin.conf || {
      printf 'ERROR: Could not "chown 666 ~/.mok/admin.conf"'
      err || return
    }
  }

  return $OK
}

# ---------------------------------------------------------------------------
set_up_master_node() {

  # Call the correct set up function based on the version
  # Args
  #   arg1 - the container ID to set up

  case "$BUILD_IMAGE_K8SVER" in
  "1.18.2")
    set_up_master_node_v1_18_2 "$@"
    ;;
  esac
}

# ---------------------------------------------------------------------------
create_docker_container() {

  # Runs a new container with docker run.
  # Args:
  #   arg1 - name to use as the name and hostname.
  #   arg2 - the label to write to the container.

  docker run --privileged \
    -v /sys/fs/cgroup:/sys/fs/cgroup:ro \
    -v /lib/modules:/lib/modules:ro \
    --tmpfs /run --tmpfs /tmp \
    --detach \
    --name "$1" \
    --hostname "$1" \
    --label "$2" \
    local/"$BASEIMAGENAME-v$CREATE_CLUSTER_K8SVER"
}

# ---------------------------------------------------------------------------
create_worker_nodes() {

  # Create the master nodes
  # Args:
  #   arg1 - number of master nodes to create

  local cahash token t
  declare -i int=0

  [[ -n $CREATE_CLUSTER_SKIPWORKERSETUP || -n \
  $CREATE_CLUSTER_SKIPMASTERSETUP ]] || {
    # Runs a script on master node to get details
    t=$(get_master_join_details $CREATE_CLUSTER_NAME-master-1) || {
      printf '\nERROR: Problem with "get_master_join_details".\n\n' >"$E"
      return $ERROR
    }

    # Sets cahash, token, and masterip:
    eval "$t"
  }

  for int in $(seq 1 "$1"); do
    run_with_progress \
      "    Creating worker container, '$CREATE_CLUSTER_NAME-worker-$int'" \
      create_docker_container \
      "$CREATE_CLUSTER_NAME-worker-$int" \
      "$LABELKEY=$CREATE_CLUSTER_NAME"
    r=$?

    [[ $r -ne 0 ]] && {
      printf '\n' >"$E"
      cat $RUNWITHPROGRESS_OUTPUT >"$E"
      rm $RUNWITHPROGRESS_OUTPUT >"$E"
      printf '\nERROR: Docker failed.\n' >"$E"
      return $ERROR
    }

    [[ -n $CREATE_CLUSTER_SKIPWORKERSETUP || -n \
    $CREATE_CLUSTER_SKIPMASTERSETUP ]] || {
      run_with_progress \
        "    Setting up '$CREATE_CLUSTER_NAME-worker-$int'" \
        set_up_worker_node "$CREATE_CLUSTER_NAME-worker-$int" \
        "$cahash" "$token" "$masterip"
      r=$?

      [[ $r -ne 0 ]] && {
        printf '\n' >"$E"
        cat $RUNWITHPROGRESS_OUTPUT >"$E"
        printf '\nERROR: Set up failed. See above, and also in the file:\n' >"$E"
        printf '%s\n' "$RUNWITHPROGRESS_OUTPUT" >"$E"
        return $ERROR
      }
    }
  done

  return $OK
}

# ---------------------------------------------------------------------------
set_up_worker_node() {

  # Call the correct set up function based on the version
  # Args
  #   arg1 - the container ID to set up

  case "$BUILD_IMAGE_K8SVER" in
  "1.18.2")
    set_up_worker_node_v1_18_2 "$@"
    ;;
  esac
}

# ---------------------------------------------------------------------------
get_master_join_details() {

  # 'docker exec' into the master to get CA hash, a token, and the master IP.
  # The caller can eval the output of this function to set the variables:
  # cahash, token, and masterip.
  # Args:
  #   arg1 - id/name of master container

  local joinvarsfile

  joinvarsfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"$E"
    return $ERROR
  }

  cat <<'EnD' >"$joinvarsfile"
#!/bin/bash
set -e

cahash=$(openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | \
        openssl rsa -pubin -outform der 2>/dev/null | \
        openssl dgst -sha256 -hex | sed 's/^.* //')
token=$(kubeadm token create --kubeconfig=/etc/kubernetes/admin.conf 2>/dev/null)
ip=$(ip ro get 8.8.8.8 | cut -d" " -f 7)

printf 'cahash=%s\ntoken=%s\nmasterip=%s' "$cahash" "$token" "$ip"

exit 0
EnD

  docker cp "$joinvarsfile" "$1":/root/joinvars.sh || err || return
  rm -f "$joinvarsfile" || err || return

  docker exec "$1" bash /root/joinvars.sh
}

# ---------------------------------------------------------------------------
do_delete_cluster_mutate() {

  # Mutate functions make system changes.

  declare -i numnodes=0
  local id ids r

  numnodes=$(get_cluster_size "$DELETE_CLUSTER_NAME") || return

  [[ $numnodes -eq 0 ]] && {
    printf '\nERROR: No cluster exists with name, "%s". Aborting.\n\n' \
      "$DELETE_CLUSTER_NAME" >"$E"
    return $ERROR
  }

  ids=$(get_docker_ids_for_cluster "$DELETE_CLUSTER_NAME") || return

  printf 'The following containers will be deleted:\n\n'

  do_get_clusters_nomutate "$DELETE_CLUSTER_NAME" || return

  printf "\nAre you sure you want to delete the cluster? (y/N) >"

  read -r ans

  [[ $ans != "y" ]] && {
    printf '\nCancelling by user request.\n'
    return $OK
  }

  printf '\n'

  for id in $ids; do
    run_with_progress \
      "    Deleting id, '$id' from cluster '$DELETE_CLUSTER_NAME'." \
      delete_docker_container "$id"
    r=$?
    [[ $r -ne 0 ]] && {
      cat "$RUNWITHPROGRESS_OUTPUT"
      printf '\nERROR: Docker failed.\n\n' >"$E"
      err
      return $r
    }
  done

  printf '\n'
}

# ---------------------------------------------------------------------------
delete_docker_container() {

  # Stops and removes docker container.
  # Args:
  #   arg1 - docker id to delete

  docker stop "$id" || err || return
  docker rm "$id" || err
}

# ---------------------------------------------------------------------------
do_build_image_mutate() {

  # Mutate functions make system changes.
  # Builds the $BASEIMAGENAME base image used for masters and workers.
  # Globals: None
  # No args expected

  local retval=0

  build_container_image
  retval=$?

  if [[ $retval -eq 0 ]]; then
    : # We only need the tick - no text
  else
    printf 'Image build failed\n' >"$E"
  fi

  return $retval
}

# ---------------------------------------------------------------------------
build_container_image() {

  # Creates the docker build directory in $DOCKERBUILDTMPDIR then calls
  # docker build to build the image.
  # No args expected.

  local retval TAGNAME buildargs

  create_docker_build_dir || return

  buildargs=$(get_build_args_for_k8s_ver $BUILD_IMAGE_K8SVER) || return
  TAGNAME="$BASEIMAGENAME-v$BUILD_IMAGE_K8SVER"
  cmd="docker build \
    -t local/$TAGNAME \
    $buildargs \
    $DOCKERBUILDTMPDIR/$BASEIMAGENAME"

  run_with_progress \
    "    Creating base image, '$TAGNAME'" "$cmd"

  retval=$?
  [[ $retval -ne 0 ]] && {
    printf 'ERROR: Docker returned an error, shown below\n\n' >"$E"
    cat $RUNWITHPROGRESS_OUTPUT >"$E"
    printf '\n' >"$E"
    return $ERROR
  }

  return $retval
}

# ---------------------------------------------------------------------------
get_build_args_for_k8s_ver() {

  local buildargs

  case "$BUILD_IMAGE_K8SVER" in
  "1.18.2")
    buildargs="--build-arg"
    buildargs="$buildargs CRIO_VERSION=1.17"
    buildargs="$buildargs --build-arg"
    buildargs="$buildargs CRICTL_VERSION=v1.17.0"
    buildargs="$buildargs --build-arg"
    buildargs="$buildargs K8SBINVER=-1.18.2"
    ;;
  esac

  printf '%s' "$buildargs"
}

# ---------------------------------------------------------------------------
create_docker_build_dir() {

  # Creates a docker build directory in /var/tmp/tmp.XXXXXXXX
  # No args expected

  DOCKERBUILDTMPDIR=$(mktemp -d -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"$E"
    err || return
  }

  # The following comments should not be removed or changed.
  # embed-dockerfile.sh adds a base64 encoded tarball and
  #  unpacking code between them.

  #mok-centos-7-tarball-start
  #mok-centos-7-tarball-end
}

# ===========================================================================
#                              NON-MUTATORS
# ===========================================================================

# ---------------------------------------------------------------------------
do_exec_nomutate() {

  # Execs into the container referenced by arg1. If just 'mokctl exec' is
  # called without options then the user is offered a selection of existing
  # clusters to exec into.
  #
  # Args
  #  arg1 - Full name of container

  local names int ans lines containernames

  GET_CLUSTER_SHOW_HEADER=$FALSE
  names=$(do_get_clusters_nomutate) || return
  names=$(printf '%s' "$names" | awk '{ print $3; }')
  readarray -t containernames <<<"$names"

  if [[ -n $1 ]]; then

    # The caller gave a specific name for exec.
    # Check if the container name exists

    if grep -qs "^$1$" <<<"$names"; then
      run_docker_exec "$1" || return
      return $OK
    else
      printf 'ERROR: Cannot exec into non-existent container: "%s".\n' \
        "$1"
      return $ERROR
    fi

  elif [[ ${#containernames[*]} == 1 ]]; then

    # If there's only one container just log into it without asking
    run_docker_exec "${containernames[0]}"

  else

    # The caller supplied no container name.
    # Present some choices

    printf 'Choose the container to log in to:\n\n'

    GET_CLUSTER_SHOW_HEADER=$TRUE
    readarray -t lines <<<"$(do_get_clusters_nomutate)" || return

    # Print the header then print the items in the loop
    printf '   %s\n' "${lines[0]}"
    for int in $(seq 1 $((${#lines[*]} - 1))); do
      printf '%00d) %s\n' "$int" "${lines[int]}"
    done | sort -k 4

    printf "\nChoose a number (Enter to cancel)> "
    read -r ans

    [[ -z $ans || $ans -lt 0 || $ans -gt $((${#lines[*]} - 1)) ]] && {
      printf '\nInvalid choice. Aborting.\n'
      return $OK
    }

    run_docker_exec "${containernames[ans - 1]}"
  fi
}

# ---------------------------------------------------------------------------
run_docker_exec() {

  # Exec into the docker container
  # Args:
  #   arg1 - docker container name
  #   arg2 - command to run

  local cmd=${2:-bash}

  docker exec -ti "$1" "$cmd" || {
    printf 'ERROR: docker failed\n\n' >"$E"
    err || return $ERROR
  }
}

# ---------------------------------------------------------------------------
do_get_clusters_nomutate() {

  # Mutate functions make system changes but this one doesn't and I don't
  #  know where to put it yet.
  # Gets cluster details
  # Globals: None
  # Args
  #   arg1 - cluster name, optional

  local ids id info clustname=$1 output
  local containerhostname containerip

  declare -a nodes

  [[ -n $clustname ]] && clustname="=$clustname"

  ids=$(get_mok_cluster_docker_ids "$clustname") || return

  if [[ -z $ids ]]; then
    return $OK
  fi

  readarray -t nodes <<<"$ids"

  # Use 'docker inspect' to get the value of the label $LABELKEY

  output=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"$E"
    return $ERROR
  }

  # Output the header
  [[ $GET_CLUSTER_SHOW_HEADER -eq $TRUE ]] && {
    printf 'MOK_Cluster Docker_ID Container_Name IP_Address\n' >"$output"
  }

  for id in "${nodes[@]}"; do

    info=$(get_info_about_container_using_docker "$id") || return

    clustname=$(sed -rn \
      '/Labels/,/}/ {s/[":,]//g; s/^ *'"$LABELKEY"' ([^ ]*).*/\1/p }' \
      <<<"$info") || err || return

    containerhostname=$(sed -rn \
      '/"Config"/,/}/ {s/[":,]//g; s/^ *Hostname ([^ ]*).*/\1/p }' \
      <<<"$info") || err || return

    containerip=$(sed -rn \
      '/NetworkSettings/,/Networks/ {s/[":,]//g; s/^ *IPAddress ([^ ]*).*/\1/p }' \
      <<<"$info") || err || return

    printf '%s %s %s %s\n' "$clustname" "$id" "$containerhostname" "$containerip"

  done | sort -k 3 >>"$output"

  column -t "$output" || err
}

# ---------------------------------------------------------------------------
get_docker_container_ip() {

  # Args:
  #   arg1 - docker container id or container name

  docker inspect \
    --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' \
    "$1" || {
    printf 'ERROR: docker failed\n\n' >"$E"
    err || return
  }

}

# ---------------------------------------------------------------------------
get_mok_cluster_docker_ids() {

  # Use 'docker ps .. label= ..' to get a list of mok clusters
  # Args
  #   arg1 - mok cluster name, optional

  docker ps -a -f label="$LABELKEY$1" -q || {
    printf 'ERROR: docker failed\n\n' >"$E"
    err || return
  }
}

# ---------------------------------------------------------------------------
get_info_about_container_using_docker() {

  # Use 'docker inspect $id' to get details about container $id
  # Args
  #   arg1 - docker container id

  docker inspect "$1" || {
    printf 'ERROR: docker failed\n' >"$E"
    err || return
  }
}

# ===========================================================================
#                                 HELPERS
# ===========================================================================

# ---------------------------------------------------------------------------
err() {

  # In case of error print the function call stack

  local frame=0
  printf '\n' >"$E"
  while caller $frame; do
    ((frame++))
  done | tac >"$E"
  printf '\n' >"$E"
  return $ERROR
}

# ---------------------------------------------------------------------------
run_with_progress() {

  # Display a progress spinner, display item text, display a tick or cross
  # based on the exit code.
  # Args:
  #   arg1 - the text to display
  #   argN - remaining args are the program and its arguments

  local displaytext=$1 retval int

  RUNWITHPROGRESS_OUTPUT=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"$E"
    err || return
  }
  shift

  # Run the command in the background
  (
    sleep 1
    eval "$*"
  ) &>"$RUNWITHPROGRESS_OUTPUT" &

  # Turn the cursor off
  tput civis

  # Start the spin animation
  printf "%s" "$displaytext"
  (while true; do
    for int in {0..3}; do
      printf '\r  %s ' "${SPINNER[int]}"
      sleep .1
    done
  done) &

  # Wait for the command to finish
  wait %1
  retval=$?

  # Kill the spinner
  kill %2

  # Mark success/fail
  if [[ $retval -eq 0 ]]; then
    printf '\r  %s\n' "$success"
  else
    printf '\r  %s\n' "$failure"
  fi

  # Restore the cursor
  tput cnorm

  return $retval
}

# ---------------------------------------------------------------------------
sanity_checks() {

  # Check our environment
  # No args expected

  local binary

  for binary in tac column tput docker grep sed; do
    if ! command -v "$binary" >&/dev/null; then
      printf 'ERROR: "%s" binary not found in path. Aborting.' "$binary" >"$E"
      return 1
    fi
  done

  # Disable terminal escapes (colours) if stdout is not a terminal
  [ -t 1 ] || {
    colgreen=
    colred=
    colreset=
    success="✓"
    failure="✕"
  }
}

# ---------------------------------------------------------------------------
usage() {

  # Every tool, no matter how small, should have help text!

  case $COMMAND in
  create)
    create_usage
    return $OK
    ;;
  delete)
    delete_usage
    return $OK
    ;;
  build)
    build_usage
    return $OK
    ;;
  get)
    get_usage
    return $OK
    ;;
  exec)
    exec_usage
    return $OK
    ;;
  esac

  cat <<'EnD'

Usage: mokctl [-h] <command> [subcommand] [OPTIONS...]
 
Global options:
 
  --help
  -h     - This help text
 
Where command can be one of:
 
  create - Add item(s) to the system.
  delete - Delete item(s) from the system.
  build  - Build item(s) used by the system.
  get    - Get details about items in the system.
  exec   - 'Log in' to the container.

EnD

  # Output individual help pages
  create_usage
  delete_usage
  build_usage
  get_usage
  exec_usage

  cat <<'EnD'
EXAMPLES
 
Get a list of mok clusters
 
  mokctl get clusters
 
Build the image used for masters and workers:
 
  mokctl build image
 
Create a single node cluster:
Note that the master node will be made schedulable for pods.
 
  mokctl create cluster mycluster 1 0
 
Create a single master and single node cluster:
Note that the master node will NOT be schedulable for pods.
 
  mokctl create cluster mycluster 1 1
 
Delete a cluster:
 
  mokctl delete cluster mycluster

EnD
}

# ---------------------------------------------------------------------------
create_usage() {

  cat <<'EnD'
CREATE subcommands are:
 
  cluster - Create a local kubernetes cluster.
 
create cluster [flags] options:
 
 Format:
  create cluster NAME NUM_MASTERS NUM_WORKERS
  NAME        - The name of the cluster. This will be used as
                the prefix in the name for newly created
                docker containers.
  NUM_MASTERS - The number of master containers.
  NUM_WORKERS - The number of worker containers. If NUM_WORKERS is
                zero then the 'node-role.kubernetes.io/master' taint
                will be removed from master nodes so that pods are
                schedulable.
 
 Flags:
  --skipmastersetup - Create the master container but don't set it
         up. Useful for manually installing kubernetes. Kubeadm, 
         kubelet and kubectl will be installed at the requested 
         version. With this option the worker will also be skipped.
         See also '--k8sver' flag.
  --skipworkersetup - The same as '--skipmastersetup', but skips
         setting up the worker only.
  --with-lb - Add a haproxy load balancer. The software will be installed
         and set up to reverse proxy to the master node(s), unless
         --skiplbsetup is used.
  --k8sver VERSION - Unimplemented.

EnD
}

# ---------------------------------------------------------------------------
delete_usage() {

  cat <<'EnD'
DELETE subcommands are:
 
  cluster - Delete a local kubernetes cluster.
 
delete cluster options:
 
 Format:
  delete cluster NAME
  NAME        - The name of the cluster to delete

EnD
}

# ---------------------------------------------------------------------------
build_usage() {

  cat <<'EnD'
BUILD subcommands are:
 
  image - Creates the docker 'mok-centos-7' container image.
 
build image options:
 
 Format:
  build image

EnD
}

# ---------------------------------------------------------------------------
get_usage() {

  cat <<'EnD'
GET subcommands are:
 
  cluster(s) - list all mokctl managed clusters.
 
get cluster(s) options:
 
 Format:
  get cluster(s) [NAME]
  NAME        - (optional) The name of the cluster to get
                details about.

EnD
}

# ---------------------------------------------------------------------------
exec_usage() {

  cat <<'EnD'
EXEC has no subcommands. Exec into a container.
 
exec options:
 
 Format:
  exec [NAME]
  NAME        - (optional) The name of the container to log into.
                If this option is empty then the user will be offered
                a choice of containers to log in to. If there is only
                one cluster and one node then NAME can be left empty
                and it will log into the only available container.

EnD
}

# ---------------------------------------------------------------------------
cleanup() {

  # Called when the script exits.

  local int

  [[ -e $DOCKERBUILDTMPDIR ]] &&
    [[ $DOCKERBUILDTMPDIR == "/var/tmp/"* ]] && {
    rm -rf "$DOCKERBUILDTMPDIR"
  }

  # If progress spinner crashed make sure the cursor is shown
  [ -t 1 ] && tput cnorm

  # Kill the spinny, and anything else, if they're running
  [[ -n $(jobs -p) ]] && printf '%s\r  ✕%s\n' "$colred" "$colreset"
  for int in $(jobs -p); do kill "$int"; done

  return $OK
}

# ===========================================================================
#                   FUNCTIONS FOR PARSING THE COMMAND LINE
# ===========================================================================

# ---------------------------------------------------------------------------
parse_options() {

  # Uses a state machine to check all command line arguments
  # Args:
  #   arg1 - The arguments given to mokctl by the user on the command line

  set -- "$@"
  local ARGN=$#
  while [ "$ARGN" -ne 0 ]; do
    case $1 in
    --skipmastersetup)
      verify_option '--skipmastersetup' || return $ERROR
      CREATE_CLUSTER_SKIPMASTERSETUP=$TRUE
      ;;
    --skipworkersetup)
      verify_option '--skipworkersetup' || return $ERROR
      CREATE_CLUSTER_SKIPWORKERSETUP=$TRUE
      ;;
    --skiplbsetup)
      verify_option '--skiplbsetup' || return $ERROR
      CREATE_CLUSTER_SKIPLBSETUP="$TRUE"
      ;;
    --with-lb)
      verify_option '--with-lb' || return $ERROR
      CREATE_CLUSTER_WITH_LB="$TRUE"
      ;;
    --k8sver)
      verify_option '--k8sver' || return $ERROR
      # enable later -> BUILD_IMAGE_K8SVER="$1"
      shift
      ;;
    --help) ;&
    -h)
      usage
      return $STOP
      ;;
    --?*)
      usage
      printf 'Invalid option: "%s"\n' "$1" >"$E"
      return $ERROR
      ;;
    ?*)
      case "$STATE" in
      COMMAND)
        check_command_token "$1"
        [[ $? -eq $ERROR ]] && {
          usage
          printf 'Invalid COMMAND, "%s".\n\n' "$1" >"$E"
          return $ERROR
        }
        ;;
      SUBCOMMAND)
        check_subcommand_token "$1"
        [[ $? -eq $ERROR ]] && {
          usage
          printf 'Invalid SUBCOMMAND for %s, "%s".\n\n' "$COMMAND" "$1" >"$E"
          return $ERROR
        }
        ;;
      OPTION)
        check_option_token "$1"
        [[ $? -eq $ERROR ]] && {
          usage
          printf 'Invalid OPTION for %s %s, "%s".\n\n' "$COMMAND" "$SUBCOMMAND" "$1" >"$E"
          return $ERROR
        }
        ;;
      OPTION2)
        check_option2_token "$1"
        [[ $? -eq $ERROR ]] && {
          usage
          printf 'Invalid OPTION for %s %s, "%s".\n\n' "$COMMAND" "$SUBCOMMAND" "$1" >"$E"
          return $ERROR
        }
        ;;
      OPTION3)
        check_option3_token "$1"
        [[ $? -eq $ERROR ]] && {
          usage
          printf 'Invalid OPTION for %s %s, "%s".\n\n' "$COMMAND" "$SUBCOMMAND" "$1" >"$E"
          return $ERROR
        }
        ;;
      END)
        usage
        printf 'ERROR No more options expected, "%s" is unexpected for "%s %s"\n' \
          "$1" "$COMMAND" "$SUBCOMMAND" >"$E"
        return $ERROR
        ;;
      ?*)
        printf 'Internal ERROR. Invalid state "%s"\n' "$STATE" >"$E"
        return $ERROR
        ;;
      esac
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done

  [[ -z $COMMAND ]] && {
    usage
    printf 'No COMMAND supplied\n' >"$E"
    return $ERROR
  }
  [[ -z $SUBCOMMAND ]] && {
    usage
    printf 'No SUBCOMMAND supplied\n' >"$E"
    return $ERROR
  }

  return $OK
}

# ===========================================================================
#                    COMMAND, SUBCOMMAND, OPTION PROCESSING
# ===========================================================================

# ---------------------------------------------------------------------------
check_command_token() {

  # Check for a valid token in command state
  # Args:
  #   arg1 - token

  case $1 in
  create)
    COMMAND="create"
    STATE="SUBCOMMAND"
    ;;
  delete)
    COMMAND="delete"
    STATE="SUBCOMMAND"
    ;;
  build)
    COMMAND="build"
    STATE="SUBCOMMAND"
    ;;
  get)
    COMMAND="get"
    STATE="SUBCOMMAND"
    ;;
  exec)
    COMMAND="exec"
    SUBCOMMAND="unused"
    STATE="OPTION"
    ;;
  ?*) return $ERROR ;;
  esac
}

# ---------------------------------------------------------------------------
check_subcommand_token() {

  # Check for a valid token in subcommand state
  # Args:
  #   arg1 - token

  case $COMMAND in
  create) check_create_subcommand_token "$1" ;;
  delete) check_delete_subcommand_token "$1" ;;
  build) check_build_subcommand_token "$1" ;;
  get) check_get_subcommand_token "$1" ;;
  esac
}

# ---------------------------------------------------------------------------
check_create_subcommand_token() {

  # Check for a valid token in subcommand state
  # Args:
  #   arg1 - token

  case $1 in
  cluster) SUBCOMMAND="cluster" ;;
  ?*) return $ERROR ;;
  esac

  STATE="OPTION"

  return $OK
}

# ---------------------------------------------------------------------------
check_delete_subcommand_token() {

  # Check for a valid token in subcommand state
  # Args:
  #   arg1 - token

  case $1 in
  cluster) SUBCOMMAND="cluster" ;;
  ?*) return $ERROR ;;
  esac

  STATE=OPTION
}

# ---------------------------------------------------------------------------
check_build_subcommand_token() {

  # Check for a valid token in subcommand state
  # Args:
  #   arg1 - token

  case $1 in
  image) SUBCOMMAND="image" ;;
  ?*) return $ERROR ;;
  esac

  STATE=END
}

# ---------------------------------------------------------------------------
check_get_subcommand_token() {

  # Check for a valid token in subcommand state
  # Args:
  #   arg1 - token

  case $1 in
  clusters) ;&
  cluster) SUBCOMMAND="cluster" ;;
  ?*) return $ERROR ;;
  esac

  STATE=OPTION
}

# ---------------------------------------------------------------------------
check_option_token() {

  # Check for a valid token in option state
  # Args:
  #   arg1 - token

  case $COMMAND in
  create)
    case $SUBCOMMAND in
    cluster)
      CREATE_CLUSTER_NAME="$1"
      STATE="OPTION2"
      ;;
    esac
    ;;
  delete)
    case $SUBCOMMAND in
    cluster)
      DELETE_CLUSTER_NAME="$1"
      STATE="END"
      ;;
    esac
    ;;
  get)
    case $SUBCOMMAND in
    cluster)
      GET_CLUSTER_NAME="$1"
      STATE="END"
      ;;
    esac
    ;;
  exec)
    EXEC_CONTAINER_NAME="$1"
    STATE="END"
    ;;
  esac
}

# ---------------------------------------------------------------------------
check_option2_token() {

  # Check for a valid token in option2 state
  # Args:
  #   arg1 - token

  case $COMMAND in
  create)
    case $SUBCOMMAND in
    cluster)
      CREATE_CLUSTER_NUM_MASTERS="$1"
      STATE="OPTION3"
      ;;
    esac
    ;;
  delete)
    case $SUBCOMMAND in
    cluster)
      return $ERROR
      ;;
    esac
    ;;
  esac
}

# ---------------------------------------------------------------------------
check_option3_token() {

  # Check for a valid token in option3 state
  # Args:
  #   arg1 - token

  case $COMMAND in
  create)
    case $SUBCOMMAND in
    cluster)
      CREATE_CLUSTER_NUM_WORKERS="$1"
      STATE="END"
      ;;
    esac
    ;;
  delete)
    case $SUBCOMMAND in
    cluster)
      return $ERROR
      ;;
    esac
    ;;
  esac
}

# ===========================================================================
#                              FLAG PROCESSING
# ===========================================================================

# ---------------------------------------------------------------------------
verify_option() {

  # Check that the sent option is valid for the command-subcommand or global
  # options.
  # Args:
  #   arg1 - The option to check.

  case "$COMMAND$SUBCOMMAND" in
  create) ;& # Treat flags located just before
  delete) ;& # or just after COMMAND
  build) ;&  # as global options.
  get) ;&
  '')
    check_valid_global_opts "$1"
    ;;
  createcluster)
    check_valid_create_cluster_opts "$1"
    ;;
  deletecluster)
    check_valid_delete_cluster_opts "$1"
    ;;
  buildimage)
    check_valid_build_image_opts "$1"
    ;;
  getcluster)
    check_valid_get_cluster_opts "$1"
    ;;
  esac && return $OK

  return $ERROR
}

# ---------------------------------------------------------------------------
check_valid_global_opts() {

  # Args:
  #   arg1 - The option to check.

  local int validopts=(
    "--help"
    "-h"
  )

  for int in "${validopts[@]}"; do
    [[ $1 == "$int" ]] && return $OK
  done

  usage
  printf 'ERROR: "%s" is not a valid global option.\n' "$1" >"$E"
  return $ERROR
}

# ---------------------------------------------------------------------------
check_valid_create_cluster_opts() {

  # Args:
  #   arg1 - The option to check.

  local opt validopts=(
    "--help"
    "-h"
    "--skipmastersetup"
    "--skipworkersetup"
    "--skiplbsetup"
    "--k8sver"
    "--with-lb"
  )

  for opt in "${validopts[@]}"; do
    [[ $1 == "$opt" ]] && return $OK
  done

  usage
  printf 'ERROR: "%s" is not a valid "create cluster" option.\n' "$1" >"$E"
  return $ERROR
}

# ---------------------------------------------------------------------------
check_valid_delete_cluster_opts() {

  # Args:
  #   arg1 - The option to check.

  local opt validopts=(
    "--help"
    "-h"
  )

  for opt in "${validopts[@]}"; do
    [[ $1 == "$opt" ]] && return $OK
  done

  usage
  printf 'ERROR: "%s" is not a valid "delete cluster" option.\n' "$1" >"$E"
  return $ERROR
}

# ---------------------------------------------------------------------------
check_valid_build_image_opts() {

  # Args:
  #   arg1 - The option to check.

  local opt validopts=(
    "--help"
    "-h"
  )

  for opt in "${validopts[@]}"; do
    [[ $1 == "$opt" ]] && return $OK
  done

  usage
  printf 'ERROR: "%s" is not a valid "build image" option.\n' "$1" >"$E"
  return $ERROR
}

# ---------------------------------------------------------------------------
check_valid_get_cluster_opts() {

  # Args:
  #   arg1 - The option to check.

  local opt validopts=(
    "--help"
    "-h"
  )

  for opt in "${validopts[@]}"; do
    [[ $1 == "$opt" ]] && return $OK
  done

  usage
  printf 'ERROR: "%s" is not a valid "get cluster" option.\n' "$1" >"$E"
  return $ERROR
}

# ---------------------------------------------------------------------------
check_valid_exec_cluster_opts() {

  # Args:
  #   arg1 - The option to check.

  local opt validopts=(
    "--help"
    "-h"
  )

  for opt in "${validopts[@]}"; do
    [[ $1 == "$opt" ]] && return $OK
  done

  usage
  printf 'ERROR: "%s" is not a valid "get cluster" option.\n' "$1" >"$E"
  return $ERROR
}

# ===========================================================================
# Funtions for installing specific vesions of kubernetes
# ===========================================================================

# ---------------------------------------------------------------------------
set_up_master_node_v1_18_2() {

  # Use kubeadm to set up the master node.
  # Args:
  #   arg1 - the container to set up.

  local setupfile

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"$E"
    return $ERROR
  }

  # Write the file
  cat <<'EnD' >"$setupfile"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

# Run the preflight phase
kubeadm init \
  --ignore-preflight-errors Swap \
  phase preflight

# Set up the kubelet
kubeadm init phase kubelet-start

# Edit the kubelet configuration file
echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml

# Tell kubeadm to carry on from here
kubeadm init \
  --pod-network-cidr=10.123.0.0/16 \
  --ignore-preflight-errors Swap \
  --skip-phases=preflight,kubelet-start

declare -i i=120
while [[ $((i--)) -gt 0 ]]; do
  curl -k https://localhost:6443/api/ && break
  sleep 1
done

systemctl enable kubelet

export KUBECONFIG=/etc/kubernetes/admin.conf

#kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
#kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"
# Calico is e2e tested by k8s team. Requires --pod-network-cidr=192.168.0.0/16
kubectl apply -f https://docs.projectcalico.org/v3.11/manifests/calico.yaml |
curl https://docs.projectcalico.org/v3.11/manifests/calico.yaml | sed 's#192.168.0.0/16#10.123.0.0/16#' | kubectl apply -f -
EnD

  docker cp "$setupfile" "$1":/root/setup.sh || err || {
    rm -f "$setupfile"
    return $ERROR
  }

  # Run the file
  docker exec "$1" bash /root/setup.sh || err || return

  # Remove the taint if we're setting up a single node cluster

  [[ $CREATE_CLUSTER_NUM_WORKERS -eq 0 ]] && {

    removetaint=$(mktemp -p /var/tmp) || {
      printf 'ERROR: mktmp failed.\n' >"$E"
      return $ERROR
    }

    # Write the file
    cat <<'EnD' >"$removetaint"
export KUBECONFIG=/etc/kubernetes/admin.conf
kubectl taint nodes --all node-role.kubernetes.io/master-
EnD

    docker cp "$removetaint" "$1":/root/removetaint.sh || err || {
      rm -f "$removetaint"
      return $ERROR
    }

    # Run the file
    docker exec "$1" bash /root/removetaint.sh || err
  }

  return $OK
}

# ---------------------------------------------------------------------------
set_up_worker_node_v1_18_2() {

  # Use kubeadm to set up the master node
  # Args:
  #   arg1 - the container to set up.

  local setupfile cahash="$2" token="$3" masterip="$4"

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"$E"
    return $ERROR
  }

  cat <<EnD >"$setupfile"
# Wait for the master API to become ready
while true; do
  curl -k https://$masterip:6443/
  [[ \$? -eq 0 ]] && break
  sleep 1
done

# Do the preflight tests (ignoring swap error)
kubeadm join \
  phase preflight \
    --token $token \
      --discovery-token-ca-cert-hash sha256:$cahash \
        --ignore-preflight-errors Swap \
          $masterip:6443

# Set up the kubelet
kubeadm join \
  phase kubelet-start \
    --token $token \
      --discovery-token-ca-cert-hash sha256:$cahash \
        $masterip:6443 &

while true; do
  [[ -e /var/lib/kubelet/config.yaml ]] && break
    sleep 1
  done

# Edit the kubelet configuration file
echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml

systemctl enable kubelet
systemctl restart kubelet
EnD

  docker cp "$setupfile" "$1":/root/setup.sh || err || {
    rm -f "$setupfile"
    return $ERROR
  }

  docker exec "$1" bash /root/setup.sh || err
}

# ---------------------------------------------------------------------------

# Calls main() if we're called from the command line
if [ "$0" = "${BASH_SOURCE[0]}" ] || [ -z "${BASH_SOURCE[0]}" ]; then
  main "$@"
fi

# vim:ft=sh:sw=2:et:ts=2:
