#!/usr/bin/env bash

# ===========================================================================
# GLOBALS
# ===========================================================================
# Don't change any globals

# The initial state for the state machine
STATE="COMMAND"

ERROR=1
OK=0

COMMAND=
SUBCOMMAND=

CREATE_CLUSTER_NAME=
CREATE_CLUSTER_NUM_MASTERS=
CREATE_CLUSTER_NUM_WORKERS=

DELETE_CLUSTER_NAME=

DOCKERBUILDTMPDIR=

# ===========================================================================
main() {
# ===========================================================================
# Execution begins here

  trap cleanup EXIT

  parse_options "$@" || return $?

  case "$COMMAND" in
    create) do_create ;;
    delete) do_delete ;;
    build)  do_build ;;
  esac
}

# ===========================================================================
# MOKCTL BUILD
# ===========================================================================

# ---------------------------------------------------------------------------
do_build() {
# ---------------------------------------------------------------------------
# Calls the correct command/subcommand function

  case $SUBCOMMAND in
    image) do_build_image_sanity_checks || return $?
           do_build_image_mutate
           ;;
  esac
}

# ---------------------------------------------------------------------------
do_build_image_sanity_checks() {
# ---------------------------------------------------------------------------
# No sanity checks required.
# Globals: None
# No args expected

  :
}

# ===========================================================================
# MOKCTL CREATE
# ===========================================================================

# ---------------------------------------------------------------------------
do_create() {
# ---------------------------------------------------------------------------
# Calls the correct command/subcommand function

  case $SUBCOMMAND in
    cluster) do_create_cluster_sanity_checks || return $?
             do_create_cluster_mutate
             ;;
  esac
}

# ---------------------------------------------------------------------------
do_create_cluster_sanity_checks() {
# ---------------------------------------------------------------------------
# Creates a mok cluster. All user vars have been parsed and saved.
# Globals: CREATE_CLUSTER_NAME CREATE_CLUSTER_NUM_MASTERS
#          CREATE_CLUSTER_NUM_WORKERS
# No args expected

  if [[ -z $CREATE_CLUSTER_NAME ]]; then
    usage
    echo "Please provide the Cluster NAME to create."
    return $ERROR
  fi

  if [[ -z $CREATE_CLUSTER_NUM_MASTERS || $CREATE_CLUSTER_NUM_MASTERS -le 0 ]]; then
    usage
    echo "Please provide the number of Masters to create. Must be 1 or more."
    return $ERROR
  fi

  if [[ -z $CREATE_CLUSTER_NUM_WORKERS ]]; then
    usage
    echo "Please provide the number of Workers to create."
    return $ERROR
  fi
}

# ===========================================================================
# MOKCTL DELETE
# ===========================================================================

# ---------------------------------------------------------------------------
do_delete() {
# ---------------------------------------------------------------------------
# Calls the correct command/subcommand function
# No args expected

  case $SUBCOMMAND in
    cluster) do_delete_cluster_sanity_checks || return $?
             do_delete_cluster_mutate
             ;;
  esac
}

# ---------------------------------------------------------------------------
do_delete_cluster_sanity_checks() {
# ---------------------------------------------------------------------------
# Deletes a mok cluster. All user vars have been parsed and saved.
# Globals: DELETE_CLUSTER_NAME
# No args expected

  if [[ -z $DELETE_CLUSTER_NAME ]]; then
    usage
    echo "Please provide the Cluster NAME to delete."
    return $ERROR
  fi
}

# ===========================================================================
#                                MUTATIONS
#                FUNCTIONS IN THIS SECTION CHANGE SYSTEM STATE
# ===========================================================================

# ---------------------------------------------------------------------------
do_create_cluster_mutate() {
# ---------------------------------------------------------------------------
# Mutate functions make system changes.

  :

  # Create master node(s)

  # Create worker node(s)
}

# ---------------------------------------------------------------------------
do_delete_cluster_mutate() {
# ---------------------------------------------------------------------------
# Mutate functions make system changes.

  :

  # Create master node(s)

  # Create worker node(s)
}

# ---------------------------------------------------------------------------
do_build_image_mutate() {
# ---------------------------------------------------------------------------
# Mutate functions make system changes.
# Builds the mok-centos-7 base image used for masters and workers.
# Globals: None
# No args expected

  local retval=0

  build_container_image >/dev/null || retval=$?

  if [[ $? -eq 0 ]]; then
    echo "Image built successfully"
  else
    echo "Image build failed"
  fi

  return $retval
}

# ---------------------------------------------------------------------------
build_container_image() {
# ---------------------------------------------------------------------------
# Creates the docker build directory in $DOCKERBUILDTMPDIR then calls
# docker build to build the image.
# No args expected.

  create_docker_build_dir

  docker build -t local/mok-centos-7 "$DOCKERBUILDTMPDIR/mok-centos-7"
}

# ---------------------------------------------------------------------------
create_docker_build_dir() {
# ---------------------------------------------------------------------------
# Creates a docker build directory in /var/tmp/tmp.XXXXXXXX
# No args expected

  DOCKERBUILDTMPDIR=`mktemp -d --tmpdir=/var/tmp`

  # The following comments should not be removed or changed.
  # embed-dockerfile.sh adds a base64 encoded tarball and
  #  unpacking code between them.

  #mok-centos-7-tarball-start 
  #mok-centos-7-tarball-end
}

# ===========================================================================
# FUNCTIONS FOR PARSING THE COMMAND LINE BELOW
# ===========================================================================

# ---------------------------------------------------------------------------
parse_options() {
# ---------------------------------------------------------------------------
# Uses a state machine to check all command line arguments
# Args:
#   arg1 - The arguments given to mokctl by the user on the command line

  set -- "$@"
  local ARGN=$#
  while [ "$ARGN" -ne 0 ]
  do
    case $1 in
      -h) usage
          return $OK
      ;;
      ?*) case "$STATE" in
            COMMAND) check_command_token $1
                   [[ $? -eq $ERROR ]] && {
                     usage
                     echo "Invalid COMMAND, '$1'."
                     echo
                     return $ERROR
                   }
                   COMMAND="$1"
                 ;;
            SUBCOMMAND) check_subcommand_token $1
                   [[ $? -eq $ERROR ]] && {
                     usage
                     echo "Invalid SUBCOMMAND for $COMMAND, '$1'."
                     echo
                     return $ERROR
                   }
                   SUBCOMMAND="$1"
                 ;;
            OPTION) check_option_token $1
                   [[ $? -eq $ERROR ]] && {
                     usage
                     echo "Invalid OPTION for $COMMAND $SUBCOMMAND, '$1'."
                     echo
                     return $ERROR
                   }
                 ;;
            OPTION2) check_option2_token $1
                   [[ $? -eq $ERROR ]] && {
                     usage
                     echo "Invalid OPTION for $COMMAND $SUBCOMMAND, '$1'."
                     echo
                     return $ERROR
                   }
                 ;;
            OPTION3) check_option3_token $1
                   [[ $? -eq $ERROR ]] && {
                     usage
                     echo "Invalid OPTION for $COMMAND $SUBCOMMAND, '$1'."
                     echo
                     return $ERROR
                   }
                 ;;
            END) usage
                 echo -n "ERROR No more options expected, '$1' is unexpected"
                 echo " for '$COMMAND $SUBCOMMAND'"
                 return $ERROR
                 ;;
            ?*) echo "Internal ERROR. Invalid state '$STATE'"
                return $ERROR
          esac
      ;;
    esac
    shift 1
    ARGN=$((ARGN-1))
  done

  [[ -z $COMMAND ]] && {
    usage
    echo "No COMMAND supplied"
    return $ERROR
  }
  [[ -z $SUBCOMMAND ]] && {
    usage
    echo "No SUBCOMMAND supplied"
    return $ERROR
  }

  return $OK
}

# ---------------------------------------------------------------------------
check_command_token() {
# ---------------------------------------------------------------------------
# Check for a valid token in command state
# Args:
#   arg1 - token

  case $1 in
    create) COMMAND=create
      ;;
    delete) COMMAND=delete
      ;;
    build) COMMAND=build
      ;;
    ?*) return $ERROR
      ;;
  esac
  STATE="SUBCOMMAND"
}

# ---------------------------------------------------------------------------
check_subcommand_token() {
# ---------------------------------------------------------------------------
# Check for a valid token in subcommand state
# Args:
#   arg1 - token

  case $COMMAND in
    create) check_create_subcommand_token $1 ;;
    delete) check_delete_subcommand_token $1 ;;
    build) check_build_subcommand_token $1   ;;
  esac
}

# ---------------------------------------------------------------------------
check_create_subcommand_token() {
# ---------------------------------------------------------------------------
# Check for a valid token in subcommand state
# Args:
#   arg1 - token

  case $1 in
    cluster) SUBCOMMAND="cluster"
      ;;
    ?*) return $ERROR
      ;;
  esac

  STATE="OPTION"

  return $OK
}

# ---------------------------------------------------------------------------
check_delete_subcommand_token() {
# ---------------------------------------------------------------------------
# Check for a valid token in subcommand state
# Args:
#   arg1 - token

  case $1 in
    cluster) SUBCOMMAND="cluster"
      ;;
    ?*) return $ERROR
      ;;
  esac

  STATE=OPTION
}

# ---------------------------------------------------------------------------
check_build_subcommand_token() {
# ---------------------------------------------------------------------------
# Check for a valid token in subcommand state
# Args:
#   arg1 - token

  case $1 in
    image) SUBCOMMAND="image"
      ;;
    ?*) return $ERROR
      ;;
  esac

  STATE=END
}

# ---------------------------------------------------------------------------
check_option_token() {
# ---------------------------------------------------------------------------
# Check for a valid token in option state
# Args:
#   arg1 - token

  case $COMMAND in
    create)
      case $SUBCOMMAND in
        cluster) CREATE_CLUSTER_NAME="$1"
          STATE="OPTION2"
          ;;
      esac
      ;;
    delete)
      case $SUBCOMMAND in
        cluster) DELETE_CLUSTER_NAME="$1"
          STATE="END"
          ;;
      esac
      ;;
  esac
}

# ---------------------------------------------------------------------------
check_option2_token() {
# ---------------------------------------------------------------------------
# Check for a valid token in option2 state
# Args:
#   arg1 - token

  case $COMMAND in
    create)
      case $SUBCOMMAND in
        cluster) CREATE_CLUSTER_NUM_MASTERS="$1"
          STATE="OPTION3"
          ;;
      esac
      ;;
    delete)
      case $SUBCOMMAND in
        cluster) return $ERROR
          ;;
      esac
      ;;
  esac
}

# ---------------------------------------------------------------------------
check_option3_token() {
# ---------------------------------------------------------------------------
# Check for a valid token in option3 state
# Args:
#   arg1 - token

  case $COMMAND in
    create)
      case $SUBCOMMAND in
        cluster) CREATE_CLUSTER_NUM_WORKERS="$1"
          STATE="END"
          ;;
      esac
      ;;
    delete)
      case $SUBCOMMAND in
        cluster) return $ERROR
          ;;
      esac
      ;;
  esac
}

# ===========================================================================
# HELPERS
# ===========================================================================

# ---------------------------------------------------------------------------
usage() {
# ---------------------------------------------------------------------------
# Every tool, no matter how small, should have help text!

  echo
  echo "Usage: mokctl [-h] <COMMAND> <SUBCOMMAND> [SUBCOMMAND_OPTIONS...]"
  echo
  echo "Global options:"
  echo
  echo "  -h - This help text"
  echo
  echo "Where COMMAND can be one of:"
  echo
  echo "  create"
  echo "  delete"
  echo "  build"
  echo
  echo "create SUBCOMMANDs:"
  echo
  echo "  cluster - Create a local kubernetes cluster."
  echo
  echo "create cluster options:"
  echo
  echo " Format:"
  echo "  create cluster NAME NUM_MASTERS NUM_WORKERS"
  echo "  NAME        - The name of the cluster. This will be used as"
  echo "                the prefix in the name for newly created"
  echo "                docker containers."
  echo "  NUM_MASTERS - The number of master containers."
  echo "  NUM_WORKERS - The number of worker containers."
  echo
  echo "delete SUBCOMMANDs:"
  echo
  echo "  cluster - Create a local kubernetes cluster."
  echo
  echo "delete cluster options:"
  echo
  echo " Format:"
  echo "  delete cluster NAME"
  echo "  NAME        - The name of the cluster to delete"
  echo
  echo "build SUBCOMMANDs:"
  echo
  echo "  image - Creates the mok-centos-7 base image."
  echo
  echo "build image options:"
  echo
  echo " Format:"
  echo "  build image"
  echo
  echo "EXAMPLES"
  echo
  echo "Build the image used for masters and workers:"
  echo
  echo "  mokctl create image"
  echo
  echo "Create a single node cluster:"
  echo "Note that the master node will be made schedulable for pods."
  echo
  echo "  mokctl create cluster mycluster 1 0"
  echo
  echo "Create a single master and single node cluster:"
  echo "Note that the master node will NOT be schedulable for pods."
  echo
  echo "  mokctl create cluster mycluster 1 1"
  echo
  echo "Delete a cluster:"
  echo
  echo "  mokctl delete cluster mycluster"
  echo
}

# ---------------------------------------------------------------------------
cleanup() {
# ---------------------------------------------------------------------------
# Called when the script exits.

    [[ -e "$DOCKERBUILDTMPDIR" ]] && \
      [[ $DOCKERBUILDTMPDIR == "/var/tmp/"* ]] && {
      rm -rf "$DOCKERBUILDTMPDIR"
    }
}

# Calls main() if we're called from the command line
if ([ "$0" = "$BASH_SOURCE" ] || ! [ -n "$BASH_SOURCE" ]);
then
  main "$@"
fi

# vim:ft=bash:sw=2:et:ts=2:
