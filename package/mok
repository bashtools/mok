#!/usr/bin/env bash
__install_extra_packages() {
  # check for Homebrew
  if ! command -v brew &>/dev/null; then
    # Install Homebrew
    # /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    for i in $(seq 1 10); do
      echo -n "."
      sleep .2
    done
  fi
}

__check_os() {
  local majorversion system_ok=1 install_bash=0

  if [[ -d /System/Library/CoreServices ]]; then
    # We're on macOS, check for a recent Bash
    if command -v bash &>/dev/null; then
      majorversion=$(bash --version | head -n 1 | sed 's/^.*version \([0-9]*\).*/\1/')
    else
      echo "No version of Bash was found which is strange. Aborting."
      exit 1
    fi

    if [[ ${majorversion} -lt 5 ]]; then
      install_bash=1
      system_ok=0
    fi

    if [[ ${system_ok} -eq 0 ]]; then
      echo "Your system requires some extra packages to be installed."
      echo "This script can install them for you using Homebrew."
      echo
      read -r -p 'Install extra packages (y/N) ' ans
      if [[ ${ans} == "y" ]]; then
        __install_extra_packages
      else
        echo "Aborting due to missing packages."
        exit 1
      fi
    fi
  fi
}

__check_os
# shellcheck shell=bash disable=SC2148
# PA - PArser

# _PA holds data specific to parsing the command line arguments.
declare -A _PA

# Declare externally defined variables ----------------------------------------

# Defined in ER (globals.sh)
declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# PA_command getter outputs the _PA[command] array member. This contains the
# command the user requested.
PA_command() {
  printf '%s' "${_PA[command]}"
}

# PA_subcommand getter outputs the _PA[subcommand] array member. This contains
# the subcommand the user requested.
PA_subcommand() {
  printf '%s' "${_PA[subcommand]}"
}

# PA_shift outputs the _PA[shift] array member, returned by the caller
# when an extra shift is required whilst consuming option values.
#
# Example code:
# ```
#XX_process_options_callback() {
#
#  case "$1" in
#  -h | --help)
#    CC_usage
#    return "${STOP}"
#    ;;
#    ... omitted ...
#  --k8sver)
#    _CC[k8sver]="$2"
#    return "$(PA_shift)"
#    ;;
#  --with-lb)
#    ... omitted ..
# ```
PA_shift() {
  printf '%s' "${_PA[shift]}"
}

# PA_set_state setter sets the initial state of the parser, which should be one
# of COMMAND, SUBCOMMAND, or ARG1.
# Args: arg1 - the initial state to set.
PA_set_state() {
  _PA[state]="$1"
}

# Public Functions ------------------------------------------------------------

# PA_add_option_callback adds a callback to the list of callbacks used for
# processing options.
# Args: arg1 - Null string (for global options), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_option_callback() {
  _PA[optscallbacks]+="$1,$2 "
}

# PA_add_usage_callback adds a callback to the list of callbacks used for
# output of help text.
# Args: arg1 - Null string (for global help), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_usage_callback() {
  _PA[usagecallbacks]+="$1,$2 "
}

# PA_add_state adds a callback to the list of callbacks used for
# programming the state machine.
# Args: arg1 - Current state to match.
#       arg2 - The value of the state to match.
#       arg3 - The new state if arg1 and arg2 match.
#       arg4 - The function to call, optional.
PA_add_state() {
  _PA[statecallbacks]+="$1,$2,$3,$4 "
}

# PA_add_run_callback adds a callback to the list of callbacks used for
# running the user defined entrypoint function.
# Args: arg1 - The value of the state to match. Probably like:
#              "commandsubcommand" "function"
#       arg2 - The function to call.
PA_add_run_callback() {
  _PA[runcallbacks]+="$1,$2 "
}

# PA_run implements an interleaved state machine to process the
# user request. It allows for strict checking of arguments and args. All
# command line arguments are processed in order from left to right.
#
# Each COMMAND can have a different set of requirements which are controlled
# by setting the next state at each transition.
#
# --global-options COMMAND --command-options SUBCOMMAND --subcommand-options \
#  ARG1 --subcommand-options ARG2 --subcommand-options ...
#
# --global-options are those before COMMAND.
# --command-options can be after the COMMAND but before SUBCOMMAND.
# --subcommand-options can be anywhere after the SUBCOMMAND.
#
# Args: arg1-N - The arguments given to mok by the user on the command line
PA_run() {

  local retval=${OK}

  set -- "$@"
  local ARGN=$# ARGNUM=0 retval=0
  while [ "${ARGN}" -ne 0 ]; do
    case "$1" in
    --* | -*)
      _PA_process_option "$1" "$2" || {
        retval=$?
        if [[ ${retval} == "${_PA[shift]}" ]]; then
          ARGN=$((ARGN - 1))
          shift
        else
          return "${retval}"
        fi
      }
      ;;
    *)
      case "${_PA[state]}" in
      COMMAND)
        _PA_check_token "${1}" "COMMAND" "command"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid COMMAND, "%s".\n\n' "$1" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      SUBCOMMAND)
        _PA_check_token "$1" "SUBCOMMAND" "subcommand"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid SUBCOMMAND for %s, "%s".\n\n' "${_PA[command]}" "${1}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      ARG*)
        ((ARGNUM++))
        _PA_check_token "${1}" "ARG${ARGNUM}"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid ARG1 for %s %s, "%s".\n\n' "${_PA[command]}" \
            "${_PA[subcommand]}" "${1}" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      END)
        PA_usage
        printf 'ERROR No more args expected, "%s" is unexpected for "%s %s"\n' \
          "${1}" "${_PA[command]}" "${_PA[subcommand]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      *)
        printf 'Internal ERROR. Invalid state "%s"\n' "${_PA[state]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      esac
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done

  # Run the user defined entrypoint function:
  for item in ${_PA[runcallbacks]}; do
    IFS=, read -r stateval func <<<"${item}"
    [[ ${stateval} == "${_PA[command]}${_PA[subcommand]}" ]] && {
      eval "${func}" || retval=$?
      return "${retval}"
    }
  done

  PA_usage

  return "${OK}"
}

# PA_usage outputs help text for a single component if help was asked for when
# a command was specified, or for all components otherwise.
# Args: None expected.
PA_usage() {

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[usagecallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func}"
      return
    }
  done

  eval "${_PA[usage]}"
}

# Private Functions -----------------------------------------------------------

# PA_new sets the initial values for the PArser's associative array.
# Args: None expected.
_PA_new() {
  _PA[command]=
  _PA[subcommand]=
  _PA[state]="COMMAND"
  _PA[optscallbacks]=
  _PA[usagecallbacks]=
  _PA[statecallbacks]=
  _PA[runcallbacks]=
  # The return value if the caller asked for an extra shift:
  _PA[shift]=126
}

# _PA_check_token checks for a valid token in arg2 state. The logic is
# most easily understood by reading the full original version at:
# https://github.com/mclarkson/my-own-kind/blob/master/docs/package.md#scripted-cluster-creation-and-deletion
# This function is a reduction of all the check_xxx_token functions.
# Args: arg1 - the token to check.
#       arg2 - the current state.
#       arg3 - the state value to set, optional. This should only be sent
#              for command and subcommand states.
_PA_check_token() {

  local item

  if [[ -n ${_PA[subcommand]} ]]; then
    cmdsubcommand="${_PA[command]}${_PA[subcommand]}"
  elif [[ -n ${_PA[command]} && ${_PA[state]} != "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}$1"
  elif [[ -n ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}"
  elif [[ -z ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand=
  else
    cmdsubcommand="$1"
  fi

  for item in ${_PA[statecallbacks]}; do
    IFS=, read -r state component newstate func <<<"${item}"
    [[ ${state} == "$2" ]] && {
      [[ ${component} == "${cmdsubcommand}" ]] && {
        [[ -n $3 ]] && _PA["$3"]="$1"
        _PA[state]="${newstate}"
        [[ -n ${func} ]] && {
          eval "${func} $1" || return
        }
        return "${OK}"
      }
    }
  done
}

# _PA_process_option checks that the user-provided option is valid for the
# command-subcommand or global states.
# Args: arg1 - The option to check.
#       arg2 - TODO The value of the option if present, optional.
_PA_process_option() {

  local item curcmdsubcmd

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[optscallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func} \"$1\" \"$2\""
      return $?
    }
  done

  return "${ERROR}"
}

# Initialise _PA
_PA_new

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GL - Globals

# Private Functions -----------------------------------------------------------

# GL_new sets the only global variables that should be in use anywhere.  The
# only other globals are the associative arrays. All the globals are constant
# (readonly) variables. Declare these globals, where needed, in other files
# so that shellcheck passes.
# Args: None expected.
_GL_new() {

  declare -rg MOKVERSION="0.8.22"
  declare -rg K8SVERSION="1.32.0"
  declare -rg GO_VERSION="1.23.2"

  # Returns, exit codes
  declare -rg OK=0
  declare -rg SUCCESS=0
  declare -rg ERROR=1
  declare -rg FAILURE=1

  # For setting flags
  declare -rg TRUE=1
  declare -rg FALSE=0

  # To signal main() to exit with SUCCESS in the PArser
  declare -rg STOP=2

  declare -rg STDOUT="/dev/stdout"
  declare -rg STDERR="/dev/stderr"

  # The following just keep shellcheck happy
  local dummy dumb
  dummy="${OK}"
  dummy="${ERROR}"
  dummy="${STOP}"
  dummy="${STDOUT}"
  dummy="${STDERR}"
  dummy="${TRUE}"
  dummy="${FALSE}"
  dummy="${SUCCESS}"
  dummy="${FAILURE}"
  dummy="${MOKVERSION}"
  dummy="${GO_VERSION}"
  dummy="${K8SVERSION}"
  dumb="${dummy}${dumb}"
}

# Initialise GL
_GL_new || exit 1

# vim helpers -----------------------------------------------------------------

# The following lines allow the use of '[C-i' and '[I' (do ':help [I') in vim.
#include buildimage.sh
#include containerutils.sh
#include createcluster.sh
#include deletecluster.sh
#include embed-dockerfile.sh
#include error.sh
#include exec.sh
#include getcluster.sh
#include main.sh
#include lib/parser.sh
#include util.sh
#include versions.sh

# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# ER - Error handling

# ER is an associative array that holds data specific to error handling.
declare -A ER

# Declare externally defined associative arrays -------------------------------

# Defined in GL (globals.sh)
declare ERROR TRUE STDERR

# Public Functions ------------------------------------------------------------

# ER_err outputs a stacktrace and returns ERROR status.
# Args: None expected.
ER_err() {

  # In case of error print the function call stack
  # No args expected

  [[ ${ER[errcalled]} == "${TRUE}" ]] && return "${ERROR}"
  ER[errcalled]="${TRUE}"
  local frame=0
  printf '\n' >"${STDERR}"
  while caller "${frame}"; do
    ((frame++))
  done | tac >"${STDERR}"
  printf '\n' >"${STDERR}"
  return "${ERROR}"
}

# err is a synonym for ER_err to aid with code readability.
err() {
  ER_err
  return
}

# Private Functions -----------------------------------------------------------

# ER_new sets the initial values for the ER associative array.
# Args: None expected.
_ER_new() {
  ER[errcalled]=
}

# Initialise ER
_ER_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# UT - Utilities

# _UT is an associative array that holds data specific to general utilities.
declare -A _UT

# Declare externally defined global variables ---------------------------------

declare OK STDERR FALSE TRUE

# Getters/Setters -------------------------------------------------------------

# UT_runlogfile getter outputs the value of _UT[runlogfile], which contains the
# name of the file written to when running UT_run_with_progress.
UT_runlogfile() {
  printf '%s' "${_UT[runlogfile]}"
}

# UT_tailf getter indicates whether a log will be shown in real-time during the
# 'run', TRUE, or not, FALSE.
# Args
UT_tailf() {
  printf '%s' "${_UT[tailf]}"
}

# UT_tailf setter indicates whether a log should be shown during the 'run',
# TRUE, or not, FALSE.
# Args: arg1 - Whether to tail, TRUE or FALSE.
UT_set_tailf() {
  _UT[tailf]="$1"
}

# UT_set_plain setter sets plain output, with no colour, animations, or UTF
# high byte characters.
# Args: arg1 - Whether to show plain output, TRUE or FALSE.
UT_set_plain() {
  _UT[plain]="$1"
  UT_disable_colours
}

# Public Functions ------------------------------------------------------------

# UT_disable_colours resets variables used for colourised output so that they
# contain no colour terminal escapes. Useful if stdin is not a terminal.
UT_disable_colours() {
  _UT[yellow]=
  _UT[green]=
  _UT[red]=
  _UT[normal]=
  _UT[probablysuccess]="!"
  _UT[success]="✓"
  _UT[failure]="✕"
}

# UT_run_with_progress displays a progress spinner, item text, and a tick or
# cross based on the exit code.
# Args: arg1   - the text to display.
#       arg2-N - remaining args are the program to run and its arguments.
UT_run_with_progress() {

  local displaytext=$1 retval int spinner=()

  _UT[runlogfile]=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }
  shift

  if [[ ${_UT[tailf]} == "${FALSE}" && ${_UT[plain]} == "${TRUE}" ]]; then

    # Output with no colours or spinny

    printf '%s' "${displaytext}"

    eval "$*" &>"${_UT[runlogfile]}"
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 0 ]]; then
      printf ' .. %s\n' "${_UT[success]}"
    else
      printf ' .. %s\n' "${_UT[failure]}"
    fi

  elif [[ ${_UT[tailf]} == "${FALSE}" ]]; then

    # Output with colours and spinny

    while read -r char; do
      spinner+=("${char}")
    done <<<"$(grep -o . <<<"${_UT[spinnerchars]}")"

    (
      eval "$*" &>"${_UT[runlogfile]}"
    ) &

    # Turn the cursor off
    tput civis

    # Start the spin animation
    printf ' %s' "${displaytext}"
    (while true; do
      for int in {0..3}; do
        printf '\r  %s ' "${spinner[int]}"
        sleep .1
      done
    done) &
    _UT[spinnerpid]=$!
    disown

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Kill the spinner
    kill "${_UT[spinnerpid]}" 2>/dev/null
    _UT[spinnerpid]=

    sleep .5

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\r  %s\n' "${_UT[probablysuccess]}"
    elif [[ ${retval} -eq 0 ]]; then
      printf '\r  %s\n' "${_UT[success]}"
    else
      printf '\r  %s\n' "${_UT[failure]}"
    fi

    # Restore the cursor
    tput cnorm
    sleep .5

  else

    # Tailf output

    printf 'COMMAND: %s\n\n' "$*"

    (
      eval "$*" &>/dev/stdout
    ) &
    sleep 1

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\n\nSTATUS: OK - (Probably)\n\n'
    elif [[ ${retval} -eq 0 ]]; then
      printf '\n\nSTATUS: OK\n\n'
    else
      printf '\n\nSTATUS: FAIL\n\n'
    fi
  fi

  return "${retval}"
}

# UT_cleanup removes any artifacts that were created during execution.
# This is called by 'MA_cleanup' trap only.
UT_cleanup() {

  # Called when the script exits.

  local int

  # Kill the spinny, and anything else, if they're running
  if [[ ${_UT[tailf]} == "${FALSE}" ]]; then
    [[ -n ${_UT[spinnerpid]} ]] && {
      printf '%s\r  ✕%s\n' "${_UT[red]}" "${_UT[normal]}"
      kill "${_UT[spinnerpid]}"
    }
    # If progress spinner crashed make sure the cursor is shown
    [ -t 1 ] && tput cnorm
  else
    kill "${_UT[spinnerpid]}" &>/dev/null
  fi

  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _UT_new sets the initial values for the _UT associative array.
# Args: None expected.
_UT_new() {
  _UT[tailf]="${FALSE}"
  _UT[yellow]=$(tput setaf 3)
  _UT[green]=$(tput setaf 2)
  _UT[red]=$(tput setaf 1)
  _UT[normal]=$(tput sgr0)
  _UT[probablysuccess]="${_UT[yellow]}✓${_UT[normal]}"
  _UT[success]="${_UT[green]}✓${_UT[normal]}"
  _UT[failure]="${_UT[red]}✕${_UT[normal]}"
  _UT[runlogfile]=
  _UT[spinnerchars]="|/-\\"
  _UT[spinnerpid]=
}

# Initialise _UT
_UT_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GC - Get Cluster

# _GC is an associative array that holds data specific to the get cluster command.
declare -A _GC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# GC_showheader getter outputs the value of the showheader array member.
GC_showheader() {
  printf '%s' "${_GC[showheader]}"
}

# GC_set_showheader setter sets the value of the showheader array member.
# If $TRUE the header will be shown, or $FALSE, then it won't be shown.
GC_set_showheader() {
  _GC[showheader]="$1"
}

# GC_set_clustername setter sets the cluster name to show information about.
GC_set_clustername() {
  _GC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# GC_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted. It is called by
# MA_cleanup.
GC_cleanup() {
  :
}

# GC_process_options checks if arg1 is in a list of valid get cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
GC_process_options() {

  case "$1" in
  -h | --help)
    GC_usage
    return "${STOP}"
    ;;
  *)
    GC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# GC_usage outputs help text for the create cluster component.
# It is called by PA_usage().
# Args: None expected.
GC_usage() {

  cat <<'EnD'
GET subcommands are:
 
  cluster[s] - list all mok managed clusters.
 
get cluster[s] options:
 
 Format:
  get cluster(s) [NAME]
  NAME        - (optional) The name of the cluster to get
                details about.

EnD
}

# GC_run gets information about cluster(s).
# This function is called in main.sh.
# Args: None expected.
GC_run() {

  _GC_sanity_checks || return

  local ids id info output labelkey
  local containerhostname containerip

  declare -a nodes

  ids=$(CU_get_cluster_container_ids "${_GC[clustername]}") || return

  if [[ -z ${ids} ]]; then
    printf 'No clusters found\n'
    return "${OK}"
  fi

  readarray -t nodes <<<"${ids}"

  # Use 'docker inspect' to get the value of the label $LABELKEY

  output=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  # Output the header
  [[ ${_GC[showheader]} -eq ${TRUE} ]] && {
    printf 'MOK_Cluster Docker_ID Container_Name IP_Address\n' >"${output}"
  }

  labelkey=$(CU_labelkey) || err || return

  for id in "${nodes[@]}"; do

    info=$(CU_get_container_info "${id}") || return

    clustname=$(JSONPath ".[0].Config.Labels.${labelkey}" -b <<<"${info}") ||
      err || return

    containerhostname=$(JSONPath '.[0].Config.Hostname' -b <<<"${info}") ||
      err || return

    containerip=$(JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}") ||
      err || return

    printf '%s %s %s %s\n' "${clustname}" "${id}" "${containerhostname}" "${containerip}"

  done | sort -k 3 >>"${output}"

  column -t "${output}" || err
}

# Private Functions -----------------------------------------------------------

# _GC_new sets the initial values for the _GC associative array.
# Args: None expected.
_GC_new() {
  _GC[showheader]="${TRUE}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "get" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "getcluster" "ARG1" ""
  PA_add_state "SUBCOMMAND" "getclusters" "ARG1" ""
  PA_add_state "ARG1" "getcluster" "END" "GC_set_clustername"
  PA_add_state "ARG1" "getclusters" "END" "GC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "get" "GC_process_options" || return
  PA_add_option_callback "getcluster" "GC_process_options" || return
  PA_add_option_callback "getclusters" "GC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "get" "GC_usage" || return
  PA_add_usage_callback "getcluster" "GC_usage" || return
  PA_add_usage_callback "getclusters" "GC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "getcluster" "GC_run"
  PA_add_run_callback "getclusters" "GC_run"
}

# GC_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_GC_sanity_checks() {

  # Only show the usage if we are in 'get' mode and have not specified a
  # subcommand. This allows internal code to call GC_run()
  if [[ $(PA_command) == "get" && -z $(PA_subcommand) ]]; then
    GC_usage
    exit "${OK}"
  fi
}

# Initialise _GC
_GC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# MU - Machine Utilities for Podman

# _MU is an associative array that holds data specific to machine utils.
declare -A _MU

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR STOP TRUE FALSE

# Getters/Setters -------------------------------------------------------------

# Public Functions ------------------------------------------------------------

# MU_cleanup removes artifacts that were created during execution. This function
# is run automatically by the Parser library. Currently this does nothing and
# this function could be deleted.
MU_cleanup() { :; }

# MU_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_process_options() {
  case "$1" in
  -h | --help)
    MU_usage
    return "${STOP}"
    ;;
  *)
    MU_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_usage() {

  cat <<'EnD'
MACHINE subcommands are:
 
  list   - List the currently created Podman machines.
           Only one machine is currently supported and if it exists
           it will be named 'mok-machine'.
  create - Create a Podman machine named 'mok-machine'.
  delete - Delete the Podman machine named 'mok-machine'.
  setup  - Modify the Podman machine to automatically apply the correct
           settings to run Kubernetes. Mok will also be copied to the
           Podman machine for cases where the host machine does not
           have GNU tools installed.
 
For more information:

  machine list -h
  machine create -h
  machine delete -h
  machine setup -h
 
EnD
}

# MACHINE LIST ================================================================

# MU_list_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_list_process_options() {
  case "$1" in
  -h | --help)
    MU_list_usage
    return "${STOP}"
    ;;
  *)
    MU_list_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_list_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_list_usage() {

  cat <<'EnD'
machine list options:
 
 Format:
  machine list [flags]
 
 Flags:
  -h - This help text.

EnD
}

# MU_list_run lists Podman machines.
# Args: None expected.
MU_list_run() {
  echo "MU_list_run"
}

# MACHINE CREATE ==============================================================

# MU_create_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_create_process_options() {
  case "$1" in
  -h | --help)
    MU_create_usage
    return "${STOP}"
    ;;
  *)
    MU_create_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_create_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_create_usage() {

  cat <<'EnD'
machine create options:
 
 Format:
  machine create [flags]
 
 Flags:
  -h - This help text.

EnD
}

# MU_create_run lists Podman machines.
# Args: None expected.
MU_create_run() {
  echo "MU_create_run"
}

# MACHINE DELETE ==============================================================

# MU_delete_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_delete_process_options() {
  case "$1" in
  -h | --help)
    MU_delete_usage
    return "${STOP}"
    ;;
  *)
    MU_delete_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_delete_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_delete_usage() {

  cat <<'EnD'
machine delete options:
 
 Format:
  machine delete [flags]
 
 Flags:
  -h - This help text.

EnD
}

# MU_delete_run deletes a Podman machine.
# Args: None expected.
MU_delete_run() {
  echo "MU_delete_run"
}

# MACHINE SETUP ===============================================================

# MU_setup_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_setup_process_options() {
  case "$1" in
  -h | --help)
    MU_setup_usage
    return "${STOP}"
    ;;
  *)
    MU_setup_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}


# MU_setup_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_setup_usage() {

  cat <<'EnD'
machine setup options:
 
 Format:
  machine setup [flags]
 
 Flags:
  -h - This help text.

EnD
}

# MU_setup_run sets up a Podman machine.
# Args: None expected.
MU_setup_run() {
  echo "MU_setup_run"
}

# Private Functions -----------------------------------------------------------

# _MU_new sets the initial values for the Machine Utils associative array and
# sets up the Parser to call functions in this file.
# Args: None expected.
_MU_new() {
  # Program the parser's state machine
  PA_add_state "COMMAND" "machine" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "machinelist" "END" ""
  PA_add_state "SUBCOMMAND" "machinecreate" "END" ""
  PA_add_state "SUBCOMMAND" "machinedelete" "END" ""
  PA_add_state "SUBCOMMAND" "machinesetup" "END" ""

  # Set up the parser's option callbacks
  PA_add_option_callback "machine" "MU_process_options" || return
  PA_add_option_callback "machinelist" "MU_list_process_options" || return
  PA_add_option_callback "machinecreate" "MU_create_process_options" || return
  PA_add_option_callback "machinedelete" "MU_delete_process_options" || return
  PA_add_option_callback "machinesetup" "MU_setup_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "machine" "MU_usage" || return
  PA_add_usage_callback "machinelist" "MU_list_usage" || return
  PA_add_usage_callback "machinecreate" "MU_create_usage" || return
  PA_add_usage_callback "machinedelete" "MU_delete_usage" || return
  PA_add_usage_callback "machinesetup" "MU_setup_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "machinelist" "MU_list_run"
  PA_add_run_callback "machinecreate" "MU_create_run"
  PA_add_run_callback "machinedelete" "MU_delete_run"
  PA_add_run_callback "machinesetup" "MU_setup_run"
}

# Initialise _MU
_MU_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# EX - EXec

# EX is an associative array that holds data specific to the exec cluster command.
declare -A _EX

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# EX_set_containername setter sets the containername to be used to 'log in' to.
EX_set_containername() {
  _EX[containername]="$1"
}

# Public Functions ------------------------------------------------------------

# EX_process_options checks if arg1 is in a list of valid exec options. This
# function is called by the parser, via a callback in _EX_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
EX_process_options() {

  case "$1" in
  -h | --help)
    EX_usage
    return "${STOP}"
    ;;
  *)
    EX_usage
    printf 'ERROR: "%s" is not a valid "exec" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# EX_usage outputs help text for the create exec component.  It is called in
# this file and by PA_usage(), via a callback in _EX_new.
# Args: None expected.
EX_usage() {

  cat <<'EnD'
'Log in' to a container. EXEC has no subcommands.
 
exec options:
 
 Format:
  exec [NAME]
  NAME        - (optional) The name of the container to 'log in' to.
                If NAME is not given then the user will be offered
                a choice of containers to log in to. If there is only
                one cluster and one node then it will 'log in' to the
                only available container.

EnD
}

# Execs 'bash' in the container referenced by _EX[containername]. If just
# 'mok exec' is called without options then the user is offered a selection
# of existing clusters to exec into.
# Args: None expected.
# ---------------------------------------------------------------------------
EX_run() {

  _EX_sanity_checks || return

  local names int ans lines containernames gcoutput

  GC_set_showheader "${TRUE}" || err || return
  gcoutput=$(GC_run) || return
  names=$(printf '%s' "${gcoutput}" | awk '{ print $3; }')
  readarray -t containernames <<<"${names}"

  if [[ -n ${_EX[containername]} ]]; then

    # The caller gave a specific name for exec.
    # Check if the container name exists

    if grep -qs "^${_EX[containername]}$" <<<"${names}"; then
      _EX_exec "${_EX[containername]}" || return
      return "${OK}"
    else
      printf 'ERROR: Cannot exec into non-existent container: "%s".\n' \
        "${_EX[containername]}"
      return "${ERROR}"
    fi

  elif [[ ${#containernames[*]} == 2 ]]; then

    # If there's only one container just log into it without asking
    _EX_exec "${containernames[1]}"

  elif [[ ${#containernames[*]} == 1 ]]; then

    printf 'No containers found.\n'
    return "${OK}"

  else

    # The caller supplied no container name.
    # Present some choices

    printf 'Choose the container to log in to:\n\n'

    readarray -t lines <<<"${gcoutput}" || return

    # Print the header then print the items in the loop
    printf '   %s\n' "${lines[0]}"
    for int in $(seq 1 $((${#lines[*]} - 1))); do
      printf '%00d) %s\n' "${int}" "${lines[int]}"
    done | sort -k 4

    printf "\nChoose a number (Enter to cancel)> "
    read -r ans

    [[ -z ${ans} || ${ans} -lt 0 || ${ans} -gt $((${#lines[*]} - 1)) ]] && {
      printf '\nInvalid choice. Aborting.\n'
      return "${OK}"
    }

    _EX_exec "${containernames[ans]}"
  fi
}

# Private Functions -----------------------------------------------------------

# _EX_new sets the initial values for the _EX associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
_EX_new() {
  _EX[containername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "exec" "ARG1" ""
  PA_add_state "ARG1" "exec" "END" "EX_set_containername"

  # Set up the parser's option callbacks
  PA_add_option_callback "exec" "EX_process_options" || return
  PA_add_usage_callback "exec" "EX_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "exec" "EX_run"
}

# EX_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For exec this does nothing.
# Args: None expected.
_EX_sanity_checks() { :; }

# _EX_exec runs a command in a docker container using bash as the command by
# default.
# Args: arg1 - docker container name
#       arg2 - command to run
_EX_exec() {

  local cmd=${2:-bash}

  containerrt=$(CU_containerrt) || err || return

  read -rt 0.1
  if [[ ${containerrt} == "podman" ]]; then
    exec podman exec -ti "$1" "${cmd}"
  elif [[ ${containerrt} == "docker" ]]; then
    exec docker exec -ti "$1" "${cmd}"
  fi
}

# Initialise EX
_EX_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# DC - Delete Cluster

# _DC is an associative array that holds data specific to deleting a cluster.
declare -A _DC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR STOP TRUE

# Getters/Setters -------------------------------------------------------------

# DC_set_clustername setter sets the cluster name to be deleted. This is
# called by the parser, via a callback in _DC_new.
DC_set_clustername() {
  _DC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# DC_process_options checks if arg1 is in a list of valid delete cluster
# options. This function is called by the parser, via a callback in _DC_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
DC_process_options() {

  case "$1" in
  -h | --help)
    DC_usage
    return "${STOP}"
    ;;
  *)
    DC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# DC_usage outputs help text for the create cluster component.
# It is called by PA_usage(), via a callback in _DC_new.
# Args: None expected.
DC_usage() {

  cat <<'EnD'
DELETE subcommands are:
 
  cluster - Delete a local kubernetes cluster.
 
delete cluster options:
 
 Format:
  delete cluster NAME
  NAME        - The name of the cluster to delete

EnD
}

# DC_run starts the delete cluster process.
# Args: None expected.
DC_run() {

  _DC_sanity_checks || return

  # Mutate functions make system changes.

  declare -i numnodes=0
  local id ids r

  numnodes=$(CU_get_cluster_size "${_DC[clustername]}") || return

  [[ ${numnodes} -eq 0 ]] && {
    printf '\nERROR: No cluster exists with name, "%s". Aborting.\n\n' \
      "${_DC[clustername]}" >"${STDERR}"
    return "${ERROR}"
  }

  ids=$(CU_get_cluster_container_ids "${_DC[clustername]}") || return

  printf 'The following containers will be deleted:\n\n'

  GC_set_showheader "${TRUE}"
  GC_set_clustername "${_DC[clustername]}"
  GC_run "${_DC[clustername]}" || return

  printf "\nAre you sure you want to delete the cluster? (y/N) >"

  read -r ans

  [[ ${ans} != "y" ]] && {
    printf '\nCancelling by user request.\n'
    return "${OK}"
  }

  printf '\n'

  for id in ${ids}; do
    UT_run_with_progress \
      "    Deleting id, '${id}' from cluster '${_DC[clustername]}'." \
      _DC_delete "${id}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n\n' >"${STDERR}"
      err
      return "${r}"
    }
  done

  printf '\n'
}

# Private Functions -----------------------------------------------------------

# _DC_new sets the initial values for the _DC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_DC_new() {
  _DC[clustername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "delete" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "deletecluster" "ARG1" ""
  PA_add_state "ARG1" "deletecluster" "END" "DC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "delete" "DC_process_options" || return
  PA_add_option_callback "deletecluster" "DC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "delete" "DC_usage" || return
  PA_add_usage_callback "deletecluster" "DC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "deletecluster" "DC_run"
}

# DC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before DC_run is called.
# Args: None expected.
_DC_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    DC_usage
    exit "${OK}"
  fi

  if [[ -z ${_DC[clustername]} ]]; then
    DC_usage
    printf 'Please provide the Cluster NAME to delete.\n' >"${STDERR}"
    return "${ERROR}"
  fi
}

# _DC_delete stops and removes a docker container.
# Args: arg1 - docker id to delete.
_DC_delete() {

  docker stop -t 5 "${id}"
  docker rm "${id}" || err
}

# Initialise _DC
_DC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE K8SVERSION

# Getters/Setters -------------------------------------------------------------

# CC_set_clustername setter sets the clustername array item.
CC_clustername() {
  printf '%s' "${_CC[clustername]}"
}

# CC_publish getter outputs the publish array item.
CC_publish() {
  printf '%s' "${_CC[publish]}"
}

# CC-withlb getter outputs the withlb array item.
CC_withlb() {
  printf '%s' "${_CC[withlb]}"
}

# CC_set_clustername setter sets the clustername array item.
CC_set_clustername() {
  _CC[clustername]="$1"
}

# CC_set_nummasters setter sets the nummasters array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_nummasters() {
  _CC[nummasters]="$1"
}

# CC_set_numworkers setter sets the numworkers array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_numworkers() {
  _CC[numworkers]="$1"
}

# Public Functions ------------------------------------------------------------

# CC_process_options checks if arg1 is in a list of valid create cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option. For example, '--masters' should be sent
#              with a value but boolean options, like 'skiplbsetup' should not.
CC_process_options() {

  case "$1" in
  -h | --help)
    CC_usage
    return "${STOP}"
    ;;
  --skiplbsetup)
    _CC[skiplbsetup]="${TRUE}"
    return
    ;;
  --k8sver)
    _CC[k8sver]="$2"
    return "$(PA_shift)"
    ;;
  --with-lb)
    _CC[withlb]="${TRUE}"
    return
    ;;
  --skipmastersetup)
    _CC[skipmastersetup]="${TRUE}"
    return
    ;;
  --skipworkersetup)
    _CC[skipworkersetup]="${TRUE}"
    return
    ;;
  --masters)
    _CC[nummasters]="$2"
    return "$(PA_shift)"
    ;;
  --workers)
    _CC[numworkers]="$2"
    return "$(PA_shift)"
    ;;
  --tailf)
    _CC[tailf]="${TRUE}"
    return "${OK}"
    ;;
  --publish)
    _CC[publish]="${TRUE}"
    return
    ;;
  *)
    CC_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# CC_usage outputs help text for the create cluster component.  It is called in
# this file and by PA_usage(), via a callback set in _CC_new.
# Args: None expected.
CC_usage() {

  cat <<'EnD'
CREATE subcommands are:
 
  cluster - Create a local kubernetes cluster.
 
create cluster [flags] options:
 
 Format:
  create cluster NAME [ [NUM_MASTERS] [NUM_WORKERS] ]
  NAME        - The name of the cluster. This will be used as
                the prefix in the name for newly created
                docker containers.
  NUM_MASTERS - The number of master containers.
  NUM_WORKERS - The number of worker containers. If NUM_WORKERS is
                zero then the 'node-role.kubernetes.io/master' taint
                will be removed from master nodes so that pods are
                schedulable.
 
 Flags:
  --skipmastersetup - Create the master container but don't set it
         up. Useful for manually installing kubernetes. Kubeadm, 
         kubelet and kubectl will be installed at the requested 
         version. With this option the worker will also be skipped.
         See also '--k8sver' flag.
  --skipworkersetup - The same as '--skipmastersetup', but skips
         setting up the worker only.
  --with-lb - Add a haproxy load balancer. The software will be installed
         and set up to reverse proxy to the master node(s), unless
         --skiplbsetup is used.
  --k8sver VERSION - Unimplemented.
  --masters NUM - The number of master containers to create.
  --workers NUM - The number of worker containers to create. When workers
                  is zero then the master node taint will be removed from
                  master nodes so that pods are schedulable on those nodes.
  --tailf - Show the log output whilst creating the cluster.
  --publish - Publish port 6443 for the master node, or the load balancer if
              it's enabled, for external kubectl access to the cluster. The IP
              address of the default route interface is added to the cert.

EnD
}

# CC_run creates the kubernetes cluster.
# Args: None expected.
CC_run() {

  _CC_sanity_checks || return

  [[ ${_CC[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  declare -i numnodes=0

  numnodes=$(CU_get_cluster_size "${_CC[clustername]}") || return

  [[ ${numnodes} -gt 0 ]] && {
    printf '\nERROR: Cluster, "%s", exists! Aborting.\n\n' "${_CC[clustername]}" \
      >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_create_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_create_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_setup_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_setup_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[numworkers]} -gt 0 ]] && {
    _CC_create_worker_nodes "${_CC[numworkers]}" || return
  }

  printf '\n'

  [[ -z ${_CC[skipmastersetup]} ]] && {
    printf 'Cluster, "%s", can be accessed using:\n\n' "${_CC[clustername]}"
    printf 'export KUBECONFIG=/var/tmp/admin-%s.conf\n\n' "${_CC[clustername]}"
  }

  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CC_new sets the initial values for the _CC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_CC_new() {
  _CC[tailf]="${FALSE}"
  _CC[skipmastersetup]=
  _CC[skipworkersetup]=
  _CC[skiplbsetup]=
  _CC[withlb]=
  _CC[clustername]=
  _CC[nummasters]=0
  _CC[numworkers]=0
  _CC[publish]=0
  _CC[k8sver]="${K8SVERSION}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "create" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "createcluster" "ARG2" ""

  # Support for the legacy style of create (less to type):
  PA_add_state "ARG1" "createcluster" "ARG2" "CC_set_clustername"
  PA_add_state "ARG2" "createcluster" "ARG3" "CC_set_nummasters"
  PA_add_state "ARG3" "createcluster" "END" "CC_set_numworkers"

  # Set up the parser's option callbacks
  PA_add_option_callback "create" "CC_process_options" || return
  PA_add_option_callback "createcluster" "CC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "create" "CC_usage" || return
  PA_add_usage_callback "createcluster" "CC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "createcluster" "CC_run"
  PA_add_run_callback "createclusters" "CC_run"
}

# CC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before CC_run is called.
# Args: None expected.
_CC_sanity_checks() {

  declare -i host_max=0 cpus=0 should_be=0

  if [[ -z $(PA_subcommand) ]]; then
    CC_usage
    exit "${OK}"
  fi

  if [[ -z ${_CC[clustername]} ]]; then
    CC_usage
    printf 'Please provide the Cluster NAME to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[nummasters]} || ${_CC[nummasters]} -le 0 ]]; then
    CC_usage
    printf 'Please provide the number of Masters to create. Must be 1 or more.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[numworkers]} ]]; then
    CC_usage
    printf 'Please provide the number of Workers to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/sys/net/nf_conntrack_max ]]; then
    host_max=$(cat /proc/sys/net/nf_conntrack_max)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    host_max=$(podman machine ssh cat /proc/sys/net/nf_conntrack_max)
  else
    printf '\nWARNING: /proc/sys/net/nf_conntrack_max not found.\n' >"${STDERR}"
    printf '         kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/cpuinfo ]]; then
    cpus=$(grep -cw ^processor /proc/cpuinfo)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    cpus=$(podman machine ssh cat /proc/cpuinfo | grep -cw ^processor)
  else
    printf '\nWARNING: /proc/cpuinfo not found.\n' >"${STDERR}"
    printf '         I have no idea how many CPUs I have\n' >"${STDERR}"
    printf '         and kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  # These are the default values that kube-proxy expects:
  # conntrack:
  #   max: null
  #   maxPerCore: 32768
  #   min: 131072
  if [[ $((32768*cpus)) -lt 131072 ]]; then
    should_be=131072
  else
    should_be=$((32768*cpus))
  fi
  if [[ ${should_be} -ne $host_max ]]; then
    printf '\nERROR: /proc/sys/net/nf_conntrack_max should be set to %d.\n' \
      "${should_be}" >"${STDERR}"
    printf '     kube-proxy will not start with an incorrect nf_conntrack_max.\n' >"${STDERR}"
    printf '     To fix this, run the following command:\n\n' >"${STDERR}"
    if [[ $(CU_podmantype) == "native" ]]; then
      printf '       sudo sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
    elif [[ $(CU_podmantype) == "machine" ]]; then
      printf '       podman machine ssh sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
      printf '     If the above command fails, you may have to recreate the podman machine, for example:\n\n' >"${STDERR}"
      tput setaf 1 # red
      printf '     WARNING: The following commands will destroy your podman machine and all its data.\n' >"${STDERR}"
      printf '              All existing pods and containers will be gone.\n\n' >"${STDERR}"
      tput sgr0 # reset
      printf '       podman machine stop\n' >"${STDERR}"
      printf '       podman machine rm\n' >"${STDERR}"
      printf '       podman machine init --now --rootful --user-mode-networing\n' >"${STDERR}"
      printf '       podman machine ssh modprobe nf_conntrack\n' >"${STDERR}"
      printf '       podman machine ssh sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
    else
      printf 'Internal ERROR. Invalid podman type.\n' >"${STDERR}"
      return "${ERROR}"
    fi
    
    printf 'Press ENTER to continue or CTRL-C to abort.\n' >"${STDERR}"
    read -r
    printf '\n' >"${STDERR}"
  fi
}

# _CC_create_master_nodes creates the master node containers.
# Args: arg1 - number of master nodes to create
_CC_create_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating master container, '${_CC[clustername]}-master-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-master-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }
  done

  return "${OK}"
}

# _CC_setup_master_nodes sets up the master node containers.
# Args: arg1 - number of master nodes to create
_CC_setup_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile lbaddr hostaddr
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-master-${int}'" \
      _CC_set_up_master_node "${_CC[clustername]}-master-${int}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  done

  # For now, copy admin.conf from master to /var/tmp/admin-CLUSTERNAME.conf

  if [[ -z ${_CC[skipmastersetup]} ]]; then
    if [[ ${_CC[publish]} -eq ${TRUE} ]]; then
      # On MacOS we need to use localhost, on linux use the host IP
      if [[ $(CU_podmantype) == "native" ]]; then
        hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
      else
        hostaddr="localhost"
      fi
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${hostaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    elif [[ ${_CC[withlb]} -eq ${TRUE} ]]; then
      lbaddr=$(CU_get_container_ip "${_CC[clustername]}-lb") || err || return
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${lbaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    else
      [[ -n ${_CC[skipmastersetup]} ]] || {
        docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
          "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      }
    fi

    chmod 666 "/var/tmp/admin-${_CC[clustername]}.conf" || {
      printf 'ERROR: Could not "chown 666 /var/tmp/admin-%s.conf"' "${_CC[clustername]}"
      err || return
    }
  fi

  return "${OK}"
}

# _CC_set_up_master_node calls the correct set up function based on the version
# Args: arg1 - the container ID to set up
_CC_set_up_master_node() {

  case "${_CC[k8sver]}" in
  "1.31."* | "1.32."*)
    _CC_set_up_master_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# _CC_get_master_join_details uses 'docker exec' or 'podman exec' to run a
# script on the master to get CA hash, a token, and the master IP.  The caller
# can eval the output of this function to set the variables: cahash, token, and
# masterip. See also:
# https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/#token-based-discovery-with-ca-pinning
# Args: arg1 - id/name of master container
_CC_get_master_join_details() {

  local joinvarsfile master1ip

  joinvarsfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  master1ip=$(CU_get_container_ip "${_CC[clustername]}-master-1") || err || return

  cat <<EnD >"${joinvarsfile}"
#!/bin/bash
set -e

sed 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${master1ip}"'\2#' \
  /etc/kubernetes/super-admin.conf >/etc/kubernetes/admin2.conf

cahash=\$(openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | \
        openssl rsa -pubin -outform der 2>/dev/null | \
        openssl dgst -sha256 -hex | sed 's/^.* //')
token=\$(kubeadm token create --kubeconfig=/etc/kubernetes/admin2.conf 2>/dev/null)
ip=\$(ip ro get 8.8.8.8 | cut -d" " -f 7)

printf 'cahash=%s\ntoken=%s\nmasterip=%s' "\$cahash" "\$token" "\$ip"

exit 0
EnD

  docker cp "${joinvarsfile}" "$1":/root/joinvars.sh 2>"${STDERR}" ||
    err || return
  rm -f "${joinvarsfile}" 2>"${STDERR}" || err || return

  [[ -z ${_CC[skipworkersetup]} ]] && {
    docker exec "$1" bash /root/joinvars.sh 2>"${STDERR}" || err || return
  }

  return "${OK}"
}

# _CC_create_lb_node creates the load balancer node container.
# Args: None expected.
_CC_create_lb_node() {

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  # Create container
  UT_run_with_progress \
    "    Creating load balancer container, '${_CC[clustername]}-lb'" \
    CU_create_container \
    "${_CC[clustername]}-lb" \
    "${labelkey}=${_CC[clustername]}" \
    "${_CC[k8sver]}"

  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    printf '\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
    printf '%s\n' "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  return "${OK}"
}

# _CC_setup_lb_node sets up the load balancer node container.
# Args: None expected.
_CC_setup_lb_node() {

  local runlogfile

  # Set up
  [[ -z ${_CC[skiplbsetup]} ]] && {
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-lb'" \
      _CC_set_up_lb_node_real "${_CC[clustername]}-lb"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _CC_set_up_lb_node_real sets up the lb node.
# Args: arg1 - the container ID to set up
_CC_set_up_lb_node_real() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masteriplist=
  nl=
  gotamaster="${FALSE}"
  for idx in $(seq 1 "${_CC[nummasters]}"); do
    ip=$(CU_get_container_ip "${_CC[clustername]}-master-${idx}") || continue
    gotamaster="${TRUE}"
    masteriplist="${masteriplist}${nl}    server master-${idx} ${ip}:6443 check fall 3 rise 2"
    nl='\n'
  done

  [[ ${gotamaster} == "${FALSE}" ]] && {
    printf 'ERROR: Did not manage to get an IP address for any master nodes\n'
    err || return
  }

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

systemctl stop kubelet crio
systemctl disable kubelet crio

apt -y install haproxy

INTERNAL_IP=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")

cat <<EOF | tee /etc/haproxy/haproxy.cfg 
frontend kubernetes
    bind \$INTERNAL_IP:6443
    option tcplog
    mode tcp
    default_backend kubernetes-master-nodes
backend kubernetes-master-nodes
    mode tcp
    balance roundrobin
    option tcp-check
\$(echo -e "${masteriplist}")
EOF

systemctl restart haproxy
systemctl enable haproxy

EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# _CC_create_worker_nodes creates the worker nodes.
# Args: arg1 - number of worker nodes to create
_CC_create_worker_nodes() {

  local cahash token t masterip
  declare -i int=0

  [[ -n ${_CC[skipmastersetup]} ]] || {
    # Runs a script on master node to get details
    t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1") || {
      printf '\nERROR: Problem with "_CC_get_master_join_details".\n\n' >"${STDERR}"
      return "${ERROR}"
    }

    # Sets cahash, token, and masterip:
    eval "${t}"
  }

  local labelkey
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating worker container, '${_CC[clustername]}-worker-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-worker-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }

    [[ -n ${_CC[skipworkersetup]} || -n ${_CC[skipmastersetup]} ]] || {
      UT_run_with_progress \
        "    Setting up '${_CC[clustername]}-worker-${int}'" \
        _CC_set_up_worker_node "${_CC[clustername]}-worker-${int}" \
        "${cahash}" "${token}" "${masterip}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n' >"${STDERR}"
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
        printf '%s\n' "${runlogfile}" >"${STDERR}"
        return "${ERROR}"
      }

      UT_run_with_progress \
        "    Waiting for system to become ready" \
        _CC_wait_for_cluster \
        "${_CC[clustername]}-master-1" \
        "${_CC[clustername]}-worker-${int}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n'
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Wait timed out.\n' >"${STDERR}"
        return "${ERROR}"
      }
    }
  done

  return "${OK}"
}

# _CC_wait_for_cluster runs a `kubectl` command in the master-1 container,
# which doesn't exit until the all pods are fully up and running before it
# returns.
# Args: arg1 - the master container name to log into
#       arg2 - the worker container name to wait for
_CC_wait_for_cluster() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  cat <<'EnD' >"${setupfile}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
found=0
for i in $(seq 1 20); do
  if kubectl get pods &>/dev/null; then
    found=1
    break
  fi
  sleep 1
done
[[ $found == 0 ]] && {
  printf '# kubectl get pods\n'
  kubectl get pods
  printf '\nWaited for 20 seconds for kubectl to work.\n'
  printf 'Kubectl cannot contact master. Aborting.\n'
  exit 1
}
counter=0
while ! kubectl get nodes | grep -qs "$1"; do
  ((counter++))
  [[ ${counter} -gt 60 ]] && {
    printf '# kubectl get nodes\n'
    kubectl get nodes
    printf '\nWaited for 2 minutes for node to appear in master. Aborting.\n'
    exit 1
  }
  sleep 2
done
counter=0
while kubectl get pods -A | tail -n +2 | awk '{ print $3; }' | grep -qs 0; do
  ((counter++))
  [[ ${counter} -gt 120 ]] && {
    printf '# kubectl get pods -A\n'
    kubectl get pods -A
    printf '\nWaited for 3 minutes for pods to be ready. Aborting.\n'
    exit 1
  }
  sleep 2
done
exit 0
EnD

  docker cp "${setupfile}" "$1":/root/wait.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/wait.sh "$2" || err
}

# _CC_set_up_worker_node calls the correct set up function based on the version.
# Args: arg1 - the container ID to set up
#       arg2 - the CA hash
#       arg3 - the token
#       arg4 - the master IP
_CC_set_up_worker_node() {

  case "${_CC[k8sver]}" in
  "1.31."* | "1.32."*)
    _CC_set_up_worker_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# Initialise _CC
_CC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster - versions file

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR TRUE

# _CC_set_up_master_node_v1_30_0 uses kubeadm to set up the master node.
# Args: arg1 - the container to set up.
_CC_set_up_master_node_v1_30_0() {

  local setupfile lbaddr certSANs="{}" certkey masternum t lbip
  # Set by _CC_get_master_join_details:
  local cahash token masterip

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masternum="${1##*-}" # <- eg. for xxx-master-1, masternum=1

  if [[ ${_CC[skipmastersetup]} != "${TRUE}" ]]; then

    if [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -eq 1 ]]; then

      # This is the first master node

      # Sets cahash, token, and masterip:
      lbip=$(CU_get_container_ip "${_CC[clustername]}-lb")
      lbaddr=", '${lbip}'"
      uploadcerts="--upload-certs"
      certkey="CertificateKey: f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07"

    elif [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -ne 1 ]]; then

      # This is not the first master node, so join with the master
      # https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/

      # Keep trying to get join details until apiserver is ready or we run out of tries
      for try in $(seq 1 9); do
        # Runs a script on master node to get join details
        t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1")
        retval=$?
        [[ ${retval} -eq 0 ]] && break
        [[ ${try} -eq 9 ]] && {
          printf '\nERROR: Problem with "_CC_get_master_join_details". Tried %d times\n\n' "${try}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        sleep 5
      done
      eval "${t}"
    fi
  fi

  # Always set certSANs for the host whether we need it or not
  hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
  certSANs="
  certSANs: [ '${hostaddr}'${lbaddr}, '127.0.0.1', 'localhost' ]"

  # Write the file regardless, so the user can use it if required

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

# Use a custom configuration. Default config created from kubeadm with:
#   kubeadm config print init-defaults
# then edited.

ipaddr=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")
podsubnet="10.244.0.0/16"
servicesubnet="10.96.0.0/16"

cat <<EOF >kubeadm-init-defaults.yaml
apiVersion: kubeadm.k8s.io/v1beta4
bootstrapTokens:
- groups:
  - system:bootstrappers:kubeadm:default-node-token
  token: abcdef.0123456789abcdef
  ttl: 24h0m0s
  usages:
  - signing
  - authentication
kind: InitConfiguration
${certkey}
localAPIEndpoint:
  advertiseAddress: \$ipaddr
  bindPort: 6443
nodeRegistration:
  criSocket: unix:///var/run/crio/crio.sock
  imagePullPolicy: IfNotPresent
  imagePullSerial: true
  name: $1
  taints:
  - effect: NoSchedule
    key: node-role.kubernetes.io/control-plane
timeouts:
  controlPlaneComponentHealthCheck: 4m0s
  discovery: 5m0s
  etcdAPICall: 2m0s
  kubeletHealthCheck: 4m0s
  kubernetesAPICall: 1m0s
  tlsBootstrap: 5m0s
  upgradeManifests: 5m0s
---
apiServer: ${certSANs}
apiVersion: kubeadm.k8s.io/v1beta4
caCertificateValidityPeriod: 87600h0m0s
certificateValidityPeriod: 8760h0m0s
certificatesDir: /etc/kubernetes/pki
clusterName: ${_CC[clustername]}-cluster
controlPlaneEndpoint: ${lbaddr:-\$ipaddr}:6443
controllerManager: {}
dns: {}
encryptionAlgorithm: RSA-2048
etcd:
  local:
    dataDir: /var/lib/etcd
imageRepository: registry.k8s.io
kind: ClusterConfiguration
networking:
  dnsDomain: cluster.local
  podSubnet: \${podsubnet}
  serviceSubnet: \${servicesubnet}
proxy: {}
scheduler: {}
EOF

mkdir -p /mok
cp kubeadm-init-defaults.yaml /mok/kubeadm.yaml

if [[ -z "${masterip}" ]]; then
  # Run the preflight phase
  kubeadm init \\
    --ignore-preflight-errors Swap \\
    --config=kubeadm-init-defaults.yaml \\
    phase preflight

  # Set up the kubelet
  kubeadm init phase kubelet-start

  # Edit the kubelet configuration file
  echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
  sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

  # Tell kubeadm to carry on from here
  kubeadm init \\
    --config=kubeadm-init-defaults.yaml \\
    --ignore-preflight-errors Swap \\
    ${uploadcerts} \\
    --skip-phases=preflight,kubelet-start

  export KUBECONFIG=/etc/kubernetes/super-admin.conf

  # Flannel - 10.244.0.0./16
  kubectl apply -f /root/kube-flannel.yml
else
  kubeadm join ${masterip}:6443 \\
    --ignore-preflight-errors Swap \\
    --control-plane \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --certificate-key f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07
fi

systemctl enable kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  # Run the file
  [[ -z ${_CC[skipmastersetup]} ]] && {
    docker exec "$1" bash /root/setup.sh || err || return

    # Remove the taint if we're setting up a single node cluster

    [[ ${_CC[numworkers]} -eq 0 ]] && {

      removetaint=$(mktemp -p /var/tmp) || {
        printf 'ERROR: mktmp failed.\n' >"${STDERR}"
        return "${ERROR}"
      }

      # Write the file
      cat <<'EnD' >"${removetaint}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
kubectl taint nodes --all node-role.kubernetes.io/control-plane:NoSchedule-
EnD

      docker cp "${removetaint}" "$1":/root/removetaint.sh || err || {
        rm -f "${removetaint}"
        return "${ERROR}"
      }

      # Run the file
      docker exec "$1" bash /root/removetaint.sh || err
    }
  }

  return "${OK}"
}

# _CC_set_up_worker_node_v1_30_0 uses kubeadm to set up the worker node.
# Args: arg1 - the container to set up.
_CC_set_up_worker_node_v1_30_0() {

  local setupfile cahash="$2" token="$3" masterip="$4"

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  if [[ ${_CC[withlb]} == "${TRUE}" ]]; then
    masterip=$(CU_get_container_ip "${_CC[clustername]}-lb") || return
  fi

  cat <<EnD >"${setupfile}"
# Wait for the master API to become ready
while true; do
  curl -k https://${masterip}:6443/
  [[ \$? -eq 0 ]] && break
  sleep 1
done

# Do the preflight tests (ignoring swap error)
kubeadm join \\
  phase preflight \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --ignore-preflight-errors Swap \\
    ${masterip}:6443

# Set up the kubelet
kubeadm join \\
  phase kubelet-start \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    ${masterip}:6443 &

while true; do
  [[ -e /var/lib/kubelet/config.yaml ]] && break
    sleep 1
  done

# Edit the kubelet configuration file
echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

systemctl enable --now kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh 2>"${STDERR}" || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CU - Container Utilities

# _CU is an associative array that holds data specific to container utils.
declare -A _CU

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# CU_containerrt getter outputs the container runtime (podman or docker)
# that has been chosen.
CU_containerrt() {
  printf '%s' "${_CU[containerrt]}"
}

# CU_imgprefix getter outputs the prefix to be used with docker build. For
# podman it is 'localhost/'. For docker it is empty.
CU_imgprefix() {
  printf '%s' "${_CU[imgprefix]}"
}

# CU_labelkey getter outputs the key value of the label that is applied to all
# cluster member's container labels for podman or docker.
CU_labelkey() {
  printf '%s' "${_CU[labelkey]}"
}

# CU_podmantype getter outputs the container runtime type (native or machine).
CU_podmantype() {
  printf '%s' "${_CU[podmantype]}"
}

# Public Functions ------------------------------------------------------------

# CU_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted.
CU_cleanup() { :; }

# CU_get_cluster_container_ids outputs just the container IDs, one per line
# for any MOK cluster, unless arg1 is set, in which case just the IDs
# for the requested cluster name are output.
# Args: arg1 - The cluster name, optional.
CU_get_cluster_container_ids() {

  local value output

  [[ -n $1 ]] && value="=$1"

  output=$(docker ps -a -f label="${_CU[labelkey]}${value}" -q) || {
    printf 'ERROR: %s command failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  output=$(printf '%s' "${output}" | sed 's/$//')

  printf '%s' "${output}"

  return "${OK}"
}

# CU_get_cluster_size searches for an existing cluster using labels and outputs
# the number of containers in that cluster. All cluster nodes are labelled with
# "${_CU[labelkey]}=${CC[clustername]}"
# Args: arg1 - The cluster name to search for.
CU_get_cluster_size() {

  local output
  declare -a nodes

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Cluster name cannot be empty.\n' >"${STDERR}"
    err || return
  }

  output=$(CU_get_cluster_container_ids "$1") || err || return

  # readarray will read null as an array item so don't run
  # through readarray if it's null
  [[ -z ${output} ]] && {
    printf '0'
    return "${OK}"
  }

  # read the nodes array and delete blank lines
  readarray -t nodes <<<"${output}"

  printf '%d' "${#nodes[*]}"
}

# CU_get_container_ip outputs the IP address of the container.
# Args: arg1 - docker container id or container name to query.
CU_get_container_ip() {

  local info

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  info=$(CU_get_container_info "$1") || return
  JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}" ||
    err || return
}

# CU_get_container_info uses 'docker/podman inspect $id' to output
# container details.
# Args: arg1 - docker container id
CU_get_container_info() {

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  docker inspect "$1" || {
    printf 'ERROR: %s inspect failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_create_container creates and runs a container with settings suitable for
# running privileged containers that can manipulate cgroups.
# Args: arg1 - The string used to set the name and hostname.
#       arg2 - The label to assign to the container.
#       arg3 - The k8s base image version to use.
CU_create_container() {

  local imagename img allimgs systemd_always clustername parg pval

  [[ -z $1 || -z $2 || -z $3 ]] && {
    printf 'INTERNAL ERROR: Neither arg1, arg2 nor arg3 can be empty.\n' \
      >"${STDERR}"
    err || return
  }

  img=$(BI_baseimagename) || err || return

  local imglocal="${_CU[imgprefix]}local/${img}"
  local imgremote="myownkind/${img}"
  local imgtag="${3}"

  # Prefer a locally built container over one downloaded from a registry
  allimgs=$(docker images | tail -n +2) || {
    printf 'ERROR: %s returned an error\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  if echo "${allimgs}" | grep -qs "${imglocal} *${imgtag}"; then
    imagename="${imglocal}:${imgtag}"
  elif echo "${allimgs}" | grep -qs "${imgremote} *${imgtag}"; then
    imagename="${imgremote}:${imgtag}"
  else
    cat <<EnD
ERROR: No container base image found. Use either:

  $ mok build image
OR
  $ mok build image --get-prebuilt-image

Then try running 'mok create ...' again.
EnD
    return "${ERROR}"
  fi

  clustername=$(CC_clustername) || err || return

  if [[ ${_CU[containerrt]} == "podman" ]];
  then 
    docker network exists "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  else
    docker network inspect "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  fi

  [[ ${create_network} -ne 0 ]] && {
    docker network create "${clustername}_network" || {
      printf 'ERROR: docker network create failed\n' >"${STDERR}"
      err || return
    }
  }

  # Docker does not have the --systemd option
  [[ ${_CU[containerrt]} == "podman" ]] && systemd_always="--systemd=always"

  [[ $(CC_publish) == "${TRUE}" ]] && {
    if [[ $(CC_withlb) == "${TRUE}" ]]; then
      if echo "$1" | grep -qs -- '-lb$'; then
        parg='-p'
        pval='6443:6443'
      fi
    else
      if echo "$1" | grep -qs -- '-master-1$'; then
        parg='-p'
        pval='6443:6443'
      fi
    fi
  }

  docker run --privileged ${systemd_always} \
    --network "${clustername}_network" \
    -v /lib/modules:/lib/modules:ro \
    --detach ${parg} ${pval} \
    --name "$1" \
    --hostname "$1" \
    --label "$2" \
    "${imagename}" \
    /usr/local/bin/entrypoint /lib/systemd/systemd log-level=info unit=sysinit.target || {
    printf 'ERROR: %s run failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_podman_or_docker checks to see if docker and/or podman are installed and
# sets the imgprefix and containerrt array members accordingly. It also defines
# the docker function to run the detected container runtime. Podman is
# preferred if both are installed.
# Args: No args expected.
CU_podman_or_docker() {
  if type podman &>/dev/null; then
    _CU[imgprefix]="localhost/"
    _CU[containerrt]="podman"
    _CU_podman_checks || return
  elif type docker &>/dev/null; then
    _CU[imgprefix]=""
    _CU[containerrt]="docker"
    _CU_docker_checks || return
  else
    printf 'ERROR: Neither "podman" nor "docker" were found.\n' \
      >"${STDERR}"
    printf 'Please install one of "podman" or "docker".\nAborting.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi
  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CU_docker_checks checks to see if the current user has permission to write
# to the docker socket. If not, it prints an error message and exits.
# Args: No args expected.
_CU_docker_checks() {
  if [[ ! -e /proc/sys/kernel/hostname ]]; then
    printf 'ERROR: Docker is currently supported on Linux only'
    exit "${ERROR}"
  fi

  if docker ps >/dev/stdout 2>&1 | grep -qs 'docker.sock.*permission denied'; then
    cat <<EnD >"${STDERR}"
Not enough permissions to write to 'docker.sock'.

Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  fi

  _CU[podmantype]="native"
  return "${OK}"
}

# _CU_podman_checks sets the _CU[podmantype] member to "native" or "machine"
# depending on whether this is linux or macos. We assume linux won't be using
# a podman machine, and macos will always be using a podman machine.
# Args: No args expected.
_CU_podman_checks() {
  local info running

  if [[ -e /proc/sys/kernel/hostname ]]; then
    # We're on linux
    _CU[podmantype]="native"
    _CU_podman_native_checks || return
  elif [[ -d /System/Library/CoreServices ]]; then
    # We're on macOS
    [[ $(id -u) -eq 0 ]] && {
      printf 'ERROR: Cannot run mok as root on macOS.\n' >"${STDERR}"
      exit "${ERROR}"
    }

    info=$(podman machine list --format json) || err || return
    running=$(JSONPath -b '..Running' <<<"${info}") || err || return

    if [[ ${running} == "true" ]]; then
      _CU[podmantype]="machine"
    else
      printf 'ERROR: Podman machine is not running. Aborting.\n' >"${STDERR}"
      exit "${ERROR}"
    fi
  else
    printf 'ERROR: Unknown OS. Aborting.\n' >"${STDERR}"
    exit "${ERROR}"
  fi
}

# _CU_podman_native_checks checks to see if the current user is root. If not,
# it prints an error message and exits.
# Args: No args expected.
_CU_podman_native_checks() {
  [[ $(id -u) -ne 0 ]] && {
    cat <<EnD >"${STDERR}"
Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  }
}

# _CU_new sets the initial values for the Container Utils associative array.
# Args: None expected.
_CU_new() {
  _CU[imgprefix]=
  _CU[labelkey]="MokCluster"
  _CU[containerrt]=

  # _CU[podmantype] will only be set only if _CU[containerrt]=podman.
  # podmantype will be "native" or "machine".
  _CU[podmantype]=
}

# Override `docker` depending on _CU[containerrt]
docker() {
  local cmd
  if [[ "${_CU[containerrt]}" == "podman" ]]; then
    podman "$@"
  else
    cmd=$(which -a docker | tail -n 1)
    $cmd "$@"
  fi
}

# Override `ip` depending on _CU[podmantype]
ip() {
  local cmd
  if [[ "${_CU[podmantype]}" == "machine" ]]; then
    podman machine ssh ip "$@"
  else
    cmd=$(which -a ip | tail -n 1)
    $cmd "$@"
  fi
}

# Initialise _CU
_CU_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# BI - Build Image

# _BI is an associative array that holds data specific to building an image.
declare -A _BI

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE

# Getters/Setters -------------------------------------------------------------

# BI_setflag_useprebuiltimage setter sets the useprebuiltimage array item.
# This is called by the parser, via a callback in _BI_new.
BI_setflag_useprebuiltimage() {
  _BI[useprebuiltimage]="$1"
}

# BI_baseimagename getter outputs the value of the _BI[baseimagename].
# Args: None expected.
BI_baseimagename() {
  printf '%s' "${_BI[baseimagename]}"
}

# Public Functions ------------------------------------------------------------

# BI_usage outputs help text for the build image component.
# It is called by PA_usage(), via a callback in _BI_new.
# Args: None expected.
BI_usage() {

  cat <<'EnD'
BUILD subcommands are:
 
  image - Creates the docker 'mok-image' container image.
 
build image options:
 
 Format:
  build image [flags]

 Flags:
  --get-prebuilt-image - Instead of building a 'node' image
         locally, download it from a container registry instead.
  --tailf - Show the build output whilst building.

EnD
}

# BI_cleanup removes temporary files created during the build.
# This function is called by the 'MA_cleanup' trap only.
# Args: None expected.
BI_cleanup() {
  [[ -e ${_BI[dockerbuildtmpdir]} ]] &&
    [[ ${_BI[dockerbuildtmpdir]} == "/var/tmp/"* ]] && {
    rm -rf "${_BI[dockerbuildtmpdir]}" || {
      printf 'ERROR: "rm -rf %s" failed.\n' "${_BI[dockerbuildtmpdir]}" \
        >"${STDERR}"
      err || return
    }
  }
}

# BI_check_valid_options checks if arg1 is in a list of valid build image
# options. This function is called by the parser, via a callback in _BI_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
BI_process_options() {

  case "$1" in
  -h | --help)
    BI_usage
    return "${STOP}"
    ;;
  --tailf)
    _BI[tailf]="${TRUE}"
    return "${OK}"
    ;;
  --get-prebuilt-image)
    _BI[useprebuiltimage]="${TRUE}"
    return "${OK}"
    ;;
  *)
    BI_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# BI_run builds the base image used for masters and workers.
# This function is called in main.sh.
# Args: None expected.
BI_run() {

  _BI_sanity_checks || return

  [[ ${_BI[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  local retval=0
  _BI_build_container_image
  retval=$?

  if [[ ${retval} -eq ${OK} ]]; then
    : # We only need the tick - no text
  else
    printf 'Image build failed\n' >"${STDERR}"
    err
  fi

  return "${retval}"
}

# Private Functions -----------------------------------------------------------

# _BI_new resets the initial values for the _BI associative array.
# Args: None expected.
_BI_new() {
  _BI[tailf]="${FALSE}"
  _BI[baseimagename]="mok-image"
  _BI[useprebuiltimage]="${FALSE}"
  _BI[dockerbuildtmpdir]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "build" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "buildimage" "END" ""

  # Set up the parser's option callbacks
  PA_add_option_callback "build" "BI_process_options" || return
  PA_add_option_callback "buildimage" "BI_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "build" "BI_usage" || return
  PA_add_usage_callback "buildimage" "BI_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "buildimage" "BI_run"
}

# BI_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_BI_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    BI_usage
    exit "${OK}"
  fi
}

# _BI_build_container_image creates the docker build directory in
# dockerbuildtmpdir then calls docker build to build the image.
# Args: No args expected.
_BI_build_container_image() {

  local cmd retval tagname buildargs text buildtype basename

  _BI_create_docker_build_dir || return

  buildargs=$(_BI_get_build_args_for_latest) || return
  basename="${_BI[baseimagename]}"
  tagname="${K8SVERSION}"

  local imgprefix
  imgprefix=$(CU_imgprefix) || err || return
  if [[ ${_BI[useprebuiltimage]} == "${FALSE}" ]]; then
    buildtype="create"
    cmd="docker build \
      -t "${imgprefix}local/${basename}:${tagname}" \
      --force-rm \
      ${buildargs} \
      ${_BI[dockerbuildtmpdir]}/${_BI[baseimagename]}"
    text="Creating"
  else
    buildtype="download"
    cmd="docker pull docker.io/myownkind/${basename}:${tagname}"
    text="Downloading"
  fi

  UT_run_with_progress \
    "    ${text} base image, '${basename}:${tagname}'" "${cmd}"

  retval=$?
  [[ ${retval} -ne ${OK} ]] && {
    local runlogfile
    runlogfile=$(UT_runlogfile) || err || return
    printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\n' >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${buildtype} == "create" ]] && {
    cmd="_BI_modify_container_image"

    UT_run_with_progress \
      "    Modifying base image (pulling kubernetes images)" "${cmd}"

    retval=$?
    [[ ${retval} -ne ${OK} ]] && {
      local runlogfile
      runlogfile=$(UT_runlogfile) || err || return
      printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\n' >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _BI_modify_container_image starts a container suitable for running kubernetes
# components (since the docker/podman build environment isn't suitable), makes
# some modifications and then 'commits' the image. The modifications allow
# `mok create ...` to complete more quickly.
# Args: No args expected.
_BI_modify_container_image() {

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify &>/dev/null
  docker rm mok-build-modify &>/dev/null

  CC_set_clustername "build" || err || return

  # Start container
  CU_create_container "mok-build-modify" "mok-build-modify" "${K8SVERSION}" ||
    return

  # Wait for crio to become ready
  local counter
  printf '\n\n ** WAITING FOR CRIO TO BECOME READY **\n\n'
  while ! docker exec mok-build-modify systemctl status crio; do
    sleep 1
    [[ ${counter} -gt 10 ]] && {
      printf '\nERROR: CRI-O did not start after %d tries.\n' "${counter}"
      err || return
    }
    ((counter++))
  done

  # Modify container
  docker exec mok-build-modify kubeadm config images pull \
    --kubernetes-version "${K8SVERSION}" || err || return

  # Stop container
  docker stop -t 5 "mok-build-modify"

  # Write image
  local imgprefix tagname basename
  imgprefix=$(CU_imgprefix) || err || return
  basename="${_BI[baseimagename]}"
  tagname="${K8SVERSION}"
  docker commit mok-build-modify "${imgprefix}local/${basename}:${tagname}" || err || return

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify
  docker rm mok-build-modify || err || return

  return "${OK}"
}

# _BI_get_build_args_for_latest sets the buildargs variable that is added
# to the 'podman build ...' command line.  Only the latest version is built
# from scratch.  Earlier versions are downloaded using '--get-prebuilt-image'.
# Args: None expected
_BI_get_build_args_for_latest() {

  local buildargs

  buildargs="--build-arg GO_VERSION=${GO_VERSION}"

  printf '%s' "${buildargs}"
}

# _BI_create_docker_build_dir creates a docker build directory in
# /var/tmp/tmp.XXXXXXXX
# Args: None expected
_BI_create_docker_build_dir() {

  _BI[dockerbuildtmpdir]="$(mktemp -d -p /var/tmp)" || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }

  # The following comments should not be removed or changed.
  # embed-dockerfile.sh adds a base64 encoded tarball and
  # unpacking code between them.

  #mok-image-tarball-start 
  cat <<EnD | base64 -d | tar xz -C "${_BI[dockerbuildtmpdir]}" 
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
+Syf5bN8ls/yWT7Lp/j5/wCgrl8pAOABAA==
EnD
  #mok-image-tarball-end
}

# Initialise _BI
_BI_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
#!/usr/bin/env bash

declare -A JSONPath

JSONPath_new() {
  JSONPath[DEBUG]=0
  JSONPath[INCLEMPTY]=0
  JSONPath[NOCASE]=0
  JSONPath[WHOLEWORD]=0
  JSONPath[FILE]=
  JSONPath[NO_HEAD]=0
  JSONPath[NORMALIZE_SOLIDUS]=0
  JSONPath[BRIEF]=0
  JSONPath[PASSTHROUGH]=0
  JSONPath[JSON]=0
  JSONPath[MULTIPASS]=0
  JSONPath[FLATTEN]=0
  JSONPath[STDINFILE]=/var/tmp/JSONPath.$$.stdin
  JSONPath[STDINFILE2]=/var/tmp/JSONPath.$$.stdin2
  JSONPath[PASSFILE]=/var/tmp/JSONPath.$$.pass1
  declare -a INDEXMATCH_QUERY
}

# JSONPath reads JSON from stdin and applies a JSON Path query.
# Args: arg1-N - command line arguments to be parsed.
JSONPath() {

  JSONPath_sanity_checks
  JSONPath_parse_options "$@"

  trap JSONPath_cleanup EXIT

  if [[ ${QUERY} == *'?(@'* ]]; then
    # This will be a multipass query

    [[ -n ${JSONPath[FILE]} ]] && JSONPath[STDINFILE]=${JSONPath[FILE]}
    [[ -z ${JSONPath[FILE]} ]] && cat >"${JSONPath[STDINFILE]}"

    while true; do
      JSONPath_tokenize_path
      JSONPath_create_filter

      JSONPath_tokenize | JSONPath_parse | JSONPath_filter |
        JSONPath_indexmatcher >"${JSONPath[PASSFILE]}" <"${JSONPath[STDINFILE]}"

      [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && {
        # replace filter expression with index sequence
        SET=$(sed -rn 's/.*[[,"]+([0-9]+)[],].*/\1/p' "${JSONPath[PASSFILE]}" | tr '\n' ,)
        SET=${SET%,}
        #QUERY=$(sed "s/?(@[^)]\+)/${SET}/" <<<"${QUERY}")
        # Testing:
        QUERY="${QUERY//\?\(@*)/${SET}}"
        [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "QUERY=${QUERY}" >/dev/stderr
        JSONPath_reset
        continue
      }

      JSONPath_flatten | JSONPath_json | JSONPath_brief <<<"${JSONPath[PASSFILE]}"

      break
    done

  else

    JSONPath_tokenize_path
    JSONPath_create_filter

    if [[ ${JSONPath[PASSTHROUGH]} -eq 1 ]]; then
      JSONPath[JSON]=1
      JSONPath_flatten | JSONPath_json
    elif [[ -z ${JSONPath[FILE]} ]]; then
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten | JSONPath_json | JSONPath_brief
    else
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten <"${JSONPath[FILE]}"
      JSONPath_json | JSONPath_brief
    fi

  fi
}

JSONPath_sanity_checks() {

  local binary

  # Reset some vars
  for binary in gawk grep sed; do
    if ! command -v "${binary}" >&/dev/null; then
      echo "ERROR: ${binary} binary not found in path. Aborting."
      exit 1
    fi
  done
}

JSONPath_reset() {

  # Reset some vars
  declare -a INDEXMATCH_QUERY
  PATHTOKENS=
  FILTER=
  OPERATOR=
  RHS=
  JSONPath[MULTIPASS]=0
}

JSONPath_cleanup() {

  [[ -e ${JSONPath[PASSFILE]} ]] && rm -f "${PASSFILE}"
  [[ -e ${JSONPath[STDINFILE2]} ]] && rm -f "${JSONPath[STDINFILE2]}"
  [[ -z ${JSONPath[FILE]} && -e ${JSONPath[STDINFILE]} ]] &&
    rm -f "${JSONPath[STDINFILE]}"
}

JSONPath_usage() {

  echo
  echo "Usage: JSONPath.sh [-b] [j] [-h] [-f FILE] [pattern]"
  echo
  echo "pattern - the JSONPath query. Defaults to '$.*' if not supplied."
  echo "-b      - Brief. Only show values."
  echo "-j      - JSON output."
  echo "-u      - Strip unnecessary leading path elements."
  echo "-i      - Case insensitive."
  echo "-p      - Pass-through to the JSON parser."
  echo "-w      - Match whole words only (for filter script expression)."
  echo "-f FILE - Read a FILE instead of stdin."
  echo "-h      - This help text."
  echo
}

JSONPath_parse_options() {

  set -- "$@"
  local ARGN=$#
  while [[ ${ARGN} -ne 0 ]]; do
    case $1 in
    -h)
      JSONPath_usage
      exit 0
      ;;
    -f)
      shift
      JSONPath[FILE]=$1
      ;;
    -i)
      JSONPath[NOCASE]=1
      ;;
    -j)
      JSONPath[JSON]=1
      ;;
    -n)
      JSONPath[NO_HEAD]=1
      ;;
    -b)
      JSONPath[BRIEF]=1
      ;;
    -u)
      JSONPath[FLATTEN]=1
      ;;
    -p)
      JSONPath[PASSTHROUGH]=1
      ;;
    -w)
      JSONPath[WHOLEWORD]=1
      ;;
    -s)
      JSONPath[NORMALIZE_SOLIDUS]=1
      ;;
    *)
      QUERY=$1
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done
  [[ -z ${QUERY} ]] && QUERY='$.*'
}

JSONPath_awk_egrep() {
  local pattern_string=$1

  gawk '{
    while ($0) {
      start=match($0, pattern);
      token=substr($0, start, RLENGTH);
      print token;
      $0=substr($0, start+RLENGTH);
    }
  }' pattern="${pattern_string}"
}

JSONPath_tokenize() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    ESCAPE='(\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
    ESCAPE='(\\\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\\\]'
  fi

  local STRING="\"${CHAR}*(${ESCAPE}${CHAR}*)*\""
  local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'
  local KEYWORD='null|false|true'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  ${GREP} "${STRING}|${NUMBER}|${KEYWORD}|${SPACE}|." | grep -Ev "^${SPACE}$"
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

JSONPath_tokenize_path() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
  fi

  local WILDCARD='\*'
  local WORD='[ A-Za-z0-9_-]*'
  local INDEX="\\[${WORD}(:${WORD}){0,2}\\]"
  local INDEXALL='\[\*\]'
  local STRING="[\\\"'][^[:cntrl:]\\\"']*[\\\"']"
  local SET="\\[(${WORD}|${STRING})(,(${WORD}|${STRING}))*\\]"
  local FILTER='\?\(@[^)]+'
  local DEEPSCAN='\.\.'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  readarray -t PATHTOKENS < <(echo "${QUERY}" |
    ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
    grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$")
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    echo "grep -Eo '${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|.'" >/dev/stderr
    echo -n "TOKENISED QUERY="
    echo "${QUERY}" |
      ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
      grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$" >/dev/stderr
  }
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

# JSONPath_create_filter creates the filter from the user's query.
# Filter works in a single pass through the data, unless a filter (script)
#  expression is used, in which case two passes are required (MULTIPASS=1).
JSONPath_create_filter() {

  local len=${#PATHTOKENS[*]}

  local -i i=0
  local a query="^\[" comma=
  while [[ i -lt len ]]; do
    case "${PATHTOKENS[i]}" in
    '"')
      :
      ;;
    '..')
      query+="${comma}[^]]*"
      comma=
      ;;
    '[*]')
      query+="${comma}[^,]*"
      comma=","
      ;;
    '*')
      query+="${comma}(\"[^\"]*\"|[0-9]+[^],]*)"
      comma=","
      ;;
    '?(@'*)
      a=${PATHTOKENS[i]#?(@.}
      elem="${a%%[<>=!]*}"
      rhs="${a##*[<>=!]}"
      a="${a#${elem}}"
      elem="${elem//./[\",.]+}" # Allows child node matching
      operator="${a%${rhs}}"
      [[ -z ${operator} ]] && {
        operator="=="
        rhs=
      }
      if [[ ${rhs} == *'"'* || ${rhs} == *"'"* ]]; then
        case ${operator} in
        '==' | '=')
          OPERATOR=
          if [[ ${elem} == '?(@' ]]; then
            # To allow search on @.property such as:
            #   $..book[?(@.title==".*Book 1.*")]
            query+="${comma}[0-9]+[],][[:space:]\"]*${rhs//\"/}"
          else
            # To allow search on @ (this node) such as:
            #   $..reviews[?(@==".*Fant.*")]
            query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs//\"/}"
          fi
          FILTER="${query}"
          ;;
        '>=' | '>')
          OPERATOR=">"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=' | '<')
          OPERATOR="<"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      else
        case ${operator} in
        '==' | '=')
          OPERATOR=
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs}"
          FILTER="${query}"
          ;;
        '>=')
          OPERATOR="-ge"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '>')
          OPERATOR="-gt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=')
          OPERATOR="-le"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<')
          OPERATOR="-lt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      fi
      JSONPath[MULTIPASS]=1
      ;;
    "["*)
      if [[ ${PATHTOKENS[i]} =~ , ]]; then
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          # converts only one comma: s/("[^"]+),([^"]+")/\1`\2/g;s/"//g
          #a=$(echo $a | sed 's/\([[:alpha:]]*\)/"\1"/g')
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        fi
        query+="${comma}(${a//,/|})"
      elif [[ ${PATHTOKENS[i]} =~ : ]]; then
        if ! [[ ${PATHTOKENS[i]} =~ [0-9][0-9] || ${PATHTOKENS[i]} =~ :] ]]; then
          if [[ ${PATHTOKENS[i]#*:} =~ : ]]; then
            INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
            query+="${comma}[^,]*"
          else
            # Index in the range of 0-9 can be handled by regex
            query+="${comma}$(echo "${PATHTOKENS[i]}" |
              gawk '/:/ { a=substr($0,0,index($0,":")-1);
                         b=substr($0,index($0,":")+1,index($0,"]")-index($0,":")-1);
                         if(b>0) { print a ":" b-1 "]" };
                         if(b<=0) { print a ":]" } }' |
              sed 's/\([0-9]\):\([0-9]\)/\1-\2/;
                       s/\[:\([0-9]\)/[0-\1/;
                       s/\([0-9]\):\]/\1-9999999]/')"
          fi
        else
          INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
          query+="${comma}[^,]*"
        fi
      else
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        else
          [[ ${i} -gt 0 ]] && comma=","
        fi
        query+="${comma}${a}"
      fi
      comma=","
      ;;
    *)
      PATHTOKENS[i]=${PATHTOKENS[i]//\'/\"}
      query+="${comma}\"${PATHTOKENS[i]//\"/}\""
      comma=","
      ;;
    esac
    i=$((i + 1))
  done

  [[ -z ${FILTER} ]] && FILTER="${query}[],]"
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
}

JSONPath_parse_array() {

  local index=0
  local ary=''
  read -r token
  case "${token}" in
  ']') ;;

  *)
    while :; do
      JSONPath_parse_value "$1" "${index}"
      index=$((index + 1))
      ary="${ary}""${value}"
      read -r token
      case "${token}" in
      ']') break ;;
      ',') ary="${ary}," ;;
      *) JSONPath_throw "EXPECTED , or ] GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_object() {

  local key
  local obj=''
  read -r token
  case "${token}" in
  '}') ;;

  *)
    while :; do
      case "${token}" in
      '"'*'"') key=${token} ;;
      *) JSONPath_throw "EXPECTED string GOT ${token:-EOF}" ;;
      esac
      read -r token
      case "${token}" in
      ':') ;;
      *) JSONPath_throw "EXPECTED : GOT ${token:-EOF}" ;;
      esac
      read -r token
      JSONPath_parse_value "$1" "${key}"
      obj="${obj}${key}:${value}"
      read -r token
      case "${token}" in
      '}') break ;;
      ',') obj="${obj}," ;;
      *) JSONPath_throw "EXPECTED , or } GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_value() {

  local jpath="${1:+$1,}$2" isleaf=0 isempty=0 print=0
  case "${token}" in
  '{') JSONPath_parse_object "${jpath}" ;;
  '[') JSONPath_parse_array "${jpath}" ;;
    # At this point, the only valid single-character tokens are digits.
  '' | [!0-9]) JSONPath_throw "EXPECTED value GOT ${token:-EOF}" ;;
  *)
    value=${token}
    # if asked, replace solidus ("\/") in json strings with normalized value: "/"
    # Testing:
    #[ "${JSONPath[NORMALIZE_SOLIDUS]}" -eq 1 ] && value=$(echo "${value}" | sed 's#\\/#/#g')
    [[ ${JSONPath[NORMALIZE_SOLIDUS]} -eq 1 ]] && value=$(${value//\\\///})
    isleaf=1
    [[ ${value} == '""' ]] && isempty=1
    ;;
  esac
  [[ -z ${JSONPath[INCLEMPTY]} ]] && [[ ${value} == '' ]] && return
  [[ ${JSONPath[NO_HEAD]} -eq 1 ]] && [[ -z ${jpath} ]] && return

  [[ ${isleaf} -eq 1 ]] && [[ ${isempty} -eq 0 ]] && print=1
  [[ ${print} -eq 1 ]] && printf "[%s]\t%s\n" "${jpath}" "${value}"
  :
}

JSONPath_flatten() {

  local path a prevpath pathlen

  if [[ ${JSONPath[FLATTEN]} -eq 1 ]]; then
    cat >"${JSONPath[STDINFILE2]}"

    highest=9999

    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      [[ -z ${prevpath} ]] && {
        prevpath=("${path[@]}")
        highest=$((${#path[*]} - 1))
        continue
      }

      pathlen=$((${#path[*]} - 1))

      for i in $(seq 0 "${pathlen}"); do
        [[ ${path[i]} != "${prevpath[i]}" ]] && {
          high=${i}
          break
        }
      done

      [[ ${high} -lt ${highest} ]] && highest=${high}

      prevpath=("${path[@]}")
    done <"${JSONPath[STDINFILE2]}"

    if [[ ${highest} -gt 0 ]]; then
      sed -r 's/\[(([0-9]+|"[^"]+")[],]){'$((highest))'}(.*)/[\3/' \
        "${JSONPath[STDINFILE2]}"
    else
      cat "${JSONPath[STDINFILE2]}"
    fi
  else
    cat
  fi
}

# JSONPath_indexmatcher is for double digit or greater indexes match each line
# individually Single digit indexes are handled more efficiently by regex
JSONPath_indexmatcher() {

  local a b

  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
      echo "INDEXMATCH_QUERY[${i}]=${INDEXMATCH_QUERY[i]}" >/dev/stderr
    done
  }

  matched=1

  step=
  if [[ ${#INDEXMATCH_QUERY[*]} -gt 0 ]]; then
    while read -r line; do
      for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
        [[ ${INDEXMATCH_QUERY[i]#*:} =~ : ]] && {
          step=${INDEXMATCH_QUERY[i]##*:}
          step=${step%]}
          INDEXMATCH_QUERY[i]="${INDEXMATCH_QUERY[i]%:*}]"
        }
        q=${INDEXMATCH_QUERY[i]:1:-1} # <- strip '[' and ']'
        a=${q%:*}                     # <- number before ':'
        b=${q#*:}                     # <- number after ':'
        [[ -z ${b} ]] && b=99999999999
        readarray -t num < <((grep -Eo '[0-9]+[],]' | tr -d ,]) <<<"${line}")
        if [[ ${num[i]} -ge ${a} && ${num[i]} -lt ${b} && matched -eq 1 ]]; then
          matched=1
          [[ ${i} -eq $((${#INDEXMATCH_QUERY[*]} - 1)) ]] && {
            if [[ ${step} -gt 1 ]]; then
              [[ $(((num[i] - a) % step)) -eq 0 ]] && {
                [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
                echo "${line}"
              }
            else
              [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
              echo "${line}"
            fi
          }
        else
          matched=0
          continue
        fi
      done
      matched=1
    done
  else
    cat -
  fi
}

JSONPath_brief() {
  # Only show the value

  if [[ ${JSONPath[BRIEF]} -eq 1 ]]; then
    sed 's/^[^\t]*\t//;s/^"//;s/"$//;'
  else
    cat
  fi
}

JSONPath_json() {
  # Turn output into JSON

  local a tab="$'\t'"
  local UP=1 DOWN=2 SAME=3
  local prevpathlen=-1 prevpath=() path a
  declare -a closers

  if [[ ${JSONPath[JSON]} -eq 0 ]]; then
    cat -
  else
    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      value=${line#*${tab}}

      # Not including the object itself (last item)
      pathlen=$((${#path[*]} - 1))

      # General direction

      direction=${SAME}
      [[ ${pathlen} -gt ${prevpathlen} ]] && direction=${DOWN}
      [[ ${pathlen} -lt ${prevpathlen} ]] && direction=${UP}

      # Handle jumps UP the tree (close previous paths)

      [[ ${prevpathlen} != -1 ]] && {
        for i in $(seq 0 $((pathlen - 1))); do
          [[ ${prevpath[i]} == "${path[i]}" ]] && continue
          [[ ${path[i]} != '"'* ]] && {
            # Testing double quotes:
            a="(${!arrays[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                arrays[k]=
              done
            }
            a="(${!comma[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                comma[k]=
              done
            }
            for j in $(seq $((prevpathlen)) -1 $((i + 2))); do
              arrays[j]=
              [[ -n ${closers[j]} ]] && {
                indent=$((j * 4))
                printf "\n%${indent}s${closers[j]}" ""
                unset "closers[j]"
                comma[j]=
              }
            done
            direction=${DOWN}
            break
          }
          direction=${DOWN}
          for j in $(seq $((prevpathlen)) -1 $((i + 1))); do
            arrays[j]=
            [[ -n ${closers[j]} ]] && {
              indent=$((j * 4))
              printf "\n%${indent}s${closers[j]}" ""
              unset "closers[j]"
              comma[j]=
            }
          done
          a="(${!arrays[*]})"
          [[ -n ${a} ]] && {
            for k in $(seq "${i}" "${a[-1]}"); do
              arrays[k]=
            done
          }
          break
        done
      }

      [[ ${direction} -eq ${UP} ]] && {
        [[ ${prevpathlen} != -1 ]] && comma[prevpathlen]=
        for i in $(seq $((prevpathlen + 1)) -1 $((pathlen + 1))); do
          arrays[i]=
          [[ -n ${closers[i]} ]] && {
            indent=$((i * 4))
            printf "\n%${indent}s${closers[i]}" ""
            unset "closers[i]"
            comma[i]=
          }
        done
        a="(${!arrays[*]})"
        [[ -n ${a} ]] && {
          for k in $(seq "${i}" "${a[-1]}"); do
            arrays[k]=
          done
        }
      }

      # Opening braces (the path leading up to the key)

      broken=
      for i in $(seq 0 $((pathlen - 1))); do
        [[ -z ${broken} && ${prevpath[i]} == "${path[i]}" ]] && continue
        [[ -z ${broken} ]] && {
          broken=${i}
          [[ ${prevpathlen} -ne -1 ]] && broken=$((i + 1))
        }
        if [[ ${path[i]} == '"'* ]]; then
          # Object
          [[ ${i} -ge ${broken} ]] && {
            indent=$((i * 4))
            printf "${comma[i]}%${indent}s{\n" ""
            closers[i]='}'
            comma[i]=
          }
          indent=$(((i + 1) * 4))
          printf "${comma[i]}%${indent}s${path[i]}:\n" ""
          comma[i]=",\n"
        else
          # Array
          if [[ ${arrays[i]} != 1 ]]; then
            indent=$((i * 4))
            printf "%${indent}s" ""
            echo "["
            closers[i]=']'
            arrays[i]=1
            comma[i]=
          else
            indent=$(((i + 1) * 4))
            printf "\n%${indent}s${closers[i - 1]}" ""
            direction=${DOWN}
            comma[i + 1]=",\n"
          fi
        fi
      done

      # keys & values

      if [[ ${path[-1]} == '"'* ]]; then
        # Object
        [[ ${direction} -eq ${DOWN} ]] && {
          indent=$((pathlen * 4))
          printf "${comma[pathlen]}%${indent}s{\n" ""
          closers[pathlen]='}'
          comma[pathlen]=
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${path[-1]}:${value}"
        comma[pathlen]=",\n"
      else
        # Array
        [[ ${arrays[i]} != 1 ]] && {
          indent=$(((pathlen - 0) * 4))
          printf "%${indent}s[\n" ""
          closers[pathlen]=']'
          comma[pathlen]=
          arrays[i]=1
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${value}"
        comma[pathlen]=",\n"
      fi

      prevpath=("${path[@]}")
      prevpathlen=${pathlen}
    done

    # closing braces

    for i in $(seq $((pathlen)) -1 0); do
      indent=$((i * 4))
      printf "\n%${indent}s${closers[i]}" ""
    done
    echo
  fi
}

JSONPath_filter() {
  # Apply the query filter

  local a tab=$'\t' v

  [[ ${JSONPath[NOCASE]} -eq 1 ]] && opts+="i"
  [[ ${JSONPath[WHOLEWORD]} -eq 1 ]] && opts+="w"
  if [[ -z ${OPERATOR} ]]; then
    [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && FILTER="${FILTER}[\"]?$"
    grep "-E${opts}" "${FILTER}"
    [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
  else
    grep "-E${opts}" "${FILTER}" |
      while read -r line; do
        v=${line#*${tab}}
        case ${OPERATOR} in
        '-ge')
          if gawk '{exit !($1>=$2)}' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-gt')
          if gawk '{exit !($1>$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-le')
          if gawk '{exit !($1<=$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-lt')
          if gawk '{exit !($1<$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '>')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} > ${RHS,,} ]] && echo "${line}"
          ;;
        '<')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} < ${RHS,,} ]] && echo "${line}"
          ;;
        *) return 1 ;;
        esac
      done
  fi
}

JSONPath_parse() {
  # Parses json

  read -r token
  JSONPath_parse_value
  read -r token
  case "${token}" in
  '') ;;
  *)
    JSONPath_throw "EXPECTED EOF GOT ${token}"
    exit 1
    ;;
  esac
}

JSONPath_throw() {
  echo "$*" >&2
  exit 1
}

JSONPath_new || exit 1

# vi: expandtab sw=2 ts=2
# shellcheck shell=bash disable=SC2148
# MA - execution starts here

# MA is an associative array that holds data specific to this file
declare -A _MA

# Defined in GL (globals.sh)
declare OK ERROR STOP STDERR TRUE

# Getters/Setters -------------------------------------------------------------

# MA_program_args getter outputs the program arguments sent by the user.
MA_program_args() {
  printf '%s' "${_MA[program_args]}"
}

# Public Functions ------------------------------------------------------------

# main is the start point for this application.
# Args: arg1-N - the command line arguments entered by the user.
MA_main() {
  local retval="${OK}"

  CU_podman_or_docker

  trap MA_cleanup EXIT
  MA_sanity_checks || return
  PA_run "$@" || retval=$?

  exit "${retval}"
}

# MA_version outputs the version information the exits.
MA_version() {
  printf 'Version: %s\n' "${MOKVERSION}"
  exit "${OK}"
}

# MA_process_global_options is called by the parser when a global option is
# encountered for processing.
# Args: arg1 - the global option that was found.
MA_process_global_options() {
  case "$1" in
  -h | --help)
    PA_usage
    return "${STOP}"
    ;;
  -p | --plain)
    UT_set_plain "${TRUE}"
    ;;
  *)
    printf 'INTERNAL ERROR: Invalid global option, "%s".' "$1"
    return "${ERROR}"
    ;;
  esac
}

# MA_cleanup is called from an EXIT trap only, when the program exits, and
# calls every other function matching the pattern '^.._cleanup'.
# Args: No args expected.
MA_cleanup() {
  local retval="${OK}" funcs func
  funcs=$(declare -F | awk '{print $NF;}' | grep '^.._cleanup')
  for func in ${funcs}; do
    [[ ${func} == "${FUNCNAME[0]}" ]] && continue
    eval "${func}" || retval=$?
  done
  return "${retval}"
}

# MA_sanity_checks is expected to run some quick and simple checks to
# see if key components are available before MA_main is called.
# Args: No args expected.
MA_sanity_checks() {

  local binary

  if [[ $(CU_podmantype) == "native" ]]; then
    binaries="gawk tac column tput grep sed ip cut"
  else
    binaries="gawk tac column tput grep sed cut"
  fi

  for binary in ${binaries}; do
    if ! command -v "${binary}" >&/dev/null; then
      printf 'ERROR: "%s" binary not found in path. Aborting.' "${binary}" \
        >"${STDERR}"
      return "${ERROR}"
    fi
  done

  # Disable terminal escapes (colours) if stdout is not a terminal
  [ -t 1 ] || UT_disable_colours
}

# MA_usage outputs help text for all components then quits with no error.  This
# is registered as a callback in the Parser, see _MA_new
# Args: None expected.
MA_usage() {

  cat <<'EnD'
Usage: mok [-h] <command> [subcommand] [ARGS...]
 
Global options:
  --help
  -h     - This help text
  --plain
  -p     - Plain output. No colours or animations.
 
Where command can be one of:
  create  - Add item(s) to the system.
  delete  - Delete item(s) from the system.
  build   - Build item(s) used by the system.
  get     - Get details about items in the system.
  exec    - 'Log in' to the container.
  machine - Manage a podman machine.
  version - Display version information.

For help on a specific command, run:
  mok <command> --help
EnD
}

# MA_new sets the initial values for the _MA associative array
_MA_new() {
  _MA[program_args]="$*"

  # Program the parser's state machine
  PA_add_state "COMMAND" "version" "END" "MA_version"

  # Set up the parser's option callbacks
  PA_add_option_callback "" "MA_process_global_options"

  # Set up the parser's usage callbacks
  PA_add_usage_callback "" "MA_usage"
}

# Initialise _MA
_MA_new "$@" || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
if [ "$0" = "${BASH_SOURCE[0]}" ] || [ -z "${BASH_SOURCE[0]}" ]; then
  MA_main "$@"
fi
