#!/usr/bin/env bash
# shellcheck shell=bash disable=SC2148

__check_os() {
  local majorversion system_ok=1 install_bash=0 install_coreutils=0 install_gawk=0
  local install_podman=0 install_sed=0 __mokostype=linux

  if [[ -d /System/Library/CoreServices ]]; then
    [[ -e /opt/homebrew/bin/bash ]] && eval "$(/opt/homebrew/bin/brew shellenv)"
    # We're on macOS, check for a recent Bash
    if command -v bash &>/dev/null; then
      majorversion=$(bash --version | head -n 1 | sed 's/^.*version \([0-9]*\).*/\1/')
    else
      echo "No version of Bash was found which is strange. Aborting."
      exit 1
    fi
    if [[ ${majorversion} -lt 5 ]]; then
      install_bash=1
      system_ok=0
    fi
    if ! command -v tac &>/dev/null; then
      install_coreutils=1
      system_ok=0
    fi
    if ! command -v gawk &>/dev/null; then
      install_gawk=1
      system_ok=0
    fi
    if ! command -v gsed &>/dev/null; then
      install_sed=1
      system_ok=0
    fi
    if ! command -v podman &>/dev/null; then
      install_podman=1
      system_ok=0
    fi

    if [[ ${system_ok} -eq 0 ]]; then
      echo "Your system requires some extra packages to be installed."
      echo "This script can install them for you."
      echo
      read -r -p 'Install extra packages? (y/N) ' ans
      if [[ ${ans} == "y" ]]; then
        if ! command -v brew &>/dev/null; then
          echo 'Homebrew is required to install extra packages.'
          echo 'You can install this yourself by following the instructions at https://brew.sh'
          echo
          read -r -p 'Should I install Homebrew now? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            # Install Homebrew
            echo -n "Installing Homebrew, with:"
            echo " /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
            echo
            /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            retval=$?
            if [[ retval -ne 0 ]]; then
              echo "Homebrew install failed."
              echo "Please try to install Homebrew manually using the above commmand."
              exit 1
            fi
            if [[ ! -e /opt/homebrew/bin/brew ]]; then
              echo "Homebrew did not seem install to /opt/homebrew."
              echo "Mok expects 'brew' to be in /opt/homebrew/bin/brew but it's not there."
              echo "Cannot continue. Please report this issue on GitHub."
              exit 1
            fi
            eval "$(/opt/homebrew/bin/brew shellenv)"
          else
            echo "Aborting due to missing 'Homebrew'."
            exit 1
          fi
        fi
        if [[ ! -e /opt/homebrew/bin/brew ]]; then
          echo "Mok expects 'brew' to be in /opt/homebrew/bin/brew but it's not there."
          echo "Cannot continue. Please report this issue on GitHub."
          exit 1
        fi
        eval "$(/opt/homebrew/bin/brew shellenv)"
        if [[ ${install_bash} -eq 1 ]]; then
          read -r -p 'Bash 5 is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install bash
          else
            echo "Aborting due to missing 'Bash 5'."
            exit 1
          fi
        fi
        if [[ ${install_coreutils} -eq 1 ]]; then
          read -r -p 'Coreutils is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install coreutils
          else
            echo "Aborting due to missing 'coreutils'."
            exit 1
          fi
        fi
        if [[ ${install_gawk} -eq 1 ]]; then
          read -r -p 'Gawk is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install gawk
          else
            echo "Aborting due to missing 'gawk'."
            exit 1
          fi
        fi
        if [[ ${install_sed} -eq 1 ]]; then
          read -r -p 'GNU-Sed is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install gnu-sed
          else
            echo "Aborting due to missing 'sed'."
            exit 1
          fi
        fi
        if [[ ${install_podman} -eq 1 ]]; then
          read -r -p 'Podman is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install podman
          else
            echo "Aborting due to missing 'podman'."
            exit 1
          fi
        fi
      else
        echo "Aborting due to missing packages."
        exit 1
      fi
    fi
  fi
}

[[ __homebrew -ne 1 ]] && __check_os

[[ -d /System/Library/CoreServices && -e /opt/homebrew/bin/bash && __homebrew -ne 1 ]] && {
  eval "$(/opt/homebrew/bin/brew shellenv)"
  export __mokostype=macos
  export __homebrew=1
  sed() {
    gsed "$@"
  }
  export -f sed
  exec bash "$0" "$@"
}

__mokostype="${__mokostype:-linux}"
# shellcheck shell=bash disable=SC2148
# PA - PArser

# _PA holds data specific to parsing the command line arguments.
declare -A _PA

# Declare externally defined variables ----------------------------------------

# Defined in ER (globals.sh)
declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# PA_command getter outputs the _PA[command] array member. This contains the
# command the user requested.
PA_command() {
  printf '%s' "${_PA[command]}"
}

# PA_subcommand getter outputs the _PA[subcommand] array member. This contains
# the subcommand the user requested.
PA_subcommand() {
  printf '%s' "${_PA[subcommand]}"
}

# PA_shift outputs the _PA[shift] array member, returned by the caller
# when an extra shift is required whilst consuming option values.
#
# Example code:
# ```
#XX_process_options_callback() {
#
#  case "$1" in
#  -h | --help)
#    CC_usage
#    return "${STOP}"
#    ;;
#    ... omitted ...
#  --k8sver)
#    _CC[k8sver]="$2"
#    return "$(PA_shift)"
#    ;;
#  --with-lb)
#    ... omitted ..
# ```
PA_shift() {
  printf '%s' "${_PA[shift]}"
}

# PA_set_state setter sets the initial state of the parser, which should be one
# of COMMAND, SUBCOMMAND, or ARG1.
# Args: arg1 - the initial state to set.
PA_set_state() {
  _PA[state]="$1"
}

# Public Functions ------------------------------------------------------------

# PA_add_option_callback adds a callback to the list of callbacks used for
# processing options.
# Args: arg1 - Null string (for global options), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_option_callback() {
  _PA[optscallbacks]+="$1,$2 "
}

# PA_add_usage_callback adds a callback to the list of callbacks used for
# output of help text.
# Args: arg1 - Null string (for global help), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_usage_callback() {
  _PA[usagecallbacks]+="$1,$2 "
}

# PA_add_state adds a callback to the list of callbacks used for
# programming the state machine.
# Args: arg1 - Current state to match.
#       arg2 - The value of the state to match.
#       arg3 - The new state if arg1 and arg2 match.
#       arg4 - The function to call, optional.
PA_add_state() {
  _PA[statecallbacks]+="$1,$2,$3,$4 "
}

# PA_add_run_callback adds a callback to the list of callbacks used for
# running the user defined entrypoint function.
# Args: arg1 - The value of the state to match. Probably like:
#              "commandsubcommand" "function"
#       arg2 - The function to call.
PA_add_run_callback() {
  _PA[runcallbacks]+="$1,$2 "
}

# PA_run implements an interleaved state machine to process the
# user request. It allows for strict checking of arguments and args. All
# command line arguments are processed in order from left to right.
#
# Each COMMAND can have a different set of requirements which are controlled
# by setting the next state at each transition.
#
# --global-options COMMAND --command-options SUBCOMMAND --subcommand-options \
#  ARG1 --subcommand-options ARG2 --subcommand-options ...
#
# --global-options are those before COMMAND.
# --command-options can be after the COMMAND but before SUBCOMMAND.
# --subcommand-options can be anywhere after the SUBCOMMAND.
#
# Args: arg1-N - The arguments given to mok by the user on the command line
PA_run() {

  local retval=${OK}

  set -- "$@"
  local ARGN=$# ARGNUM=0 retval=0
  while [ "${ARGN}" -ne 0 ]; do
    case "$1" in
    --* | -*)
      _PA_process_option "$1" "$2" || {
        retval=$?
        if [[ ${retval} == "${_PA[shift]}" ]]; then
          ARGN=$((ARGN - 1))
          shift
        else
          return "${retval}"
        fi
      }
      ;;
    *)
      case "${_PA[state]}" in
      COMMAND)
        _PA_check_token "${1}" "COMMAND" "command"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid COMMAND, "%s".\n\n' "$1" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      SUBCOMMAND)
        _PA_check_token "$1" "SUBCOMMAND" "subcommand"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid SUBCOMMAND for %s, "%s".\n\n' "${_PA[command]}" "${1}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      ARG*)
        ((ARGNUM++))
        _PA_check_token "${1}" "ARG${ARGNUM}"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid ARG1 for %s %s, "%s".\n\n' "${_PA[command]}" \
            "${_PA[subcommand]}" "${1}" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      END)
        PA_usage
        printf 'ERROR No more args expected, "%s" is unexpected for "%s %s"\n' \
          "${1}" "${_PA[command]}" "${_PA[subcommand]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      *)
        printf 'Internal ERROR. Invalid state "%s"\n' "${_PA[state]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      esac
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done

  # Run the user defined entrypoint function:
  for item in ${_PA[runcallbacks]}; do
    IFS=, read -r stateval func <<<"${item}"
    [[ ${stateval} == "${_PA[command]}${_PA[subcommand]}" ]] && {
      eval "${func}" || retval=$?
      return "${retval}"
    }
  done

  PA_usage

  return "${OK}"
}

# PA_usage outputs help text for a single component if help was asked for when
# a command was specified, or for all components otherwise.
# Args: None expected.
PA_usage() {

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[usagecallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func}"
      return
    }
  done

  eval "${_PA[usage]}"
}

# Private Functions -----------------------------------------------------------

# PA_new sets the initial values for the PArser's associative array.
# Args: None expected.
_PA_new() {
  _PA[command]=
  _PA[subcommand]=
  _PA[state]="COMMAND"
  _PA[optscallbacks]=
  _PA[usagecallbacks]=
  _PA[statecallbacks]=
  _PA[runcallbacks]=
  # The return value if the caller asked for an extra shift:
  _PA[shift]=126
}

# _PA_check_token checks for a valid token in arg2 state. The logic is
# most easily understood by reading the full original version at:
# https://github.com/mclarkson/my-own-kind/blob/master/docs/package.md#scripted-cluster-creation-and-deletion
# This function is a reduction of all the check_xxx_token functions.
# Args: arg1 - the token to check.
#       arg2 - the current state.
#       arg3 - the state value to set, optional. This should only be sent
#              for command and subcommand states.
_PA_check_token() {

  local item

  if [[ -n ${_PA[subcommand]} ]]; then
    cmdsubcommand="${_PA[command]}${_PA[subcommand]}"
  elif [[ -n ${_PA[command]} && ${_PA[state]} != "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}$1"
  elif [[ -n ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}"
  elif [[ -z ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand=
  else
    cmdsubcommand="$1"
  fi

  for item in ${_PA[statecallbacks]}; do
    IFS=, read -r state component newstate func <<<"${item}"
    [[ ${state} == "$2" ]] && {
      [[ ${component} == "${cmdsubcommand}" ]] && {
        [[ -n $3 ]] && _PA["$3"]="$1"
        _PA[state]="${newstate}"
        [[ -n ${func} ]] && {
          eval "${func} $1" || return
        }
        return "${OK}"
      }
    }
  done
}

# _PA_process_option checks that the user-provided option is valid for the
# command-subcommand or global states.
# Args: arg1 - The option to check.
#       arg2 - TODO The value of the option if present, optional.
_PA_process_option() {

  local item curcmdsubcmd

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[optscallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func} \"$1\" \"$2\""
      return $?
    }
  done

  return "${ERROR}"
}

# Initialise _PA
_PA_new

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GL - Globals

# Private Functions -----------------------------------------------------------

# GL_new sets the only global variables that should be in use anywhere.  The
# only other globals are the associative arrays. All the globals are constant
# (readonly) variables. Declare these globals, where needed, in other files
# so that shellcheck passes.
# Args: None expected.
_GL_new() {

  declare -rg MOKVERSION="0.8.24"
  declare -rg K8SVERSION="1.32.1"
  declare -rg GO_VERSION="1.23.4"

  # Returns, exit codes
  declare -rg OK=0
  declare -rg SUCCESS=0
  declare -rg ERROR=1
  declare -rg FAILURE=1

  # For setting flags
  declare -rg TRUE=1
  declare -rg FALSE=0

  # To signal main() to exit with SUCCESS in the PArser
  declare -rg STOP=2

  declare -rg STDOUT="/dev/stdout"
  declare -rg STDERR="/dev/stderr"

  # The following just keep shellcheck happy
  local dummy dumb
  dummy="${OK}"
  dummy="${ERROR}"
  dummy="${STOP}"
  dummy="${STDOUT}"
  dummy="${STDERR}"
  dummy="${TRUE}"
  dummy="${FALSE}"
  dummy="${SUCCESS}"
  dummy="${FAILURE}"
  dummy="${MOKVERSION}"
  dummy="${GO_VERSION}"
  dummy="${K8SVERSION}"
  dumb="${dummy}${dumb}"
}

# Initialise GL
_GL_new || exit 1

# vim helpers -----------------------------------------------------------------

# The following lines allow the use of '[C-i' and '[I' (do ':help [I') in vim.
#include buildimage.sh
#include containerutils.sh
#include createcluster.sh
#include deletecluster.sh
#include embed-dockerfile.sh
#include error.sh
#include exec.sh
#include getcluster.sh
#include main.sh
#include lib/parser.sh
#include util.sh
#include versions.sh

# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# ER - Error handling

# ER is an associative array that holds data specific to error handling.
declare -A ER

# Declare externally defined associative arrays -------------------------------

# Defined in GL (globals.sh)
declare ERROR TRUE STDERR

# Public Functions ------------------------------------------------------------

# ER_err outputs a stacktrace and returns ERROR status.
# Args: None expected.
ER_err() {

  # In case of error print the function call stack
  # No args expected

  [[ ${ER[errcalled]} == "${TRUE}" ]] && return "${ERROR}"
  ER[errcalled]="${TRUE}"
  local frame=0
  printf '\n' >"${STDERR}"
  while caller "${frame}"; do
    ((frame++))
  done | tac >"${STDERR}"
  printf '\n' >"${STDERR}"
  return "${ERROR}"
}

# err is a synonym for ER_err to aid with code readability.
err() {
  ER_err
  return
}

# Private Functions -----------------------------------------------------------

# ER_new sets the initial values for the ER associative array.
# Args: None expected.
_ER_new() {
  ER[errcalled]=
}

# Initialise ER
_ER_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# UT - Utilities

# _UT is an associative array that holds data specific to general utilities.
declare -A _UT

# Declare externally defined global variables ---------------------------------

declare OK STDERR FALSE TRUE

# Getters/Setters -------------------------------------------------------------

# UT_runlogfile getter outputs the value of _UT[runlogfile], which contains the
# name of the file written to when running UT_run_with_progress.
UT_runlogfile() {
  printf '%s' "${_UT[runlogfile]}"
}

# UT_tailf getter indicates whether a log will be shown in real-time during the
# 'run', TRUE, or not, FALSE.
# Args
UT_tailf() {
  printf '%s' "${_UT[tailf]}"
}

# UT_tailf setter indicates whether a log should be shown during the 'run',
# TRUE, or not, FALSE.
# Args: arg1 - Whether to tail, TRUE or FALSE.
UT_set_tailf() {
  _UT[tailf]="$1"
}

# UT_set_plain setter sets plain output, with no colour, animations, or UTF
# high byte characters.
# Args: arg1 - Whether to show plain output, TRUE or FALSE.
UT_set_plain() {
  _UT[plain]="$1"
  UT_disable_colours
}

# Public Functions ------------------------------------------------------------

# UT_disable_colours resets variables used for colourised output so that they
# contain no colour terminal escapes. Useful if stdin is not a terminal.
UT_disable_colours() {
  _UT[yellow]=
  _UT[green]=
  _UT[red]=
  _UT[normal]=
  _UT[probablysuccess]="!"
  _UT[success]="✓"
  _UT[failure]="✕"
}

# UT_run_with_progress displays a progress spinner, item text, and a tick or
# cross based on the exit code.
# Args: arg1   - the text to display.
#       arg2-N - remaining args are the program to run and its arguments.
UT_run_with_progress() {

  local displaytext=$1 retval int spinner=()

  _UT[runlogfile]=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }
  shift

  if [[ ${_UT[tailf]} == "${FALSE}" && ${_UT[plain]} == "${TRUE}" ]]; then

    # Output with no colours or spinny

    printf '%s' "${displaytext}"

    eval "$*" &>"${_UT[runlogfile]}"
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 0 ]]; then
      printf ' .. %s\n' "${_UT[success]}"
    else
      printf ' .. %s\n' "${_UT[failure]}"
    fi

  elif [[ ${_UT[tailf]} == "${FALSE}" ]]; then

    # Output with colours and spinny

    while read -r char; do
      spinner+=("${char}")
    done <<<"$(grep -o . <<<"${_UT[spinnerchars]}")"

    (
      eval "$*" &>"${_UT[runlogfile]}"
    ) &

    # Turn the cursor off
    tput civis

    # Start the spin animation
    printf ' %s' "${displaytext}"
    (while true; do
      for int in {0..3}; do
        printf '\r  %s ' "${spinner[int]}"
        sleep .1
      done
    done) &
    _UT[spinnerpid]=$!
    disown

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Kill the spinner
    kill "${_UT[spinnerpid]}" 2>/dev/null
    _UT[spinnerpid]=

    sleep .5

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\r  %s\n' "${_UT[probablysuccess]}"
    elif [[ ${retval} -eq 0 ]]; then
      printf '\r  %s\n' "${_UT[success]}"
    else
      printf '\r  %s\n' "${_UT[failure]}"
    fi

    # Restore the cursor
    tput cnorm
    sleep .5

  else

    # Tailf output

    printf 'COMMAND: %s\n\n' "$*"

    (
      eval "$*" &>/dev/stdout
    ) &
    sleep 1

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\n\nSTATUS: OK - (Probably)\n\n'
    elif [[ ${retval} -eq 0 ]]; then
      printf '\n\nSTATUS: OK\n\n'
    else
      printf '\n\nSTATUS: FAIL\n\n'
    fi
  fi

  return "${retval}"
}

# UT_cleanup removes any artifacts that were created during execution.
# This is called by 'MA_cleanup' trap only.
UT_cleanup() {

  # Called when the script exits.

  local int

  # Kill the spinny, and anything else, if they're running
  if [[ ${_UT[tailf]} == "${FALSE}" ]]; then
    [[ -n ${_UT[spinnerpid]} ]] && {
      printf '%s\r  ✕%s\n' "${_UT[red]}" "${_UT[normal]}"
      kill "${_UT[spinnerpid]}"
    }
    # If progress spinner crashed make sure the cursor is shown
    [ -t 1 ] && tput cnorm
  else
    kill "${_UT[spinnerpid]}" &>/dev/null
  fi

  return "${OK}"
}

# UT_sed_json_block returns the value of the query_key between
# block_start_key:block_start_val and block_end_key.
# Args:
#  Arg 1: data
#  Arg 2: block_start_key
#  Arg 3: block_start_val
#  Arg 4: block_end_key
#  Arg 5: query_key
UT_sed_json_block() {
  local data block_start_key block_start_val block_end_key query_key
  data="$1"
  block_start_key="$2"
  block_start_val="$3"
  block_end_key="$4"
  query_key="$5"
  echo "$data" | sed -rn \
    '/'"${block_start_key}"'.*'"${block_start_val}"'/,/'"${block_end_key}"'/ { s/^ *"'"${query_key}"'": *//p }' \
    | tr -d ',"'
}

# Private Functions -----------------------------------------------------------

# _UT_new sets the initial values for the _UT associative array.
# Args: None expected.
_UT_new() {
  _UT[tailf]="${FALSE}"
  _UT[yellow]=$(tput setaf 3)
  _UT[green]=$(tput setaf 2)
  _UT[red]=$(tput setaf 1)
  _UT[normal]=$(tput sgr0)
  _UT[probablysuccess]="${_UT[yellow]}✓${_UT[normal]}"
  _UT[success]="${_UT[green]}✓${_UT[normal]}"
  _UT[failure]="${_UT[red]}✕${_UT[normal]}"
  _UT[runlogfile]=
  _UT[spinnerchars]="|/-\\"
  _UT[spinnerpid]=
}

# Initialise _UT
_UT_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GC - Get Cluster

# _GC is an associative array that holds data specific to the get cluster command.
declare -A _GC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# GC_showheader getter outputs the value of the showheader array member.
GC_showheader() {
  printf '%s' "${_GC[showheader]}"
}

# GC_set_showheader setter sets the value of the showheader array member.
# If $TRUE the header will be shown, or $FALSE, then it won't be shown.
GC_set_showheader() {
  _GC[showheader]="$1"
}

# GC_set_clustername setter sets the cluster name to show information about.
GC_set_clustername() {
  _GC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# GC_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted. It is called by
# MA_cleanup.
GC_cleanup() {
  :
}

# GC_process_options checks if arg1 is in a list of valid get cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
GC_process_options() {

  case "$1" in
  -h | --help)
    GC_usage
    return "${STOP}"
    ;;
  *)
    GC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# GC_usage outputs help text for the create cluster component.
# It is called by PA_usage().
# Args: None expected.
GC_usage() {

  cat <<'EnD'
GET subcommands are:
 
  cluster[s] - list all mok managed clusters.
 
get cluster[s] options:
 
 Format:
  get cluster(s) [NAME]
  NAME        - (optional) The name of the cluster to get
                details about.

EnD
}

# GC_run gets information about cluster(s).
# This function is called in main.sh.
# Args: None expected.
GC_run() {

  _GC_sanity_checks || return

  local ids id info output labelkey
  local containerhostname containerip

  declare -a nodes

  ids=$(CU_get_cluster_container_ids "${_GC[clustername]}") || return

  if [[ -z ${ids} ]]; then
    printf 'No clusters found\n'
    return "${OK}"
  fi

  readarray -t nodes <<<"${ids}"

  # Use 'docker inspect' to get the value of the label $LABELKEY

  output=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  # Output the header
  [[ ${_GC[showheader]} -eq ${TRUE} ]] && {
    printf 'MOK_Cluster Docker_ID Container_Name IP_Address\n' >"${output}"
  }

  labelkey=$(CU_labelkey) || err || return

  for id in "${nodes[@]}"; do

    info=$(CU_get_container_info "${id}") || return

    clustname=$(JSONPath ".[0].Config.Labels.${labelkey}" -b <<<"${info}") ||
      err || return

    containerhostname=$(JSONPath '.[0].Config.Hostname' -b <<<"${info}") ||
      err || return

    containerip=$(JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}") ||
      err || return

    printf '%s %s %s %s\n' "${clustname}" "${id}" "${containerhostname}" "${containerip}"

  done | sort -k 3 >>"${output}"

  column -t "${output}" || err
}

# Private Functions -----------------------------------------------------------

# _GC_new sets the initial values for the _GC associative array.
# Args: None expected.
_GC_new() {
  _GC[showheader]="${TRUE}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "get" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "getcluster" "ARG1" ""
  PA_add_state "SUBCOMMAND" "getclusters" "ARG1" ""
  PA_add_state "ARG1" "getcluster" "END" "GC_set_clustername"
  PA_add_state "ARG1" "getclusters" "END" "GC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "get" "GC_process_options" || return
  PA_add_option_callback "getcluster" "GC_process_options" || return
  PA_add_option_callback "getclusters" "GC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "get" "GC_usage" || return
  PA_add_usage_callback "getcluster" "GC_usage" || return
  PA_add_usage_callback "getclusters" "GC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "getcluster" "GC_run"
  PA_add_run_callback "getclusters" "GC_run"
}

# GC_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_GC_sanity_checks() {

  # Only show the usage if we are in 'get' mode and have not specified a
  # subcommand. This allows internal code to call GC_run()
  if [[ $(PA_command) == "get" && -z $(PA_subcommand) ]]; then
    GC_usage
    exit "${OK}"
  fi
}

# Initialise _GC
_GC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# MU - Machine Utilities for Podman

# _MU is an associative array that holds data specific to machine utils.
declare -A _MU

# Declare externally defined variables ----------------------------------------

declare ERROR STDERR STOP

# Getters/Setters -------------------------------------------------------------

# Public Functions ------------------------------------------------------------

# MU_cleanup removes artifacts that were created during execution. This function
# is run automatically by the Parser library. Currently this does nothing and
# this function could be deleted.
MU_cleanup() { :; }

# MU_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_process_options() {
  case "$1" in
  -h | --help)
    MU_usage
    return "${STOP}"
    ;;
  *)
    MU_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_usage() {

  cat <<'EnD'
MACHINE subcommands are:
 
  list    - List the currently created Podman machines. Only one machine
            is currently supported and it will be named 'mok-machine'.
  create  - Create a Podman machine named 'mok-machine'. This will also
            setup the Podman machine to run Kubernetes so there is no
            need to run 'machine setup'.
  destroy - Completely removes the Podman machine named 'mok-machine'.
  start   - Start the Podman machine named 'mok-machine'.
  stop    - Stop the Podman machine named 'mok-machine'.
  setup   - Apply the correct settings to the Podman machine to run
            Kubernetes.
 
For more information:

  machine list -h
  machine create -h
  machine destroy -h
  machine start -h
  machine stop -h
  machine setup -h
 
EnD
}

# Private Functions -----------------------------------------------------------

# _MU_new sets the initial values for the Machine Utils associative array and
# sets up the Parser to call functions in machine*.sh files.
# Args: None expected.
_MU_new() {
  # Program the parser's state machine
  PA_add_state "COMMAND" "machine" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "machinelist" "END" ""
  PA_add_state "SUBCOMMAND" "machinecreate" "END" ""
  PA_add_state "SUBCOMMAND" "machinedestroy" "END" ""
  PA_add_state "SUBCOMMAND" "machinesetup" "END" ""
  PA_add_state "SUBCOMMAND" "machinestart" "END" ""
  PA_add_state "SUBCOMMAND" "machinestop" "END" ""

  # Set up the parser's option callbacks
  PA_add_option_callback "machine" "MU_process_options" || return
  PA_add_option_callback "machinelist" "MU_list_process_options" || return
  PA_add_option_callback "machinecreate" "MU_create_process_options" || return
  PA_add_option_callback "machinedestroy" "MU_destroy_process_options" || return
  PA_add_option_callback "machinesetup" "MU_setup_process_options" || return
  PA_add_option_callback "machinestart" "MU_start_process_options" || return
  PA_add_option_callback "machinestop" "MU_stop_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "machine" "MU_usage" || return
  PA_add_usage_callback "machinelist" "MU_list_usage" || return
  PA_add_usage_callback "machinecreate" "MU_create_usage" || return
  PA_add_usage_callback "machinedestroy" "MU_destroy_usage" || return
  PA_add_usage_callback "machinesetup" "MU_setup_usage" || return
  PA_add_usage_callback "machinestart" "MU_start_usage" || return
  PA_add_usage_callback "machinestop" "MU_stop_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "machinelist" "MU_list_run"
  PA_add_run_callback "machinecreate" "MU_create_run"
  PA_add_run_callback "machinedestroy" "MU_destroy_run"
  PA_add_run_callback "machinesetup" "MU_setup_run"
  PA_add_run_callback "machinestart" "MU_start_run"
  PA_add_run_callback "machinestop" "MU_stop_run"
}

# Initialise _MU
_MU_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148

# MACHINE STOP ================================================================

# MU_stop_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_stop_process_options() {
  case "$1" in
  -h | --help)
    MU_stop_usage
    return "${STOP}"
    ;;
  *)
    MU_stop_usage
    printf 'ERROR: "%s" is not a valid "stop" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_stop_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_stop_usage() {

  cat <<EnD
machine stop options:
 
 Format:
  machine stop [flags]
 
 Flags:
  -h - This help text.

 Description:
  This will stop a Podman machine named 'mok-machine'.
  Stop the podman machine with: $(MA_program_name) machine stop
EnD
}

# MU_stop_run lists Podman machines.
# Args: None expected.
MU_stop_run() {
  UT_run_with_progress \
    "    Stopping Podman machine: mok-machine" \
    podman machine stop mok-machine
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}


# shellcheck shell=bash disable=SC2148

# MACHINE START ===============================================================

# MU_start_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_start_process_options() {
  case "$1" in
  -h | --help)
    MU_start_usage
    return "${STOP}"
    ;;
  -v | --verbose)
    UT_set_tailf "${TRUE}" || err || return
    ;;
  *)
    MU_start_usage
    printf 'ERROR: "%s" is not a valid "start" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_start_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_start_usage() {

  cat <<EnD
machine start options:
 
 Format:
  machine start [flags]
 
 Flags:
  -h, --help - This help text.
  -v, --verbose - Verbose output. Useful if there was a problem.

 Description:
  This will start a Podman machine named 'mok-machine'.
  Start the podman machine with: $(MA_program_name) machine start
EnD
}

# MU_start_run lists Podman machines.
# Args: None expected.
MU_start_run() {
  UT_run_with_progress \
    "    Starting Podman machine: mok-machine" \
    podman machine start mok-machine
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}

# shellcheck shell=bash disable=SC2148

# MACHINE CREATE ==============================================================

# MU_create_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_create_process_options() {
  case "$1" in
  -h | --help)
    MU_create_usage
    return "${STOP}"
    ;;
  -v | --verbose)
    UT_set_tailf "${TRUE}" || err || return
    ;;
  *)
    MU_create_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_create_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_create_usage() {

  cat <<EnD
machine create options:
 
 Format:
  machine create [flags]
 
 Flags:
  -h, --help - This help text.
  -v, --verbose - Verbose output. Useful if there was a problem.

 Description:
  This will create a Podman machine named 'mok-machine' and setup the
  machine to run Kubernetes.
EnD
}

# MU_create_run lists Podman machines.
# Args: None expected.
MU_create_run() {
  UT_run_with_progress \
    "    Creating the Podman machine: mok-machine" \
    podman machine init --now --rootful --user-mode-networking mok-machine
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Loading module in mok-machine" \
    podman machine ssh --username root mok-machine modprobe nf_conntrack
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Persisting nf_conntrack module in mok-machine" \
    podman machine ssh --username root mok-machine \
      bash -c \
      "\"\\\"echo nf_conntrack \
      >/etc/modules-load.d/nf_conntrack.conf\\\"\""
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Setting nf_conntrack_max in mok-machine" \
    podman machine ssh --username root mok-machine sysctl -q \
      -w net.netfilter.nf_conntrack_max=163840
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Persisting nf_conntrack_max in mok-machine" \
    podman machine ssh --username root mok-machine \
      bash -c \
      "\"\\\"echo net.netfilter.nf_conntrack_max=163840 \
      >/etc/sysctl.d/99-nf_conntrack_max.conf\\\"\""
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}

# shellcheck shell=bash disable=SC2148

# MACHINE LIST ================================================================

# MU_list_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_list_process_options() {
  case "$1" in
  -h | --help)
    MU_list_usage
    return "${STOP}"
    ;;
  *)
    MU_list_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_list_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_list_usage() {

  cat <<'EnD'
machine list options:
 
 Format:
  machine list [flags]
 
 Flags:
  -h - This help text.

EnD
}

# MU_list_run lists Podman machines.
# Args: None expected.
MU_list_run() {
  info=$(podman machine list --format json) || err || return

  running=$(UT_sed_json_block "${info}" \
    'Name' 'mok-machine' '}' \
    'Running' \
    ) || err || return

  exists=$(UT_sed_json_block "${info}" \
    'Name' 'mok-machine' '}' \
    'Name' \
    ) || err || return

  if [[ ${exists} != "mok-machine" ]]; then
    printf 'mok-machine: does not exist.\n'
  else
    if [[ ${running} == "true" ]]; then
      printf 'mok-machine: running.\n'
    else
      printf 'mok-machine: stopped.\n'
    fi
  fi
}

# shellcheck shell=bash disable=SC2148

# MACHINE DESTROY ==============================================================

# MU_destroy_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_destroy_process_options() {
  case "$1" in
  -h | --help)
    MU_destroy_usage
    return "${STOP}"
    ;;
  -v | --verbose)
    UT_set_tailf "${TRUE}" || err || return
    ;;
  *)
    MU_destroy_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_destroy_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_destroy_usage() {

  cat <<'EnD'
machine destroy options:
 
 Format:
  machine destroy [flags]
 
 Flags:
  -h, --help - This help text.
  -v, --verbose - Verbose output. Useful if there was a problem.

 Description:
  This will completely remove a Podman machine named 'mok-machine'.
  A machine must be stopped before it can be destroyed.

EnD
}

# MU_destroy_run deletes a Podman machine.
# Args: None expected.
MU_destroy_run() {
  printf 'This will completely remove the podman machine named "mok-machine"\n'
  printf "Are you sure you want to destroy the machine? (y/N) >"
  read -r ans
  [[ ${ans} != "y" ]] && {
    printf 'Cancelling by user request.\n'
    return "${OK}"
  }
  UT_run_with_progress \
    "    Deleting the Podman machine: mok-machine" \
    podman machine rm -f mok-machine
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}

# shellcheck shell=bash disable=SC2148

# MACHINE SETUP ===============================================================

# MU_setup_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_setup_process_options() {
  case "$1" in
  -h | --help)
    MU_setup_usage
    return "${STOP}"
    ;;
  -v | --verbose)
    UT_set_tailf "${TRUE}" || err || return
    ;;
  *)
    MU_setup_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}


# MU_setup_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_setup_usage() {

  cat <<'EnD'
machine setup options:
 
 Format:
  machine setup [flags]
 
 Flags:
  -h, --help - This help text.
  -v, --verbose - Verbose output. Useful if there was a problem.

EnD
}

# MU_setup_run sets up a Podman machine.
# Args: None expected.
MU_setup_run() {
  UT_run_with_progress \
    "    Loading module in mok-machine" \
    podman machine ssh --username root mok-machine modprobe nf_conntrack
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Persisting nf_conntrack module in mok-machine" \
    podman machine ssh --username root mok-machine \
      bash -c \
      "\"\\\"echo nf_conntrack \
      >/etc/modules-load.d/nf_conntrack.conf\\\"\""
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Setting nf_conntrack_max in mok-machine" \
    podman machine ssh --username root mok-machine sysctl -q \
      -w net.netfilter.nf_conntrack_max=163840
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Persisting nf_conntrack_max in mok-machine" \
    podman machine ssh --username root mok-machine \
      bash -c \
      "\"\\\"echo net.netfilter.nf_conntrack_max=163840 \
      >/etc/sysctl.d/99-nf_conntrack_max.conf\\\"\""
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}

# shellcheck shell=bash disable=SC2148
# EX - EXec

# EX is an associative array that holds data specific to the exec cluster command.
declare -A _EX

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# EX_set_containername setter sets the containername to be used to 'log in' to.
EX_set_containername() {
  _EX[containername]="$1"
}

# Public Functions ------------------------------------------------------------

# EX_process_options checks if arg1 is in a list of valid exec options. This
# function is called by the parser, via a callback in _EX_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
EX_process_options() {

  case "$1" in
  -h | --help)
    EX_usage
    return "${STOP}"
    ;;
  *)
    EX_usage
    printf 'ERROR: "%s" is not a valid "exec" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# EX_usage outputs help text for the create exec component.  It is called in
# this file and by PA_usage(), via a callback in _EX_new.
# Args: None expected.
EX_usage() {

  cat <<'EnD'
'Log in' to a container. EXEC has no subcommands.
 
exec options:
 
 Format:
  exec [NAME]
  NAME        - (optional) The name of the container to 'log in' to.
                If NAME is not given then the user will be offered
                a choice of containers to log in to. If there is only
                one cluster and one node then it will 'log in' to the
                only available container.

EnD
}

# Execs 'bash' in the container referenced by _EX[containername]. If just
# 'mok exec' is called without options then the user is offered a selection
# of existing clusters to exec into.
# Args: None expected.
# ---------------------------------------------------------------------------
EX_run() {

  _EX_sanity_checks || return

  local names int ans lines containernames gcoutput

  GC_set_showheader "${TRUE}" || err || return
  gcoutput=$(GC_run) || return
  names=$(printf '%s' "${gcoutput}" | awk '{ print $3; }')
  readarray -t containernames <<<"${names}"

  if [[ -n ${_EX[containername]} ]]; then

    # The caller gave a specific name for exec.
    # Check if the container name exists

    if grep -qs "^${_EX[containername]}$" <<<"${names}"; then
      _EX_exec "${_EX[containername]}" || return
      return "${OK}"
    else
      printf 'ERROR: Cannot exec into non-existent container: "%s".\n' \
        "${_EX[containername]}"
      return "${ERROR}"
    fi

  elif [[ ${#containernames[*]} == 2 ]]; then

    # If there's only one container just log into it without asking
    _EX_exec "${containernames[1]}"

  elif [[ ${#containernames[*]} == 1 ]]; then

    printf 'No containers found.\n'
    return "${OK}"

  else

    # The caller supplied no container name.
    # Present some choices

    printf 'Choose the container to log in to:\n\n'

    readarray -t lines <<<"${gcoutput}" || return

    # Print the header then print the items in the loop
    printf '   %s\n' "${lines[0]}"
    for int in $(seq 1 $((${#lines[*]} - 1))); do
      printf '%00d) %s\n' "${int}" "${lines[int]}"
    done | sort -k 4

    printf "\nChoose a number (Enter to cancel)> "
    read -r ans

    [[ -z ${ans} || ${ans} -lt 0 || ${ans} -gt $((${#lines[*]} - 1)) ]] && {
      printf '\nInvalid choice. Aborting.\n'
      return "${OK}"
    }

    _EX_exec "${containernames[ans]}"
  fi
}

# Private Functions -----------------------------------------------------------

# _EX_new sets the initial values for the _EX associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
_EX_new() {
  _EX[containername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "exec" "ARG1" ""
  PA_add_state "ARG1" "exec" "END" "EX_set_containername"

  # Set up the parser's option callbacks
  PA_add_option_callback "exec" "EX_process_options" || return
  PA_add_usage_callback "exec" "EX_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "exec" "EX_run"
}

# EX_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For exec this does nothing.
# Args: None expected.
_EX_sanity_checks() { :; }

# _EX_exec runs a command in a docker container using bash as the command by
# default.
# Args: arg1 - docker container name
#       arg2 - command to run
_EX_exec() {

  local cmd=${2:-bash} url port

  containerrt=$(CU_containerrt) || err || return
  podmantype=$(CU_podmantype) || err || return

  # TODO: A named podman machine does not work the same way
  #       as the default podman machine. Rootful doesn't work
  #       for a named machine so need to use '--url'. Ask
  #       Podman developers about this.
  port=$(podman machine inspect mok-machine | grep Port | grep -o '[0-9]\+')
  url="ssh://root@127.0.0.1:$port/run/podman/podman.sock"

  read -rt 0.1
  if [[ $containerrt == "podman" && $podmantype == "machine" ]]; then
      # TODO: This would be preferred to '--url'
    # podman -c mok-machine exec -ti "$1" "${cmd}" 
    podman --url "${url}" exec -ti "$1" "${cmd}" 
  elif [[ $containerrt == "podman" ]]; then
    exec podman exec -ti "$1" "${cmd}"
  elif [[ $containerrt == "docker" ]]; then
    exec docker exec -ti "$1" "${cmd}"
  fi
}

# Initialise EX
_EX_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# DC - Delete Cluster

# _DC is an associative array that holds data specific to deleting a cluster.
declare -A _DC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR STOP TRUE

# Getters/Setters -------------------------------------------------------------

# DC_set_clustername setter sets the cluster name to be deleted. This is
# called by the parser, via a callback in _DC_new.
DC_set_clustername() {
  _DC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# DC_process_options checks if arg1 is in a list of valid delete cluster
# options. This function is called by the parser, via a callback in _DC_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
DC_process_options() {

  case "$1" in
  -h | --help)
    DC_usage
    return "${STOP}"
    ;;
  *)
    DC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# DC_usage outputs help text for the create cluster component.
# It is called by PA_usage(), via a callback in _DC_new.
# Args: None expected.
DC_usage() {

  cat <<'EnD'
DELETE subcommands are:
 
  cluster - Delete a local kubernetes cluster.
 
delete cluster options:
 
 Format:
  delete cluster NAME
  NAME        - The name of the cluster to delete

EnD
}

# DC_run starts the delete cluster process.
# Args: None expected.
DC_run() {

  _DC_sanity_checks || return

  # Mutate functions make system changes.

  declare -i numnodes=0
  local id ids r

  numnodes=$(CU_get_cluster_size "${_DC[clustername]}") || return

  [[ ${numnodes} -eq 0 ]] && {
    printf '\nERROR: No cluster exists with name, "%s". Aborting.\n\n' \
      "${_DC[clustername]}" >"${STDERR}"
    return "${ERROR}"
  }

  ids=$(CU_get_cluster_container_ids "${_DC[clustername]}") || return

  printf 'The following containers will be deleted:\n\n'

  GC_set_showheader "${TRUE}"
  GC_set_clustername "${_DC[clustername]}"
  GC_run "${_DC[clustername]}" || return

  printf "\nAre you sure you want to delete the cluster? (y/N) >"

  read -r ans

  [[ ${ans} != "y" ]] && {
    printf '\nCancelling by user request.\n'
    return "${OK}"
  }

  printf '\n'

  for id in ${ids}; do
    UT_run_with_progress \
      "    Deleting id, '${id}' from cluster '${_DC[clustername]}'." \
      _DC_delete "${id}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n\n' >"${STDERR}"
      err
      return "${r}"
    }
  done

  printf '\n'
}

# Private Functions -----------------------------------------------------------

# _DC_new sets the initial values for the _DC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_DC_new() {
  _DC[clustername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "delete" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "deletecluster" "ARG1" ""
  PA_add_state "ARG1" "deletecluster" "END" "DC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "delete" "DC_process_options" || return
  PA_add_option_callback "deletecluster" "DC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "delete" "DC_usage" || return
  PA_add_usage_callback "deletecluster" "DC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "deletecluster" "DC_run"
}

# DC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before DC_run is called.
# Args: None expected.
_DC_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    DC_usage
    exit "${OK}"
  fi

  if [[ -z ${_DC[clustername]} ]]; then
    DC_usage
    printf 'Please provide the Cluster NAME to delete.\n' >"${STDERR}"
    return "${ERROR}"
  fi
}

# _DC_delete stops and removes a docker container.
# Args: arg1 - docker id to delete.
_DC_delete() {

  docker stop -t 5 "${id}"
  docker rm "${id}" || err
}

# Initialise _DC
_DC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE K8SVERSION

# Getters/Setters -------------------------------------------------------------

# CC_set_clustername setter sets the clustername array item.
CC_clustername() {
  printf '%s' "${_CC[clustername]}"
}

# CC_publish getter outputs the publish array item.
CC_publish() {
  printf '%s' "${_CC[publish]}"
}

# CC-withlb getter outputs the withlb array item.
CC_withlb() {
  printf '%s' "${_CC[withlb]}"
}

# CC_set_clustername setter sets the clustername array item.
CC_set_clustername() {
  _CC[clustername]="$1"
}

# CC_set_nummasters setter sets the nummasters array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_nummasters() {
  _CC[nummasters]="$1"
}

# CC_set_numworkers setter sets the numworkers array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_numworkers() {
  _CC[numworkers]="$1"
}

# Public Functions ------------------------------------------------------------

# CC_process_options checks if arg1 is in a list of valid create cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option. For example, '--masters' should be sent
#              with a value but boolean options, like 'skiplbsetup' should not.
CC_process_options() {

  case "$1" in
  -h | --help)
    CC_usage
    return "${STOP}"
    ;;
  --skiplbsetup)
    _CC[skiplbsetup]="${TRUE}"
    return
    ;;
  --k8sver)
    _CC[k8sver]="$2"
    return "$(PA_shift)"
    ;;
  --with-lb)
    _CC[withlb]="${TRUE}"
    return
    ;;
  --skipmastersetup)
    _CC[skipmastersetup]="${TRUE}"
    return
    ;;
  --skipworkersetup)
    _CC[skipworkersetup]="${TRUE}"
    return
    ;;
  --masters)
    _CC[nummasters]="$2"
    return "$(PA_shift)"
    ;;
  --workers)
    _CC[numworkers]="$2"
    return "$(PA_shift)"
    ;;
  --tailf)
    _CC[tailf]="${TRUE}"
    return "${OK}"
    ;;
  --publish)
    _CC[publish]="${TRUE}"
    return
    ;;
  *)
    CC_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# CC_usage outputs help text for the create cluster component.  It is called in
# this file and by PA_usage(), via a callback set in _CC_new.
# Args: None expected.
CC_usage() {

  cat <<'EnD'
CREATE subcommands are:
 
  cluster - Create a local kubernetes cluster.
 
create cluster [flags] options:
 
 Format:
  create cluster NAME [ [NUM_MASTERS] [NUM_WORKERS] ]
  NAME        - The name of the cluster. This will be used as
                the prefix in the name for newly created
                docker containers.
  NUM_MASTERS - The number of master containers.
  NUM_WORKERS - The number of worker containers. If NUM_WORKERS is
                zero then the 'node-role.kubernetes.io/master' taint
                will be removed from master nodes so that pods are
                schedulable.
 
 Flags:
  --skipmastersetup - Create the master container but don't set it
         up. Useful for manually installing kubernetes. Kubeadm, 
         kubelet and kubectl will be installed at the requested 
         version. With this option the worker will also be skipped.
         See also '--k8sver' flag.
  --skipworkersetup - The same as '--skipmastersetup', but skips
         setting up the worker only.
  --with-lb - Add a haproxy load balancer. The software will be installed
         and set up to reverse proxy to the master node(s), unless
         --skiplbsetup is used.
  --k8sver VERSION - Unimplemented.
  --masters NUM - The number of master containers to create.
  --workers NUM - The number of worker containers to create. When workers
                  is zero then the master node taint will be removed from
                  master nodes so that pods are schedulable on those nodes.
  --tailf - Show the log output whilst creating the cluster.
  --publish - Publish port 6443 for the master node, or the load balancer if
              it's enabled, for external kubectl access to the cluster. The IP
              address of the default route interface is added to the cert.

EnD
}

# CC_run creates the kubernetes cluster.
# Args: None expected.
CC_run() {

  _CC_sanity_checks || return

  [[ ${_CC[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  declare -i numnodes=0

  numnodes=$(CU_get_cluster_size "${_CC[clustername]}") || return

  [[ ${numnodes} -gt 0 ]] && {
    printf '\nERROR: Cluster, "%s", exists! Aborting.\n\n' "${_CC[clustername]}" \
      >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_create_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_create_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_setup_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_setup_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[numworkers]} -gt 0 ]] && {
    _CC_create_worker_nodes "${_CC[numworkers]}" || return
  }

  printf '\n'

  [[ -z ${_CC[skipmastersetup]} ]] && {
    printf 'Cluster, "%s", can be accessed using:\n\n' "${_CC[clustername]}"
    printf 'export KUBECONFIG=/var/tmp/admin-%s.conf\n\n' "${_CC[clustername]}"
  }

  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CC_new sets the initial values for the _CC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_CC_new() {
  _CC[tailf]="${FALSE}"
  _CC[skipmastersetup]=
  _CC[skipworkersetup]=
  _CC[skiplbsetup]=
  _CC[withlb]=
  _CC[clustername]=
  _CC[nummasters]=0
  _CC[numworkers]=0
  _CC[publish]=0
  _CC[k8sver]="${K8SVERSION}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "create" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "createcluster" "ARG2" ""

  # Support for the legacy style of create (less to type):
  PA_add_state "ARG1" "createcluster" "ARG2" "CC_set_clustername"
  PA_add_state "ARG2" "createcluster" "ARG3" "CC_set_nummasters"
  PA_add_state "ARG3" "createcluster" "END" "CC_set_numworkers"

  # Set up the parser's option callbacks
  PA_add_option_callback "create" "CC_process_options" || return
  PA_add_option_callback "createcluster" "CC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "create" "CC_usage" || return
  PA_add_usage_callback "createcluster" "CC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "createcluster" "CC_run"
  PA_add_run_callback "createclusters" "CC_run"
}

# CC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before CC_run is called.
# Args: None expected.
_CC_sanity_checks() {

  declare -i host_max=0 cpus=0 should_be=0

  if [[ -z $(PA_subcommand) ]]; then
    CC_usage
    exit "${OK}"
  fi

  if [[ -z ${_CC[clustername]} ]]; then
    CC_usage
    printf 'Please provide the Cluster NAME to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[nummasters]} || ${_CC[nummasters]} -le 0 ]]; then
    CC_usage
    printf 'Please provide the number of Masters to create. Must be 1 or more.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[numworkers]} ]]; then
    CC_usage
    printf 'Please provide the number of Workers to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/sys/net/nf_conntrack_max ]]; then
    host_max=$(cat /proc/sys/net/nf_conntrack_max)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    host_max=$(podman machine ssh mok-machine cat /proc/sys/net/nf_conntrack_max)
  else
    printf '\nWARNING: /proc/sys/net/nf_conntrack_max not found.\n' >"${STDERR}"
    printf '         kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/cpuinfo ]]; then
    cpus=$(grep -cw ^processor /proc/cpuinfo)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    cpus=$(podman machine ssh mok-machine cat /proc/cpuinfo | grep -cw ^processor)
  else
    printf '\nWARNING: /proc/cpuinfo not found.\n' >"${STDERR}"
    printf '         I have no idea how many CPUs I have\n' >"${STDERR}"
    printf '         and kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  # These are the default values that kube-proxy expects:
  # conntrack:
  #   max: null
  #   maxPerCore: 32768
  #   min: 131072
  if [[ $((32768*cpus)) -lt 131072 ]]; then
    should_be=131072
  else
    should_be=$((32768*cpus))
  fi
  if [[ ${should_be} -ne $host_max ]]; then
    printf '\nERROR: /proc/sys/net/nf_conntrack_max should be set to %d.\n' \
      "${should_be}" >"${STDERR}"
    printf '     kube-proxy will not start with an incorrect nf_conntrack_max.\n' >"${STDERR}"
    printf '     To fix this, run the following command:\n\n' >"${STDERR}"
    if [[ $(CU_podmantype) == "native" ]]; then
      printf '       sudo sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
    elif [[ $(CU_podmantype) == "machine" ]]; then
      printf '       %s machine setup\n\n' "$(MA_program_name)" >"${STDERR}"
    else
      printf 'Internal ERROR. Invalid podman type.\n' >"${STDERR}"
      return "${ERROR}"
    fi
    
    printf 'Press ENTER to continue or CTRL-C to abort.\n' >"${STDERR}"
    read -r
    printf '\n' >"${STDERR}"
  fi
}

# _CC_create_master_nodes creates the master node containers.
# Args: arg1 - number of master nodes to create
_CC_create_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating master container, '${_CC[clustername]}-master-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-master-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }
  done

  return "${OK}"
}

# _CC_setup_master_nodes sets up the master node containers.
# Args: arg1 - number of master nodes to create
_CC_setup_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile lbaddr hostaddr
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-master-${int}'" \
      _CC_set_up_master_node "${_CC[clustername]}-master-${int}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  done

  # For now, copy admin.conf from master to /var/tmp/admin-CLUSTERNAME.conf

  if [[ -z ${_CC[skipmastersetup]} ]]; then
    if [[ ${_CC[publish]} -eq ${TRUE} ]]; then
      # On MacOS we need to use localhost, on linux use the host IP
      if [[ $(CU_podmantype) == "native" ]]; then
        hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
      else
        hostaddr="localhost"
      fi
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${hostaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    elif [[ ${_CC[withlb]} -eq ${TRUE} ]]; then
      lbaddr=$(CU_get_container_ip "${_CC[clustername]}-lb") || err || return
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${lbaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    else
      [[ -n ${_CC[skipmastersetup]} ]] || {
        docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
          "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      }
    fi

    chmod 666 "/var/tmp/admin-${_CC[clustername]}.conf" || {
      printf 'ERROR: Could not "chown 666 /var/tmp/admin-%s.conf"' "${_CC[clustername]}"
      err || return
    }
  fi

  return "${OK}"
}

# _CC_set_up_master_node calls the correct set up function based on the version
# Args: arg1 - the container ID to set up
_CC_set_up_master_node() {

  case "${_CC[k8sver]}" in
  "1.31."* | "1.32."*)
    _CC_set_up_master_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# _CC_get_master_join_details uses 'docker exec' or 'podman exec' to run a
# script on the master to get CA hash, a token, and the master IP.  The caller
# can eval the output of this function to set the variables: cahash, token, and
# masterip. See also:
# https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/#token-based-discovery-with-ca-pinning
# Args: arg1 - id/name of master container
_CC_get_master_join_details() {

  local joinvarsfile master1ip

  joinvarsfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  master1ip=$(CU_get_container_ip "${_CC[clustername]}-master-1") || err || return

  cat <<EnD >"${joinvarsfile}"
#!/bin/bash
set -e

sed 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${master1ip}"'\2#' \
  /etc/kubernetes/super-admin.conf >/etc/kubernetes/admin2.conf

cahash=\$(openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | \
        openssl rsa -pubin -outform der 2>/dev/null | \
        openssl dgst -sha256 -hex | sed 's/^.* //')
token=\$(kubeadm token create --kubeconfig=/etc/kubernetes/admin2.conf 2>/dev/null)
ip=\$(ip ro get 8.8.8.8 | cut -d" " -f 7)

printf 'cahash=%s\ntoken=%s\nmasterip=%s' "\$cahash" "\$token" "\$ip"

exit 0
EnD

  docker cp "${joinvarsfile}" "$1":/root/joinvars.sh 2>"${STDERR}" ||
    err || return
  rm -f "${joinvarsfile}" 2>"${STDERR}" || err || return

  [[ -z ${_CC[skipworkersetup]} ]] && {
    docker exec "$1" bash /root/joinvars.sh 2>"${STDERR}" || err || return
  }

  return "${OK}"
}

# _CC_create_lb_node creates the load balancer node container.
# Args: None expected.
_CC_create_lb_node() {

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  # Create container
  UT_run_with_progress \
    "    Creating load balancer container, '${_CC[clustername]}-lb'" \
    CU_create_container \
    "${_CC[clustername]}-lb" \
    "${labelkey}=${_CC[clustername]}" \
    "${_CC[k8sver]}"

  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    printf '\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
    printf '%s\n' "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  return "${OK}"
}

# _CC_setup_lb_node sets up the load balancer node container.
# Args: None expected.
_CC_setup_lb_node() {

  local runlogfile

  # Set up
  [[ -z ${_CC[skiplbsetup]} ]] && {
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-lb'" \
      _CC_set_up_lb_node_real "${_CC[clustername]}-lb"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _CC_set_up_lb_node_real sets up the lb node.
# Args: arg1 - the container ID to set up
_CC_set_up_lb_node_real() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masteriplist=
  nl=
  gotamaster="${FALSE}"
  for idx in $(seq 1 "${_CC[nummasters]}"); do
    ip=$(CU_get_container_ip "${_CC[clustername]}-master-${idx}") || continue
    gotamaster="${TRUE}"
    masteriplist="${masteriplist}${nl}    server master-${idx} ${ip}:6443 check fall 3 rise 2"
    nl='\n'
  done

  [[ ${gotamaster} == "${FALSE}" ]] && {
    printf 'ERROR: Did not manage to get an IP address for any master nodes\n'
    err || return
  }

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

systemctl stop kubelet crio
systemctl disable kubelet crio

apt -y install haproxy

INTERNAL_IP=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")

cat <<EOF | tee /etc/haproxy/haproxy.cfg 
frontend kubernetes
    bind \$INTERNAL_IP:6443
    option tcplog
    mode tcp
    default_backend kubernetes-master-nodes
backend kubernetes-master-nodes
    mode tcp
    balance roundrobin
    option tcp-check
\$(echo -e "${masteriplist}")
EOF

systemctl restart haproxy
systemctl enable haproxy

EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# _CC_create_worker_nodes creates the worker nodes.
# Args: arg1 - number of worker nodes to create
_CC_create_worker_nodes() {

  local cahash token t masterip
  declare -i int=0

  [[ -n ${_CC[skipmastersetup]} ]] || {
    # Runs a script on master node to get details
    t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1") || {
      printf '\nERROR: Problem with "_CC_get_master_join_details".\n\n' >"${STDERR}"
      return "${ERROR}"
    }

    # Sets cahash, token, and masterip:
    eval "${t}"
  }

  local labelkey
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating worker container, '${_CC[clustername]}-worker-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-worker-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }

    [[ -n ${_CC[skipworkersetup]} || -n ${_CC[skipmastersetup]} ]] || {
      UT_run_with_progress \
        "    Setting up '${_CC[clustername]}-worker-${int}'" \
        _CC_set_up_worker_node "${_CC[clustername]}-worker-${int}" \
        "${cahash}" "${token}" "${masterip}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n' >"${STDERR}"
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
        printf '%s\n' "${runlogfile}" >"${STDERR}"
        return "${ERROR}"
      }

      UT_run_with_progress \
        "    Waiting for system to become ready" \
        _CC_wait_for_cluster \
        "${_CC[clustername]}-master-1" \
        "${_CC[clustername]}-worker-${int}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n'
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Wait timed out.\n' >"${STDERR}"
        return "${ERROR}"
      }
    }
  done

  return "${OK}"
}

# _CC_wait_for_cluster runs a `kubectl` command in the master-1 container,
# which doesn't exit until the all pods are fully up and running before it
# returns.
# Args: arg1 - the master container name to log into
#       arg2 - the worker container name to wait for
_CC_wait_for_cluster() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  cat <<'EnD' >"${setupfile}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
found=0
for i in $(seq 1 20); do
  if kubectl get pods &>/dev/null; then
    found=1
    break
  fi
  sleep 1
done
[[ $found == 0 ]] && {
  printf '# kubectl get pods\n'
  kubectl get pods
  printf '\nWaited for 20 seconds for kubectl to work.\n'
  printf 'Kubectl cannot contact master. Aborting.\n'
  exit 1
}
counter=0
while ! kubectl get nodes | grep -qs "$1"; do
  ((counter++))
  [[ ${counter} -gt 60 ]] && {
    printf '# kubectl get nodes\n'
    kubectl get nodes
    printf '\nWaited for 2 minutes for node to appear in master. Aborting.\n'
    exit 1
  }
  sleep 2
done
counter=0
while kubectl get pods -A | tail -n +2 | awk '{ print $3; }' | grep -qs 0; do
  ((counter++))
  [[ ${counter} -gt 120 ]] && {
    printf '# kubectl get pods -A\n'
    kubectl get pods -A
    printf '\nWaited for 3 minutes for pods to be ready. Aborting.\n'
    exit 1
  }
  sleep 2
done
exit 0
EnD

  docker cp "${setupfile}" "$1":/root/wait.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/wait.sh "$2" || err
}

# _CC_set_up_worker_node calls the correct set up function based on the version.
# Args: arg1 - the container ID to set up
#       arg2 - the CA hash
#       arg3 - the token
#       arg4 - the master IP
_CC_set_up_worker_node() {

  case "${_CC[k8sver]}" in
  "1.31."* | "1.32."*)
    _CC_set_up_worker_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# Initialise _CC
_CC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster - versions file

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR TRUE

# _CC_set_up_master_node_v1_30_0 uses kubeadm to set up the master node.
# Args: arg1 - the container to set up.
_CC_set_up_master_node_v1_30_0() {

  local setupfile lbaddr certSANs="{}" certkey masternum t lbip
  # Set by _CC_get_master_join_details:
  local cahash token masterip

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masternum="${1##*-}" # <- eg. for xxx-master-1, masternum=1

  if [[ ${_CC[skipmastersetup]} != "${TRUE}" ]]; then

    if [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -eq 1 ]]; then

      # This is the first master node

      # Sets cahash, token, and masterip:
      lbip=$(CU_get_container_ip "${_CC[clustername]}-lb")
      lbaddr=", '${lbip}'"
      uploadcerts="--upload-certs"
      certkey="CertificateKey: f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07"

    elif [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -ne 1 ]]; then

      # This is not the first master node, so join with the master
      # https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/

      # Keep trying to get join details until apiserver is ready or we run out of tries
      for try in $(seq 1 9); do
        # Runs a script on master node to get join details
        t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1")
        retval=$?
        [[ ${retval} -eq 0 ]] && break
        [[ ${try} -eq 9 ]] && {
          printf '\nERROR: Problem with "_CC_get_master_join_details". Tried %d times\n\n' "${try}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        sleep 5
      done
      eval "${t}"
    fi
  fi

  # Always set certSANs for the host whether we need it or not
  hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
  certSANs="
  certSANs: [ '${hostaddr}'${lbaddr}, '127.0.0.1', 'localhost' ]"

  # Write the file regardless, so the user can use it if required

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

# Use a custom configuration. Default config created from kubeadm with:
#   kubeadm config print init-defaults
# then edited.

ipaddr=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")
podsubnet="10.244.0.0/16"
servicesubnet="10.96.0.0/16"

cat <<EOF >kubeadm-init-defaults.yaml
apiVersion: kubeadm.k8s.io/v1beta4
bootstrapTokens:
- groups:
  - system:bootstrappers:kubeadm:default-node-token
  token: abcdef.0123456789abcdef
  ttl: 24h0m0s
  usages:
  - signing
  - authentication
kind: InitConfiguration
${certkey}
localAPIEndpoint:
  advertiseAddress: \$ipaddr
  bindPort: 6443
nodeRegistration:
  criSocket: unix:///var/run/crio/crio.sock
  imagePullPolicy: IfNotPresent
  imagePullSerial: true
  name: $1
  taints:
  - effect: NoSchedule
    key: node-role.kubernetes.io/control-plane
timeouts:
  controlPlaneComponentHealthCheck: 4m0s
  discovery: 5m0s
  etcdAPICall: 2m0s
  kubeletHealthCheck: 4m0s
  kubernetesAPICall: 1m0s
  tlsBootstrap: 5m0s
  upgradeManifests: 5m0s
---
apiServer: ${certSANs}
apiVersion: kubeadm.k8s.io/v1beta4
caCertificateValidityPeriod: 87600h0m0s
certificateValidityPeriod: 8760h0m0s
certificatesDir: /etc/kubernetes/pki
clusterName: ${_CC[clustername]}-cluster
controlPlaneEndpoint: ${lbaddr:-\$ipaddr}:6443
controllerManager: {}
dns: {}
encryptionAlgorithm: RSA-2048
etcd:
  local:
    dataDir: /var/lib/etcd
imageRepository: registry.k8s.io
kind: ClusterConfiguration
networking:
  dnsDomain: cluster.local
  podSubnet: \${podsubnet}
  serviceSubnet: \${servicesubnet}
proxy: {}
scheduler: {}
EOF

mkdir -p /mok
cp kubeadm-init-defaults.yaml /mok/kubeadm.yaml

if [[ -z "${masterip}" ]]; then
  # Run the preflight phase
  kubeadm init \\
    --ignore-preflight-errors Swap \\
    --config=kubeadm-init-defaults.yaml \\
    phase preflight

  # Set up the kubelet
  kubeadm init phase kubelet-start

  # Edit the kubelet configuration file
  echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
  sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

  # Tell kubeadm to carry on from here
  kubeadm init \\
    --config=kubeadm-init-defaults.yaml \\
    --ignore-preflight-errors Swap \\
    ${uploadcerts} \\
    --skip-phases=preflight,kubelet-start

  export KUBECONFIG=/etc/kubernetes/super-admin.conf

  # Flannel - 10.244.0.0./16
  kubectl apply -f /root/kube-flannel.yml
else
  kubeadm join ${masterip}:6443 \\
    --ignore-preflight-errors Swap \\
    --control-plane \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --certificate-key f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07
fi

systemctl enable kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  # Run the file
  [[ -z ${_CC[skipmastersetup]} ]] && {
    docker exec "$1" bash /root/setup.sh || err || return

    # Remove the taint if we're setting up a single node cluster

    [[ ${_CC[numworkers]} -eq 0 ]] && {

      removetaint=$(mktemp -p /var/tmp) || {
        printf 'ERROR: mktmp failed.\n' >"${STDERR}"
        return "${ERROR}"
      }

      # Write the file
      cat <<'EnD' >"${removetaint}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
kubectl taint nodes --all node-role.kubernetes.io/control-plane:NoSchedule-
EnD

      docker cp "${removetaint}" "$1":/root/removetaint.sh || err || {
        rm -f "${removetaint}"
        return "${ERROR}"
      }

      # Run the file
      docker exec "$1" bash /root/removetaint.sh || err
    }
  }

  return "${OK}"
}

# _CC_set_up_worker_node_v1_30_0 uses kubeadm to set up the worker node.
# Args: arg1 - the container to set up.
_CC_set_up_worker_node_v1_30_0() {

  local setupfile cahash="$2" token="$3" masterip="$4"

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  if [[ ${_CC[withlb]} == "${TRUE}" ]]; then
    masterip=$(CU_get_container_ip "${_CC[clustername]}-lb") || return
  fi

  cat <<EnD >"${setupfile}"
# Wait for the master API to become ready
while true; do
  curl -k https://${masterip}:6443/
  [[ \$? -eq 0 ]] && break
  sleep 1
done

# Do the preflight tests (ignoring swap error)
kubeadm join \\
  phase preflight \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --ignore-preflight-errors Swap \\
    ${masterip}:6443

# Set up the kubelet
kubeadm join \\
  phase kubelet-start \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    ${masterip}:6443 &

while true; do
  [[ -e /var/lib/kubelet/config.yaml ]] && break
    sleep 1
  done

# Edit the kubelet configuration file
echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

systemctl enable --now kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh 2>"${STDERR}" || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CU - Container Utilities

# _CU is an associative array that holds data specific to container utils.
declare -A _CU

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# CU_containerrt getter outputs the container runtime (podman or docker)
# that has been chosen.
CU_containerrt() {
  printf '%s' "${_CU[containerrt]}"
}

# CU_imgprefix getter outputs the prefix to be used with docker build. For
# podman it is 'localhost/'. For docker it is empty.
CU_imgprefix() {
  printf '%s' "${_CU[imgprefix]}"
}

# CU_labelkey getter outputs the key value of the label that is applied to all
# cluster member's container labels for podman or docker.
CU_labelkey() {
  printf '%s' "${_CU[labelkey]}"
}

# CU_podmantype getter outputs the container runtime type (native or machine).
CU_podmantype() {
  printf '%s' "${_CU[podmantype]}"
}

# Public Functions ------------------------------------------------------------

# CU_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted.
CU_cleanup() { :; }

# CU_get_cluster_container_ids outputs just the container IDs, one per line
# for any MOK cluster, unless arg1 is set, in which case just the IDs
# for the requested cluster name are output.
# Args: arg1 - The cluster name, optional.
CU_get_cluster_container_ids() {

  local value output

  [[ -n $1 ]] && value="=$1"

  output=$(docker ps -a -f label="${_CU[labelkey]}${value}" -q) || {
    printf 'ERROR: %s command failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  output=$(printf '%s' "${output}" | sed 's/$//')

  printf '%s' "${output}"

  return "${OK}"
}

# CU_get_cluster_size searches for an existing cluster using labels and outputs
# the number of containers in that cluster. All cluster nodes are labelled with
# "${_CU[labelkey]}=${CC[clustername]}"
# Args: arg1 - The cluster name to search for.
CU_get_cluster_size() {

  local output
  declare -a nodes

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Cluster name cannot be empty.\n' >"${STDERR}"
    err || return
  }

  output=$(CU_get_cluster_container_ids "$1") || err || return

  # readarray will read null as an array item so don't run
  # through readarray if it's null
  [[ -z ${output} ]] && {
    printf '0'
    return "${OK}"
  }

  # read the nodes array and delete blank lines
  readarray -t nodes <<<"${output}"

  printf '%d' "${#nodes[*]}"
}

# CU_get_container_ip outputs the IP address of the container.
# Args: arg1 - docker container id or container name to query.
CU_get_container_ip() {

  local info

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  info=$(CU_get_container_info "$1") || return
  JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}" ||
    err || return
}

# CU_get_container_info uses 'docker/podman inspect $id' to output
# container details.
# Args: arg1 - docker container id
CU_get_container_info() {

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  docker inspect "$1" || {
    printf 'ERROR: %s inspect failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_create_container creates and runs a container with settings suitable for
# running privileged containers that can manipulate cgroups.
# Args: arg1 - The string used to set the name and hostname.
#       arg2 - The label to assign to the container.
#       arg3 - The k8s base image version to use.
CU_create_container() {

  local imagename img allimgs systemd_always clustername parg pval root_user url port

  [[ -z $1 || -z $2 || -z $3 ]] && {
    printf 'INTERNAL ERROR: Neither arg1, arg2 nor arg3 can be empty.\n' \
      >"${STDERR}"
    err || return
  }

  img="$(BI_baseimagename)_$(MA_ostype)"

  local imglocal="${_CU[imgprefix]}local/${img}"
  local imgremote="myownkind/${img}"
  local imgtag="${3}"

  # Prefer a locally built container over one downloaded from a registry
  allimgs=$(docker images | tail -n +2) || {
    printf 'ERROR: %s returned an error\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  if echo "${allimgs}" | grep -qs "${imglocal} *${imgtag}"; then
    imagename="${imglocal}:${imgtag}"
  elif echo "${allimgs}" | grep -qs "${imgremote} *${imgtag}"; then
    imagename="${imgremote}:${imgtag}"
  else
    cat <<EnD
ERROR: No container base image found. Use either:

  $ mok build image
OR
  $ mok build image --get-prebuilt-image

Then try running 'mok create ...' again.
EnD
    return "${ERROR}"
  fi

  clustername=$(CC_clustername) || err || return

  if [[ ${_CU[containerrt]} == "podman" ]];
  then 
    docker network exists "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  else
    docker network inspect "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  fi

  [[ ${create_network} -ne 0 ]] && {
    docker network create "${clustername}_network" || {
      printf 'ERROR: docker network create failed\n' >"${STDERR}"
      err || return
    }
  }

  # Docker does not have the --systemd option
  [[ ${_CU[containerrt]} == "podman" ]] && systemd_always="--systemd=always"
  [[ ${_CU[podmantype]} == "machine" ]] && {
    root_user="--user=root"
    # TODO: A named podman machine does not work the same way
    #       as the default podman machine. Rootful doesn't work
    #       for a named machine so need to use '--url'. Ask
    #       Podman developers about this.
    port=$(podman machine inspect mok-machine | grep Port | grep -o '[0-9]\+')
    url="--url ssh://root@127.0.0.1:$port/run/podman/podman.sock"
  }

  [[ $(CC_publish) == "${TRUE}" ]] && {
    if [[ $(CC_withlb) == "${TRUE}" ]]; then
      if echo "$1" | grep -qs -- '-lb$'; then
        parg='-p'
        pval='6443:6443'
      fi
    else
      if echo "$1" | grep -qs -- '-master-1$'; then
        parg='-p'
        pval='6443:6443'
      fi
    fi
  }

  # shellcheck disable=SC2086
  docker ${url} run --privileged ${systemd_always} ${root_user} \
    --network "${clustername}_network" \
    -v /lib/modules:/lib/modules:ro \
    --detach ${parg} ${pval} \
    --name "$1" \
    --hostname "$1" \
    --label "$2" \
    "${imagename}" \
    /usr/local/bin/entrypoint /lib/systemd/systemd log-level=info unit=sysinit.target || {
    printf 'ERROR: %s run failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_podman_or_docker checks to see if docker and/or podman are installed and
# sets the imgprefix and containerrt array members accordingly. It also defines
# the docker function to run the detected container runtime. Podman is
# preferred if both are installed.
# Args: No args expected.
CU_podman_or_docker() {
  if type podman &>/dev/null; then
    _CU[imgprefix]="localhost/"
    _CU[containerrt]="podman"
    _CU_podman_checks || return
  elif type docker &>/dev/null; then
    _CU[imgprefix]=""
    _CU[containerrt]="docker"
    _CU_docker_checks || return
  else
    printf 'ERROR: Neither "podman" nor "docker" were found.\n' \
      >"${STDERR}"
    printf 'Please install one of "podman" or "docker".\nAborting.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi
  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CU_docker_checks checks to see if the current user has permission to write
# to the docker socket. If not, it prints an error message and exits.
# Args: No args expected.
_CU_docker_checks() {
  if [[ ! -e /proc/sys/kernel/hostname ]]; then
    printf 'ERROR: Docker is currently supported on Linux only'
    exit "${ERROR}"
  fi

  if docker ps >/dev/stdout 2>&1 | grep -qs 'docker.sock.*permission denied'; then
    cat <<EnD >"${STDERR}"
Not enough permissions to write to 'docker.sock'.

Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  fi

  _CU[podmantype]="native"
  return "${OK}"
}

# _CU_podman_checks sets the _CU[podmantype] member to "native" or "machine"
# depending on whether this is linux or macos. We assume linux won't be using
# a podman machine, and macos will always be using a podman machine.
# Args: No args expected.
_CU_podman_checks() {
  local info running exists

  if [[ -e /proc/sys/kernel/hostname ]]; then
    # We're on linux
    _CU[podmantype]="native"
    _CU_podman_native_checks || return
  elif [[ -d /System/Library/CoreServices ]]; then
    # We're on macOS
    [[ $(id -u) -eq 0 ]] && {
      printf 'ERROR: Cannot run mok as root on macOS.\n' >"${STDERR}"
      exit "${ERROR}"
    }

    info=$(podman machine list --format json) || err || return
    running=$(UT_sed_json_block "${info}" \
      'Name' 'mok-machine' '}' \
      'Running' \
      ) || err || return
    exists=$(UT_sed_json_block "${info}" \
      'Name' 'mok-machine' '}' \
      'Name' \
      ) || err || return

    if [[ $(MA_arg_1) != "machine" && ${exists} != "mok-machine" ]]; then
      printf 'ERROR: Podman machine does not exist.\n' >"${STDERR}"
      printf '       Create a Podman machine with: %s machine create\n' \
        "$(MA_program_name)" >"${STDERR}"
      exit "${ERROR}"
    elif [[ ${running} == "true" ]]; then
      _CU[podmantype]="machine"
    elif [[ $(MA_arg_1) != "machine" ]]; then
      # Don't check for a podman machine if we're running 'machine' commands
      printf 'ERROR: Podman machine is not running.\n' >"${STDERR}"
      printf '       Try starting the machine with: %s machine start\n' \
        "$(MA_program_name)" >"${STDERR}"
      exit "${ERROR}"
    fi
  else
    printf 'ERROR: Unknown OS. Aborting.\n' >"${STDERR}"
    exit "${ERROR}"
  fi
}

# _CU_podman_native_checks checks to see if the current user is root. If not,
# it prints an error message and exits.
# Args: No args expected.
_CU_podman_native_checks() {
  [[ $(id -u) -ne 0 ]] && {
    cat <<EnD >"${STDERR}"
Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  }
}

# _CU_new sets the initial values for the Container Utils associative array.
# Args: None expected.
_CU_new() {
  _CU[imgprefix]=
  _CU[labelkey]="MokCluster"
  _CU[containerrt]=

  # _CU[podmantype] will only be set only if _CU[containerrt]=podman.
  # podmantype will be "native" or "machine".
  _CU[podmantype]=
}

# Override `docker` depending on _CU[containerrt]
# [[ -n ${_CU[containerrt]} ]] && {
  docker() {
    local cmd port url

    if [[ "${_CU[containerrt]}" == "podman" && "${_CU[podmantype]}" == "machine" ]]; then
      # TODO: A named podman machine does not work the same way
      #       as the default podman machine. Rootful doesn't work
      #       for a named machine so need to use '--url'. Ask
      #       Podman developers about this.
      port=$(podman machine inspect mok-machine | grep Port | grep -o '[0-9]\+')
      url="ssh://root@127.0.0.1:$port/run/podman/podman.sock"

      # TODO: This would be preferred to '--url'
      # podman -c mok-machine "$@"
      podman --url "${url}" "$@"
    elif [[ "${_CU[containerrt]}" == "podman" ]]; then
      podman "$@"
    else
      cmd=$(which -a docker | tail -n 1)
      $cmd "$@"
    fi
  }
# }

# Override `ip` depending on _CU[podmantype]
ip() {
  local cmd
  if [[ "${_CU[podmantype]}" == "machine" ]]; then
    podman machine ssh mok-machine ip "$@"
  else
    cmd=$(which -a ip | tail -n 1)
    $cmd "$@"
  fi
}

# Initialise _CU
_CU_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# BI - Build Image

# _BI is an associative array that holds data specific to building an image.
declare -A _BI

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE

# Getters/Setters -------------------------------------------------------------

# BI_setflag_useprebuiltimage setter sets the useprebuiltimage array item.
# This is called by the parser, via a callback in _BI_new.
BI_setflag_useprebuiltimage() {
  _BI[useprebuiltimage]="$1"
}

# BI_baseimagename getter outputs the value of the _BI[baseimagename].
# Args: None expected.
BI_baseimagename() {
  printf '%s' "${_BI[baseimagename]}"
}

# Public Functions ------------------------------------------------------------

# BI_usage outputs help text for the build image component.
# It is called by PA_usage(), via a callback in _BI_new.
# Args: None expected.
BI_usage() {

  cat <<'EnD'
BUILD subcommands are:
 
  image - Creates the docker 'mok-image' container image.
 
build image options:
 
 Format:
  build image [flags]

 Flags:
  --get-prebuilt-image - Instead of building a 'node' image
         locally, download it from a container registry instead.
  --tailf - Show the build output whilst building.

EnD
}

# BI_cleanup removes temporary files created during the build.
# This function is called by the 'MA_cleanup' trap only.
# Args: None expected.
BI_cleanup() {
  [[ -e ${_BI[dockerbuildtmpdir]} ]] &&
    [[ ${_BI[dockerbuildtmpdir]} == "/var/tmp/"* ]] && {
    rm -rf "${_BI[dockerbuildtmpdir]}" || {
      printf 'ERROR: "rm -rf %s" failed.\n' "${_BI[dockerbuildtmpdir]}" \
        >"${STDERR}"
      err || return
    }
  }
}

# BI_check_valid_options checks if arg1 is in a list of valid build image
# options. This function is called by the parser, via a callback in _BI_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
BI_process_options() {

  case "$1" in
  -h | --help)
    BI_usage
    return "${STOP}"
    ;;
  --tailf)
    _BI[tailf]="${TRUE}"
    return "${OK}"
    ;;
  --get-prebuilt-image)
    _BI[useprebuiltimage]="${TRUE}"
    return "${OK}"
    ;;
  *)
    BI_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# BI_run builds the base image used for masters and workers.
# This function is called in main.sh.
# Args: None expected.
BI_run() {

  _BI_sanity_checks || return

  [[ ${_BI[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  local retval=0
  _BI_build_container_image
  retval=$?

  if [[ ${retval} -eq ${OK} ]]; then
    : # We only need the tick - no text
  else
    printf 'Image build failed\n' >"${STDERR}"
    err
  fi

  return "${retval}"
}

# Private Functions -----------------------------------------------------------

# _BI_new resets the initial values for the _BI associative array.
# Args: None expected.
_BI_new() {
  _BI[tailf]="${FALSE}"
  _BI[baseimagename]="mok-image"
  _BI[useprebuiltimage]="${FALSE}"
  _BI[dockerbuildtmpdir]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "build" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "buildimage" "END" ""

  # Set up the parser's option callbacks
  PA_add_option_callback "build" "BI_process_options" || return
  PA_add_option_callback "buildimage" "BI_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "build" "BI_usage" || return
  PA_add_usage_callback "buildimage" "BI_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "buildimage" "BI_run"
}

# BI_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_BI_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    BI_usage
    exit "${OK}"
  fi
}

# _BI_build_container_image creates the docker build directory in
# dockerbuildtmpdir then calls docker build to build the image.
# Args: No args expected.
_BI_build_container_image() {

  local cmd retval tagname buildargs text buildtype basename

  _BI_create_docker_build_dir || return

  buildargs=$(_BI_get_build_args_for_latest) || return
  basename="${_BI[baseimagename]}_$(MA_ostype)"
  tagname="${K8SVERSION}"

  local imgprefix
  imgprefix=$(CU_imgprefix) || err || return
  if [[ ${_BI[useprebuiltimage]} == "${FALSE}" ]]; then
    buildtype="create"
    cmd="docker build \
      -t "${imgprefix}local/${basename}:${tagname}" \
      --force-rm \
      ${buildargs} \
      ${_BI[dockerbuildtmpdir]}/${_BI[baseimagename]}"
    text="Creating"
  else
    buildtype="download"
    cmd="docker pull docker.io/myownkind/${basename}:${tagname}"
    text="Downloading"
  fi

  UT_run_with_progress \
    "    ${text} base image, '${basename}:${tagname}'" "${cmd}"

  retval=$?
  [[ ${retval} -ne ${OK} ]] && {
    local runlogfile
    runlogfile=$(UT_runlogfile) || err || return
    printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\n' >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${buildtype} == "create" ]] && {
    cmd="_BI_modify_container_image"

    UT_run_with_progress \
      "    Modifying base image (pulling kubernetes images)" "${cmd}"

    retval=$?
    [[ ${retval} -ne ${OK} ]] && {
      local runlogfile
      runlogfile=$(UT_runlogfile) || err || return
      printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\n' >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _BI_modify_container_image starts a container suitable for running kubernetes
# components (since the docker/podman build environment isn't suitable), makes
# some modifications and then 'commits' the image. The modifications allow
# `mok create ...` to complete more quickly.
# Args: No args expected.
_BI_modify_container_image() {

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify &>/dev/null
  docker rm mok-build-modify &>/dev/null

  CC_set_clustername "build" || err || return

  # Start container
  CU_create_container "mok-build-modify" "mok-build-modify" "${K8SVERSION}" ||
    return

  # Wait for crio to become ready
  local counter
  printf '\n\n ** WAITING FOR CRIO TO BECOME READY **\n\n'
  while ! docker exec mok-build-modify systemctl status crio; do
    sleep 1
    [[ ${counter} -gt 10 ]] && {
      printf '\nERROR: CRI-O did not start after %d tries.\n' "${counter}"
      err || return
    }
    ((counter++))
  done

  # Modify container
  docker exec mok-build-modify kubeadm config images pull \
    --kubernetes-version "${K8SVERSION}" || err || return

  # Stop container
  docker stop -t 5 "mok-build-modify"

  # Write image
  local imgprefix tagname basename
  imgprefix=$(CU_imgprefix) || err || return
  basename="${_BI[baseimagename]}_$(MA_ostype)"
  tagname="${K8SVERSION}"
  docker commit mok-build-modify "${imgprefix}local/${basename}:${tagname}" || err || return

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify
  docker rm mok-build-modify || err || return

  return "${OK}"
}

# _BI_get_build_args_for_latest sets the buildargs variable that is added
# to the 'podman build ...' command line.  Only the latest version is built
# from scratch.  Earlier versions are downloaded using '--get-prebuilt-image'.
# Args: None expected
_BI_get_build_args_for_latest() {

  local buildargs

  buildargs="--build-arg GO_VERSION=${GO_VERSION}"

  printf '%s' "${buildargs}"
}

# _BI_create_docker_build_dir creates a docker build directory in
# /var/tmp/tmp.XXXXXXXX
# Args: None expected
_BI_create_docker_build_dir() {

  _BI[dockerbuildtmpdir]="$(mktemp -d -p /var/tmp)" || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }

  # The following comments should not be removed or changed.
  # embed-dockerfile.sh adds a base64 encoded tarball and
  # unpacking code between them.

  #mok-image-tarball-start 
  cat <<EnD | base64 -d | tar xz -C "${_BI[dockerbuildtmpdir]}" 
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
EnD
  #mok-image-tarball-end
}

# Initialise _BI
_BI_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
#!/usr/bin/env bash

declare -A JSONPath

JSONPath_new() {
  JSONPath[DEBUG]=0
  JSONPath[INCLEMPTY]=0
  JSONPath[NOCASE]=0
  JSONPath[WHOLEWORD]=0
  JSONPath[FILE]=
  JSONPath[NO_HEAD]=0
  JSONPath[NORMALIZE_SOLIDUS]=0
  JSONPath[BRIEF]=0
  JSONPath[PASSTHROUGH]=0
  JSONPath[JSON]=0
  JSONPath[MULTIPASS]=0
  JSONPath[FLATTEN]=0
  JSONPath[STDINFILE]=/var/tmp/JSONPath.$$.stdin
  JSONPath[STDINFILE2]=/var/tmp/JSONPath.$$.stdin2
  JSONPath[PASSFILE]=/var/tmp/JSONPath.$$.pass1
  declare -a INDEXMATCH_QUERY
}

# JSONPath reads JSON from stdin and applies a JSON Path query.
# Args: arg1-N - command line arguments to be parsed.
JSONPath() {

  JSONPath_sanity_checks
  JSONPath_parse_options "$@"

  trap JSONPath_cleanup EXIT

  if [[ ${QUERY} == *'?(@'* ]]; then
    # This will be a multipass query

    [[ -n ${JSONPath[FILE]} ]] && JSONPath[STDINFILE]=${JSONPath[FILE]}
    [[ -z ${JSONPath[FILE]} ]] && cat >"${JSONPath[STDINFILE]}"

    while true; do
      JSONPath_tokenize_path
      JSONPath_create_filter

      JSONPath_tokenize | JSONPath_parse | JSONPath_filter |
        JSONPath_indexmatcher >"${JSONPath[PASSFILE]}" <"${JSONPath[STDINFILE]}"

      [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && {
        # replace filter expression with index sequence
        SET=$(sed -rn 's/.*[[,"]+([0-9]+)[],].*/\1/p' "${JSONPath[PASSFILE]}" | tr '\n' ,)
        SET=${SET%,}
        #QUERY=$(sed "s/?(@[^)]\+)/${SET}/" <<<"${QUERY}")
        # Testing:
        QUERY="${QUERY//\?\(@*)/${SET}}"
        [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "QUERY=${QUERY}" >/dev/stderr
        JSONPath_reset
        continue
      }

      JSONPath_flatten | JSONPath_json | JSONPath_brief <<<"${JSONPath[PASSFILE]}"

      break
    done

  else

    JSONPath_tokenize_path
    JSONPath_create_filter

    if [[ ${JSONPath[PASSTHROUGH]} -eq 1 ]]; then
      JSONPath[JSON]=1
      JSONPath_flatten | JSONPath_json
    elif [[ -z ${JSONPath[FILE]} ]]; then
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten | JSONPath_json | JSONPath_brief
    else
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten <"${JSONPath[FILE]}"
      JSONPath_json | JSONPath_brief
    fi

  fi
}

JSONPath_sanity_checks() {

  local binary

  # Reset some vars
  for binary in gawk grep sed; do
    if ! command -v "${binary}" >&/dev/null; then
      echo "ERROR: ${binary} binary not found in path. Aborting."
      exit 1
    fi
  done
}

JSONPath_reset() {

  # Reset some vars
  declare -a INDEXMATCH_QUERY
  PATHTOKENS=
  FILTER=
  OPERATOR=
  RHS=
  JSONPath[MULTIPASS]=0
}

JSONPath_cleanup() {

  [[ -e ${JSONPath[PASSFILE]} ]] && rm -f "${PASSFILE}"
  [[ -e ${JSONPath[STDINFILE2]} ]] && rm -f "${JSONPath[STDINFILE2]}"
  [[ -z ${JSONPath[FILE]} && -e ${JSONPath[STDINFILE]} ]] &&
    rm -f "${JSONPath[STDINFILE]}"
}

JSONPath_usage() {

  echo
  echo "Usage: JSONPath.sh [-b] [j] [-h] [-f FILE] [pattern]"
  echo
  echo "pattern - the JSONPath query. Defaults to '$.*' if not supplied."
  echo "-b      - Brief. Only show values."
  echo "-j      - JSON output."
  echo "-u      - Strip unnecessary leading path elements."
  echo "-i      - Case insensitive."
  echo "-p      - Pass-through to the JSON parser."
  echo "-w      - Match whole words only (for filter script expression)."
  echo "-f FILE - Read a FILE instead of stdin."
  echo "-h      - This help text."
  echo
}

JSONPath_parse_options() {

  set -- "$@"
  local ARGN=$#
  while [[ ${ARGN} -ne 0 ]]; do
    case $1 in
    -h)
      JSONPath_usage
      exit 0
      ;;
    -f)
      shift
      JSONPath[FILE]=$1
      ;;
    -i)
      JSONPath[NOCASE]=1
      ;;
    -j)
      JSONPath[JSON]=1
      ;;
    -n)
      JSONPath[NO_HEAD]=1
      ;;
    -b)
      JSONPath[BRIEF]=1
      ;;
    -u)
      JSONPath[FLATTEN]=1
      ;;
    -p)
      JSONPath[PASSTHROUGH]=1
      ;;
    -w)
      JSONPath[WHOLEWORD]=1
      ;;
    -s)
      JSONPath[NORMALIZE_SOLIDUS]=1
      ;;
    *)
      QUERY=$1
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done
  [[ -z ${QUERY} ]] && QUERY='$.*'
}

JSONPath_awk_egrep() {
  local pattern_string=$1

  gawk '{
    while ($0) {
      start=match($0, pattern);
      token=substr($0, start, RLENGTH);
      print token;
      $0=substr($0, start+RLENGTH);
    }
  }' pattern="${pattern_string}"
}

JSONPath_tokenize() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    ESCAPE='(\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
    ESCAPE='(\\\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\\\]'
  fi

  local STRING="\"${CHAR}*(${ESCAPE}${CHAR}*)*\""
  local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'
  local KEYWORD='null|false|true'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  ${GREP} "${STRING}|${NUMBER}|${KEYWORD}|${SPACE}|." | grep -Ev "^${SPACE}$"
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

JSONPath_tokenize_path() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
  fi

  local WILDCARD='\*'
  local WORD='[ A-Za-z0-9_-]*'
  local INDEX="\\[${WORD}(:${WORD}){0,2}\\]"
  local INDEXALL='\[\*\]'
  local STRING="[\\\"'][^[:cntrl:]\\\"']*[\\\"']"
  local SET="\\[(${WORD}|${STRING})(,(${WORD}|${STRING}))*\\]"
  local FILTER='\?\(@[^)]+'
  local DEEPSCAN='\.\.'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  readarray -t PATHTOKENS < <(echo "${QUERY}" |
    ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
    grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$")
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    echo "grep -Eo '${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|.'" >/dev/stderr
    echo -n "TOKENISED QUERY="
    echo "${QUERY}" |
      ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
      grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$" >/dev/stderr
  }
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

# JSONPath_create_filter creates the filter from the user's query.
# Filter works in a single pass through the data, unless a filter (script)
#  expression is used, in which case two passes are required (MULTIPASS=1).
JSONPath_create_filter() {

  local len=${#PATHTOKENS[*]}

  local -i i=0
  local a query="^\[" comma=
  while [[ i -lt len ]]; do
    case "${PATHTOKENS[i]}" in
    '"')
      :
      ;;
    '..')
      query+="${comma}[^]]*"
      comma=
      ;;
    '[*]')
      query+="${comma}[^,]*"
      comma=","
      ;;
    '*')
      query+="${comma}(\"[^\"]*\"|[0-9]+[^],]*)"
      comma=","
      ;;
    '?(@'*)
      a=${PATHTOKENS[i]#?(@.}
      elem="${a%%[<>=!]*}"
      rhs="${a##*[<>=!]}"
      a="${a#${elem}}"
      elem="${elem//./[\",.]+}" # Allows child node matching
      operator="${a%${rhs}}"
      [[ -z ${operator} ]] && {
        operator="=="
        rhs=
      }
      if [[ ${rhs} == *'"'* || ${rhs} == *"'"* ]]; then
        case ${operator} in
        '==' | '=')
          OPERATOR=
          if [[ ${elem} == '?(@' ]]; then
            # To allow search on @.property such as:
            #   $..book[?(@.title==".*Book 1.*")]
            query+="${comma}[0-9]+[],][[:space:]\"]*${rhs//\"/}"
          else
            # To allow search on @ (this node) such as:
            #   $..reviews[?(@==".*Fant.*")]
            query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs//\"/}"
          fi
          FILTER="${query}"
          ;;
        '>=' | '>')
          OPERATOR=">"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=' | '<')
          OPERATOR="<"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      else
        case ${operator} in
        '==' | '=')
          OPERATOR=
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs}"
          FILTER="${query}"
          ;;
        '>=')
          OPERATOR="-ge"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '>')
          OPERATOR="-gt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=')
          OPERATOR="-le"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<')
          OPERATOR="-lt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      fi
      JSONPath[MULTIPASS]=1
      ;;
    "["*)
      if [[ ${PATHTOKENS[i]} =~ , ]]; then
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          # converts only one comma: s/("[^"]+),([^"]+")/\1`\2/g;s/"//g
          #a=$(echo $a | sed 's/\([[:alpha:]]*\)/"\1"/g')
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        fi
        query+="${comma}(${a//,/|})"
      elif [[ ${PATHTOKENS[i]} =~ : ]]; then
        if ! [[ ${PATHTOKENS[i]} =~ [0-9][0-9] || ${PATHTOKENS[i]} =~ :] ]]; then
          if [[ ${PATHTOKENS[i]#*:} =~ : ]]; then
            INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
            query+="${comma}[^,]*"
          else
            # Index in the range of 0-9 can be handled by regex
            query+="${comma}$(echo "${PATHTOKENS[i]}" |
              gawk '/:/ { a=substr($0,0,index($0,":")-1);
                         b=substr($0,index($0,":")+1,index($0,"]")-index($0,":")-1);
                         if(b>0) { print a ":" b-1 "]" };
                         if(b<=0) { print a ":]" } }' |
              sed 's/\([0-9]\):\([0-9]\)/\1-\2/;
                       s/\[:\([0-9]\)/[0-\1/;
                       s/\([0-9]\):\]/\1-9999999]/')"
          fi
        else
          INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
          query+="${comma}[^,]*"
        fi
      else
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        else
          [[ ${i} -gt 0 ]] && comma=","
        fi
        query+="${comma}${a}"
      fi
      comma=","
      ;;
    *)
      PATHTOKENS[i]=${PATHTOKENS[i]//\'/\"}
      query+="${comma}\"${PATHTOKENS[i]//\"/}\""
      comma=","
      ;;
    esac
    i=$((i + 1))
  done

  [[ -z ${FILTER} ]] && FILTER="${query}[],]"
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
}

JSONPath_parse_array() {

  local index=0
  local ary=''
  read -r token
  case "${token}" in
  ']') ;;

  *)
    while :; do
      JSONPath_parse_value "$1" "${index}"
      index=$((index + 1))
      ary="${ary}""${value}"
      read -r token
      case "${token}" in
      ']') break ;;
      ',') ary="${ary}," ;;
      *) JSONPath_throw "EXPECTED , or ] GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_object() {

  local key
  local obj=''
  read -r token
  case "${token}" in
  '}') ;;

  *)
    while :; do
      case "${token}" in
      '"'*'"') key=${token} ;;
      *) JSONPath_throw "EXPECTED string GOT ${token:-EOF}" ;;
      esac
      read -r token
      case "${token}" in
      ':') ;;
      *) JSONPath_throw "EXPECTED : GOT ${token:-EOF}" ;;
      esac
      read -r token
      JSONPath_parse_value "$1" "${key}"
      obj="${obj}${key}:${value}"
      read -r token
      case "${token}" in
      '}') break ;;
      ',') obj="${obj}," ;;
      *) JSONPath_throw "EXPECTED , or } GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_value() {

  local jpath="${1:+$1,}$2" isleaf=0 isempty=0 print=0
  case "${token}" in
  '{') JSONPath_parse_object "${jpath}" ;;
  '[') JSONPath_parse_array "${jpath}" ;;
    # At this point, the only valid single-character tokens are digits.
  '' | [!0-9]) JSONPath_throw "EXPECTED value GOT ${token:-EOF}" ;;
  *)
    value=${token}
    # if asked, replace solidus ("\/") in json strings with normalized value: "/"
    # Testing:
    #[ "${JSONPath[NORMALIZE_SOLIDUS]}" -eq 1 ] && value=$(echo "${value}" | sed 's#\\/#/#g')
    [[ ${JSONPath[NORMALIZE_SOLIDUS]} -eq 1 ]] && value=$(${value//\\\///})
    isleaf=1
    [[ ${value} == '""' ]] && isempty=1
    ;;
  esac
  [[ -z ${JSONPath[INCLEMPTY]} ]] && [[ ${value} == '' ]] && return
  [[ ${JSONPath[NO_HEAD]} -eq 1 ]] && [[ -z ${jpath} ]] && return

  [[ ${isleaf} -eq 1 ]] && [[ ${isempty} -eq 0 ]] && print=1
  [[ ${print} -eq 1 ]] && printf "[%s]\t%s\n" "${jpath}" "${value}"
  :
}

JSONPath_flatten() {

  local path a prevpath pathlen

  if [[ ${JSONPath[FLATTEN]} -eq 1 ]]; then
    cat >"${JSONPath[STDINFILE2]}"

    highest=9999

    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      [[ -z ${prevpath} ]] && {
        prevpath=("${path[@]}")
        highest=$((${#path[*]} - 1))
        continue
      }

      pathlen=$((${#path[*]} - 1))

      for i in $(seq 0 "${pathlen}"); do
        [[ ${path[i]} != "${prevpath[i]}" ]] && {
          high=${i}
          break
        }
      done

      [[ ${high} -lt ${highest} ]] && highest=${high}

      prevpath=("${path[@]}")
    done <"${JSONPath[STDINFILE2]}"

    if [[ ${highest} -gt 0 ]]; then
      sed -r 's/\[(([0-9]+|"[^"]+")[],]){'$((highest))'}(.*)/[\3/' \
        "${JSONPath[STDINFILE2]}"
    else
      cat "${JSONPath[STDINFILE2]}"
    fi
  else
    cat
  fi
}

# JSONPath_indexmatcher is for double digit or greater indexes match each line
# individually Single digit indexes are handled more efficiently by regex
JSONPath_indexmatcher() {

  local a b

  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
      echo "INDEXMATCH_QUERY[${i}]=${INDEXMATCH_QUERY[i]}" >/dev/stderr
    done
  }

  matched=1

  step=
  if [[ ${#INDEXMATCH_QUERY[*]} -gt 0 ]]; then
    while read -r line; do
      for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
        [[ ${INDEXMATCH_QUERY[i]#*:} =~ : ]] && {
          step=${INDEXMATCH_QUERY[i]##*:}
          step=${step%]}
          INDEXMATCH_QUERY[i]="${INDEXMATCH_QUERY[i]%:*}]"
        }
        q=${INDEXMATCH_QUERY[i]:1:-1} # <- strip '[' and ']'
        a=${q%:*}                     # <- number before ':'
        b=${q#*:}                     # <- number after ':'
        [[ -z ${b} ]] && b=99999999999
        readarray -t num < <((grep -Eo '[0-9]+[],]' | tr -d ,]) <<<"${line}")
        if [[ ${num[i]} -ge ${a} && ${num[i]} -lt ${b} && matched -eq 1 ]]; then
          matched=1
          [[ ${i} -eq $((${#INDEXMATCH_QUERY[*]} - 1)) ]] && {
            if [[ ${step} -gt 1 ]]; then
              [[ $(((num[i] - a) % step)) -eq 0 ]] && {
                [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
                echo "${line}"
              }
            else
              [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
              echo "${line}"
            fi
          }
        else
          matched=0
          continue
        fi
      done
      matched=1
    done
  else
    cat -
  fi
}

JSONPath_brief() {
  # Only show the value

  if [[ ${JSONPath[BRIEF]} -eq 1 ]]; then
    sed 's/^[^\t]*\t//;s/^"//;s/"$//;'
  else
    cat
  fi
}

JSONPath_json() {
  # Turn output into JSON

  local a tab="$'\t'"
  local UP=1 DOWN=2 SAME=3
  local prevpathlen=-1 prevpath=() path a
  declare -a closers

  if [[ ${JSONPath[JSON]} -eq 0 ]]; then
    cat -
  else
    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      value=${line#*${tab}}

      # Not including the object itself (last item)
      pathlen=$((${#path[*]} - 1))

      # General direction

      direction=${SAME}
      [[ ${pathlen} -gt ${prevpathlen} ]] && direction=${DOWN}
      [[ ${pathlen} -lt ${prevpathlen} ]] && direction=${UP}

      # Handle jumps UP the tree (close previous paths)

      [[ ${prevpathlen} != -1 ]] && {
        for i in $(seq 0 $((pathlen - 1))); do
          [[ ${prevpath[i]} == "${path[i]}" ]] && continue
          [[ ${path[i]} != '"'* ]] && {
            # Testing double quotes:
            a="(${!arrays[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                arrays[k]=
              done
            }
            a="(${!comma[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                comma[k]=
              done
            }
            for j in $(seq $((prevpathlen)) -1 $((i + 2))); do
              arrays[j]=
              [[ -n ${closers[j]} ]] && {
                indent=$((j * 4))
                printf "\n%${indent}s${closers[j]}" ""
                unset "closers[j]"
                comma[j]=
              }
            done
            direction=${DOWN}
            break
          }
          direction=${DOWN}
          for j in $(seq $((prevpathlen)) -1 $((i + 1))); do
            arrays[j]=
            [[ -n ${closers[j]} ]] && {
              indent=$((j * 4))
              printf "\n%${indent}s${closers[j]}" ""
              unset "closers[j]"
              comma[j]=
            }
          done
          a="(${!arrays[*]})"
          [[ -n ${a} ]] && {
            for k in $(seq "${i}" "${a[-1]}"); do
              arrays[k]=
            done
          }
          break
        done
      }

      [[ ${direction} -eq ${UP} ]] && {
        [[ ${prevpathlen} != -1 ]] && comma[prevpathlen]=
        for i in $(seq $((prevpathlen + 1)) -1 $((pathlen + 1))); do
          arrays[i]=
          [[ -n ${closers[i]} ]] && {
            indent=$((i * 4))
            printf "\n%${indent}s${closers[i]}" ""
            unset "closers[i]"
            comma[i]=
          }
        done
        a="(${!arrays[*]})"
        [[ -n ${a} ]] && {
          for k in $(seq "${i}" "${a[-1]}"); do
            arrays[k]=
          done
        }
      }

      # Opening braces (the path leading up to the key)

      broken=
      for i in $(seq 0 $((pathlen - 1))); do
        [[ -z ${broken} && ${prevpath[i]} == "${path[i]}" ]] && continue
        [[ -z ${broken} ]] && {
          broken=${i}
          [[ ${prevpathlen} -ne -1 ]] && broken=$((i + 1))
        }
        if [[ ${path[i]} == '"'* ]]; then
          # Object
          [[ ${i} -ge ${broken} ]] && {
            indent=$((i * 4))
            printf "${comma[i]}%${indent}s{\n" ""
            closers[i]='}'
            comma[i]=
          }
          indent=$(((i + 1) * 4))
          printf "${comma[i]}%${indent}s${path[i]}:\n" ""
          comma[i]=",\n"
        else
          # Array
          if [[ ${arrays[i]} != 1 ]]; then
            indent=$((i * 4))
            printf "%${indent}s" ""
            echo "["
            closers[i]=']'
            arrays[i]=1
            comma[i]=
          else
            indent=$(((i + 1) * 4))
            printf "\n%${indent}s${closers[i - 1]}" ""
            direction=${DOWN}
            comma[i + 1]=",\n"
          fi
        fi
      done

      # keys & values

      if [[ ${path[-1]} == '"'* ]]; then
        # Object
        [[ ${direction} -eq ${DOWN} ]] && {
          indent=$((pathlen * 4))
          printf "${comma[pathlen]}%${indent}s{\n" ""
          closers[pathlen]='}'
          comma[pathlen]=
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${path[-1]}:${value}"
        comma[pathlen]=",\n"
      else
        # Array
        [[ ${arrays[i]} != 1 ]] && {
          indent=$(((pathlen - 0) * 4))
          printf "%${indent}s[\n" ""
          closers[pathlen]=']'
          comma[pathlen]=
          arrays[i]=1
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${value}"
        comma[pathlen]=",\n"
      fi

      prevpath=("${path[@]}")
      prevpathlen=${pathlen}
    done

    # closing braces

    for i in $(seq $((pathlen)) -1 0); do
      indent=$((i * 4))
      printf "\n%${indent}s${closers[i]}" ""
    done
    echo
  fi
}

JSONPath_filter() {
  # Apply the query filter

  local a tab=$'\t' v

  [[ ${JSONPath[NOCASE]} -eq 1 ]] && opts+="i"
  [[ ${JSONPath[WHOLEWORD]} -eq 1 ]] && opts+="w"
  if [[ -z ${OPERATOR} ]]; then
    [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && FILTER="${FILTER}[\"]?$"
    grep "-E${opts}" "${FILTER}"
    [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
  else
    grep "-E${opts}" "${FILTER}" |
      while read -r line; do
        v=${line#*${tab}}
        case ${OPERATOR} in
        '-ge')
          if gawk '{exit !($1>=$2)}' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-gt')
          if gawk '{exit !($1>$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-le')
          if gawk '{exit !($1<=$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-lt')
          if gawk '{exit !($1<$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '>')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} > ${RHS,,} ]] && echo "${line}"
          ;;
        '<')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} < ${RHS,,} ]] && echo "${line}"
          ;;
        *) return 1 ;;
        esac
      done
  fi
}

JSONPath_parse() {
  # Parses json

  read -r token
  JSONPath_parse_value
  read -r token
  case "${token}" in
  '') ;;
  *)
    JSONPath_throw "EXPECTED EOF GOT ${token}"
    exit 1
    ;;
  esac
}

JSONPath_throw() {
  echo "$*" >&2
  exit 1
}

JSONPath_new || exit 1

# vi: expandtab sw=2 ts=2
# shellcheck shell=bash disable=SC2148
# MA - execution starts here

# MA is an associative array that holds data specific to this file
declare -A _MA

# Defined in GL (globals.sh)
declare OK ERROR STOP STDERR TRUE __mokostype

# Getters/Setters -------------------------------------------------------------

# MA_program_args getter outputs the program arguments sent by the user.
MA_program_args() {
  printf '%s' "${_MA[program_args]}"
}

# MA_arg_1 getter outputs the first argument sent by the user.
# Used by _CU_podman_checks so it doesn't check for a podman machine
# if we're running 'machine' commands
MA_arg_1() {
  printf '%s' "${_MA[arg_1]}"
}

# MA_program_name getter outputs the name of the program.
MA_program_name() {
  printf '%s' "${_MA[arg_0]##*/}"
}

# MA_ostype getter outputs the OS type.
MA_ostype() {
  printf '%s' "${_MA[ostype]}"
}

# Public Functions ------------------------------------------------------------

# main is the start point for this application.
# Args: arg1-N - the command line arguments entered by the user.
MA_main() {
  local retval="${OK}"

  CU_podman_or_docker

  trap MA_cleanup EXIT
  MA_sanity_checks || return
  PA_run "$@" || retval=$?

  exit "${retval}"
}

# MA_version outputs the version information the exits.
MA_version() {
  printf 'Version: %s\n' "${MOKVERSION}"
  exit "${OK}"
}

# MA_process_global_options is called by the parser when a global option is
# encountered for processing.
# Args: arg1 - the global option that was found.
MA_process_global_options() {
  case "$1" in
  -h | --help)
    PA_usage
    return "${STOP}"
    ;;
  -p | --plain)
    UT_set_plain "${TRUE}"
    ;;
  *)
    printf 'INTERNAL ERROR: Invalid global option, "%s".' "$1"
    return "${ERROR}"
    ;;
  esac
}

# MA_cleanup is called from an EXIT trap only, when the program exits, and
# calls every other function matching the pattern '^.._cleanup'.
# Args: No args expected.
MA_cleanup() {
  local retval="${OK}" funcs func
  funcs=$(declare -F | awk '{print $NF;}' | grep '^.._cleanup')
  for func in ${funcs}; do
    [[ ${func} == "${FUNCNAME[0]}" ]] && continue
    eval "${func}" || retval=$?
  done
  return "${retval}"
}

# MA_sanity_checks is expected to run some quick and simple checks to
# see if key components are available before MA_main is called.
# Args: No args expected.
MA_sanity_checks() {

  local binary binaries

  if [[ $(CU_podmantype) == "native" ]]; then
    binaries="gawk tac column tput grep sed ip cut"
  else
    binaries="gawk tac column tput grep sed cut"
  fi

  for binary in ${binaries}; do
    if ! command -v "${binary}" >&/dev/null; then
      printf 'ERROR: "%s" binary not found in path. Aborting.' "${binary}" \
        >"${STDERR}"
      return "${ERROR}"
    fi
  done

  # Disable terminal escapes (colours) if stdout is not a terminal
  [ -t 1 ] || UT_disable_colours
}

# MA_usage outputs help text for all components then quits with no error.  This
# is registered as a callback in the Parser, see _MA_new
# Args: None expected.
MA_usage() {

  cat <<'EnD'
Usage: mok [-h] <command> [subcommand] [ARGS...]
 
Global options:
  --help
  -h     - This help text
  --plain
  -p     - Plain output. No colours or animations.
 
Where command can be one of:
  create  - Add item(s) to the system.
  delete  - Delete item(s) from the system.
  build   - Build item(s) used by the system.
  get     - Get details about items in the system.
  exec    - 'Log in' to the container.
  machine - Manage a podman machine (MacOS only).
  version - Display version information.

For help on a specific command, run:
  mok <command> --help
EnD
}

# MA_new sets the initial values for the _MA associative array
_MA_new() {
  _MA[program_args]="$*"
  _MA[arg_0]="$0"
  _MA[arg_1]="$1"
  _MA[ostype]="${__mokostype}" # linux or macos

  # Program the parser's state machine
  PA_add_state "COMMAND" "version" "END" "MA_version"

  # Set up the parser's option callbacks
  PA_add_option_callback "" "MA_process_global_options"

  # Set up the parser's usage callbacks
  PA_add_usage_callback "" "MA_usage"
}

# Initialise _MA
_MA_new "$@" || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
if [ "$0" = "${BASH_SOURCE[0]}" ] || [ -z "${BASH_SOURCE[0]}" ]; then
  MA_main "$@"
fi
