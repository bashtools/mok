#!/usr/bin/env bash
# shellcheck shell=bash disable=SC2148

__check_os() {
  local majorversion system_ok=1 install_bash=0 install_coreutils=0 install_gawk=0
  local install_podman=0 install_sed=0 __mokostype=linux

  if [[ -d /System/Library/CoreServices ]]; then
    [[ -e /opt/homebrew/bin/bash ]] && eval "$(/opt/homebrew/bin/brew shellenv)"
    # We're on macOS, check for a recent Bash
    if command -v bash &>/dev/null; then
      majorversion=$(bash --version | head -n 1 | sed 's/^.*version \([0-9]*\).*/\1/')
    else
      echo "No version of Bash was found which is strange. Aborting."
      exit 1
    fi
    if [[ ${majorversion} -lt 5 ]]; then
      install_bash=1
      system_ok=0
    fi
    if ! command -v tac &>/dev/null; then
      install_coreutils=1
      system_ok=0
    fi
    if ! command -v gawk &>/dev/null; then
      install_gawk=1
      system_ok=0
    fi
    if ! command -v gsed &>/dev/null; then
      install_sed=1
      system_ok=0
    fi
    if ! command -v podman &>/dev/null; then
      install_podman=1
      system_ok=0
    fi

    if [[ ${system_ok} -eq 0 ]]; then
      echo "Your system requires some extra packages to be installed."
      echo "This script can install them for you."
      echo
      read -r -p 'Install extra packages? (y/N) ' ans
      if [[ ${ans} == "y" ]]; then
        if ! command -v brew &>/dev/null; then
          echo 'Homebrew is required to install extra packages.'
          echo 'You can install this yourself by following the instructions at https://brew.sh'
          echo
          read -r -p 'Should I install Homebrew now? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            # Install Homebrew
            echo -n "Installing Homebrew, with:"
            echo " /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
            echo
            /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            retval=$?
            if [[ retval -ne 0 ]]; then
              echo "Homebrew install failed."
              echo "Please try to install Homebrew manually using the above commmand."
              exit 1
            fi
            if [[ ! -e /opt/homebrew/bin/brew ]]; then
              echo "Homebrew did not seem install to /opt/homebrew."
              echo "Mok expects 'brew' to be in /opt/homebrew/bin/brew but it's not there."
              echo "Cannot continue. Please report this issue on GitHub."
              exit 1
            fi
            eval "$(/opt/homebrew/bin/brew shellenv)"
          else
            echo "Aborting due to missing 'Homebrew'."
            exit 1
          fi
        fi
        if [[ ! -e /opt/homebrew/bin/brew ]]; then
          echo "Mok expects 'brew' to be in /opt/homebrew/bin/brew but it's not there."
          echo "Cannot continue. Please report this issue on GitHub."
          exit 1
        fi
        eval "$(/opt/homebrew/bin/brew shellenv)"
        if [[ ${install_bash} -eq 1 ]]; then
          read -r -p 'Bash 5 is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install bash
          else
            echo "Aborting due to missing 'Bash 5'."
            exit 1
          fi
        fi
        if [[ ${install_coreutils} -eq 1 ]]; then
          read -r -p 'Coreutils is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install coreutils
          else
            echo "Aborting due to missing 'coreutils'."
            exit 1
          fi
        fi
        if [[ ${install_gawk} -eq 1 ]]; then
          read -r -p 'Gawk is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install gawk
          else
            echo "Aborting due to missing 'gawk'."
            exit 1
          fi
        fi
        if [[ ${install_sed} -eq 1 ]]; then
          read -r -p 'GNU-Sed is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install gnu-sed
          else
            echo "Aborting due to missing 'sed'."
            exit 1
          fi
        fi
        if [[ ${install_podman} -eq 1 ]]; then
          read -r -p 'Podman is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install podman
          else
            echo "Aborting due to missing 'podman'."
            exit 1
          fi
        fi
      else
        echo "Aborting due to missing packages."
        exit 1
      fi
    fi
  fi
}

[[ __homebrew -ne 1 ]] && __check_os

[[ -d /System/Library/CoreServices && -e /opt/homebrew/bin/bash && __homebrew -ne 1 ]] && {
  eval "$(/opt/homebrew/bin/brew shellenv)"
  export __mokostype=macos
  export __homebrew=1
  sed() {
    gsed "$@"
  }
  export -f sed
  exec bash "$0" "$@"
}

__mokostype="${__mokostype:-linux}"
# shellcheck shell=bash disable=SC2148
# PA - PArser

# _PA holds data specific to parsing the command line arguments.
declare -A _PA

# Declare externally defined variables ----------------------------------------

# Defined in ER (globals.sh)
declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# PA_command getter outputs the _PA[command] array member. This contains the
# command the user requested.
PA_command() {
  printf '%s' "${_PA[command]}"
}

# PA_subcommand getter outputs the _PA[subcommand] array member. This contains
# the subcommand the user requested.
PA_subcommand() {
  printf '%s' "${_PA[subcommand]}"
}

# PA_shift outputs the _PA[shift] array member, returned by the caller
# when an extra shift is required whilst consuming option values.
#
# Example code:
# ```
#XX_process_options_callback() {
#
#  case "$1" in
#  -h | --help)
#    CC_usage
#    return "${STOP}"
#    ;;
#    ... omitted ...
#  --k8sver)
#    _CC[k8sver]="$2"
#    return "$(PA_shift)"
#    ;;
#  --with-lb)
#    ... omitted ..
# ```
PA_shift() {
  printf '%s' "${_PA[shift]}"
}

# PA_set_state setter sets the initial state of the parser, which should be one
# of COMMAND, SUBCOMMAND, or ARG1.
# Args: arg1 - the initial state to set.
PA_set_state() {
  _PA[state]="$1"
}

# Public Functions ------------------------------------------------------------

# PA_add_option_callback adds a callback to the list of callbacks used for
# processing options.
# Args: arg1 - Null string (for global options), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_option_callback() {
  _PA[optscallbacks]+="$1,$2 "
}

# PA_add_usage_callback adds a callback to the list of callbacks used for
# output of help text.
# Args: arg1 - Null string (for global help), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_usage_callback() {
  _PA[usagecallbacks]+="$1,$2 "
}

# PA_add_state adds a callback to the list of callbacks used for
# programming the state machine.
# Args: arg1 - Current state to match.
#       arg2 - The value of the state to match.
#       arg3 - The new state if arg1 and arg2 match.
#       arg4 - The function to call, optional.
PA_add_state() {
  _PA[statecallbacks]+="$1,$2,$3,$4 "
}

# PA_add_run_callback adds a callback to the list of callbacks used for
# running the user defined entrypoint function.
# Args: arg1 - The value of the state to match. Probably like:
#              "commandsubcommand" "function"
#       arg2 - The function to call.
PA_add_run_callback() {
  _PA[runcallbacks]+="$1,$2 "
}

# PA_run implements an interleaved state machine to process the
# user request. It allows for strict checking of arguments and args. All
# command line arguments are processed in order from left to right.
#
# Each COMMAND can have a different set of requirements which are controlled
# by setting the next state at each transition.
#
# --global-options COMMAND --command-options SUBCOMMAND --subcommand-options \
#  ARG1 --subcommand-options ARG2 --subcommand-options ...
#
# --global-options are those before COMMAND.
# --command-options can be after the COMMAND but before SUBCOMMAND.
# --subcommand-options can be anywhere after the SUBCOMMAND.
#
# Args: arg1-N - The arguments given to mok by the user on the command line
PA_run() {

  local retval=${OK}

  set -- "$@"
  local ARGN=$# ARGNUM=0 retval=0
  while [ "${ARGN}" -ne 0 ]; do
    case "$1" in
    --* | -*)
      _PA_process_option "$1" "$2" || {
        retval=$?
        if [[ ${retval} == "${_PA[shift]}" ]]; then
          ARGN=$((ARGN - 1))
          shift
        else
          return "${retval}"
        fi
      }
      ;;
    *)
      case "${_PA[state]}" in
      COMMAND)
        _PA_check_token "${1}" "COMMAND" "command"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid COMMAND, "%s".\n\n' "$1" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      SUBCOMMAND)
        _PA_check_token "$1" "SUBCOMMAND" "subcommand"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid SUBCOMMAND for %s, "%s".\n\n' "${_PA[command]}" "${1}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      ARG*)
        ((ARGNUM++))
        _PA_check_token "${1}" "ARG${ARGNUM}"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid ARG1 for %s %s, "%s".\n\n' "${_PA[command]}" \
            "${_PA[subcommand]}" "${1}" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      END)
        PA_usage
        printf 'ERROR No more args expected, "%s" is unexpected for "%s %s"\n' \
          "${1}" "${_PA[command]}" "${_PA[subcommand]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      *)
        printf 'Internal ERROR. Invalid state "%s"\n' "${_PA[state]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      esac
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done

  # Run the user defined entrypoint function:
  for item in ${_PA[runcallbacks]}; do
    IFS=, read -r stateval func <<<"${item}"
    [[ ${stateval} == "${_PA[command]}${_PA[subcommand]}" ]] && {
      eval "${func}" || retval=$?
      return "${retval}"
    }
  done

  PA_usage

  return "${OK}"
}

# PA_usage outputs help text for a single component if help was asked for when
# a command was specified, or for all components otherwise.
# Args: None expected.
PA_usage() {

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[usagecallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func}"
      return
    }
  done

  eval "${_PA[usage]}"
}

# Private Functions -----------------------------------------------------------

# PA_new sets the initial values for the PArser's associative array.
# Args: None expected.
_PA_new() {
  _PA[command]=
  _PA[subcommand]=
  _PA[state]="COMMAND"
  _PA[optscallbacks]=
  _PA[usagecallbacks]=
  _PA[statecallbacks]=
  _PA[runcallbacks]=
  # The return value if the caller asked for an extra shift:
  _PA[shift]=126
}

# _PA_check_token checks for a valid token in arg2 state. The logic is
# most easily understood by reading the full original version at:
# https://github.com/mclarkson/my-own-kind/blob/master/docs/package.md#scripted-cluster-creation-and-deletion
# This function is a reduction of all the check_xxx_token functions.
# Args: arg1 - the token to check.
#       arg2 - the current state.
#       arg3 - the state value to set, optional. This should only be sent
#              for command and subcommand states.
_PA_check_token() {

  local item

  if [[ -n ${_PA[subcommand]} ]]; then
    cmdsubcommand="${_PA[command]}${_PA[subcommand]}"
  elif [[ -n ${_PA[command]} && ${_PA[state]} != "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}$1"
  elif [[ -n ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}"
  elif [[ -z ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand=
  else
    cmdsubcommand="$1"
  fi

  for item in ${_PA[statecallbacks]}; do
    IFS=, read -r state component newstate func <<<"${item}"
    [[ ${state} == "$2" ]] && {
      [[ ${component} == "${cmdsubcommand}" ]] && {
        [[ -n $3 ]] && _PA["$3"]="$1"
        _PA[state]="${newstate}"
        [[ -n ${func} ]] && {
          eval "${func} $1" || return
        }
        return "${OK}"
      }
    }
  done
}

# _PA_process_option checks that the user-provided option is valid for the
# command-subcommand or global states.
# Args: arg1 - The option to check.
#       arg2 - TODO The value of the option if present, optional.
_PA_process_option() {

  local item curcmdsubcmd

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[optscallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func} \"$1\" \"$2\""
      return $?
    }
  done

  return "${ERROR}"
}

# Initialise _PA
_PA_new

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GL - Globals

# Private Functions -----------------------------------------------------------

# GL_new sets the only global variables that should be in use anywhere.  The
# only other globals are the associative arrays. All the globals are constant
# (readonly) variables. Declare these globals, where needed, in other files
# so that shellcheck passes.
# Args: None expected.
_GL_new() {

  declare -rg MOKVERSION="0.8.25"
  declare -rg K8SVERSION="1.32.1"
  declare -rg GO_VERSION="1.23.4"

  # Returns, exit codes
  declare -rg OK=0
  declare -rg SUCCESS=0
  declare -rg ERROR=1
  declare -rg FAILURE=1

  # For setting flags
  declare -rg TRUE=1
  declare -rg FALSE=0

  # To signal main() to exit with SUCCESS in the PArser
  declare -rg STOP=2

  declare -rg STDOUT="/dev/stdout"
  declare -rg STDERR="/dev/stderr"

  # The following just keep shellcheck happy
  local dummy dumb
  dummy="${OK}"
  dummy="${ERROR}"
  dummy="${STOP}"
  dummy="${STDOUT}"
  dummy="${STDERR}"
  dummy="${TRUE}"
  dummy="${FALSE}"
  dummy="${SUCCESS}"
  dummy="${FAILURE}"
  dummy="${MOKVERSION}"
  dummy="${GO_VERSION}"
  dummy="${K8SVERSION}"
  dumb="${dummy}${dumb}"
}

# Initialise GL
_GL_new || exit 1

# vim helpers -----------------------------------------------------------------

# The following lines allow the use of '[C-i' and '[I' (do ':help [I') in vim.
#include buildimage.sh
#include containerutils.sh
#include createcluster.sh
#include deletecluster.sh
#include embed-dockerfile.sh
#include error.sh
#include exec.sh
#include getcluster.sh
#include main.sh
#include lib/parser.sh
#include util.sh
#include versions.sh

# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# ER - Error handling

# ER is an associative array that holds data specific to error handling.
declare -A ER

# Declare externally defined associative arrays -------------------------------

# Defined in GL (globals.sh)
declare ERROR TRUE STDERR

# Public Functions ------------------------------------------------------------

# ER_err outputs a stacktrace and returns ERROR status.
# Args: None expected.
ER_err() {

  # In case of error print the function call stack
  # No args expected

  [[ ${ER[errcalled]} == "${TRUE}" ]] && return "${ERROR}"
  ER[errcalled]="${TRUE}"
  local frame=0
  printf '\n' >"${STDERR}"
  while caller "${frame}"; do
    ((frame++))
  done | tac >"${STDERR}"
  printf '\n' >"${STDERR}"
  return "${ERROR}"
}

# err is a synonym for ER_err to aid with code readability.
err() {
  ER_err
  return
}

# Private Functions -----------------------------------------------------------

# ER_new sets the initial values for the ER associative array.
# Args: None expected.
_ER_new() {
  ER[errcalled]=
}

# Initialise ER
_ER_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# UT - Utilities

# _UT is an associative array that holds data specific to general utilities.
declare -A _UT

# Declare externally defined global variables ---------------------------------

declare OK STDERR FALSE TRUE

# Getters/Setters -------------------------------------------------------------

# UT_runlogfile getter outputs the value of _UT[runlogfile], which contains the
# name of the file written to when running UT_run_with_progress.
UT_runlogfile() {
  printf '%s' "${_UT[runlogfile]}"
}

# UT_tailf getter indicates whether a log will be shown in real-time during the
# 'run', TRUE, or not, FALSE.
# Args
UT_tailf() {
  printf '%s' "${_UT[tailf]}"
}

# UT_tailf setter indicates whether a log should be shown during the 'run',
# TRUE, or not, FALSE.
# Args: arg1 - Whether to tail, TRUE or FALSE.
UT_set_tailf() {
  _UT[tailf]="$1"
}

# UT_set_plain setter sets plain output, with no colour, animations, or UTF
# high byte characters.
# Args: arg1 - Whether to show plain output, TRUE or FALSE.
UT_set_plain() {
  _UT[plain]="$1"
  UT_disable_colours
}

# Public Functions ------------------------------------------------------------

# UT_disable_colours resets variables used for colourised output so that they
# contain no colour terminal escapes. Useful if stdin is not a terminal.
UT_disable_colours() {
  _UT[yellow]=
  _UT[green]=
  _UT[red]=
  _UT[normal]=
  _UT[probablysuccess]="!"
  _UT[success]="✓"
  _UT[failure]="✕"
}

# UT_run_with_progress displays a progress spinner, item text, and a tick or
# cross based on the exit code.
# Args: arg1   - the text to display.
#       arg2-N - remaining args are the program to run and its arguments.
UT_run_with_progress() {

  local displaytext=$1 retval int spinner=()

  _UT[runlogfile]=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }
  shift

  if [[ ${_UT[tailf]} == "${FALSE}" && ${_UT[plain]} == "${TRUE}" ]]; then

    # Output with no colours or spinny

    printf '%s' "${displaytext}"

    eval "$*" &>"${_UT[runlogfile]}"
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 0 ]]; then
      printf ' .. %s\n' "${_UT[success]}"
    else
      printf ' .. %s\n' "${_UT[failure]}"
    fi

  elif [[ ${_UT[tailf]} == "${FALSE}" ]]; then

    # Output with colours and spinny

    while read -r char; do
      spinner+=("${char}")
    done <<<"$(grep -o . <<<"${_UT[spinnerchars]}")"

    (
      eval "$*" &>"${_UT[runlogfile]}"
    ) &

    # Turn the cursor off
    tput civis

    # Start the spin animation
    printf ' %s' "${displaytext}"
    (while true; do
      for int in {0..3}; do
        printf '\r  %s ' "${spinner[int]}"
        sleep .1
      done
    done) &
    _UT[spinnerpid]=$!
    disown

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Kill the spinner
    kill "${_UT[spinnerpid]}" 2>/dev/null
    _UT[spinnerpid]=

    sleep .5

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\r  %s\n' "${_UT[probablysuccess]}"
    elif [[ ${retval} -eq 0 ]]; then
      printf '\r  %s\n' "${_UT[success]}"
    else
      printf '\r  %s\n' "${_UT[failure]}"
    fi

    # Restore the cursor
    tput cnorm
    sleep .5

  else

    # Tailf output

    printf 'COMMAND: %s\n\n' "$*"

    (
      eval "$*" &>/dev/stdout
    ) &
    sleep 1

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\n\nSTATUS: OK - (Probably)\n\n'
    elif [[ ${retval} -eq 0 ]]; then
      printf '\n\nSTATUS: OK\n\n'
    else
      printf '\n\nSTATUS: FAIL\n\n'
    fi
  fi

  return "${retval}"
}

# UT_cleanup removes any artifacts that were created during execution.
# This is called by 'MA_cleanup' trap only.
UT_cleanup() {

  # Called when the script exits.

  local int

  # Kill the spinny, and anything else, if they're running
  if [[ ${_UT[tailf]} == "${FALSE}" ]]; then
    [[ -n ${_UT[spinnerpid]} ]] && {
      printf '%s\r  ✕%s\n' "${_UT[red]}" "${_UT[normal]}"
      kill "${_UT[spinnerpid]}"
    }
    # If progress spinner crashed make sure the cursor is shown
    [ -t 1 ] && tput cnorm
  else
    kill "${_UT[spinnerpid]}" &>/dev/null
  fi

  return "${OK}"
}

# UT_sed_json_block returns the value of the query_key between
# block_start_key:block_start_val and block_end_key.
# Args:
#  Arg 1: data
#  Arg 2: block_start_key
#  Arg 3: block_start_val
#  Arg 4: block_end_key
#  Arg 5: query_key
UT_sed_json_block() {
  local data block_start_key block_start_val block_end_key query_key
  data="$1"
  block_start_key="$2"
  block_start_val="$3"
  block_end_key="$4"
  query_key="$5"
  echo "$data" | sed -rn \
    '/'"${block_start_key}"'.*'"${block_start_val}"'/,/'"${block_end_key}"'/ { s/^ *"'"${query_key}"'": *//p }' \
    | tr -d ',"'
}

# Private Functions -----------------------------------------------------------

# _UT_new sets the initial values for the _UT associative array.
# Args: None expected.
_UT_new() {
  _UT[tailf]="${FALSE}"
  _UT[yellow]=$(tput setaf 3)
  _UT[green]=$(tput setaf 2)
  _UT[red]=$(tput setaf 1)
  _UT[normal]=$(tput sgr0)
  _UT[probablysuccess]="${_UT[yellow]}✓${_UT[normal]}"
  _UT[success]="${_UT[green]}✓${_UT[normal]}"
  _UT[failure]="${_UT[red]}✕${_UT[normal]}"
  _UT[runlogfile]=
  _UT[spinnerchars]="|/-\\"
  _UT[spinnerpid]=
}

# Initialise _UT
_UT_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GC - Get Cluster

# _GC is an associative array that holds data specific to the get cluster command.
declare -A _GC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# GC_showheader getter outputs the value of the showheader array member.
GC_showheader() {
  printf '%s' "${_GC[showheader]}"
}

# GC_set_showheader setter sets the value of the showheader array member.
# If $TRUE the header will be shown, or $FALSE, then it won't be shown.
GC_set_showheader() {
  _GC[showheader]="$1"
}

# GC_set_clustername setter sets the cluster name to show information about.
GC_set_clustername() {
  _GC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# GC_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted. It is called by
# MA_cleanup.
GC_cleanup() {
  :
}

# GC_process_options checks if arg1 is in a list of valid get cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
GC_process_options() {

  case "$1" in
  -h | --help)
    GC_usage
    return "${STOP}"
    ;;
  *)
    GC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# GC_usage outputs help text for the create cluster component.
# It is called by PA_usage().
# Args: None expected.
GC_usage() {

  cat <<'EnD'
GET subcommands are:
 
  cluster[s] - list all mok managed clusters.
 
get cluster[s] options:
 
 Format:
  get cluster(s) [NAME]
  NAME        - (optional) The name of the cluster to get
                details about.

EnD
}

# GC_run gets information about cluster(s).
# This function is called in main.sh.
# Args: None expected.
GC_run() {

  _GC_sanity_checks || return

  local ids id info output labelkey
  local containerhostname containerip

  declare -a nodes

  ids=$(CU_get_cluster_container_ids "${_GC[clustername]}") || return

  if [[ -z ${ids} ]]; then
    printf 'No clusters found\n'
    return "${OK}"
  fi

  readarray -t nodes <<<"${ids}"

  # Use 'docker inspect' to get the value of the label $LABELKEY

  output=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  # Output the header
  [[ ${_GC[showheader]} -eq ${TRUE} ]] && {
    printf 'MOK_Cluster Docker_ID Container_Name IP_Address\n' >"${output}"
  }

  labelkey=$(CU_labelkey) || err || return

  for id in "${nodes[@]}"; do

    info=$(CU_get_container_info "${id}") || return

    clustname=$(JSONPath ".[0].Config.Labels.${labelkey}" -b <<<"${info}") ||
      err || return

    containerhostname=$(JSONPath '.[0].Config.Hostname' -b <<<"${info}") ||
      err || return

    containerip=$(JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}") ||
      err || return

    printf '%s %s %s %s\n' "${clustname}" "${id}" "${containerhostname}" "${containerip}"

  done | sort -k 3 >>"${output}"

  column -t "${output}" || err
}

# Private Functions -----------------------------------------------------------

# _GC_new sets the initial values for the _GC associative array.
# Args: None expected.
_GC_new() {
  _GC[showheader]="${TRUE}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "get" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "getcluster" "ARG1" ""
  PA_add_state "SUBCOMMAND" "getclusters" "ARG1" ""
  PA_add_state "ARG1" "getcluster" "END" "GC_set_clustername"
  PA_add_state "ARG1" "getclusters" "END" "GC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "get" "GC_process_options" || return
  PA_add_option_callback "getcluster" "GC_process_options" || return
  PA_add_option_callback "getclusters" "GC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "get" "GC_usage" || return
  PA_add_usage_callback "getcluster" "GC_usage" || return
  PA_add_usage_callback "getclusters" "GC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "getcluster" "GC_run"
  PA_add_run_callback "getclusters" "GC_run"
}

# GC_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_GC_sanity_checks() {

  # Only show the usage if we are in 'get' mode and have not specified a
  # subcommand. This allows internal code to call GC_run()
  if [[ $(PA_command) == "get" && -z $(PA_subcommand) ]]; then
    GC_usage
    exit "${OK}"
  fi
}

# Initialise _GC
_GC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# MU - Machine Utilities for Podman

# _MU is an associative array that holds data specific to machine utils.
declare -A _MU

# Declare externally defined variables ----------------------------------------

declare ERROR STDERR STOP

# Getters/Setters -------------------------------------------------------------

# Public Functions ------------------------------------------------------------

# MU_cleanup removes artifacts that were created during execution. This function
# is run automatically by the Parser library. Currently this does nothing and
# this function could be deleted.
MU_cleanup() { :; }

# MU_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_process_options() {
  case "$1" in
  -h | --help)
    MU_usage
    return "${STOP}"
    ;;
  *)
    MU_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_usage() {

  cat <<'EnD'
MACHINE subcommands are:
 
  list    - List the currently created Podman machines. Only one machine
            is currently supported and it will be named 'mok-machine'.
  create  - Create a Podman machine named 'mok-machine'. This will also
            setup the Podman machine to run Kubernetes so there is no
            need to run 'machine setup'.
  destroy - Completely removes the Podman machine named 'mok-machine'.
  start   - Start the Podman machine named 'mok-machine'.
  stop    - Stop the Podman machine named 'mok-machine'.
  setup   - Apply the correct settings to the Podman machine to run
            Kubernetes.
 
For more information:

  machine list -h
  machine create -h
  machine destroy -h
  machine start -h
  machine stop -h
  machine setup -h
 
EnD
}

# Private Functions -----------------------------------------------------------

# _MU_new sets the initial values for the Machine Utils associative array and
# sets up the Parser to call functions in machine*.sh files.
# Args: None expected.
_MU_new() {
  # Program the parser's state machine
  PA_add_state "COMMAND" "machine" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "machinelist" "END" ""
  PA_add_state "SUBCOMMAND" "machinecreate" "END" ""
  PA_add_state "SUBCOMMAND" "machinedestroy" "END" ""
  PA_add_state "SUBCOMMAND" "machinesetup" "END" ""
  PA_add_state "SUBCOMMAND" "machinestart" "END" ""
  PA_add_state "SUBCOMMAND" "machinestop" "END" ""

  # Set up the parser's option callbacks
  PA_add_option_callback "machine" "MU_process_options" || return
  PA_add_option_callback "machinelist" "MU_list_process_options" || return
  PA_add_option_callback "machinecreate" "MU_create_process_options" || return
  PA_add_option_callback "machinedestroy" "MU_destroy_process_options" || return
  PA_add_option_callback "machinesetup" "MU_setup_process_options" || return
  PA_add_option_callback "machinestart" "MU_start_process_options" || return
  PA_add_option_callback "machinestop" "MU_stop_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "machine" "MU_usage" || return
  PA_add_usage_callback "machinelist" "MU_list_usage" || return
  PA_add_usage_callback "machinecreate" "MU_create_usage" || return
  PA_add_usage_callback "machinedestroy" "MU_destroy_usage" || return
  PA_add_usage_callback "machinesetup" "MU_setup_usage" || return
  PA_add_usage_callback "machinestart" "MU_start_usage" || return
  PA_add_usage_callback "machinestop" "MU_stop_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "machinelist" "MU_list_run"
  PA_add_run_callback "machinecreate" "MU_create_run"
  PA_add_run_callback "machinedestroy" "MU_destroy_run"
  PA_add_run_callback "machinesetup" "MU_setup_run"
  PA_add_run_callback "machinestart" "MU_start_run"
  PA_add_run_callback "machinestop" "MU_stop_run"
}

# Initialise _MU
_MU_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148

# MACHINE STOP ================================================================

# MU_stop_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_stop_process_options() {
  case "$1" in
  -h | --help)
    MU_stop_usage
    return "${STOP}"
    ;;
  *)
    MU_stop_usage
    printf 'ERROR: "%s" is not a valid "stop" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_stop_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_stop_usage() {

  cat <<EnD
machine stop options:
 
 Format:
  machine stop [flags]
 
 Flags:
  -h - This help text.

 Description:
  This will stop a Podman machine named 'mok-machine'.
  Stop the podman machine with: $(MA_program_name) machine stop
EnD
}

# MU_stop_run lists Podman machines.
# Args: None expected.
MU_stop_run() {
  UT_run_with_progress \
    "    Stopping Podman machine: mok-machine" \
    podman machine stop mok-machine
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}


# shellcheck shell=bash disable=SC2148

# MACHINE START ===============================================================

# MU_start_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_start_process_options() {
  case "$1" in
  -h | --help)
    MU_start_usage
    return "${STOP}"
    ;;
  -v | --verbose)
    UT_set_tailf "${TRUE}" || err || return
    ;;
  *)
    MU_start_usage
    printf 'ERROR: "%s" is not a valid "start" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_start_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_start_usage() {

  cat <<EnD
machine start options:
 
 Format:
  machine start [flags]
 
 Flags:
  -h, --help - This help text.
  -v, --verbose - Verbose output. Useful if there was a problem.

 Description:
  This will start a Podman machine named 'mok-machine'.
  Start the podman machine with: $(MA_program_name) machine start
EnD
}

# MU_start_run lists Podman machines.
# Args: None expected.
MU_start_run() {
  UT_run_with_progress \
    "    Starting Podman machine: mok-machine" \
    podman machine start mok-machine
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}

# shellcheck shell=bash disable=SC2148

# MACHINE CREATE ==============================================================

# MU_create_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_create_process_options() {
  case "$1" in
  -h | --help)
    MU_create_usage
    return "${STOP}"
    ;;
  -v | --verbose)
    UT_set_tailf "${TRUE}" || err || return
    ;;
  *)
    MU_create_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_create_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_create_usage() {

  cat <<EnD
machine create options:
 
 Format:
  machine create [flags]
 
 Flags:
  -h, --help - This help text.
  -v, --verbose - Verbose output. Useful if there was a problem.

 Description:
  This will create a Podman machine named 'mok-machine' and setup the
  machine to run Kubernetes.
EnD
}

# MU_create_run lists Podman machines.
# Args: None expected.
MU_create_run() {
  UT_run_with_progress \
    "    Creating the Podman machine: mok-machine" \
    podman machine init --now --rootful --user-mode-networking mok-machine
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Loading module in mok-machine" \
    podman machine ssh --username root mok-machine modprobe nf_conntrack
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Persisting nf_conntrack module in mok-machine" \
    podman machine ssh --username root mok-machine \
      bash -c \
      "\"\\\"echo nf_conntrack \
      >/etc/modules-load.d/nf_conntrack.conf\\\"\""
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Setting nf_conntrack_max in mok-machine" \
    podman machine ssh --username root mok-machine sysctl -q \
      -w net.netfilter.nf_conntrack_max=163840
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Persisting nf_conntrack_max in mok-machine" \
    podman machine ssh --username root mok-machine \
      bash -c \
      "\"\\\"echo net.netfilter.nf_conntrack_max=163840 \
      >/etc/sysctl.d/99-nf_conntrack_max.conf\\\"\""
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}

# shellcheck shell=bash disable=SC2148

# MACHINE LIST ================================================================

# MU_list_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_list_process_options() {
  case "$1" in
  -h | --help)
    MU_list_usage
    return "${STOP}"
    ;;
  *)
    MU_list_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_list_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_list_usage() {

  cat <<'EnD'
machine list options:
 
 Format:
  machine list [flags]
 
 Flags:
  -h - This help text.

EnD
}

# MU_list_run lists Podman machines.
# Args: None expected.
MU_list_run() {
  info=$(podman machine list --format json) || err || return

  running=$(UT_sed_json_block "${info}" \
    'Name' 'mok-machine' '}' \
    'Running' \
    ) || err || return

  exists=$(UT_sed_json_block "${info}" \
    'Name' 'mok-machine' '}' \
    'Name' \
    ) || err || return

  if [[ ${exists} != "mok-machine" ]]; then
    printf 'mok-machine: does not exist.\n'
  else
    if [[ ${running} == "true" ]]; then
      printf 'mok-machine: running.\n'
    else
      printf 'mok-machine: stopped.\n'
    fi
  fi
}

# shellcheck shell=bash disable=SC2148

# MACHINE DESTROY ==============================================================

# MU_destroy_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_destroy_process_options() {
  case "$1" in
  -h | --help)
    MU_destroy_usage
    return "${STOP}"
    ;;
  -v | --verbose)
    UT_set_tailf "${TRUE}" || err || return
    ;;
  *)
    MU_destroy_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_destroy_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_destroy_usage() {

  cat <<'EnD'
machine destroy options:
 
 Format:
  machine destroy [flags]
 
 Flags:
  -h, --help - This help text.
  -v, --verbose - Verbose output. Useful if there was a problem.

 Description:
  This will completely remove a Podman machine named 'mok-machine'.
  A machine must be stopped before it can be destroyed.

EnD
}

# MU_destroy_run deletes a Podman machine.
# Args: None expected.
MU_destroy_run() {
  printf 'This will completely remove the podman machine named "mok-machine"\n'
  printf "Are you sure you want to destroy the machine? (y/N) >"
  read -r ans
  [[ ${ans} != "y" ]] && {
    printf 'Cancelling by user request.\n'
    return "${OK}"
  }
  UT_run_with_progress \
    "    Deleting the Podman machine: mok-machine" \
    podman machine rm -f mok-machine
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}

# shellcheck shell=bash disable=SC2148

# MACHINE SETUP ===============================================================

# MU_setup_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_setup_process_options() {
  case "$1" in
  -h | --help)
    MU_setup_usage
    return "${STOP}"
    ;;
  -v | --verbose)
    UT_set_tailf "${TRUE}" || err || return
    ;;
  *)
    MU_setup_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}


# MU_setup_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_setup_usage() {

  cat <<'EnD'
machine setup options:
 
 Format:
  machine setup [flags]
 
 Flags:
  -h, --help - This help text.
  -v, --verbose - Verbose output. Useful if there was a problem.

EnD
}

# MU_setup_run sets up a Podman machine.
# Args: None expected.
MU_setup_run() {
  UT_run_with_progress \
    "    Loading module in mok-machine" \
    podman machine ssh --username root mok-machine modprobe nf_conntrack
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Persisting nf_conntrack module in mok-machine" \
    podman machine ssh --username root mok-machine \
      bash -c \
      "\"\\\"echo nf_conntrack \
      >/etc/modules-load.d/nf_conntrack.conf\\\"\""
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Setting nf_conntrack_max in mok-machine" \
    podman machine ssh --username root mok-machine sysctl -q \
      -w net.netfilter.nf_conntrack_max=163840
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Persisting nf_conntrack_max in mok-machine" \
    podman machine ssh --username root mok-machine \
      bash -c \
      "\"\\\"echo net.netfilter.nf_conntrack_max=163840 \
      >/etc/sysctl.d/99-nf_conntrack_max.conf\\\"\""
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}

# shellcheck shell=bash disable=SC2148
# EX - EXec

# EX is an associative array that holds data specific to the exec cluster command.
declare -A _EX

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# EX_set_containername setter sets the containername to be used to 'log in' to.
EX_set_containername() {
  _EX[containername]="$1"
}

# Public Functions ------------------------------------------------------------

# EX_process_options checks if arg1 is in a list of valid exec options. This
# function is called by the parser, via a callback in _EX_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
EX_process_options() {

  case "$1" in
  -h | --help)
    EX_usage
    return "${STOP}"
    ;;
  *)
    EX_usage
    printf 'ERROR: "%s" is not a valid "exec" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# EX_usage outputs help text for the create exec component.  It is called in
# this file and by PA_usage(), via a callback in _EX_new.
# Args: None expected.
EX_usage() {

  cat <<'EnD'
'Log in' to a container. EXEC has no subcommands.
 
exec options:
 
 Format:
  exec [NAME]
  NAME        - (optional) The name of the container to 'log in' to.
                If NAME is not given then the user will be offered
                a choice of containers to log in to. If there is only
                one cluster and one node then it will 'log in' to the
                only available container.

EnD
}

# Execs 'bash' in the container referenced by _EX[containername]. If just
# 'mok exec' is called without options then the user is offered a selection
# of existing clusters to exec into.
# Args: None expected.
# ---------------------------------------------------------------------------
EX_run() {

  _EX_sanity_checks || return

  local names int ans lines containernames gcoutput

  GC_set_showheader "${TRUE}" || err || return
  gcoutput=$(GC_run) || return
  names=$(printf '%s' "${gcoutput}" | awk '{ print $3; }')
  readarray -t containernames <<<"${names}"

  if [[ -n ${_EX[containername]} ]]; then

    # The caller gave a specific name for exec.
    # Check if the container name exists

    if grep -qs "^${_EX[containername]}$" <<<"${names}"; then
      _EX_exec "${_EX[containername]}" || return
      return "${OK}"
    else
      printf 'ERROR: Cannot exec into non-existent container: "%s".\n' \
        "${_EX[containername]}"
      return "${ERROR}"
    fi

  elif [[ ${#containernames[*]} == 2 ]]; then

    # If there's only one container just log into it without asking
    _EX_exec "${containernames[1]}"

  elif [[ ${#containernames[*]} == 1 ]]; then

    printf 'No containers found.\n'
    return "${OK}"

  else

    # The caller supplied no container name.
    # Present some choices

    printf 'Choose the container to log in to:\n\n'

    readarray -t lines <<<"${gcoutput}" || return

    # Print the header then print the items in the loop
    printf '   %s\n' "${lines[0]}"
    for int in $(seq 1 $((${#lines[*]} - 1))); do
      printf '%00d) %s\n' "${int}" "${lines[int]}"
    done | sort -k 4

    printf "\nChoose a number (Enter to cancel)> "
    read -r ans

    [[ -z ${ans} || ${ans} -lt 0 || ${ans} -gt $((${#lines[*]} - 1)) ]] && {
      printf '\nInvalid choice. Aborting.\n'
      return "${OK}"
    }

    _EX_exec "${containernames[ans]}"
  fi
}

# Private Functions -----------------------------------------------------------

# _EX_new sets the initial values for the _EX associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
_EX_new() {
  _EX[containername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "exec" "ARG1" ""
  PA_add_state "ARG1" "exec" "END" "EX_set_containername"

  # Set up the parser's option callbacks
  PA_add_option_callback "exec" "EX_process_options" || return
  PA_add_usage_callback "exec" "EX_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "exec" "EX_run"
}

# EX_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For exec this does nothing.
# Args: None expected.
_EX_sanity_checks() { :; }

# _EX_exec runs a command in a docker container using bash as the command by
# default.
# Args: arg1 - docker container name
#       arg2 - command to run
_EX_exec() {

  local cmd=${2:-bash} url port

  containerrt=$(CU_containerrt) || err || return
  podmantype=$(CU_podmantype) || err || return

  # TODO: A named podman machine does not work the same way
  #       as the default podman machine. Rootful doesn't work
  #       for a named machine so need to use '--url'. Ask
  #       Podman developers about this.
  port=$(podman machine inspect mok-machine | grep Port | grep -o '[0-9]\+')
  url="ssh://root@127.0.0.1:$port/run/podman/podman.sock"

  read -rt 0.1
  if [[ $containerrt == "podman" && $podmantype == "machine" ]]; then
      # TODO: This would be preferred to '--url'
    # podman -c mok-machine exec -ti "$1" "${cmd}" 
    podman --url "${url}" exec -ti "$1" "${cmd}" 
  elif [[ $containerrt == "podman" ]]; then
    exec podman exec -ti "$1" "${cmd}"
  elif [[ $containerrt == "docker" ]]; then
    exec docker exec -ti "$1" "${cmd}"
  fi
}

# Initialise EX
_EX_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# DC - Delete Cluster

# _DC is an associative array that holds data specific to deleting a cluster.
declare -A _DC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR STOP TRUE

# Getters/Setters -------------------------------------------------------------

# DC_set_clustername setter sets the cluster name to be deleted. This is
# called by the parser, via a callback in _DC_new.
DC_set_clustername() {
  _DC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# DC_process_options checks if arg1 is in a list of valid delete cluster
# options. This function is called by the parser, via a callback in _DC_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
DC_process_options() {

  case "$1" in
  -h | --help)
    DC_usage
    return "${STOP}"
    ;;
  *)
    DC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# DC_usage outputs help text for the create cluster component.
# It is called by PA_usage(), via a callback in _DC_new.
# Args: None expected.
DC_usage() {

  cat <<'EnD'
DELETE subcommands are:
 
  cluster - Delete a local kubernetes cluster.
 
delete cluster options:
 
 Format:
  delete cluster NAME
  NAME        - The name of the cluster to delete

EnD
}

# DC_run starts the delete cluster process.
# Args: None expected.
DC_run() {

  _DC_sanity_checks || return

  # Mutate functions make system changes.

  declare -i numnodes=0
  local id ids r

  numnodes=$(CU_get_cluster_size "${_DC[clustername]}") || return

  [[ ${numnodes} -eq 0 ]] && {
    printf '\nERROR: No cluster exists with name, "%s". Aborting.\n\n' \
      "${_DC[clustername]}" >"${STDERR}"
    return "${ERROR}"
  }

  ids=$(CU_get_cluster_container_ids "${_DC[clustername]}") || return

  printf 'The following containers will be deleted:\n\n'

  GC_set_showheader "${TRUE}"
  GC_set_clustername "${_DC[clustername]}"
  GC_run "${_DC[clustername]}" || return

  printf "\nAre you sure you want to delete the cluster? (y/N) >"

  read -r ans

  [[ ${ans} != "y" ]] && {
    printf '\nCancelling by user request.\n'
    return "${OK}"
  }

  printf '\n'

  for id in ${ids}; do
    UT_run_with_progress \
      "    Deleting id, '${id}' from cluster '${_DC[clustername]}'." \
      _DC_delete "${id}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n\n' >"${STDERR}"
      err
      return "${r}"
    }
  done

  printf '\n'
}

# Private Functions -----------------------------------------------------------

# _DC_new sets the initial values for the _DC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_DC_new() {
  _DC[clustername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "delete" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "deletecluster" "ARG1" ""
  PA_add_state "ARG1" "deletecluster" "END" "DC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "delete" "DC_process_options" || return
  PA_add_option_callback "deletecluster" "DC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "delete" "DC_usage" || return
  PA_add_usage_callback "deletecluster" "DC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "deletecluster" "DC_run"
}

# DC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before DC_run is called.
# Args: None expected.
_DC_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    DC_usage
    exit "${OK}"
  fi

  if [[ -z ${_DC[clustername]} ]]; then
    DC_usage
    printf 'Please provide the Cluster NAME to delete.\n' >"${STDERR}"
    return "${ERROR}"
  fi
}

# _DC_delete stops and removes a docker container.
# Args: arg1 - docker id to delete.
_DC_delete() {

  docker stop -t 5 "${id}"
  docker rm "${id}" || err
}

# Initialise _DC
_DC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE K8SVERSION

# Getters/Setters -------------------------------------------------------------

# CC_set_clustername setter sets the clustername array item.
CC_clustername() {
  printf '%s' "${_CC[clustername]}"
}

# CC_publish getter outputs the publish array item.
CC_publish() {
  printf '%s' "${_CC[publish]}"
}

# CC-withlb getter outputs the withlb array item.
CC_withlb() {
  printf '%s' "${_CC[withlb]}"
}

# CC_set_clustername setter sets the clustername array item.
CC_set_clustername() {
  _CC[clustername]="$1"
}

# CC_set_nummasters setter sets the nummasters array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_nummasters() {
  _CC[nummasters]="$1"
}

# CC_set_numworkers setter sets the numworkers array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_numworkers() {
  _CC[numworkers]="$1"
}

# Public Functions ------------------------------------------------------------

# CC_process_options checks if arg1 is in a list of valid create cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option. For example, '--masters' should be sent
#              with a value but boolean options, like 'skiplbsetup' should not.
CC_process_options() {

  case "$1" in
  -h | --help)
    CC_usage
    return "${STOP}"
    ;;
  --skiplbsetup)
    _CC[skiplbsetup]="${TRUE}"
    return
    ;;
  --k8sver)
    _CC[k8sver]="$2"
    return "$(PA_shift)"
    ;;
  --with-lb)
    _CC[withlb]="${TRUE}"
    return
    ;;
  --skipmastersetup)
    _CC[skipmastersetup]="${TRUE}"
    return
    ;;
  --skipworkersetup)
    _CC[skipworkersetup]="${TRUE}"
    return
    ;;
  --masters)
    _CC[nummasters]="$2"
    return "$(PA_shift)"
    ;;
  --workers)
    _CC[numworkers]="$2"
    return "$(PA_shift)"
    ;;
  --tailf)
    _CC[tailf]="${TRUE}"
    return "${OK}"
    ;;
  --publish)
    _CC[publish]="${TRUE}"
    return
    ;;
  *)
    CC_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# CC_usage outputs help text for the create cluster component.  It is called in
# this file and by PA_usage(), via a callback set in _CC_new.
# Args: None expected.
CC_usage() {

  cat <<'EnD'
CREATE subcommands are:
 
  cluster - Create a local kubernetes cluster.
 
create cluster [flags] options:
 
 Format:
  create cluster NAME [ [NUM_MASTERS] [NUM_WORKERS] ]
  NAME        - The name of the cluster. This will be used as
                the prefix in the name for newly created
                docker containers.
  NUM_MASTERS - The number of master containers.
  NUM_WORKERS - The number of worker containers. If NUM_WORKERS is
                zero then the 'node-role.kubernetes.io/master' taint
                will be removed from master nodes so that pods are
                schedulable.
 
 Flags:
  --skipmastersetup - Create the master container but don't set it
         up. Useful for manually installing kubernetes. Kubeadm, 
         kubelet and kubectl will be installed at the requested 
         version. With this option the worker will also be skipped.
         See also '--k8sver' flag.
  --skipworkersetup - The same as '--skipmastersetup', but skips
         setting up the worker only.
  --with-lb - Add a haproxy load balancer. The software will be installed
         and set up to reverse proxy to the master node(s), unless
         --skiplbsetup is used.
  --k8sver VERSION - The Kubernetes version, e.g. "1.32.0" or "1.32.1".
         A previous version will need to be downloaded first with:
           mok build image --get-prebuilt-image --k8sver VERSION
  --masters NUM - The number of master containers to create.
  --workers NUM - The number of worker containers to create. When workers
                  is zero then the master node taint will be removed from
                  master nodes so that pods are schedulable on those nodes.
  --tailf - Show the log output whilst creating the cluster.
  --publish - Publish port 6443 for the master node, or the load balancer if
              it's enabled, for external kubectl access to the cluster. The IP
              address of the default route interface is added to the cert.

EnD
}

# CC_run creates the kubernetes cluster.
# Args: None expected.
CC_run() {

  _CC_sanity_checks || return

  [[ ${_CC[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  declare -i numnodes=0

  numnodes=$(CU_get_cluster_size "${_CC[clustername]}") || return

  [[ ${numnodes} -gt 0 ]] && {
    printf '\nERROR: Cluster, "%s", exists! Aborting.\n\n' "${_CC[clustername]}" \
      >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_create_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_create_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_setup_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_setup_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[numworkers]} -gt 0 ]] && {
    _CC_create_worker_nodes "${_CC[numworkers]}" || return
  }

  printf '\n'

  [[ -z ${_CC[skipmastersetup]} ]] && {
    printf 'Cluster, "%s", can be accessed using:\n\n' "${_CC[clustername]}"
    printf 'export KUBECONFIG=/var/tmp/admin-%s.conf\n\n' "${_CC[clustername]}"
  }

  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CC_new sets the initial values for the _CC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_CC_new() {
  _CC[tailf]="${FALSE}"
  _CC[skipmastersetup]=
  _CC[skipworkersetup]=
  _CC[skiplbsetup]=
  _CC[withlb]=
  _CC[clustername]=
  _CC[nummasters]=0
  _CC[numworkers]=0
  _CC[publish]=0
  _CC[k8sver]="${K8SVERSION}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "create" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "createcluster" "ARG2" ""

  # Support for the legacy style of create (less to type):
  PA_add_state "ARG1" "createcluster" "ARG2" "CC_set_clustername"
  PA_add_state "ARG2" "createcluster" "ARG3" "CC_set_nummasters"
  PA_add_state "ARG3" "createcluster" "END" "CC_set_numworkers"

  # Set up the parser's option callbacks
  PA_add_option_callback "create" "CC_process_options" || return
  PA_add_option_callback "createcluster" "CC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "create" "CC_usage" || return
  PA_add_usage_callback "createcluster" "CC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "createcluster" "CC_run"
  PA_add_run_callback "createclusters" "CC_run"
}

# CC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before CC_run is called.
# Args: None expected.
_CC_sanity_checks() {

  declare -i host_max=0 cpus=0 should_be=0

  if [[ -z $(PA_subcommand) ]]; then
    CC_usage
    exit "${OK}"
  fi

  if [[ -z ${_CC[clustername]} ]]; then
    CC_usage
    printf 'Please provide the Cluster NAME to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[nummasters]} || ${_CC[nummasters]} -le 0 ]]; then
    CC_usage
    printf 'Please provide the number of Masters to create. Must be 1 or more.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[numworkers]} ]]; then
    CC_usage
    printf 'Please provide the number of Workers to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/sys/net/nf_conntrack_max ]]; then
    host_max=$(cat /proc/sys/net/nf_conntrack_max)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    host_max=$(podman machine ssh mok-machine cat /proc/sys/net/nf_conntrack_max)
  else
    printf '\nWARNING: /proc/sys/net/nf_conntrack_max not found.\n' >"${STDERR}"
    printf '         kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/cpuinfo ]]; then
    cpus=$(grep -cw ^processor /proc/cpuinfo)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    cpus=$(podman machine ssh mok-machine cat /proc/cpuinfo | grep -cw ^processor)
  else
    printf '\nWARNING: /proc/cpuinfo not found.\n' >"${STDERR}"
    printf '         I have no idea how many CPUs I have\n' >"${STDERR}"
    printf '         and kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  # These are the default values that kube-proxy expects:
  # conntrack:
  #   max: null
  #   maxPerCore: 32768
  #   min: 131072
  if [[ $((32768*cpus)) -lt 131072 ]]; then
    should_be=131072
  else
    should_be=$((32768*cpus))
  fi
  if [[ ${should_be} -ne $host_max ]]; then
    printf '\nERROR: /proc/sys/net/nf_conntrack_max should be set to %d.\n' \
      "${should_be}" >"${STDERR}"
    printf '     kube-proxy will not start with an incorrect nf_conntrack_max.\n' >"${STDERR}"
    printf '     To fix this, run the following command:\n\n' >"${STDERR}"
    if [[ $(CU_podmantype) == "native" ]]; then
      printf '       sudo sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
    elif [[ $(CU_podmantype) == "machine" ]]; then
      printf '       %s machine setup\n\n' "$(MA_program_name)" >"${STDERR}"
    else
      printf 'Internal ERROR. Invalid podman type.\n' >"${STDERR}"
      return "${ERROR}"
    fi
    
    printf 'Press ENTER to continue or CTRL-C to abort.\n' >"${STDERR}"
    read -r
    printf '\n' >"${STDERR}"
  fi
}

# _CC_create_master_nodes creates the master node containers.
# Args: arg1 - number of master nodes to create
_CC_create_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating master container, '${_CC[clustername]}-master-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-master-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }
  done

  return "${OK}"
}

# _CC_setup_master_nodes sets up the master node containers.
# Args: arg1 - number of master nodes to create
_CC_setup_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile lbaddr hostaddr
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-master-${int}'" \
      _CC_set_up_master_node "${_CC[clustername]}-master-${int}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  done

  # For now, copy admin.conf from master to /var/tmp/admin-CLUSTERNAME.conf

  if [[ -z ${_CC[skipmastersetup]} ]]; then
    if [[ ${_CC[publish]} -eq ${TRUE} ]]; then
      # On MacOS we need to use localhost, on linux use the host IP
      if [[ $(CU_podmantype) == "native" ]]; then
        hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
      else
        hostaddr="localhost"
      fi
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${hostaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    elif [[ ${_CC[withlb]} -eq ${TRUE} ]]; then
      lbaddr=$(CU_get_container_ip "${_CC[clustername]}-lb") || err || return
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${lbaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    else
      [[ -n ${_CC[skipmastersetup]} ]] || {
        docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
          "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      }
    fi

    chmod 666 "/var/tmp/admin-${_CC[clustername]}.conf" || {
      printf 'ERROR: Could not "chown 666 /var/tmp/admin-%s.conf"' "${_CC[clustername]}"
      err || return
    }
  fi

  return "${OK}"
}

# _CC_set_up_master_node calls the correct set up function based on the version
# Args: arg1 - the container ID to set up
_CC_set_up_master_node() {

  case "${_CC[k8sver]}" in
  "1.31."* | "1.32."*)
    _CC_set_up_master_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# _CC_get_master_join_details uses 'docker exec' or 'podman exec' to run a
# script on the master to get CA hash, a token, and the master IP.  The caller
# can eval the output of this function to set the variables: cahash, token, and
# masterip. See also:
# https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/#token-based-discovery-with-ca-pinning
# Args: arg1 - id/name of master container
_CC_get_master_join_details() {

  local joinvarsfile master1ip

  joinvarsfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  master1ip=$(CU_get_container_ip "${_CC[clustername]}-master-1") || err || return

  cat <<EnD >"${joinvarsfile}"
#!/bin/bash
set -e

sed 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${master1ip}"'\2#' \
  /etc/kubernetes/super-admin.conf >/etc/kubernetes/admin2.conf

cahash=\$(openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | \
        openssl rsa -pubin -outform der 2>/dev/null | \
        openssl dgst -sha256 -hex | sed 's/^.* //')
token=\$(kubeadm token create --kubeconfig=/etc/kubernetes/admin2.conf 2>/dev/null)
ip=\$(ip ro get 8.8.8.8 | cut -d" " -f 7)

printf 'cahash=%s\ntoken=%s\nmasterip=%s' "\$cahash" "\$token" "\$ip"

exit 0
EnD

  docker cp "${joinvarsfile}" "$1":/root/joinvars.sh 2>"${STDERR}" ||
    err || return
  rm -f "${joinvarsfile}" 2>"${STDERR}" || err || return

  [[ -z ${_CC[skipworkersetup]} ]] && {
    docker exec "$1" bash /root/joinvars.sh 2>"${STDERR}" || err || return
  }

  return "${OK}"
}

# _CC_create_lb_node creates the load balancer node container.
# Args: None expected.
_CC_create_lb_node() {

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  # Create container
  UT_run_with_progress \
    "    Creating load balancer container, '${_CC[clustername]}-lb'" \
    CU_create_container \
    "${_CC[clustername]}-lb" \
    "${labelkey}=${_CC[clustername]}" \
    "${_CC[k8sver]}"

  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    printf '\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
    printf '%s\n' "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  return "${OK}"
}

# _CC_setup_lb_node sets up the load balancer node container.
# Args: None expected.
_CC_setup_lb_node() {

  local runlogfile

  # Set up
  [[ -z ${_CC[skiplbsetup]} ]] && {
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-lb'" \
      _CC_set_up_lb_node_real "${_CC[clustername]}-lb"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _CC_set_up_lb_node_real sets up the lb node.
# Args: arg1 - the container ID to set up
_CC_set_up_lb_node_real() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masteriplist=
  nl=
  gotamaster="${FALSE}"
  for idx in $(seq 1 "${_CC[nummasters]}"); do
    ip=$(CU_get_container_ip "${_CC[clustername]}-master-${idx}") || continue
    gotamaster="${TRUE}"
    masteriplist="${masteriplist}${nl}    server master-${idx} ${ip}:6443 check fall 3 rise 2"
    nl='\n'
  done

  [[ ${gotamaster} == "${FALSE}" ]] && {
    printf 'ERROR: Did not manage to get an IP address for any master nodes\n'
    err || return
  }

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

systemctl stop kubelet crio
systemctl disable kubelet crio

apt -y install haproxy

INTERNAL_IP=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")

cat <<EOF | tee /etc/haproxy/haproxy.cfg 
frontend kubernetes
    bind \$INTERNAL_IP:6443
    option tcplog
    mode tcp
    default_backend kubernetes-master-nodes
backend kubernetes-master-nodes
    mode tcp
    balance roundrobin
    option tcp-check
\$(echo -e "${masteriplist}")
EOF

systemctl restart haproxy
systemctl enable haproxy

EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# _CC_create_worker_nodes creates the worker nodes.
# Args: arg1 - number of worker nodes to create
_CC_create_worker_nodes() {

  local cahash token t masterip
  declare -i int=0

  [[ -n ${_CC[skipmastersetup]} ]] || {
    # Runs a script on master node to get details
    t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1") || {
      printf '\nERROR: Problem with "_CC_get_master_join_details".\n\n' >"${STDERR}"
      return "${ERROR}"
    }

    # Sets cahash, token, and masterip:
    eval "${t}"
  }

  local labelkey
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating worker container, '${_CC[clustername]}-worker-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-worker-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }

    [[ -n ${_CC[skipworkersetup]} || -n ${_CC[skipmastersetup]} ]] || {
      UT_run_with_progress \
        "    Setting up '${_CC[clustername]}-worker-${int}'" \
        _CC_set_up_worker_node "${_CC[clustername]}-worker-${int}" \
        "${cahash}" "${token}" "${masterip}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n' >"${STDERR}"
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
        printf '%s\n' "${runlogfile}" >"${STDERR}"
        return "${ERROR}"
      }

      UT_run_with_progress \
        "    Waiting for system to become ready" \
        _CC_wait_for_cluster \
        "${_CC[clustername]}-master-1" \
        "${_CC[clustername]}-worker-${int}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n'
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Wait timed out.\n' >"${STDERR}"
        return "${ERROR}"
      }
    }
  done

  return "${OK}"
}

# _CC_wait_for_cluster runs a `kubectl` command in the master-1 container,
# which doesn't exit until the all pods are fully up and running before it
# returns.
# Args: arg1 - the master container name to log into
#       arg2 - the worker container name to wait for
_CC_wait_for_cluster() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  cat <<'EnD' >"${setupfile}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
found=0
for i in $(seq 1 20); do
  if kubectl get pods &>/dev/null; then
    found=1
    break
  fi
  sleep 1
done
[[ $found == 0 ]] && {
  printf '# kubectl get pods\n'
  kubectl get pods
  printf '\nWaited for 20 seconds for kubectl to work.\n'
  printf 'Kubectl cannot contact master. Aborting.\n'
  exit 1
}
counter=0
while ! kubectl get nodes | grep -qs "$1"; do
  ((counter++))
  [[ ${counter} -gt 60 ]] && {
    printf '# kubectl get nodes\n'
    kubectl get nodes
    printf '\nWaited for 2 minutes for node to appear in master. Aborting.\n'
    exit 1
  }
  sleep 2
done
counter=0
while kubectl get pods -A | tail -n +2 | awk '{ print $3; }' | grep -qs 0; do
  ((counter++))
  [[ ${counter} -gt 120 ]] && {
    printf '# kubectl get pods -A\n'
    kubectl get pods -A
    printf '\nWaited for 3 minutes for pods to be ready. Aborting.\n'
    exit 1
  }
  sleep 2
done
exit 0
EnD

  docker cp "${setupfile}" "$1":/root/wait.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/wait.sh "$2" || err
}

# _CC_set_up_worker_node calls the correct set up function based on the version.
# Args: arg1 - the container ID to set up
#       arg2 - the CA hash
#       arg3 - the token
#       arg4 - the master IP
_CC_set_up_worker_node() {

  case "${_CC[k8sver]}" in
  "1.31."* | "1.32."*)
    _CC_set_up_worker_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# Initialise _CC
_CC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster - versions file

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR TRUE

# _CC_set_up_master_node_v1_30_0 uses kubeadm to set up the master node.
# Args: arg1 - the container to set up.
_CC_set_up_master_node_v1_30_0() {

  local setupfile lbaddr certSANs="{}" certkey masternum t lbip
  # Set by _CC_get_master_join_details:
  local cahash token masterip

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masternum="${1##*-}" # <- eg. for xxx-master-1, masternum=1

  if [[ ${_CC[skipmastersetup]} != "${TRUE}" ]]; then

    if [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -eq 1 ]]; then

      # This is the first master node

      # Sets cahash, token, and masterip:
      lbip=$(CU_get_container_ip "${_CC[clustername]}-lb")
      lbaddr=", '${lbip}'"
      uploadcerts="--upload-certs"
      certkey="CertificateKey: f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07"

    elif [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -ne 1 ]]; then

      # This is not the first master node, so join with the master
      # https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/

      # Keep trying to get join details until apiserver is ready or we run out of tries
      for try in $(seq 1 9); do
        # Runs a script on master node to get join details
        t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1")
        retval=$?
        [[ ${retval} -eq 0 ]] && break
        [[ ${try} -eq 9 ]] && {
          printf '\nERROR: Problem with "_CC_get_master_join_details". Tried %d times\n\n' "${try}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        sleep 5
      done
      eval "${t}"
    fi
  fi

  # Always set certSANs for the host whether we need it or not
  hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
  certSANs="
  certSANs: [ '${hostaddr}'${lbaddr}, '127.0.0.1', 'localhost' ]"

  # Write the file regardless, so the user can use it if required

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

# Use a custom configuration. Default config created from kubeadm with:
#   kubeadm config print init-defaults
# then edited.

ipaddr=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")
podsubnet="10.244.0.0/16"
servicesubnet="10.96.0.0/16"

cat <<EOF >kubeadm-init-defaults.yaml
apiVersion: kubeadm.k8s.io/v1beta4
bootstrapTokens:
- groups:
  - system:bootstrappers:kubeadm:default-node-token
  token: abcdef.0123456789abcdef
  ttl: 24h0m0s
  usages:
  - signing
  - authentication
kind: InitConfiguration
${certkey}
localAPIEndpoint:
  advertiseAddress: \$ipaddr
  bindPort: 6443
nodeRegistration:
  criSocket: unix:///var/run/crio/crio.sock
  imagePullPolicy: IfNotPresent
  imagePullSerial: true
  name: $1
  taints:
  - effect: NoSchedule
    key: node-role.kubernetes.io/control-plane
timeouts:
  controlPlaneComponentHealthCheck: 4m0s
  discovery: 5m0s
  etcdAPICall: 2m0s
  kubeletHealthCheck: 4m0s
  kubernetesAPICall: 1m0s
  tlsBootstrap: 5m0s
  upgradeManifests: 5m0s
---
apiServer: ${certSANs}
apiVersion: kubeadm.k8s.io/v1beta4
caCertificateValidityPeriod: 87600h0m0s
certificateValidityPeriod: 8760h0m0s
certificatesDir: /etc/kubernetes/pki
clusterName: ${_CC[clustername]}-cluster
controlPlaneEndpoint: ${lbaddr:-\$ipaddr}:6443
controllerManager: {}
dns: {}
encryptionAlgorithm: RSA-2048
etcd:
  local:
    dataDir: /var/lib/etcd
imageRepository: registry.k8s.io
kind: ClusterConfiguration
kubernetesVersion: v${_CC[k8sver]}
networking:
  dnsDomain: cluster.local
  podSubnet: \${podsubnet}
  serviceSubnet: \${servicesubnet}
proxy: {}
scheduler: {}
EOF

mkdir -p /mok
cp kubeadm-init-defaults.yaml /mok/kubeadm.yaml

if [[ -z "${masterip}" ]]; then
  # Run the preflight phase
  kubeadm init \\
    --ignore-preflight-errors Swap \\
    --config=kubeadm-init-defaults.yaml \\
    phase preflight

  # Set up the kubelet
  kubeadm init phase kubelet-start

  # Edit the kubelet configuration file
  echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
  sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

  # Tell kubeadm to carry on from here
  kubeadm init \\
    --config=kubeadm-init-defaults.yaml \\
    --ignore-preflight-errors Swap \\
    ${uploadcerts} \\
    --skip-phases=preflight,kubelet-start

  export KUBECONFIG=/etc/kubernetes/super-admin.conf

  # Flannel - 10.244.0.0./16
  kubectl apply -f /root/kube-flannel.yml
else
  kubeadm join ${masterip}:6443 \\
    --ignore-preflight-errors Swap \\
    --control-plane \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --certificate-key f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07
fi

systemctl enable kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  # Run the file
  [[ -z ${_CC[skipmastersetup]} ]] && {
    docker exec "$1" bash /root/setup.sh || err || return

    # Remove the taint if we're setting up a single node cluster

    [[ ${_CC[numworkers]} -eq 0 ]] && {

      removetaint=$(mktemp -p /var/tmp) || {
        printf 'ERROR: mktmp failed.\n' >"${STDERR}"
        return "${ERROR}"
      }

      # Write the file
      cat <<'EnD' >"${removetaint}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
kubectl taint nodes --all node-role.kubernetes.io/control-plane:NoSchedule-
EnD

      docker cp "${removetaint}" "$1":/root/removetaint.sh || err || {
        rm -f "${removetaint}"
        return "${ERROR}"
      }

      # Run the file
      docker exec "$1" bash /root/removetaint.sh || err
    }
  }

  return "${OK}"
}

# _CC_set_up_worker_node_v1_30_0 uses kubeadm to set up the worker node.
# Args: arg1 - the container to set up.
_CC_set_up_worker_node_v1_30_0() {

  local setupfile cahash="$2" token="$3" masterip="$4"

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  if [[ ${_CC[withlb]} == "${TRUE}" ]]; then
    masterip=$(CU_get_container_ip "${_CC[clustername]}-lb") || return
  fi

  cat <<EnD >"${setupfile}"
# Wait for the master API to become ready
while true; do
  curl -k https://${masterip}:6443/
  [[ \$? -eq 0 ]] && break
  sleep 1
done

# Do the preflight tests (ignoring swap error)
kubeadm join \\
  phase preflight \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --ignore-preflight-errors Swap \\
    ${masterip}:6443

# Set up the kubelet
kubeadm join \\
  phase kubelet-start \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    ${masterip}:6443 &

while true; do
  [[ -e /var/lib/kubelet/config.yaml ]] && break
    sleep 1
  done

# Edit the kubelet configuration file
echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

systemctl enable --now kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh 2>"${STDERR}" || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CU - Container Utilities

# _CU is an associative array that holds data specific to container utils.
declare -A _CU

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# CU_containerrt getter outputs the container runtime (podman or docker)
# that has been chosen.
CU_containerrt() {
  printf '%s' "${_CU[containerrt]}"
}

# CU_imgprefix getter outputs the prefix to be used with docker build. For
# podman it is 'localhost/'. For docker it is empty.
CU_imgprefix() {
  printf '%s' "${_CU[imgprefix]}"
}

# CU_labelkey getter outputs the key value of the label that is applied to all
# cluster member's container labels for podman or docker.
CU_labelkey() {
  printf '%s' "${_CU[labelkey]}"
}

# CU_podmantype getter outputs the container runtime type (native or machine).
CU_podmantype() {
  printf '%s' "${_CU[podmantype]}"
}

# Public Functions ------------------------------------------------------------

# CU_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted.
CU_cleanup() { :; }

# CU_get_cluster_container_ids outputs just the container IDs, one per line
# for any MOK cluster, unless arg1 is set, in which case just the IDs
# for the requested cluster name are output.
# Args: arg1 - The cluster name, optional.
CU_get_cluster_container_ids() {

  local value output

  [[ -n $1 ]] && value="=$1"

  output=$(docker ps -a -f label="${_CU[labelkey]}${value}" -q) || {
    printf 'ERROR: %s command failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  output=$(printf '%s' "${output}" | sed 's/$//')

  printf '%s' "${output}"

  return "${OK}"
}

# CU_get_cluster_size searches for an existing cluster using labels and outputs
# the number of containers in that cluster. All cluster nodes are labelled with
# "${_CU[labelkey]}=${CC[clustername]}"
# Args: arg1 - The cluster name to search for.
CU_get_cluster_size() {

  local output
  declare -a nodes

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Cluster name cannot be empty.\n' >"${STDERR}"
    err || return
  }

  output=$(CU_get_cluster_container_ids "$1") || err || return

  # readarray will read null as an array item so don't run
  # through readarray if it's null
  [[ -z ${output} ]] && {
    printf '0'
    return "${OK}"
  }

  # read the nodes array and delete blank lines
  readarray -t nodes <<<"${output}"

  printf '%d' "${#nodes[*]}"
}

# CU_get_container_ip outputs the IP address of the container.
# Args: arg1 - docker container id or container name to query.
CU_get_container_ip() {

  local info

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  info=$(CU_get_container_info "$1") || return
  JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}" ||
    err || return
}

# CU_get_container_info uses 'docker/podman inspect $id' to output
# container details.
# Args: arg1 - docker container id
CU_get_container_info() {

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  docker inspect "$1" || {
    printf 'ERROR: %s inspect failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_create_container creates and runs a container with settings suitable for
# running privileged containers that can manipulate cgroups.
# Args: arg1 - The string used to set the name and hostname.
#       arg2 - The label to assign to the container.
#       arg3 - The k8s base image version to use.
CU_create_container() {

  local imagename img allimgs systemd_always clustername parg pval root_user url port

  [[ -z $1 || -z $2 || -z $3 ]] && {
    printf 'INTERNAL ERROR: Neither arg1, arg2 nor arg3 can be empty.\n' \
      >"${STDERR}"
    err || return
  }

  img="$(BI_baseimagename)_$(MA_ostype)"

  local imglocal="${_CU[imgprefix]}local/${img}"
  local imgremote="myownkind/${img}"
  local imgtag="${3}"

  # Prefer a locally built container over one downloaded from a registry
  allimgs=$(docker images | tail -n +2) || {
    printf 'ERROR: %s returned an error\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  if echo "${allimgs}" | grep -qs "${imglocal} *${imgtag}"; then
    imagename="${imglocal}:${imgtag}"
  elif echo "${allimgs}" | grep -qs "${imgremote} *${imgtag}"; then
    imagename="${imgremote}:${imgtag}"
  else
    cat <<EnD
ERROR: No container base image found. Use either:

  $ mok build image
OR
  $ mok build image --get-prebuilt-image

Then try running 'mok create ...' again.
EnD
    return "${ERROR}"
  fi

  clustername=$(CC_clustername) || err || return

  if [[ ${_CU[containerrt]} == "podman" ]];
  then 
    docker network exists "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  else
    docker network inspect "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  fi

  [[ ${create_network} -ne 0 ]] && {
    docker network create "${clustername}_network" || {
      printf 'ERROR: docker network create failed\n' >"${STDERR}"
      err || return
    }
  }

  # Docker does not have the --systemd option
  [[ ${_CU[containerrt]} == "podman" ]] && systemd_always="--systemd=always"
  [[ ${_CU[podmantype]} == "machine" ]] && {
    root_user="--user=root"
    # TODO: A named podman machine does not work the same way
    #       as the default podman machine. Rootful doesn't work
    #       for a named machine so need to use '--url'. Ask
    #       Podman developers about this.
    port=$(podman machine inspect mok-machine | grep Port | grep -o '[0-9]\+')
    url="--url ssh://root@127.0.0.1:$port/run/podman/podman.sock"
  }

  [[ $(CC_publish) == "${TRUE}" ]] && {
    if [[ $(CC_withlb) == "${TRUE}" ]]; then
      if echo "$1" | grep -qs -- '-lb$'; then
        parg='-p'
        pval='6443:6443'
      fi
    else
      if echo "$1" | grep -qs -- '-master-1$'; then
        parg='-p'
        pval='6443:6443'
      fi
    fi
  }

  # shellcheck disable=SC2086
  docker ${url} run --privileged ${systemd_always} ${root_user} \
    --network "${clustername}_network" \
    -v /lib/modules:/lib/modules:ro \
    --detach ${parg} ${pval} \
    --name "$1" \
    --hostname "$1" \
    --label "$2" \
    "${imagename}" \
    /usr/local/bin/entrypoint /lib/systemd/systemd log-level=info unit=sysinit.target || {
    printf 'ERROR: %s run failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_podman_or_docker checks to see if docker and/or podman are installed and
# sets the imgprefix and containerrt array members accordingly. It also defines
# the docker function to run the detected container runtime. Podman is
# preferred if both are installed.
# Args: No args expected.
CU_podman_or_docker() {
  if type podman &>/dev/null; then
    _CU[imgprefix]="localhost/"
    _CU[containerrt]="podman"
    _CU_podman_checks || return
  elif type docker &>/dev/null; then
    _CU[imgprefix]=""
    _CU[containerrt]="docker"
    _CU_docker_checks || return
  else
    printf 'ERROR: Neither "podman" nor "docker" were found.\n' \
      >"${STDERR}"
    printf 'Please install one of "podman" or "docker".\nAborting.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi
  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CU_docker_checks checks to see if the current user has permission to write
# to the docker socket. If not, it prints an error message and exits.
# Args: No args expected.
_CU_docker_checks() {
  if [[ ! -e /proc/sys/kernel/hostname ]]; then
    printf 'ERROR: Docker is currently supported on Linux only'
    exit "${ERROR}"
  fi

  if docker ps >/dev/stdout 2>&1 | grep -qs 'docker.sock.*permission denied'; then
    cat <<EnD >"${STDERR}"
Not enough permissions to write to 'docker.sock'.

Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  fi

  _CU[podmantype]="native"
  return "${OK}"
}

# _CU_podman_checks sets the _CU[podmantype] member to "native" or "machine"
# depending on whether this is linux or macos. We assume linux won't be using
# a podman machine, and macos will always be using a podman machine.
# Args: No args expected.
_CU_podman_checks() {
  local info running exists

  if [[ -e /proc/sys/kernel/hostname ]]; then
    # We're on linux
    _CU[podmantype]="native"
    _CU_podman_native_checks || return
  elif [[ -d /System/Library/CoreServices ]]; then
    # We're on macOS
    [[ $(id -u) -eq 0 ]] && {
      printf 'ERROR: Cannot run mok as root on macOS.\n' >"${STDERR}"
      exit "${ERROR}"
    }

    info=$(podman machine list --format json) || err || return
    running=$(UT_sed_json_block "${info}" \
      'Name' 'mok-machine' '}' \
      'Running' \
      ) || err || return
    exists=$(UT_sed_json_block "${info}" \
      'Name' 'mok-machine' '}' \
      'Name' \
      ) || err || return

    if [[ $(MA_arg_1) != "machine" && ${exists} != "mok-machine" ]]; then
      printf 'ERROR: Podman machine does not exist.\n' >"${STDERR}"
      printf '       Create a Podman machine with: %s machine create\n' \
        "$(MA_program_name)" >"${STDERR}"
      exit "${ERROR}"
    elif [[ ${running} == "true" ]]; then
      _CU[podmantype]="machine"
    elif [[ $(MA_arg_1) != "machine" ]]; then
      # Don't check for a podman machine if we're running 'machine' commands
      printf 'ERROR: Podman machine is not running.\n' >"${STDERR}"
      printf '       Try starting the machine with: %s machine start\n' \
        "$(MA_program_name)" >"${STDERR}"
      exit "${ERROR}"
    fi
  else
    printf 'ERROR: Unknown OS. Aborting.\n' >"${STDERR}"
    exit "${ERROR}"
  fi
}

# _CU_podman_native_checks checks to see if the current user is root. If not,
# it prints an error message and exits.
# Args: No args expected.
_CU_podman_native_checks() {
  [[ $(id -u) -ne 0 ]] && {
    cat <<EnD >"${STDERR}"
Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  }
}

# _CU_new sets the initial values for the Container Utils associative array.
# Args: None expected.
_CU_new() {
  _CU[imgprefix]=
  _CU[labelkey]="MokCluster"
  _CU[containerrt]=

  # _CU[podmantype] will only be set only if _CU[containerrt]=podman.
  # podmantype will be "native" or "machine".
  _CU[podmantype]=
}

# Override `docker` depending on _CU[containerrt]
# [[ -n ${_CU[containerrt]} ]] && {
  docker() {
    local cmd port url

    if [[ "${_CU[containerrt]}" == "podman" && "${_CU[podmantype]}" == "machine" ]]; then
      # TODO: A named podman machine does not work the same way
      #       as the default podman machine. Rootful doesn't work
      #       for a named machine so need to use '--url'. Ask
      #       Podman developers about this.
      port=$(podman machine inspect mok-machine | grep Port | grep -o '[0-9]\+')
      url="ssh://root@127.0.0.1:$port/run/podman/podman.sock"

      # TODO: This would be preferred to '--url'
      # podman -c mok-machine "$@"
      podman --url "${url}" "$@"
    elif [[ "${_CU[containerrt]}" == "podman" ]]; then
      podman "$@"
    else
      cmd=$(which -a docker | tail -n 1)
      $cmd "$@"
    fi
  }
# }

# Override `ip` depending on _CU[podmantype]
ip() {
  local cmd
  if [[ "${_CU[podmantype]}" == "machine" ]]; then
    podman machine ssh mok-machine ip "$@"
  else
    cmd=$(which -a ip | tail -n 1)
    $cmd "$@"
  fi
}

# Initialise _CU
_CU_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# BI - Build Image

# _BI is an associative array that holds data specific to building an image.
declare -A _BI

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE

# Getters/Setters -------------------------------------------------------------

# BI_setflag_useprebuiltimage setter sets the useprebuiltimage array item.
# This is called by the parser, via a callback in _BI_new.
BI_setflag_useprebuiltimage() {
  _BI[useprebuiltimage]="$1"
}

# BI_baseimagename getter outputs the value of the _BI[baseimagename].
# Args: None expected.
BI_baseimagename() {
  printf '%s' "${_BI[baseimagename]}"
}

# Public Functions ------------------------------------------------------------

# BI_usage outputs help text for the build image component.
# It is called by PA_usage(), via a callback in _BI_new.
# Args: None expected.
BI_usage() {

  cat <<'EnD'
BUILD subcommands are:
 
  image - Creates the docker 'mok-image' container image.
 
build image options:
 
 Format:
  build image [flags]

 Flags:
  --get-prebuilt-image - Instead of building a 'node' image
         locally, download it from a container registry instead.
  --k8sver VERSION - The Kubernetes version, e.g. "1.32.0" or "1.32.1".
         A previous version cannot be built from scratch. This option
         must be used with '--get-prebuilt-image'. To build a previous
         version of kubernetes it must be built with a previous version
         of mok.
  --tailf - Show the build output whilst building.

EnD
}

# BI_cleanup removes temporary files created during the build.
# This function is called by the 'MA_cleanup' trap only.
# Args: None expected.
BI_cleanup() {
  [[ -e ${_BI[dockerbuildtmpdir]} ]] &&
    [[ ${_BI[dockerbuildtmpdir]} == "/var/tmp/"* ]] && {
    rm -rf "${_BI[dockerbuildtmpdir]}" || {
      printf 'ERROR: "rm -rf %s" failed.\n' "${_BI[dockerbuildtmpdir]}" \
        >"${STDERR}"
      err || return
    }
  }
}

# BI_check_valid_options checks if arg1 is in a list of valid build image
# options. This function is called by the parser, via a callback in _BI_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
BI_process_options() {

  case "$1" in
  -h | --help)
    BI_usage
    return "${STOP}"
    ;;
  --tailf)
    _BI[tailf]="${TRUE}"
    return "${OK}"
    ;;
  --k8sver)
    _BI[k8sver]="$2"
    return "$(PA_shift)"
    ;;
  --get-prebuilt-image)
    _BI[useprebuiltimage]="${TRUE}"
    return "${OK}"
    ;;
  *)
    BI_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# BI_run builds the base image used for masters and workers.
# This function is called in main.sh.
# Args: None expected.
BI_run() {

  _BI_sanity_checks || return

  [[ ${_BI[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  local retval=0
  _BI_build_container_image
  retval=$?

  if [[ ${retval} -eq ${OK} ]]; then
    : # We only need the tick - no text
  else
    printf 'Image build failed\n' >"${STDERR}"
    err
  fi

  return "${retval}"
}

# Private Functions -----------------------------------------------------------

# _BI_new resets the initial values for the _BI associative array.
# Args: None expected.
_BI_new() {
  _BI[tailf]="${FALSE}"
  _BI[baseimagename]="mok-image"
  _BI[useprebuiltimage]="${FALSE}"
  _BI[dockerbuildtmpdir]=
  _BI[k8sver]="${K8SVERSION}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "build" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "buildimage" "END" ""

  # Set up the parser's option callbacks
  PA_add_option_callback "build" "BI_process_options" || return
  PA_add_option_callback "buildimage" "BI_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "build" "BI_usage" || return
  PA_add_usage_callback "buildimage" "BI_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "buildimage" "BI_run"
}

# BI_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_BI_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    BI_usage
    exit "${OK}"
  fi
}

# _BI_build_container_image creates the docker build directory in
# dockerbuildtmpdir then calls docker build to build the image.
# Args: No args expected.
_BI_build_container_image() {

  local cmd retval tagname buildargs text buildtype basename

  _BI_create_docker_build_dir || return

  buildargs=$(_BI_get_build_args_for_latest) || return
  basename="${_BI[baseimagename]}_$(MA_ostype)"
  tagname="${_BI[k8sver]}"

  local imgprefix
  imgprefix=$(CU_imgprefix) || err || return
  if [[ ${_BI[useprebuiltimage]} == "${FALSE}" ]]; then
    # Each mok release can build the hardcoded version only
    # so reset the tagname to that version
    tagname="${K8SVERSION}"
    buildtype="create"
    cmd="docker build \
      -t "${imgprefix}local/${basename}:${tagname}" \
      --force-rm \
      ${buildargs} \
      ${_BI[dockerbuildtmpdir]}/${_BI[baseimagename]}"
    text="Creating"
  else
    # We can download and run any available version
    buildtype="download"
    cmd="docker pull docker.io/myownkind/${basename}:${tagname}"
    text="Downloading"
  fi

  UT_run_with_progress \
    "    ${text} base image, '${basename}:${tagname}'" "${cmd}"

  retval=$?
  [[ ${retval} -ne ${OK} ]] && {
    local runlogfile
    runlogfile=$(UT_runlogfile) || err || return
    printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\n' >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${buildtype} == "create" ]] && {
    cmd="_BI_modify_container_image"

    UT_run_with_progress \
      "    Modifying base image (pulling kubernetes images)" "${cmd}"

    retval=$?
    [[ ${retval} -ne ${OK} ]] && {
      local runlogfile
      runlogfile=$(UT_runlogfile) || err || return
      printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\n' >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _BI_modify_container_image starts a container suitable for running kubernetes
# components (since the docker/podman build environment isn't suitable), makes
# some modifications and then 'commits' the image. The modifications allow
# `mok create ...` to complete more quickly.
# Args: No args expected.
_BI_modify_container_image() {

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify &>/dev/null
  docker rm mok-build-modify &>/dev/null

  CC_set_clustername "build" || err || return

  # Start container
  CU_create_container "mok-build-modify" "mok-build-modify" "${K8SVERSION}" ||
    return

  # Wait for crio to become ready
  local counter
  printf '\n\n ** WAITING FOR CRIO TO BECOME READY **\n\n'
  while ! docker exec mok-build-modify systemctl status crio; do
    sleep 1
    [[ ${counter} -gt 10 ]] && {
      printf '\nERROR: CRI-O did not start after %d tries.\n' "${counter}"
      err || return
    }
    ((counter++))
  done

  # Modify container
  docker exec mok-build-modify kubeadm config images pull \
    --kubernetes-version "${K8SVERSION}" || err || return

  # Stop container
  docker stop -t 5 "mok-build-modify"

  # Write image
  local imgprefix tagname basename
  imgprefix=$(CU_imgprefix) || err || return
  basename="${_BI[baseimagename]}_$(MA_ostype)"
  tagname="${K8SVERSION}"
  docker commit mok-build-modify "${imgprefix}local/${basename}:${tagname}" || err || return

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify
  docker rm mok-build-modify || err || return

  return "${OK}"
}

# _BI_get_build_args_for_latest sets the buildargs variable that is added
# to the 'podman build ...' command line.  Only the latest version is built
# from scratch.  Earlier versions are downloaded using '--get-prebuilt-image'.
# Args: None expected
_BI_get_build_args_for_latest() {

  local buildargs

  buildargs="--build-arg GO_VERSION=${GO_VERSION}"

  printf '%s' "${buildargs}"
}

# _BI_create_docker_build_dir creates a docker build directory in
# /var/tmp/tmp.XXXXXXXX
# Args: None expected
_BI_create_docker_build_dir() {

  _BI[dockerbuildtmpdir]="$(mktemp -d -p /var/tmp)" || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }

  # The following comments should not be removed or changed.
  # embed-dockerfile.sh adds a base64 encoded tarball and
  # unpacking code between them.

  #mok-image-tarball-start 
  cat <<EnD | base64 -d | tar xz -C "${_BI[dockerbuildtmpdir]}" 
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
/+rn/wBJNd6fAOABAA==
EnD
  #mok-image-tarball-end
}

# Initialise _BI
_BI_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
#!/usr/bin/env bash

declare -A JSONPath

JSONPath_new() {
  JSONPath[DEBUG]=0
  JSONPath[INCLEMPTY]=0
  JSONPath[NOCASE]=0
  JSONPath[WHOLEWORD]=0
  JSONPath[FILE]=
  JSONPath[NO_HEAD]=0
  JSONPath[NORMALIZE_SOLIDUS]=0
  JSONPath[BRIEF]=0
  JSONPath[PASSTHROUGH]=0
  JSONPath[JSON]=0
  JSONPath[MULTIPASS]=0
  JSONPath[FLATTEN]=0
  JSONPath[STDINFILE]=/var/tmp/JSONPath.$$.stdin
  JSONPath[STDINFILE2]=/var/tmp/JSONPath.$$.stdin2
  JSONPath[PASSFILE]=/var/tmp/JSONPath.$$.pass1
  declare -a INDEXMATCH_QUERY
}

# JSONPath reads JSON from stdin and applies a JSON Path query.
# Args: arg1-N - command line arguments to be parsed.
JSONPath() {

  JSONPath_sanity_checks
  JSONPath_parse_options "$@"

  trap JSONPath_cleanup EXIT

  if [[ ${QUERY} == *'?(@'* ]]; then
    # This will be a multipass query

    [[ -n ${JSONPath[FILE]} ]] && JSONPath[STDINFILE]=${JSONPath[FILE]}
    [[ -z ${JSONPath[FILE]} ]] && cat >"${JSONPath[STDINFILE]}"

    while true; do
      JSONPath_tokenize_path
      JSONPath_create_filter

      JSONPath_tokenize | JSONPath_parse | JSONPath_filter |
        JSONPath_indexmatcher >"${JSONPath[PASSFILE]}" <"${JSONPath[STDINFILE]}"

      [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && {
        # replace filter expression with index sequence
        SET=$(sed -rn 's/.*[[,"]+([0-9]+)[],].*/\1/p' "${JSONPath[PASSFILE]}" | tr '\n' ,)
        SET=${SET%,}
        #QUERY=$(sed "s/?(@[^)]\+)/${SET}/" <<<"${QUERY}")
        # Testing:
        QUERY="${QUERY//\?\(@*)/${SET}}"
        [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "QUERY=${QUERY}" >/dev/stderr
        JSONPath_reset
        continue
      }

      JSONPath_flatten | JSONPath_json | JSONPath_brief <<<"${JSONPath[PASSFILE]}"

      break
    done

  else

    JSONPath_tokenize_path
    JSONPath_create_filter

    if [[ ${JSONPath[PASSTHROUGH]} -eq 1 ]]; then
      JSONPath[JSON]=1
      JSONPath_flatten | JSONPath_json
    elif [[ -z ${JSONPath[FILE]} ]]; then
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten | JSONPath_json | JSONPath_brief
    else
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten <"${JSONPath[FILE]}"
      JSONPath_json | JSONPath_brief
    fi

  fi
}

JSONPath_sanity_checks() {

  local binary

  # Reset some vars
  for binary in gawk grep sed; do
    if ! command -v "${binary}" >&/dev/null; then
      echo "ERROR: ${binary} binary not found in path. Aborting."
      exit 1
    fi
  done
}

JSONPath_reset() {

  # Reset some vars
  declare -a INDEXMATCH_QUERY
  PATHTOKENS=
  FILTER=
  OPERATOR=
  RHS=
  JSONPath[MULTIPASS]=0
}

JSONPath_cleanup() {

  [[ -e ${JSONPath[PASSFILE]} ]] && rm -f "${PASSFILE}"
  [[ -e ${JSONPath[STDINFILE2]} ]] && rm -f "${JSONPath[STDINFILE2]}"
  [[ -z ${JSONPath[FILE]} && -e ${JSONPath[STDINFILE]} ]] &&
    rm -f "${JSONPath[STDINFILE]}"
}

JSONPath_usage() {

  echo
  echo "Usage: JSONPath.sh [-b] [j] [-h] [-f FILE] [pattern]"
  echo
  echo "pattern - the JSONPath query. Defaults to '$.*' if not supplied."
  echo "-b      - Brief. Only show values."
  echo "-j      - JSON output."
  echo "-u      - Strip unnecessary leading path elements."
  echo "-i      - Case insensitive."
  echo "-p      - Pass-through to the JSON parser."
  echo "-w      - Match whole words only (for filter script expression)."
  echo "-f FILE - Read a FILE instead of stdin."
  echo "-h      - This help text."
  echo
}

JSONPath_parse_options() {

  set -- "$@"
  local ARGN=$#
  while [[ ${ARGN} -ne 0 ]]; do
    case $1 in
    -h)
      JSONPath_usage
      exit 0
      ;;
    -f)
      shift
      JSONPath[FILE]=$1
      ;;
    -i)
      JSONPath[NOCASE]=1
      ;;
    -j)
      JSONPath[JSON]=1
      ;;
    -n)
      JSONPath[NO_HEAD]=1
      ;;
    -b)
      JSONPath[BRIEF]=1
      ;;
    -u)
      JSONPath[FLATTEN]=1
      ;;
    -p)
      JSONPath[PASSTHROUGH]=1
      ;;
    -w)
      JSONPath[WHOLEWORD]=1
      ;;
    -s)
      JSONPath[NORMALIZE_SOLIDUS]=1
      ;;
    *)
      QUERY=$1
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done
  [[ -z ${QUERY} ]] && QUERY='$.*'
}

JSONPath_awk_egrep() {
  local pattern_string=$1

  gawk '{
    while ($0) {
      start=match($0, pattern);
      token=substr($0, start, RLENGTH);
      print token;
      $0=substr($0, start+RLENGTH);
    }
  }' pattern="${pattern_string}"
}

JSONPath_tokenize() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    ESCAPE='(\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
    ESCAPE='(\\\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\\\]'
  fi

  local STRING="\"${CHAR}*(${ESCAPE}${CHAR}*)*\""
  local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'
  local KEYWORD='null|false|true'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  ${GREP} "${STRING}|${NUMBER}|${KEYWORD}|${SPACE}|." | grep -Ev "^${SPACE}$"
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

JSONPath_tokenize_path() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
  fi

  local WILDCARD='\*'
  local WORD='[ A-Za-z0-9_-]*'
  local INDEX="\\[${WORD}(:${WORD}){0,2}\\]"
  local INDEXALL='\[\*\]'
  local STRING="[\\\"'][^[:cntrl:]\\\"']*[\\\"']"
  local SET="\\[(${WORD}|${STRING})(,(${WORD}|${STRING}))*\\]"
  local FILTER='\?\(@[^)]+'
  local DEEPSCAN='\.\.'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  readarray -t PATHTOKENS < <(echo "${QUERY}" |
    ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
    grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$")
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    echo "grep -Eo '${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|.'" >/dev/stderr
    echo -n "TOKENISED QUERY="
    echo "${QUERY}" |
      ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
      grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$" >/dev/stderr
  }
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

# JSONPath_create_filter creates the filter from the user's query.
# Filter works in a single pass through the data, unless a filter (script)
#  expression is used, in which case two passes are required (MULTIPASS=1).
JSONPath_create_filter() {

  local len=${#PATHTOKENS[*]}

  local -i i=0
  local a query="^\[" comma=
  while [[ i -lt len ]]; do
    case "${PATHTOKENS[i]}" in
    '"')
      :
      ;;
    '..')
      query+="${comma}[^]]*"
      comma=
      ;;
    '[*]')
      query+="${comma}[^,]*"
      comma=","
      ;;
    '*')
      query+="${comma}(\"[^\"]*\"|[0-9]+[^],]*)"
      comma=","
      ;;
    '?(@'*)
      a=${PATHTOKENS[i]#?(@.}
      elem="${a%%[<>=!]*}"
      rhs="${a##*[<>=!]}"
      a="${a#${elem}}"
      elem="${elem//./[\",.]+}" # Allows child node matching
      operator="${a%${rhs}}"
      [[ -z ${operator} ]] && {
        operator="=="
        rhs=
      }
      if [[ ${rhs} == *'"'* || ${rhs} == *"'"* ]]; then
        case ${operator} in
        '==' | '=')
          OPERATOR=
          if [[ ${elem} == '?(@' ]]; then
            # To allow search on @.property such as:
            #   $..book[?(@.title==".*Book 1.*")]
            query+="${comma}[0-9]+[],][[:space:]\"]*${rhs//\"/}"
          else
            # To allow search on @ (this node) such as:
            #   $..reviews[?(@==".*Fant.*")]
            query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs//\"/}"
          fi
          FILTER="${query}"
          ;;
        '>=' | '>')
          OPERATOR=">"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=' | '<')
          OPERATOR="<"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      else
        case ${operator} in
        '==' | '=')
          OPERATOR=
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs}"
          FILTER="${query}"
          ;;
        '>=')
          OPERATOR="-ge"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '>')
          OPERATOR="-gt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=')
          OPERATOR="-le"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<')
          OPERATOR="-lt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      fi
      JSONPath[MULTIPASS]=1
      ;;
    "["*)
      if [[ ${PATHTOKENS[i]} =~ , ]]; then
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          # converts only one comma: s/("[^"]+),([^"]+")/\1`\2/g;s/"//g
          #a=$(echo $a | sed 's/\([[:alpha:]]*\)/"\1"/g')
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        fi
        query+="${comma}(${a//,/|})"
      elif [[ ${PATHTOKENS[i]} =~ : ]]; then
        if ! [[ ${PATHTOKENS[i]} =~ [0-9][0-9] || ${PATHTOKENS[i]} =~ :] ]]; then
          if [[ ${PATHTOKENS[i]#*:} =~ : ]]; then
            INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
            query+="${comma}[^,]*"
          else
            # Index in the range of 0-9 can be handled by regex
            query+="${comma}$(echo "${PATHTOKENS[i]}" |
              gawk '/:/ { a=substr($0,0,index($0,":")-1);
                         b=substr($0,index($0,":")+1,index($0,"]")-index($0,":")-1);
                         if(b>0) { print a ":" b-1 "]" };
                         if(b<=0) { print a ":]" } }' |
              sed 's/\([0-9]\):\([0-9]\)/\1-\2/;
                       s/\[:\([0-9]\)/[0-\1/;
                       s/\([0-9]\):\]/\1-9999999]/')"
          fi
        else
          INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
          query+="${comma}[^,]*"
        fi
      else
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        else
          [[ ${i} -gt 0 ]] && comma=","
        fi
        query+="${comma}${a}"
      fi
      comma=","
      ;;
    *)
      PATHTOKENS[i]=${PATHTOKENS[i]//\'/\"}
      query+="${comma}\"${PATHTOKENS[i]//\"/}\""
      comma=","
      ;;
    esac
    i=$((i + 1))
  done

  [[ -z ${FILTER} ]] && FILTER="${query}[],]"
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
}

JSONPath_parse_array() {

  local index=0
  local ary=''
  read -r token
  case "${token}" in
  ']') ;;

  *)
    while :; do
      JSONPath_parse_value "$1" "${index}"
      index=$((index + 1))
      ary="${ary}""${value}"
      read -r token
      case "${token}" in
      ']') break ;;
      ',') ary="${ary}," ;;
      *) JSONPath_throw "EXPECTED , or ] GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_object() {

  local key
  local obj=''
  read -r token
  case "${token}" in
  '}') ;;

  *)
    while :; do
      case "${token}" in
      '"'*'"') key=${token} ;;
      *) JSONPath_throw "EXPECTED string GOT ${token:-EOF}" ;;
      esac
      read -r token
      case "${token}" in
      ':') ;;
      *) JSONPath_throw "EXPECTED : GOT ${token:-EOF}" ;;
      esac
      read -r token
      JSONPath_parse_value "$1" "${key}"
      obj="${obj}${key}:${value}"
      read -r token
      case "${token}" in
      '}') break ;;
      ',') obj="${obj}," ;;
      *) JSONPath_throw "EXPECTED , or } GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_value() {

  local jpath="${1:+$1,}$2" isleaf=0 isempty=0 print=0
  case "${token}" in
  '{') JSONPath_parse_object "${jpath}" ;;
  '[') JSONPath_parse_array "${jpath}" ;;
    # At this point, the only valid single-character tokens are digits.
  '' | [!0-9]) JSONPath_throw "EXPECTED value GOT ${token:-EOF}" ;;
  *)
    value=${token}
    # if asked, replace solidus ("\/") in json strings with normalized value: "/"
    # Testing:
    #[ "${JSONPath[NORMALIZE_SOLIDUS]}" -eq 1 ] && value=$(echo "${value}" | sed 's#\\/#/#g')
    [[ ${JSONPath[NORMALIZE_SOLIDUS]} -eq 1 ]] && value=$(${value//\\\///})
    isleaf=1
    [[ ${value} == '""' ]] && isempty=1
    ;;
  esac
  [[ -z ${JSONPath[INCLEMPTY]} ]] && [[ ${value} == '' ]] && return
  [[ ${JSONPath[NO_HEAD]} -eq 1 ]] && [[ -z ${jpath} ]] && return

  [[ ${isleaf} -eq 1 ]] && [[ ${isempty} -eq 0 ]] && print=1
  [[ ${print} -eq 1 ]] && printf "[%s]\t%s\n" "${jpath}" "${value}"
  :
}

JSONPath_flatten() {

  local path a prevpath pathlen

  if [[ ${JSONPath[FLATTEN]} -eq 1 ]]; then
    cat >"${JSONPath[STDINFILE2]}"

    highest=9999

    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      [[ -z ${prevpath} ]] && {
        prevpath=("${path[@]}")
        highest=$((${#path[*]} - 1))
        continue
      }

      pathlen=$((${#path[*]} - 1))

      for i in $(seq 0 "${pathlen}"); do
        [[ ${path[i]} != "${prevpath[i]}" ]] && {
          high=${i}
          break
        }
      done

      [[ ${high} -lt ${highest} ]] && highest=${high}

      prevpath=("${path[@]}")
    done <"${JSONPath[STDINFILE2]}"

    if [[ ${highest} -gt 0 ]]; then
      sed -r 's/\[(([0-9]+|"[^"]+")[],]){'$((highest))'}(.*)/[\3/' \
        "${JSONPath[STDINFILE2]}"
    else
      cat "${JSONPath[STDINFILE2]}"
    fi
  else
    cat
  fi
}

# JSONPath_indexmatcher is for double digit or greater indexes match each line
# individually Single digit indexes are handled more efficiently by regex
JSONPath_indexmatcher() {

  local a b

  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
      echo "INDEXMATCH_QUERY[${i}]=${INDEXMATCH_QUERY[i]}" >/dev/stderr
    done
  }

  matched=1

  step=
  if [[ ${#INDEXMATCH_QUERY[*]} -gt 0 ]]; then
    while read -r line; do
      for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
        [[ ${INDEXMATCH_QUERY[i]#*:} =~ : ]] && {
          step=${INDEXMATCH_QUERY[i]##*:}
          step=${step%]}
          INDEXMATCH_QUERY[i]="${INDEXMATCH_QUERY[i]%:*}]"
        }
        q=${INDEXMATCH_QUERY[i]:1:-1} # <- strip '[' and ']'
        a=${q%:*}                     # <- number before ':'
        b=${q#*:}                     # <- number after ':'
        [[ -z ${b} ]] && b=99999999999
        readarray -t num < <((grep -Eo '[0-9]+[],]' | tr -d ,]) <<<"${line}")
        if [[ ${num[i]} -ge ${a} && ${num[i]} -lt ${b} && matched -eq 1 ]]; then
          matched=1
          [[ ${i} -eq $((${#INDEXMATCH_QUERY[*]} - 1)) ]] && {
            if [[ ${step} -gt 1 ]]; then
              [[ $(((num[i] - a) % step)) -eq 0 ]] && {
                [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
                echo "${line}"
              }
            else
              [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
              echo "${line}"
            fi
          }
        else
          matched=0
          continue
        fi
      done
      matched=1
    done
  else
    cat -
  fi
}

JSONPath_brief() {
  # Only show the value

  if [[ ${JSONPath[BRIEF]} -eq 1 ]]; then
    sed 's/^[^\t]*\t//;s/^"//;s/"$//;'
  else
    cat
  fi
}

JSONPath_json() {
  # Turn output into JSON

  local a tab="$'\t'"
  local UP=1 DOWN=2 SAME=3
  local prevpathlen=-1 prevpath=() path a
  declare -a closers

  if [[ ${JSONPath[JSON]} -eq 0 ]]; then
    cat -
  else
    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      value=${line#*${tab}}

      # Not including the object itself (last item)
      pathlen=$((${#path[*]} - 1))

      # General direction

      direction=${SAME}
      [[ ${pathlen} -gt ${prevpathlen} ]] && direction=${DOWN}
      [[ ${pathlen} -lt ${prevpathlen} ]] && direction=${UP}

      # Handle jumps UP the tree (close previous paths)

      [[ ${prevpathlen} != -1 ]] && {
        for i in $(seq 0 $((pathlen - 1))); do
          [[ ${prevpath[i]} == "${path[i]}" ]] && continue
          [[ ${path[i]} != '"'* ]] && {
            # Testing double quotes:
            a="(${!arrays[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                arrays[k]=
              done
            }
            a="(${!comma[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                comma[k]=
              done
            }
            for j in $(seq $((prevpathlen)) -1 $((i + 2))); do
              arrays[j]=
              [[ -n ${closers[j]} ]] && {
                indent=$((j * 4))
                printf "\n%${indent}s${closers[j]}" ""
                unset "closers[j]"
                comma[j]=
              }
            done
            direction=${DOWN}
            break
          }
          direction=${DOWN}
          for j in $(seq $((prevpathlen)) -1 $((i + 1))); do
            arrays[j]=
            [[ -n ${closers[j]} ]] && {
              indent=$((j * 4))
              printf "\n%${indent}s${closers[j]}" ""
              unset "closers[j]"
              comma[j]=
            }
          done
          a="(${!arrays[*]})"
          [[ -n ${a} ]] && {
            for k in $(seq "${i}" "${a[-1]}"); do
              arrays[k]=
            done
          }
          break
        done
      }

      [[ ${direction} -eq ${UP} ]] && {
        [[ ${prevpathlen} != -1 ]] && comma[prevpathlen]=
        for i in $(seq $((prevpathlen + 1)) -1 $((pathlen + 1))); do
          arrays[i]=
          [[ -n ${closers[i]} ]] && {
            indent=$((i * 4))
            printf "\n%${indent}s${closers[i]}" ""
            unset "closers[i]"
            comma[i]=
          }
        done
        a="(${!arrays[*]})"
        [[ -n ${a} ]] && {
          for k in $(seq "${i}" "${a[-1]}"); do
            arrays[k]=
          done
        }
      }

      # Opening braces (the path leading up to the key)

      broken=
      for i in $(seq 0 $((pathlen - 1))); do
        [[ -z ${broken} && ${prevpath[i]} == "${path[i]}" ]] && continue
        [[ -z ${broken} ]] && {
          broken=${i}
          [[ ${prevpathlen} -ne -1 ]] && broken=$((i + 1))
        }
        if [[ ${path[i]} == '"'* ]]; then
          # Object
          [[ ${i} -ge ${broken} ]] && {
            indent=$((i * 4))
            printf "${comma[i]}%${indent}s{\n" ""
            closers[i]='}'
            comma[i]=
          }
          indent=$(((i + 1) * 4))
          printf "${comma[i]}%${indent}s${path[i]}:\n" ""
          comma[i]=",\n"
        else
          # Array
          if [[ ${arrays[i]} != 1 ]]; then
            indent=$((i * 4))
            printf "%${indent}s" ""
            echo "["
            closers[i]=']'
            arrays[i]=1
            comma[i]=
          else
            indent=$(((i + 1) * 4))
            printf "\n%${indent}s${closers[i - 1]}" ""
            direction=${DOWN}
            comma[i + 1]=",\n"
          fi
        fi
      done

      # keys & values

      if [[ ${path[-1]} == '"'* ]]; then
        # Object
        [[ ${direction} -eq ${DOWN} ]] && {
          indent=$((pathlen * 4))
          printf "${comma[pathlen]}%${indent}s{\n" ""
          closers[pathlen]='}'
          comma[pathlen]=
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${path[-1]}:${value}"
        comma[pathlen]=",\n"
      else
        # Array
        [[ ${arrays[i]} != 1 ]] && {
          indent=$(((pathlen - 0) * 4))
          printf "%${indent}s[\n" ""
          closers[pathlen]=']'
          comma[pathlen]=
          arrays[i]=1
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${value}"
        comma[pathlen]=",\n"
      fi

      prevpath=("${path[@]}")
      prevpathlen=${pathlen}
    done

    # closing braces

    for i in $(seq $((pathlen)) -1 0); do
      indent=$((i * 4))
      printf "\n%${indent}s${closers[i]}" ""
    done
    echo
  fi
}

JSONPath_filter() {
  # Apply the query filter

  local a tab=$'\t' v

  [[ ${JSONPath[NOCASE]} -eq 1 ]] && opts+="i"
  [[ ${JSONPath[WHOLEWORD]} -eq 1 ]] && opts+="w"
  if [[ -z ${OPERATOR} ]]; then
    [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && FILTER="${FILTER}[\"]?$"
    grep "-E${opts}" "${FILTER}"
    [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
  else
    grep "-E${opts}" "${FILTER}" |
      while read -r line; do
        v=${line#*${tab}}
        case ${OPERATOR} in
        '-ge')
          if gawk '{exit !($1>=$2)}' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-gt')
          if gawk '{exit !($1>$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-le')
          if gawk '{exit !($1<=$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-lt')
          if gawk '{exit !($1<$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '>')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} > ${RHS,,} ]] && echo "${line}"
          ;;
        '<')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} < ${RHS,,} ]] && echo "${line}"
          ;;
        *) return 1 ;;
        esac
      done
  fi
}

JSONPath_parse() {
  # Parses json

  read -r token
  JSONPath_parse_value
  read -r token
  case "${token}" in
  '') ;;
  *)
    JSONPath_throw "EXPECTED EOF GOT ${token}"
    exit 1
    ;;
  esac
}

JSONPath_throw() {
  echo "$*" >&2
  exit 1
}

JSONPath_new || exit 1

# vi: expandtab sw=2 ts=2
# shellcheck shell=bash disable=SC2148
# MA - execution starts here

# MA is an associative array that holds data specific to this file
declare -A _MA

# Defined in GL (globals.sh)
declare OK ERROR STOP STDERR TRUE __mokostype

# Getters/Setters -------------------------------------------------------------

# MA_program_args getter outputs the program arguments sent by the user.
MA_program_args() {
  printf '%s' "${_MA[program_args]}"
}

# MA_arg_1 getter outputs the first argument sent by the user.
# Used by _CU_podman_checks so it doesn't check for a podman machine
# if we're running 'machine' commands
MA_arg_1() {
  printf '%s' "${_MA[arg_1]}"
}

# MA_program_name getter outputs the name of the program.
MA_program_name() {
  printf '%s' "${_MA[arg_0]##*/}"
}

# MA_ostype getter outputs the OS type.
MA_ostype() {
  printf '%s' "${_MA[ostype]}"
}

# Public Functions ------------------------------------------------------------

# main is the start point for this application.
# Args: arg1-N - the command line arguments entered by the user.
MA_main() {
  local retval="${OK}"

  CU_podman_or_docker

  trap MA_cleanup EXIT
  MA_sanity_checks || return
  PA_run "$@" || retval=$?

  exit "${retval}"
}

# MA_version outputs the version information the exits.
MA_version() {
  printf 'Version: %s\n' "${MOKVERSION}"
  exit "${OK}"
}

# MA_process_global_options is called by the parser when a global option is
# encountered for processing.
# Args: arg1 - the global option that was found.
MA_process_global_options() {
  case "$1" in
  -h | --help)
    PA_usage
    return "${STOP}"
    ;;
  -p | --plain)
    UT_set_plain "${TRUE}"
    ;;
  *)
    printf 'INTERNAL ERROR: Invalid global option, "%s".' "$1"
    return "${ERROR}"
    ;;
  esac
}

# MA_cleanup is called from an EXIT trap only, when the program exits, and
# calls every other function matching the pattern '^.._cleanup'.
# Args: No args expected.
MA_cleanup() {
  local retval="${OK}" funcs func
  funcs=$(declare -F | awk '{print $NF;}' | grep '^.._cleanup')
  for func in ${funcs}; do
    [[ ${func} == "${FUNCNAME[0]}" ]] && continue
    eval "${func}" || retval=$?
  done
  return "${retval}"
}

# MA_sanity_checks is expected to run some quick and simple checks to
# see if key components are available before MA_main is called.
# Args: No args expected.
MA_sanity_checks() {

  local binary binaries

  if [[ $(CU_podmantype) == "native" ]]; then
    binaries="gawk tac column tput grep sed ip cut"
  else
    binaries="gawk tac column tput grep sed cut"
  fi

  for binary in ${binaries}; do
    if ! command -v "${binary}" >&/dev/null; then
      printf 'ERROR: "%s" binary not found in path. Aborting.' "${binary}" \
        >"${STDERR}"
      return "${ERROR}"
    fi
  done

  # Disable terminal escapes (colours) if stdout is not a terminal
  [ -t 1 ] || UT_disable_colours
}

# MA_usage outputs help text for all components then quits with no error.  This
# is registered as a callback in the Parser, see _MA_new
# Args: None expected.
MA_usage() {

  cat <<'EnD'
Usage: mok [-h] <command> [subcommand] [ARGS...]
 
Global options:
  --help
  -h     - This help text
  --plain
  -p     - Plain output. No colours or animations.
 
Where command can be one of:
  create  - Add item(s) to the system.
  delete  - Delete item(s) from the system.
  build   - Build item(s) used by the system.
  get     - Get details about items in the system.
  exec    - 'Log in' to the container.
  machine - Manage a podman machine (MacOS only).
  version - Display version information.

For help on a specific command, run:
  mok <command> --help
EnD
}

# MA_new sets the initial values for the _MA associative array
_MA_new() {
  _MA[program_args]="$*"
  _MA[arg_0]="$0"
  _MA[arg_1]="$1"
  _MA[ostype]="${__mokostype}" # linux or macos

  # Program the parser's state machine
  PA_add_state "COMMAND" "version" "END" "MA_version"

  # Set up the parser's option callbacks
  PA_add_option_callback "" "MA_process_global_options"

  # Set up the parser's usage callbacks
  PA_add_usage_callback "" "MA_usage"
}

# Initialise _MA
_MA_new "$@" || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
if [ "$0" = "${BASH_SOURCE[0]}" ] || [ -z "${BASH_SOURCE[0]}" ]; then
  MA_main "$@"
fi
