#!/usr/bin/env bash
# shellcheck shell=bash disable=SC2148
# PA - PArser

# _PA holds data specific to parsing the command line arguments.
declare -A _PA

# Declare externally defined variables ----------------------------------------

# Defined in ER (globals.sh)
declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# PA_command getter outputs the _PA[command] array member. This contains the
# command the user requested.
PA_command() {
  printf '%s' "${_PA[command]}"
}

# PA_subcommand getter outputs the _PA[subcommand] array member. This contains
# the subcommand the user requested.
PA_subcommand() {
  printf '%s' "${_PA[subcommand]}"
}

# PA_shift outputs the _PA[shift] array member, returned by the caller
# when an extra shift is required whilst consuming option values.
#
# Example code:
# ```
#XX_process_options_callback() {
#
#  case "$1" in
#  -h | --help)
#    CC_usage
#    return "${STOP}"
#    ;;
#    ... omitted ...
#  --k8sver)
#    _CC[k8sver]="$2"
#    return "$(PA_shift)"
#    ;;
#  --with-lb)
#    ... omitted ..
# ```
PA_shift() {
  printf '%s' "${_PA[shift]}"
}

# PA_set_state setter sets the initial state of the parser, which should be one
# of COMMAND, SUBCOMMAND, or ARG1.
# Args: arg1 - the initial state to set.
PA_set_state() {
  _PA[state]="$1"
}

# Public Functions ------------------------------------------------------------

# PA_add_option_callback adds a callback to the list of callbacks used for
# processing options.
# Args: arg1 - Null string (for global options), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_option_callback() {
  _PA[optscallbacks]+="$1,$2 "
}

# PA_add_usage_callback adds a callback to the list of callbacks used for
# output of help text.
# Args: arg1 - Null string (for global help), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_usage_callback() {
  _PA[usagecallbacks]+="$1,$2 "
}

# PA_add_state adds a callback to the list of callbacks used for
# programming the state machine.
# Args: arg1 - Current state to match.
#       arg2 - The value of the state to match.
#       arg3 - The new state if arg1 and arg2 match.
#       arg4 - The function to call, optional.
PA_add_state() {
  _PA[statecallbacks]+="$1,$2,$3,$4 "
}

# PA_add_run_callback adds a callback to the list of callbacks used for
# running the user defined entrypoint function.
# Args: arg1 - The value of the state to match. Probably like:
#              "commandsubcommand" "function"
#       arg2 - The function to call.
PA_add_run_callback() {
  _PA[runcallbacks]+="$1,$2 "
}

# PA_run implements an interleaved state machine to process the
# user request. It allows for strict checking of arguments and args. All
# command line arguments are processed in order from left to right.
#
# Each COMMAND can have a different set of requirements which are controlled
# by setting the next state at each transition.
#
# --global-options COMMAND --command-options SUBCOMMAND --subcommand-options \
#  ARG1 --subcommand-options ARG2 --subcommand-options ...
#
# --global-options are those before COMMAND.
# --command-options can be after the COMMAND but before SUBCOMMAND.
# --subcommand-options can be anywhere after the SUBCOMMAND.
#
# Args: arg1-N - The arguments given to mok by the user on the command line
PA_run() {

  local retval=${OK}

  set -- "$@"
  local ARGN=$# ARGNUM=0 retval=0
  while [ "${ARGN}" -ne 0 ]; do
    case "$1" in
    --* | -*)
      _PA_process_option "$1" "$2" || {
        retval=$?
        if [[ ${retval} == "${_PA[shift]}" ]]; then
          ARGN=$((ARGN - 1))
          shift
        else
          return "${retval}"
        fi
      }
      ;;
    *)
      case "${_PA[state]}" in
      COMMAND)
        _PA_check_token "${1}" "COMMAND" "command"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid COMMAND, "%s".\n\n' "$1" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      SUBCOMMAND)
        _PA_check_token "$1" "SUBCOMMAND" "subcommand"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid SUBCOMMAND for %s, "%s".\n\n' "${_PA[command]}" "${1}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      ARG*)
        ((ARGNUM++))
        _PA_check_token "${1}" "ARG${ARGNUM}"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid ARG1 for %s %s, "%s".\n\n' "${_PA[command]}" \
            "${_PA[subcommand]}" "${1}" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      END)
        PA_usage
        printf 'ERROR No more args expected, "%s" is unexpected for "%s %s"\n' \
          "${1}" "${_PA[command]}" "${_PA[subcommand]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      *)
        printf 'Internal ERROR. Invalid state "%s"\n' "${_PA[state]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      esac
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done

  # Run the user defined entrypoint function:
  for item in ${_PA[runcallbacks]}; do
    IFS=, read -r stateval func <<<"${item}"
    [[ ${stateval} == "${_PA[command]}${_PA[subcommand]}" ]] && {
      eval "${func}" || retval=$?
      return "${retval}"
    }
  done

  PA_usage

  return "${OK}"
}

# PA_usage outputs help text for a single component if help was asked for when
# a command was specified, or for all components otherwise.
# Args: None expected.
PA_usage() {

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[usagecallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func}"
      return
    }
  done

  eval "${_PA[usage]}"
}

# Private Functions -----------------------------------------------------------

# PA_new sets the initial values for the PArser's associative array.
# Args: None expected.
_PA_new() {
  _PA[command]=
  _PA[subcommand]=
  _PA[state]="COMMAND"
  _PA[optscallbacks]=
  _PA[usagecallbacks]=
  _PA[statecallbacks]=
  _PA[runcallbacks]=
  # The return value if the caller asked for an extra shift:
  _PA[shift]=126
}

# _PA_check_token checks for a valid token in arg2 state. The logic is
# most easily understood by reading the full original version at:
# https://github.com/mclarkson/my-own-kind/blob/master/docs/package.md#scripted-cluster-creation-and-deletion
# This function is a reduction of all the check_xxx_token functions.
# Args: arg1 - the token to check.
#       arg2 - the current state.
#       arg3 - the state value to set, optional. This should only be sent
#              for command and subcommand states.
_PA_check_token() {

  local item

  if [[ -n ${_PA[subcommand]} ]]; then
    cmdsubcommand="${_PA[command]}${_PA[subcommand]}"
  elif [[ -n ${_PA[command]} && ${_PA[state]} != "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}$1"
  elif [[ -n ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}"
  elif [[ -z ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand=
  else
    cmdsubcommand="$1"
  fi

  for item in ${_PA[statecallbacks]}; do
    IFS=, read -r state component newstate func <<<"${item}"
    [[ ${state} == "$2" ]] && {
      [[ ${component} == "${cmdsubcommand}" ]] && {
        [[ -n $3 ]] && _PA["$3"]="$1"
        _PA[state]="${newstate}"
        [[ -n ${func} ]] && {
          eval "${func} $1" || return
        }
        return "${OK}"
      }
    }
  done
}

# _PA_process_option checks that the user-provided option is valid for the
# command-subcommand or global states.
# Args: arg1 - The option to check.
#       arg2 - TODO The value of the option if present, optional.
_PA_process_option() {

  local item curcmdsubcmd

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[optscallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func} \"$1\" \"$2\""
      return $?
    }
  done

  return "${ERROR}"
}

# Initialise _PA
_PA_new

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GL - Globals

# Private Functions -----------------------------------------------------------

# GL_new sets the only global variables that should be in use anywhere.  The
# only other globals are the associative arrays. All the globals are constant
# (readonly) variables. Declare these globals, where needed, in other files
# so that shellcheck passes.
# Args: None expected.
_GL_new() {

  declare -rg MOKVERSION="0.8.19"
  declare -rg K8SVERSION="1.31.1"
  declare -rg GO_VERSION="1.23.2"

  # Returns, exit codes
  declare -rg OK=0
  declare -rg SUCCESS=0
  declare -rg ERROR=1
  declare -rg FAILURE=1

  # For setting flags
  declare -rg TRUE=1
  declare -rg FALSE=0

  # To signal main() to exit with SUCCESS in the PArser
  declare -rg STOP=2

  declare -rg STDOUT="/dev/stdout"
  declare -rg STDERR="/dev/stderr"

  # The following just keep shellcheck happy
  local dummy dumb
  dummy="${OK}"
  dummy="${ERROR}"
  dummy="${STOP}"
  dummy="${STDOUT}"
  dummy="${STDERR}"
  dummy="${TRUE}"
  dummy="${FALSE}"
  dummy="${SUCCESS}"
  dummy="${FAILURE}"
  dummy="${MOKVERSION}"
  dummy="${GO_VERSION}"
  dummy="${K8SVERSION}"
  dumb="${dummy}${dumb}"
}

# Initialise GL
_GL_new || exit 1

# vim helpers -----------------------------------------------------------------

# The following lines allow the use of '[C-i' and '[I' (do ':help [I') in vim.
#include buildimage.sh
#include containerutils.sh
#include createcluster.sh
#include deletecluster.sh
#include embed-dockerfile.sh
#include error.sh
#include exec.sh
#include getcluster.sh
#include main.sh
#include lib/parser.sh
#include util.sh
#include versions.sh

# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# ER - Error handling

# ER is an associative array that holds data specific to error handling.
declare -A ER

# Declare externally defined associative arrays -------------------------------

# Defined in GL (globals.sh)
declare ERROR TRUE STDERR

# Public Functions ------------------------------------------------------------

# ER_err outputs a stacktrace and returns ERROR status.
# Args: None expected.
ER_err() {

  # In case of error print the function call stack
  # No args expected

  [[ ${ER[errcalled]} == "${TRUE}" ]] && return "${ERROR}"
  ER[errcalled]="${TRUE}"
  local frame=0
  printf '\n' >"${STDERR}"
  while caller "${frame}"; do
    ((frame++))
  done | tac >"${STDERR}"
  printf '\n' >"${STDERR}"
  return "${ERROR}"
}

# err is a synonym for ER_err to aid with code readability.
err() {
  ER_err
  return
}

# Private Functions -----------------------------------------------------------

# ER_new sets the initial values for the ER associative array.
# Args: None expected.
_ER_new() {
  ER[errcalled]=
}

# Initialise ER
_ER_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# UT - Utilities

# _UT is an associative array that holds data specific to general utilities.
declare -A _UT

# Declare externally defined global variables ---------------------------------

declare OK STDERR FALSE TRUE

# Getters/Setters -------------------------------------------------------------

# UT_runlogfile getter outputs the value of _UT[runlogfile], which contains the
# name of the file written to when running UT_run_with_progress.
UT_runlogfile() {
  printf '%s' "${_UT[runlogfile]}"
}

# UT_tailf getter indicates whether a log will be shown in real-time during the
# 'run', TRUE, or not, FALSE.
# Args
UT_tailf() {
  printf '%s' "${_UT[tailf]}"
}

# UT_tailf setter indicates whether a log should be shown during the 'run',
# TRUE, or not, FALSE.
# Args: arg1 - Whether to tail, TRUE or FALSE.
UT_set_tailf() {
  _UT[tailf]="$1"
}

# UT_set_plain setter sets plain output, with no colour, animations, or UTF
# high byte characters.
# Args: arg1 - Whether to show plain output, TRUE or FALSE.
UT_set_plain() {
  _UT[plain]="$1"
  UT_disable_colours
}

# Public Functions ------------------------------------------------------------

# UT_disable_colours resets variables used for colourised output so that they
# contain no colour terminal escapes. Useful if stdin is not a terminal.
UT_disable_colours() {
  _UT[yellow]=
  _UT[green]=
  _UT[red]=
  _UT[normal]=
  _UT[probablysuccess]="PROBABLY SUCCESS (!)"
  _UT[success]="SUCCESS"
  _UT[failure]="FAIL"
}

# UT_run_with_progress displays a progress spinner, item text, and a tick or
# cross based on the exit code.
# Args: arg1   - the text to display.
#       arg2-N - remaining args are the program to run and its arguments.
UT_run_with_progress() {

  local displaytext=$1 retval int spinner=()

  _UT[runlogfile]=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }
  shift

  if [[ ${_UT[tailf]} == "${FALSE}" && ${_UT[plain]} == "${TRUE}" ]]; then

    # Output with no colours or spinny

    printf '%s' "${displaytext}"

    eval "$*" &>"${_UT[runlogfile]}"
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 0 ]]; then
      printf ' .. %s\n' "${_UT[success]}"
    else
      printf ' .. %s\n' "${_UT[failure]}"
    fi

  elif [[ ${_UT[tailf]} == "${FALSE}" ]]; then

    # Output with colours and spinny

    while read -r char; do
      spinner+=("${char}")
    done <<<"$(grep -o . <<<"${_UT[spinnerchars]}")"

    (
      eval "$*" &>"${_UT[runlogfile]}"
    ) &

    # Turn the cursor off
    tput civis

    # Start the spin animation
    printf ' %s' "${displaytext}"
    (while true; do
      for int in {0..3}; do
        printf '\r  %s ' "${spinner[int]}"
        sleep .1
      done
    done) &
    _UT[spinnerpid]=$!
    disown

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Kill the spinner
    kill "${_UT[spinnerpid]}" 2>/dev/null
    _UT[spinnerpid]=

    sleep .5

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\r  %s\n' "${_UT[probablysuccess]}"
    elif [[ ${retval} -eq 0 ]]; then
      printf '\r  %s\n' "${_UT[success]}"
    else
      printf '\r  %s\n' "${_UT[failure]}"
    fi

    # Restore the cursor
    tput cnorm
    sleep .5

  else

    # Tailf output

    printf 'COMMAND: %s\n\n' "$*"

    (
      eval "$*" &>/dev/stdout
    ) &
    sleep 1

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\n\nSTATUS: OK - (Probably)\n\n'
    elif [[ ${retval} -eq 0 ]]; then
      printf '\n\nSTATUS: OK\n\n'
    else
      printf '\n\nSTATUS: FAIL\n\n'
    fi
  fi

  return "${retval}"
}

# UT_cleanup removes any artifacts that were created during execution.
# This is called by 'MA_cleanup' trap only.
UT_cleanup() {

  # Called when the script exits.

  local int

  # Kill the spinny, and anything else, if they're running
  if [[ ${_UT[tailf]} == "${FALSE}" ]]; then
    [[ -n ${_UT[spinnerpid]} ]] && {
      printf '%s\r  ✕%s\n' "${_UT[red]}" "${_UT[normal]}"
      kill "${_UT[spinnerpid]}"
    }
    # If progress spinner crashed make sure the cursor is shown
    [ -t 1 ] && tput cnorm
  else
    kill "${_UT[spinnerpid]}" &>/dev/null
  fi

  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _UT_new sets the initial values for the _UT associative array.
# Args: None expected.
_UT_new() {
  _UT[tailf]="${FALSE}"
  _UT[yellow]=$(tput setaf 3)
  _UT[green]=$(tput setaf 2)
  _UT[red]=$(tput setaf 1)
  _UT[normal]=$(tput sgr0)
  _UT[probablysuccess]="${_UT[yellow]}✓${_UT[normal]}"
  _UT[success]="${_UT[green]}✓${_UT[normal]}"
  _UT[failure]="${_UT[red]}✕${_UT[normal]}"
  _UT[runlogfile]=
  _UT[spinnerchars]="|/-\\"
  _UT[spinnerpid]=
}

# Initialise _UT
_UT_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GC - Get Cluster

# _GC is an associative array that holds data specific to the get cluster command.
declare -A _GC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# GC_showheader getter outputs the value of the showheader array member.
GC_showheader() {
  printf '%s' "${_GC[showheader]}"
}

# GC_set_showheader setter sets the value of the showheader array member.
# If $TRUE the header will be shown, or $FALSE, then it won't be shown.
GC_set_showheader() {
  _GC[showheader]="$1"
}

# GC_set_clustername setter sets the cluster name to show information about.
GC_set_clustername() {
  _GC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# GC_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted. It is called by
# MA_cleanup.
GC_cleanup() {
  :
}

# GC_process_options checks if arg1 is in a list of valid get cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
GC_process_options() {

  case "$1" in
  -h | --help)
    GC_usage
    return "${STOP}"
    ;;
  *)
    GC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# GC_usage outputs help text for the create cluster component.
# It is called by PA_usage().
# Args: None expected.
GC_usage() {

  cat <<'EnD'
GET subcommands are:
 
  cluster(s) - list all mok managed clusters.
 
get cluster(s) options:
 
 Format:
  get cluster(s) [NAME]
  NAME        - (optional) The name of the cluster to get
                details about.

EnD
}

# GC_run gets information about cluster(s).
# This function is called in main.sh.
# Args: None expected.
GC_run() {

  _GC_sanity_checks || return

  local ids id info output labelkey
  local containerhostname containerip

  declare -a nodes

  ids=$(CU_get_cluster_container_ids "${_GC[clustername]}") || return

  if [[ -z ${ids} ]]; then
    printf 'No clusters found\n'
    return "${OK}"
  fi

  readarray -t nodes <<<"${ids}"

  # Use 'docker inspect' to get the value of the label $LABELKEY

  output=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  # Output the header
  [[ ${_GC[showheader]} -eq ${TRUE} ]] && {
    printf 'MOK_Cluster Docker_ID Container_Name IP_Address\n' >"${output}"
  }

  labelkey=$(CU_labelkey) || err || return

  for id in "${nodes[@]}"; do

    info=$(CU_get_container_info "${id}") || return

    clustname=$(JSONPath ".[0].Config.Labels.${labelkey}" -b <<<"${info}") ||
      err || return

    containerhostname=$(JSONPath '.[0].Config.Hostname' -b <<<"${info}") ||
      err || return

    containerip=$(JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}") ||
      err || return

    printf '%s %s %s %s\n' "${clustname}" "${id}" "${containerhostname}" "${containerip}"

  done | sort -k 3 >>"${output}"

  column -t "${output}" || err
}

# Private Functions -----------------------------------------------------------

# _GC_new sets the initial values for the _GC associative array.
# Args: None expected.
_GC_new() {
  _GC[showheader]="${TRUE}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "get" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "getcluster" "ARG1" ""
  PA_add_state "SUBCOMMAND" "getclusters" "ARG1" ""
  PA_add_state "ARG1" "getcluster" "END" "GC_set_clustername"
  PA_add_state "ARG1" "getclusters" "END" "GC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "get" "GC_process_options" || return
  PA_add_option_callback "getcluster" "GC_process_options" || return
  PA_add_option_callback "getclusters" "GC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "get" "GC_usage" || return
  PA_add_usage_callback "getcluster" "GC_usage" || return
  PA_add_usage_callback "getclusters" "GC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "getcluster" "GC_run"
  PA_add_run_callback "getclusters" "GC_run"
}

# GC_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_GC_sanity_checks() {

  # Only show the usage if we are in 'get' mode and have not specified a
  # subcommand. This allows internal code to call GC_run()
  if [[ $(PA_command) == "get" && -z $(PA_subcommand) ]]; then
    GC_usage
    exit "${OK}"
  fi
}

# Initialise _GC
_GC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# EX - EXec

# EX is an associative array that holds data specific to the exec cluster command.
declare -A _EX

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# EX_set_containername setter sets the containername to be used to 'log in' to.
EX_set_containername() {
  _EX[containername]="$1"
}

# Public Functions ------------------------------------------------------------

# EX_process_options checks if arg1 is in a list of valid exec options. This
# function is called by the parser, via a callback in _EX_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
EX_process_options() {

  case "$1" in
  -h | --help)
    EX_usage
    return "${STOP}"
    ;;
  *)
    EX_usage
    printf 'ERROR: "%s" is not a valid "exec" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# EX_usage outputs help text for the create exec component.  It is called in
# this file and by PA_usage(), via a callback in _EX_new.
# Args: None expected.
EX_usage() {

  cat <<'EnD'
'Log in' to a container. EXEC has no subcommands.
 
exec options:
 
 Format:
  exec [NAME]
  NAME        - (optional) The name of the container to 'log in' to.
                If NAME is not given then the user will be offered
                a choice of containers to log in to. If there is only
                one cluster and one node then it will 'log in' to the
                only available container.

EnD
}

# Execs 'bash' in the container referenced by _EX[containername]. If just
# 'mok exec' is called without options then the user is offered a selection
# of existing clusters to exec into.
# Args: None expected.
# ---------------------------------------------------------------------------
EX_run() {

  _EX_sanity_checks || return

  local names int ans lines containernames gcoutput

  GC_set_showheader "${TRUE}" || err || return
  gcoutput=$(GC_run) || return
  names=$(printf '%s' "${gcoutput}" | awk '{ print $3; }')
  readarray -t containernames <<<"${names}"

  if [[ -n ${_EX[containername]} ]]; then

    # The caller gave a specific name for exec.
    # Check if the container name exists

    if grep -qs "^${_EX[containername]}$" <<<"${names}"; then
      _EX_exec "${_EX[containername]}" || return
      return "${OK}"
    else
      printf 'ERROR: Cannot exec into non-existent container: "%s".\n' \
        "${_EX[containername]}"
      return "${ERROR}"
    fi

  elif [[ ${#containernames[*]} == 2 ]]; then

    # If there's only one container just log into it without asking
    _EX_exec "${containernames[1]}"

  elif [[ ${#containernames[*]} == 1 ]]; then

    printf 'No containers found.\n'
    return "${OK}"

  else

    # The caller supplied no container name.
    # Present some choices

    printf 'Choose the container to log in to:\n\n'

    readarray -t lines <<<"${gcoutput}" || return

    # Print the header then print the items in the loop
    printf '   %s\n' "${lines[0]}"
    for int in $(seq 1 $((${#lines[*]} - 1))); do
      printf '%00d) %s\n' "${int}" "${lines[int]}"
    done | sort -k 4

    printf "\nChoose a number (Enter to cancel)> "
    read -r ans

    [[ -z ${ans} || ${ans} -lt 0 || ${ans} -gt $((${#lines[*]} - 1)) ]] && {
      printf '\nInvalid choice. Aborting.\n'
      return "${OK}"
    }

    _EX_exec "${containernames[ans]}"
  fi
}

# Private Functions -----------------------------------------------------------

# _EX_new sets the initial values for the _EX associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
_EX_new() {
  _EX[containername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "exec" "ARG1" ""
  PA_add_state "ARG1" "exec" "END" "EX_set_containername"

  # Set up the parser's option callbacks
  PA_add_option_callback "exec" "EX_process_options" || return
  PA_add_usage_callback "exec" "EX_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "exec" "EX_run"
}

# EX_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For exec this does nothing.
# Args: None expected.
_EX_sanity_checks() { :; }

# _EX_exec runs a command in a docker container using bash as the command by
# default.
# Args: arg1 - docker container name
#       arg2 - command to run
_EX_exec() {

  local cmd=${2:-bash}

  containerrt=$(CU_containerrt) || err || return

  read -rt 0.1
  if [[ ${containerrt} == "podman" ]]; then
    exec podman exec -ti "$1" "${cmd}"
  elif [[ ${containerrt} == "docker" ]]; then
    exec docker exec -ti "$1" "${cmd}"
  fi
}

# Initialise EX
_EX_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# DC - Delete Cluster

# _DC is an associative array that holds data specific to deleting a cluster.
declare -A _DC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR STOP TRUE

# Getters/Setters -------------------------------------------------------------

# DC_set_clustername setter sets the cluster name to be deleted. This is
# called by the parser, via a callback in _DC_new.
DC_set_clustername() {
  _DC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# DC_process_options checks if arg1 is in a list of valid delete cluster
# options. This function is called by the parser, via a callback in _DC_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
DC_process_options() {

  case "$1" in
  -h | --help)
    DC_usage
    return "${STOP}"
    ;;
  *)
    DC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# DC_usage outputs help text for the create cluster component.
# It is called by PA_usage(), via a callback in _DC_new.
# Args: None expected.
DC_usage() {

  cat <<'EnD'
DELETE subcommands are:
 
  cluster - Delete a local kubernetes cluster.
 
delete cluster options:
 
 Format:
  delete cluster NAME
  NAME        - The name of the cluster to delete

EnD
}

# DC_run starts the delete cluster process.
# Args: None expected.
DC_run() {

  _DC_sanity_checks || return

  # Mutate functions make system changes.

  declare -i numnodes=0
  local id ids r

  numnodes=$(CU_get_cluster_size "${_DC[clustername]}") || return

  [[ ${numnodes} -eq 0 ]] && {
    printf '\nERROR: No cluster exists with name, "%s". Aborting.\n\n' \
      "${_DC[clustername]}" >"${STDERR}"
    return "${ERROR}"
  }

  ids=$(CU_get_cluster_container_ids "${_DC[clustername]}") || return

  printf 'The following containers will be deleted:\n\n'

  GC_set_showheader "${TRUE}"
  GC_set_clustername "${_DC[clustername]}"
  GC_run "${_DC[clustername]}" || return

  printf "\nAre you sure you want to delete the cluster? (y/N) >"

  read -r ans

  [[ ${ans} != "y" ]] && {
    printf '\nCancelling by user request.\n'
    return "${OK}"
  }

  printf '\n'

  for id in ${ids}; do
    UT_run_with_progress \
      "    Deleting id, '${id}' from cluster '${_DC[clustername]}'." \
      _DC_delete "${id}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n\n' >"${STDERR}"
      err
      return "${r}"
    }
  done

  printf '\n'
}

# Private Functions -----------------------------------------------------------

# _DC_new sets the initial values for the _DC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_DC_new() {
  _DC[clustername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "delete" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "deletecluster" "ARG1" ""
  PA_add_state "ARG1" "deletecluster" "END" "DC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "delete" "DC_process_options" || return
  PA_add_option_callback "deletecluster" "DC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "delete" "DC_usage" || return
  PA_add_usage_callback "deletecluster" "DC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "deletecluster" "DC_run"
}

# DC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before DC_run is called.
# Args: None expected.
_DC_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    DC_usage
    exit "${OK}"
  fi

  if [[ -z ${_DC[clustername]} ]]; then
    DC_usage
    printf 'Please provide the Cluster NAME to delete.\n' >"${STDERR}"
    return "${ERROR}"
  fi
}

# _DC_delete stops and removes a docker container.
# Args: arg1 - docker id to delete.
_DC_delete() {

  docker stop -t 5 "${id}"
  docker rm "${id}" || err
}

# Initialise _DC
_DC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE K8SVERSION

# Getters/Setters -------------------------------------------------------------

# CC_set_clustername setter sets the clustername array item.
CC_clustername() {
  printf '%s' "${_CC[clustername]}"
}

# CC_publish getter outputs the publish array item.
CC_publish() {
  printf '%s' "${_CC[publish]}"
}

# CC-withlb getter outputs the withlb array item.
CC_withlb() {
  printf '%s' "${_CC[withlb]}"
}

# CC_set_clustername setter sets the clustername array item.
CC_set_clustername() {
  _CC[clustername]="$1"
}

# CC_set_nummasters setter sets the nummasters array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_nummasters() {
  _CC[nummasters]="$1"
}

# CC_set_numworkers setter sets the numworkers array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_numworkers() {
  _CC[numworkers]="$1"
}

# Public Functions ------------------------------------------------------------

# CC_process_options checks if arg1 is in a list of valid create cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option. For example, '--masters' should be sent
#              with a value but boolean options, like 'skiplbsetup' should not.
CC_process_options() {

  case "$1" in
  -h | --help)
    CC_usage
    return "${STOP}"
    ;;
  --skiplbsetup)
    _CC[skiplbsetup]="${TRUE}"
    return
    ;;
  --k8sver)
    _CC[k8sver]="$2"
    return "$(PA_shift)"
    ;;
  --with-lb)
    _CC[withlb]="${TRUE}"
    return
    ;;
  --skipmastersetup)
    _CC[skipmastersetup]="${TRUE}"
    return
    ;;
  --skipworkersetup)
    _CC[skipworkersetup]="${TRUE}"
    return
    ;;
  --masters)
    _CC[nummasters]="$2"
    return "$(PA_shift)"
    ;;
  --workers)
    _CC[numworkers]="$2"
    return "$(PA_shift)"
    ;;
  --tailf)
    _CC[tailf]="${TRUE}"
    return "${OK}"
    ;;
  --publish)
    _CC[publish]="${TRUE}"
    return
    ;;
  *)
    CC_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# CC_usage outputs help text for the create cluster component.  It is called in
# this file and by PA_usage(), via a callback set in _CC_new.
# Args: None expected.
CC_usage() {

  cat <<'EnD'
CREATE subcommands are:
 
  cluster - Create a local kubernetes cluster.
 
create cluster [flags] options:
 
 Format:
  create cluster NAME [ [NUM_MASTERS] [NUM_WORKERS] ]
  NAME        - The name of the cluster. This will be used as
                the prefix in the name for newly created
                docker containers.
  NUM_MASTERS - The number of master containers.
  NUM_WORKERS - The number of worker containers. If NUM_WORKERS is
                zero then the 'node-role.kubernetes.io/master' taint
                will be removed from master nodes so that pods are
                schedulable.
 
 Flags:
  --skipmastersetup - Create the master container but don't set it
         up. Useful for manually installing kubernetes. Kubeadm, 
         kubelet and kubectl will be installed at the requested 
         version. With this option the worker will also be skipped.
         See also '--k8sver' flag.
  --skipworkersetup - The same as '--skipmastersetup', but skips
         setting up the worker only.
  --with-lb - Add a haproxy load balancer. The software will be installed
         and set up to reverse proxy to the master node(s), unless
         --skiplbsetup is used.
  --k8sver VERSION - Unimplemented.
  --masters NUM - The number of master containers to create.
  --workers NUM - The number of worker containers to create. When workers
                  is zero then the master node taint will be removed from
                  master nodes so that pods are schedulable on those nodes.
  --tailf - Show the log output whilst creating the cluster.
  --publish - Publish port 6443 for the master node, or the load balancer if
              it's enabled, for external kubectl access to the cluster. The IP
              address of the default route interface is added to the cert.


EnD
}

# CC_run creates the kubernetes cluster.
# Args: None expected.
CC_run() {

  _CC_sanity_checks || return

  [[ ${_CC[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  declare -i numnodes=0

  numnodes=$(CU_get_cluster_size "${_CC[clustername]}") || return

  [[ ${numnodes} -gt 0 ]] && {
    printf '\nERROR: Cluster, "%s", exists! Aborting.\n\n' "${_CC[clustername]}" \
      >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_create_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_create_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_setup_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_setup_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[numworkers]} -gt 0 ]] && {
    _CC_create_worker_nodes "${_CC[numworkers]}" || return
  }

  printf '\n'

  [[ -z ${_CC[skipmastersetup]} ]] && {
    printf 'Cluster, "%s", can be accessed using:\n\n' "${_CC[clustername]}"
    printf 'export KUBECONFIG=/var/tmp/admin-%s.conf\n\n' "${_CC[clustername]}"
  }

  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CC_new sets the initial values for the _CC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_CC_new() {
  _CC[tailf]="${FALSE}"
  _CC[skipmastersetup]=
  _CC[skipworkersetup]=
  _CC[skiplbsetup]=
  _CC[withlb]=
  _CC[clustername]=
  _CC[nummasters]=0
  _CC[numworkers]=0
  _CC[publish]=0
  _CC[k8sver]="${K8SVERSION}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "create" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "createcluster" "ARG2" ""

  # Support for the legacy style of create (less to type):
  PA_add_state "ARG1" "createcluster" "ARG2" "CC_set_clustername"
  PA_add_state "ARG2" "createcluster" "ARG3" "CC_set_nummasters"
  PA_add_state "ARG3" "createcluster" "END" "CC_set_numworkers"

  # Set up the parser's option callbacks
  PA_add_option_callback "create" "CC_process_options" || return
  PA_add_option_callback "createcluster" "CC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "create" "CC_usage" || return
  PA_add_usage_callback "createcluster" "CC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "createcluster" "CC_run"
  PA_add_run_callback "createclusters" "CC_run"
}

# CC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before CC_run is called.
# Args: None expected.
_CC_sanity_checks() {

  declare -i host_max=0 cpus=0 should_be=0

  if [[ -z $(PA_subcommand) ]]; then
    CC_usage
    exit "${OK}"
  fi

  if [[ -z ${_CC[clustername]} ]]; then
    CC_usage
    printf 'Please provide the Cluster NAME to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[nummasters]} || ${_CC[nummasters]} -le 0 ]]; then
    CC_usage
    printf 'Please provide the number of Masters to create. Must be 1 or more.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[numworkers]} ]]; then
    CC_usage
    printf 'Please provide the number of Workers to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/sys/net/nf_conntrack_max ]]; then
    host_max=$(cat /proc/sys/net/nf_conntrack_max)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    host_max=$(podman machine ssh cat /proc/sys/net/nf_conntrack_max)
  else
    printf '\nWARNING: /proc/sys/net/nf_conntrack_max not found.\n' >"${STDERR}"
    printf '         kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/cpuinfo ]]; then
    cpus=$(grep -cw ^processor /proc/cpuinfo)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    cpus=$(podman machine ssh cat /proc/cpuinfo | grep -cw ^processor)
  else
    printf '\nWARNING: /proc/cpuinfo not found.\n' >"${STDERR}"
    printf '         I have no idea how many CPUs I have\n' >"${STDERR}"
    printf '         and kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  # These are the default values that kube-proxy expects:
  # conntrack:
  #   max: null
  #   maxPerCore: 32768
  #   min: 131072
  if [[ $((32768*cpus)) -lt 131072 ]]; then
    should_be=131072
  else
    should_be=$((32768*cpus))
  fi
  if [[ ${should_be} -ne $host_max ]]; then
    printf '\nERROR: /proc/sys/net/nf_conntrack_max should be set to %d.\n' \
      "${should_be}" >"${STDERR}"
    printf '     kube-proxy will not start with an incorrect nf_conntrack_max.\n' >"${STDERR}"
    printf '     To fix this, run the following command:\n\n' >"${STDERR}"
    if [[ ${_CU[podmantype]} == "native" ]]; then
      printf '       sudo sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
    elif [[ ${_CU[podmantype]} == "machine" ]]; then
      printf '       podman machine ssh sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
      printf '     If the above command fails, you may have to recreate the podman machine, for example:\n\n' >"${STDERR}"
      tput setaf 1 # red
      printf '     WARNING: The following commands will destroy your podman machine and all its data.\n' >"${STDERR}"
      printf '              All existing pods and containers will be gone.\n\n' >"${STDERR}"
      tput sgr0 # reset
      printf '       podman machine stop\n' >"${STDERR}"
      printf '       podman machine rm\n' >"${STDERR}"
      printf '       podman machine init --now --rootful --user-mode-networing\n' >"${STDERR}"
      printf '       podman machine ssh modprobe nf_conntrack\n' >"${STDERR}"
      printf '       podman machine ssh sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
    else
      printf 'Internal ERROR. Invalid podman type.\n' >"${STDERR}"
      return "${ERROR}"
    fi
    
    printf 'Press ENTER to continue or CTRL-C to abort.\n' >"${STDERR}"
    read -r
    printf '\n' >"${STDERR}"
  fi
}

# _CC_create_master_nodes creates the master node containers.
# Args: arg1 - number of master nodes to create
_CC_create_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating master container, '${_CC[clustername]}-master-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-master-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }
  done

  return "${OK}"
}

# _CC_setup_master_nodes sets up the master node containers.
# Args: arg1 - number of master nodes to create
_CC_setup_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile lbaddr hostaddr
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-master-${int}'" \
      _CC_set_up_master_node "${_CC[clustername]}-master-${int}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  done

  # For now, copy admin.conf from master to /var/tmp/admin-CLUSTERNAME.conf

  if [[ -z ${_CC[skipmastersetup]} ]]; then
    if [[ ${_CC[publish]} -eq ${TRUE} ]]; then
      # On MacOS we need to use localhost, on linux use the host IP
      if [[ $(CU_podmantype) == "native" ]]; then
        hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
      else
        hostaddr="localhost"
      fi
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${hostaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    elif [[ ${_CC[withlb]} -eq ${TRUE} ]]; then
      lbaddr=$(CU_get_container_ip "${_CC[clustername]}-lb") || err || return
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${lbaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    else
      [[ -n ${_CC[skipmastersetup]} ]] || {
        docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
          "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      }
    fi

    chmod 666 "/var/tmp/admin-${_CC[clustername]}.conf" || {
      printf 'ERROR: Could not "chown 666 /var/tmp/admin-%s.conf"' "${_CC[clustername]}"
      err || return
    }
  fi

  return "${OK}"
}

# _CC_set_up_master_node calls the correct set up function based on the version
# Args: arg1 - the container ID to set up
_CC_set_up_master_node() {

  case "${_CC[k8sver]}" in
  "1.30.0" | "1.30.1" | "1.31.1")
    _CC_set_up_master_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# _CC_get_master_join_details uses 'docker exec' or 'podman exec' to run a
# script on the master to get CA hash, a token, and the master IP.  The caller
# can eval the output of this function to set the variables: cahash, token, and
# masterip. See also:
# https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/#token-based-discovery-with-ca-pinning
# Args: arg1 - id/name of master container
_CC_get_master_join_details() {

  local joinvarsfile master1ip

  joinvarsfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  master1ip=$(CU_get_container_ip "${_CC[clustername]}-master-1") || err || return

  cat <<EnD >"${joinvarsfile}"
#!/bin/bash
set -e

sed 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${master1ip}"'\2#' \
  /etc/kubernetes/super-admin.conf >/etc/kubernetes/admin2.conf

cahash=\$(openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | \
        openssl rsa -pubin -outform der 2>/dev/null | \
        openssl dgst -sha256 -hex | sed 's/^.* //')
token=\$(kubeadm token create --kubeconfig=/etc/kubernetes/admin2.conf 2>/dev/null)
ip=\$(ip ro get 8.8.8.8 | cut -d" " -f 7)

printf 'cahash=%s\ntoken=%s\nmasterip=%s' "\$cahash" "\$token" "\$ip"

exit 0
EnD

  docker cp "${joinvarsfile}" "$1":/root/joinvars.sh 2>"${STDERR}" ||
    err || return
  rm -f "${joinvarsfile}" 2>"${STDERR}" || err || return

  [[ -z ${_CC[skipworkersetup]} ]] && {
    docker exec "$1" bash /root/joinvars.sh 2>"${STDERR}" || err || return
  }

  return "${OK}"
}

# _CC_create_lb_node creates the load balancer node container.
# Args: None expected.
_CC_create_lb_node() {

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  # Create container
  UT_run_with_progress \
    "    Creating load balancer container, '${_CC[clustername]}-lb'" \
    CU_create_container \
    "${_CC[clustername]}-lb" \
    "${labelkey}=${_CC[clustername]}" \
    "${_CC[k8sver]}"

  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    printf '\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
    printf '%s\n' "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  return "${OK}"
}

# _CC_setup_lb_node sets up the load balancer node container.
# Args: None expected.
_CC_setup_lb_node() {

  local runlogfile

  # Set up
  [[ -z ${_CC[skiplbsetup]} ]] && {
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-lb'" \
      _CC_set_up_lb_node_real "${_CC[clustername]}-lb"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _CC_set_up_lb_node_real sets up the lb node.
# Args: arg1 - the container ID to set up
_CC_set_up_lb_node_real() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masteriplist=
  nl=
  gotamaster="${FALSE}"
  for idx in $(seq 1 "${_CC[nummasters]}"); do
    ip=$(CU_get_container_ip "${_CC[clustername]}-master-${idx}") || continue
    gotamaster="${TRUE}"
    masteriplist="${masteriplist}${nl}    server master-${idx} ${ip}:6443 check fall 3 rise 2"
    nl='\n'
  done

  [[ ${gotamaster} == "${FALSE}" ]] && {
    printf 'ERROR: Did not manage to get an IP address for any master nodes\n'
    err || return
  }

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

systemctl stop kubelet crio
systemctl disable kubelet crio

apt -y install haproxy

INTERNAL_IP=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")

cat <<EOF | tee /etc/haproxy/haproxy.cfg 
frontend kubernetes
    bind \$INTERNAL_IP:6443
    option tcplog
    mode tcp
    default_backend kubernetes-master-nodes
backend kubernetes-master-nodes
    mode tcp
    balance roundrobin
    option tcp-check
\$(echo -e "${masteriplist}")
EOF

systemctl restart haproxy
systemctl enable haproxy

EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# _CC_create_worker_nodes creates the worker nodes.
# Args: arg1 - number of worker nodes to create
_CC_create_worker_nodes() {

  local cahash token t masterip
  declare -i int=0

  [[ -n ${_CC[skipmastersetup]} ]] || {
    # Runs a script on master node to get details
    t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1") || {
      printf '\nERROR: Problem with "_CC_get_master_join_details".\n\n' >"${STDERR}"
      return "${ERROR}"
    }

    # Sets cahash, token, and masterip:
    eval "${t}"
  }

  local labelkey
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating worker container, '${_CC[clustername]}-worker-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-worker-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }

    [[ -n ${_CC[skipworkersetup]} || -n ${_CC[skipmastersetup]} ]] || {
      UT_run_with_progress \
        "    Setting up '${_CC[clustername]}-worker-${int}'" \
        _CC_set_up_worker_node "${_CC[clustername]}-worker-${int}" \
        "${cahash}" "${token}" "${masterip}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n' >"${STDERR}"
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
        printf '%s\n' "${runlogfile}" >"${STDERR}"
        return "${ERROR}"
      }

      UT_run_with_progress \
        "    Waiting for system to become ready" \
        _CC_wait_for_cluster \
        "${_CC[clustername]}-master-1" \
        "${_CC[clustername]}-worker-${int}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n'
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Wait timed out.\n' >"${STDERR}"
        return "${ERROR}"
      }
    }
  done

  return "${OK}"
}

# _CC_wait_for_cluster runs a `kubectl` command in the master-1 container,
# which doesn't exit until the all pods are fully up and running before it
# returns.
# Args: arg1 - the master container name to log into
#       arg2 - the worker container name to wait for
_CC_wait_for_cluster() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  cat <<'EnD' >"${setupfile}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
found=0
for i in $(seq 1 20); do
  if kubectl get pods &>/dev/null; then
    found=1
    break
  fi
  sleep 1
done
[[ $found == 0 ]] && {
  printf '# kubectl get pods\n'
  kubectl get pods
  printf '\nWaited for 20 seconds for kubectl to work.\n'
  printf 'Kubectl cannot contact master. Aborting.\n'
  exit 1
}
counter=0
while ! kubectl get nodes | grep -qs "$1"; do
  ((counter++))
  [[ ${counter} -gt 60 ]] && {
    printf '# kubectl get nodes\n'
    kubectl get nodes
    printf '\nWaited for 2 minutes for node to appear in master. Aborting.\n'
    exit 1
  }
  sleep 2
done
counter=0
while kubectl get pods -A | tail -n +2 | awk '{ print $3; }' | grep -qs 0; do
  ((counter++))
  [[ ${counter} -gt 120 ]] && {
    printf '# kubectl get pods -A\n'
    kubectl get pods -A
    printf '\nWaited for 3 minutes for pods to be ready. Aborting.\n'
    exit 1
  }
  sleep 2
done
exit 0
EnD

  docker cp "${setupfile}" "$1":/root/wait.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/wait.sh "$2" || err
}

# _CC_set_up_worker_node calls the correct set up function based on the version.
# Args: arg1 - the container ID to set up
#       arg2 - the CA hash
#       arg3 - the token
#       arg4 - the master IP
_CC_set_up_worker_node() {

  case "${_CC[k8sver]}" in
  "1.30.0" | "1.30.1" | "1.31.1")
    _CC_set_up_worker_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# Initialise _CC
_CC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster - versions file

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR TRUE

# _CC_set_up_master_node_v1_30_0 uses kubeadm to set up the master node.
# Args: arg1 - the container to set up.
_CC_set_up_master_node_v1_30_0() {

  local setupfile lbaddr certSANs="{}" certkey masternum t lbip
  # Set by _CC_get_master_join_details:
  local cahash token masterip

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masternum="${1##*-}" # <- eg. for xxx-master-1, masternum=1

  if [[ ${_CC[skipmastersetup]} != "${TRUE}" ]]; then

    if [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -eq 1 ]]; then

      # This is the first master node

      # Sets cahash, token, and masterip:
      lbip=$(CU_get_container_ip "${_CC[clustername]}-lb")
      lbaddr=", '${lbip}'"
      uploadcerts="--upload-certs"
      certkey="CertificateKey: f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07"

    elif [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -ne 1 ]]; then

      # This is not the first master node, so join with the master
      # https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/

      # Keep trying to get join details until apiserver is ready or we run out of tries
      for try in $(seq 1 9); do
        # Runs a script on master node to get join details
        t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1")
        retval=$?
        [[ ${retval} -eq 0 ]] && break
        [[ ${try} -eq 9 ]] && {
          printf '\nERROR: Problem with "_CC_get_master_join_details". Tried %d times\n\n' "${try}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        sleep 5
      done
      eval "${t}"
    fi
  fi

  # Always set certSANs for the host whether we need it or not
  hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
  certSANs="
  certSANs: [ '${hostaddr}'${lbaddr}, '127.0.0.1', 'localhost' ]"

  # Write the file regardless, so the user can use it if required

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

# Use a custom configuration. Default config created from kubeadm with:
#   kubeadm config print init-defaults
# then edited.

ipaddr=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")
podsubnet="10.244.0.0/16"
servicesubnet="10.96.0.0/16"

cat <<EOF >kubeadm-init-defaults.yaml
apiVersion: kubeadm.k8s.io/v1beta4
bootstrapTokens:
- groups:
  - system:bootstrappers:kubeadm:default-node-token
  token: abcdef.0123456789abcdef
  ttl: 24h0m0s
  usages:
  - signing
  - authentication
kind: InitConfiguration
${certkey}
localAPIEndpoint:
  advertiseAddress: \$ipaddr
  bindPort: 6443
nodeRegistration:
  criSocket: unix:///var/run/crio/crio.sock
  imagePullPolicy: IfNotPresent
  imagePullSerial: true
  name: $1
  taints:
  - effect: NoSchedule
    key: node-role.kubernetes.io/control-plane
timeouts:
  controlPlaneComponentHealthCheck: 4m0s
  discovery: 5m0s
  etcdAPICall: 2m0s
  kubeletHealthCheck: 4m0s
  kubernetesAPICall: 1m0s
  tlsBootstrap: 5m0s
  upgradeManifests: 5m0s
---
apiServer: ${certSANs}
apiVersion: kubeadm.k8s.io/v1beta4
caCertificateValidityPeriod: 87600h0m0s
certificateValidityPeriod: 8760h0m0s
certificatesDir: /etc/kubernetes/pki
clusterName: ${_CC[clustername]}-cluster
controlPlaneEndpoint: ${lbaddr:-\$ipaddr}:6443
controllerManager: {}
dns: {}
encryptionAlgorithm: RSA-2048
etcd:
  local:
    dataDir: /var/lib/etcd
imageRepository: registry.k8s.io
kind: ClusterConfiguration
networking:
  dnsDomain: cluster.local
  podSubnet: \${podsubnet}
  serviceSubnet: \${servicesubnet}
proxy: {}
scheduler: {}
EOF

mkdir -p /mok
cp kubeadm-init-defaults.yaml /mok/kubeadm.yaml

if [[ -z "${masterip}" ]]; then
  # Run the preflight phase
  kubeadm init \\
    --ignore-preflight-errors Swap \\
    --config=kubeadm-init-defaults.yaml \\
    phase preflight

  # Set up the kubelet
  kubeadm init phase kubelet-start

  # Edit the kubelet configuration file
  echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
  sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

  # Tell kubeadm to carry on from here
  kubeadm init \\
    --config=kubeadm-init-defaults.yaml \\
    --ignore-preflight-errors Swap \\
    ${uploadcerts} \\
    --skip-phases=preflight,kubelet-start

  export KUBECONFIG=/etc/kubernetes/super-admin.conf

  # Flannel - 10.244.0.0./16
  kubectl apply -f /root/kube-flannel.yml
else
  kubeadm join ${masterip}:6443 \\
    --ignore-preflight-errors Swap \\
    --control-plane \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --certificate-key f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07
fi

systemctl enable kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  # Run the file
  [[ -z ${_CC[skipmastersetup]} ]] && {
    docker exec "$1" bash /root/setup.sh || err || return

    # Remove the taint if we're setting up a single node cluster

    [[ ${_CC[numworkers]} -eq 0 ]] && {

      removetaint=$(mktemp -p /var/tmp) || {
        printf 'ERROR: mktmp failed.\n' >"${STDERR}"
        return "${ERROR}"
      }

      # Write the file
      cat <<'EnD' >"${removetaint}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
kubectl taint nodes --all node-role.kubernetes.io/control-plane:NoSchedule-
EnD

      docker cp "${removetaint}" "$1":/root/removetaint.sh || err || {
        rm -f "${removetaint}"
        return "${ERROR}"
      }

      # Run the file
      docker exec "$1" bash /root/removetaint.sh || err
    }
  }

  return "${OK}"
}

# _CC_set_up_worker_node_v1_30_0 uses kubeadm to set up the worker node.
# Args: arg1 - the container to set up.
_CC_set_up_worker_node_v1_30_0() {

  local setupfile cahash="$2" token="$3" masterip="$4"

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  if [[ ${_CC[withlb]} == "${TRUE}" ]]; then
    masterip=$(CU_get_container_ip "${_CC[clustername]}-lb") || return
  fi

  cat <<EnD >"${setupfile}"
# Wait for the master API to become ready
while true; do
  curl -k https://${masterip}:6443/
  [[ \$? -eq 0 ]] && break
  sleep 1
done

# Do the preflight tests (ignoring swap error)
kubeadm join \\
  phase preflight \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --ignore-preflight-errors Swap \\
    ${masterip}:6443

# Set up the kubelet
kubeadm join \\
  phase kubelet-start \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    ${masterip}:6443 &

while true; do
  [[ -e /var/lib/kubelet/config.yaml ]] && break
    sleep 1
  done

# Edit the kubelet configuration file
echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

systemctl enable --now kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh 2>"${STDERR}" || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CU - Container Utilities

# _CU is an associative array that holds data specific to container utils.
declare -A _CU

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# CU_containerrt getter outputs the container runtime (podman or docker)
# that has been chosen.
CU_containerrt() {
  printf '%s' "${_CU[containerrt]}"
}

# CU_imgprefix getter outputs the prefix to be used with docker build. For
# podman it is 'localhost/'. For docker it is empty.
CU_imgprefix() {
  printf '%s' "${_CU[imgprefix]}"
}

# CU_labelkey getter outputs the key value of the label that is applied to all
# cluster member's container labels for podman or docker.
CU_labelkey() {
  printf '%s' "${_CU[labelkey]}"
}

# CU_podmantype getter outputs the container runtime type (native or machine).
CU_podmantype() {
  printf '%s' "${_CU[podmantype]}"
}

# Public Functions ------------------------------------------------------------

# CU_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted.
CU_cleanup() { :; }

# CU_get_cluster_container_ids outputs just the container IDs, one per line
# for any MOK cluster, unless arg1 is set, in which case just the IDs
# for the requested cluster name are output.
# Args: arg1 - The cluster name, optional.
CU_get_cluster_container_ids() {

  local value output

  [[ -n $1 ]] && value="=$1"

  output=$(docker ps -a -f label="${_CU[labelkey]}${value}" -q) || {
    printf 'ERROR: %s command failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  output=$(printf '%s' "${output}" | sed 's/$//')

  printf '%s' "${output}"

  return "${OK}"
}

# CU_get_cluster_size searches for an existing cluster using labels and outputs
# the number of containers in that cluster. All cluster nodes are labelled with
# "${_CU[labelkey]}=${CC[clustername]}"
# Args: arg1 - The cluster name to search for.
CU_get_cluster_size() {

  local output
  declare -a nodes

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Cluster name cannot be empty.\n' >"${STDERR}"
    err || return
  }

  output=$(CU_get_cluster_container_ids "$1") || err || return

  # readarray will read null as an array item so don't run
  # through readarray if it's null
  [[ -z ${output} ]] && {
    printf '0'
    return "${OK}"
  }

  # read the nodes array and delete blank lines
  readarray -t nodes <<<"${output}"

  printf '%d' "${#nodes[*]}"
}

# CU_get_container_ip outputs the IP address of the container.
# Args: arg1 - docker container id or container name to query.
CU_get_container_ip() {

  local info

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  info=$(CU_get_container_info "$1") || return
  JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}" ||
    err || return
}

# CU_get_container_info uses 'docker/podman inspect $id' to output
# container details.
# Args: arg1 - docker container id
CU_get_container_info() {

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  docker inspect "$1" || {
    printf 'ERROR: %s inspect failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_create_container creates and runs a container with settings suitable for
# running privileged containers that can manipulate cgroups.
# Args: arg1 - The string used to set the name and hostname.
#       arg2 - The label to assign to the container.
#       arg3 - The k8s base image version to use.
CU_create_container() {

  local imagename img allimgs systemd_always clustername parg pval

  [[ -z $1 || -z $2 || -z $3 ]] && {
    printf 'INTERNAL ERROR: Neither arg1, arg2 nor arg3 can be empty.\n' \
      >"${STDERR}"
    err || return
  }

  img=$(BI_baseimagename) || err || return

  local imglocal="${_CU[imgprefix]}local/${img}-v${3}"
  local imgremote="myownkind/${img}-v${3}"

  # Prefer a locally built container over one downloaded from a registry
  allimgs=$(docker images | tail -n +2) || {
    printf 'ERROR: %s returned an error\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  if echo "${allimgs}" | grep -qs "${imglocal}"; then
    imagename="${imglocal}"
  elif echo "${allimgs}" | grep -qs "${imgremote}"; then
    imagename="${imgremote}"
  else
    cat <<EnD
ERROR: No container base image found. Use either:

  $ mok build image
OR
  $ mok build image --get-prebuilt-image

Then try running 'mok create ...' again.
EnD
    return "${ERROR}"
  fi

  clustername=$(CC_clustername) || err || return

  if [[ ${_CU[containerrt]} == "podman" ]];
  then 
    docker network exists "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  else
    docker network inspect "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  fi

  [[ ${create_network} -ne 0 ]] && {
    docker network create "${clustername}_network" || {
      printf 'ERROR: docker network create failed\n' >"${STDERR}"
      err || return
    }
  }

  # Docker does not have the --systemd option
  [[ ${_CU[containerrt]} == "podman" ]] && systemd_always="--systemd=always"

  [[ $(CC_publish) == "${TRUE}" ]] && {
    if [[ $(CC_withlb) == "${TRUE}" ]]; then
      if echo "$1" | grep -qs -- '-lb$'; then
        parg='-p'
        pval='6443:6443'
      fi
    else
      if echo "$1" | grep -qs -- '-master-1$'; then
        parg='-p'
        pval='6443:6443'
      fi
    fi
  }

  docker run --privileged ${systemd_always} \
    --network "${clustername}_network" \
    -v /lib/modules:/lib/modules:ro \
    --detach ${parg} ${pval} \
    --name "$1" \
    --hostname "$1" \
    --label "$2" \
    "${imagename}" \
    /usr/local/bin/entrypoint /lib/systemd/systemd log-level=info unit=sysinit.target || {
    printf 'ERROR: %s run failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_podman_or_docker checks to see if docker and/or podman are installed and
# sets the imgprefix and containerrt array members accordingly. It also defines
# the docker function to run the detected container runtime. Podman is
# preferred if both are installed.
# Args: No args expected.
CU_podman_or_docker() {
  if type podman &>/dev/null; then
    _CU[imgprefix]="localhost/"
    _CU[containerrt]="podman"
    _CU_podman_checks || return
  elif type docker &>/dev/null; then
    _CU[imgprefix]=""
    _CU[containerrt]="docker"
    _CU_docker_checks || return
  else
    printf 'ERROR: Neither "podman" nor "docker" were found.\n' \
      >"${STDERR}"
    printf 'Please install one of "podman" or "docker".\nAborting.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi
  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CU_docker_checks checks to see if the current user has permission to write
# to the docker socket. If not, it prints an error message and exits.
# Args: No args expected.
_CU_docker_checks() {
  if [[ ! -e /proc/sys/kernel/hostname ]]; then
    printf 'ERROR: Docker is currently supported on Linux only'
    exit "${ERROR}"
  fi

  if docker ps >/dev/stdout 2>&1 | grep -qs 'docker.sock.*permission denied'; then
    cat <<EnD >"${STDERR}"
Not enough permissions to write to 'docker.sock'.

Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  fi

  _CU[podmantype]="native"
  return "${OK}"
}

# _CU_podman_checks sets the _CU[podmantype] member to "native" or "machine"
# depending on whether this is linux or macos. We assume linux won't be using
# a podman machine, and macos will always be using a podman machine.
# Args: No args expected.
_CU_podman_checks() {
  local info running

  if [[ -e /proc/sys/kernel/hostname ]]; then
    # We're on linux
    _CU[podmantype]="native"
    _CU_podman_native_checks || return
  elif [[ -d /System/Library/CoreServices ]]; then
    # We're on macOS
    [[ $(id -u) -eq 0 ]] && {
      printf 'ERROR: Cannot run mok as root on macOS.\n' >"${STDERR}"
      exit "${ERROR}"
    }

    info=$(podman machine list --format json) || err || return
    running=$(JSONPath -b '..Running' <<<"${info}") || err || return

    if [[ ${running} == "true" ]]; then
      _CU[podmantype]="machine"
    else
      printf 'ERROR: Podman machine is not running. Aborting.\n' >"${STDERR}"
      exit "${ERROR}"
    fi
  else
    printf 'ERROR: Unknown OS. Aborting.\n' >"${STDERR}"
    exit "${ERROR}"
  fi
}

# _CU_podman_native_checks checks to see if the current user is root. If not,
# it prints an error message and exits.
# Args: No args expected.
_CU_podman_native_checks() {
  [[ $(id -u) -ne 0 ]] && {
    cat <<EnD >"${STDERR}"
Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  }
}

# _CU_new sets the initial values for the Container Utils associative array.
# Args: None expected.
_CU_new() {
  _CU[imgprefix]=
  _CU[labelkey]="MokCluster"
  _CU[containerrt]=

  # _CU[podmantype] will only be set only if _CU[containerrt]=podman.
  # podmantype will be "native" or "machine".
  _CU[podmantype]=
}

# Override `docker` depending on _CU[containerrt]
docker() {
  local cmd
  if [[ "${_CU[containerrt]}" == "podman" ]]; then
    podman "$@"
  else
    cmd=$(which -a docker | tail -n 1)
    $cmd "$@"
  fi
}

# Override `ip` depending on _CU[podmantype]
ip() {
  local cmd
  if [[ "${_CU[podmantype]}" == "machine" ]]; then
    podman machine ssh ip "$@"
  else
    cmd=$(which -a ip | tail -n 1)
    $cmd "$@"
  fi
}

# Initialise _CU
_CU_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# BI - Build Image

# _BI is an associative array that holds data specific to building an image.
declare -A _BI

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE

# Getters/Setters -------------------------------------------------------------

# BI_setflag_useprebuiltimage setter sets the useprebuiltimage array item.
# This is called by the parser, via a callback in _BI_new.
BI_setflag_useprebuiltimage() {
  _BI[useprebuiltimage]="$1"
}

# BI_baseimagename getter outputs the value of the _BI[baseimagename].
# Args: None expected.
BI_baseimagename() {
  printf '%s' "${_BI[baseimagename]}"
}

# Public Functions ------------------------------------------------------------

# BI_usage outputs help text for the build image component.
# It is called by PA_usage(), via a callback in _BI_new.
# Args: None expected.
BI_usage() {

  # NOTE: This flag to be added back in the future
  # --get-prebuilt-image - Instead of building a 'node' image
  #        locally, download it from a container registry instead.

  cat <<'EnD'
BUILD subcommands are:
 
  image - Creates the docker 'mok-image' container image.
 
build image options:
 
 Format:
  build image

 Flags:
  --tailf - Show the build output whilst building.

EnD
}

# BI_cleanup removes temporary files created during the build.
# This function is called by the 'MA_cleanup' trap only.
# Args: None expected.
BI_cleanup() {
  [[ -e ${_BI[dockerbuildtmpdir]} ]] &&
    [[ ${_BI[dockerbuildtmpdir]} == "/var/tmp/"* ]] && {
    rm -rf "${_BI[dockerbuildtmpdir]}" || {
      printf 'ERROR: "rm -rf %s" failed.\n' "${_BI[dockerbuildtmpdir]}" \
        >"${STDERR}"
      err || return
    }
  }
}

# BI_check_valid_options checks if arg1 is in a list of valid build image
# options. This function is called by the parser, via a callback in _BI_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
BI_process_options() {

  case "$1" in
  -h | --help)
    BI_usage
    return "${STOP}"
    ;;
  --tailf)
    _BI[tailf]="${TRUE}"
    return "${OK}"
    ;;
  # NOTE: This flag to be added back in the future
  # --get-prebuilt-image)
  #   _BI[useprebuiltimage]="${TRUE}"
  #   return "${OK}"
  #   ;;
  *)
    BI_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# BI_run builds the base image used for masters and workers.
# This function is called in main.sh.
# Args: None expected.
BI_run() {

  _BI_sanity_checks || return

  [[ ${_BI[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  local retval=0
  _BI_build_container_image
  retval=$?

  if [[ ${retval} -eq ${OK} ]]; then
    : # We only need the tick - no text
  else
    printf 'Image build failed\n' >"${STDERR}"
    err
  fi

  return "${retval}"
}

# Private Functions -----------------------------------------------------------

# _BI_new resets the initial values for the _BI associative array.
# Args: None expected.
_BI_new() {
  _BI[tailf]="${FALSE}"
  _BI[baseimagename]="mok-image"
  _BI[useprebuiltimage]="${FALSE}"
  _BI[dockerbuildtmpdir]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "build" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "buildimage" "END" ""

  # Set up the parser's option callbacks
  PA_add_option_callback "build" "BI_process_options" || return
  PA_add_option_callback "buildimage" "BI_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "build" "BI_usage" || return
  PA_add_usage_callback "buildimage" "BI_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "buildimage" "BI_run"
}

# BI_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_BI_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    BI_usage
    exit "${OK}"
  fi
}

# _BI_build_container_image creates the docker build directory in
# dockerbuildtmpdir then calls docker build to build the image.
# Args: No args expected.
_BI_build_container_image() {

  local cmd retval tagname buildargs text buildtype

  _BI_create_docker_build_dir || return

  buildargs=$(_BI_get_build_args_for_latest) || return
  tagname="${_BI[baseimagename]}-v${K8SVERSION}"

  local imgprefix
  imgprefix=$(CU_imgprefix) || err || return
  if [[ ${_BI[useprebuiltimage]} == "${FALSE}" ]]; then
    buildtype="create"
    cmd="docker build \
      -t "${imgprefix}local/${tagname}" \
      --force-rm \
      ${buildargs} \
      ${_BI[dockerbuildtmpdir]}/${_BI[baseimagename]}"
    text="Creating"
  else
    buildtype="download"
    cmd="docker pull myownkind/${tagname}"
    text="Downloading"
  fi

  UT_run_with_progress \
    "    ${text} base image, '${tagname}'" "${cmd}"

  retval=$?
  [[ ${retval} -ne ${OK} ]] && {
    local runlogfile
    runlogfile=$(UT_runlogfile) || err || return
    printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\n' >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${buildtype} == "create" ]] && {
    cmd="_BI_modify_container_image"

    UT_run_with_progress \
      "    Modifying base image (pulling kubernetes images)" "${cmd}"

    retval=$?
    [[ ${retval} -ne ${OK} ]] && {
      local runlogfile
      runlogfile=$(UT_runlogfile) || err || return
      printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\n' >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _BI_modify_container_image starts a container suitable for running kubernetes
# components (since the docker/podman build environment isn't suitable), makes
# some modifications and then 'commits' the image. The modifications allow
# `mok create ...` to complete more quickly.
# Args: No args expected.
_BI_modify_container_image() {

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify &>/dev/null
  docker rm mok-build-modify &>/dev/null

  CC_set_clustername "build" || err || return

  # Start container
  CU_create_container "mok-build-modify" "mok-build-modify" "${K8SVERSION}" ||
    return

  # Wait for crio to become ready
  printf '\n\n ** WAITING FOR CRIO TO BECOME READY **\n\n'
  while ! docker exec mok-build-modify systemctl status crio; do
    sleep 1
    [[ ${counter} -gt 10 ]] && {
      printf '\nERROR: CRI-O did not start after %d tries.\n' "${counter}"
      err || return
    }
    ((counter++))
  done

  # Modify container
  docker exec mok-build-modify kubeadm config images pull \
    --kubernetes-version "${K8SVERSION}" || err || return

  # Stop container
  docker stop -t 5 "mok-build-modify"

  # Write image
  local imgprefix tagname
  imgprefix=$(CU_imgprefix) || err || return
  tagname="${_BI[baseimagename]}-v${K8SVERSION}"
  docker commit mok-build-modify "${imgprefix}local/${tagname}" || err || return

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify
  docker rm mok-build-modify || err || return

  return "${OK}"
}

# _BI_get_build_args_for_latest sets the buildargs variable that is added
# to the 'podman build ...' command line.  Only the latest version is built
# from scratch.  Earlier versions are downloaded using '--get-prebuilt-image'.
# Args: None expected
_BI_get_build_args_for_latest() {

  local buildargs

  buildargs="--build-arg GO_VERSION=${GO_VERSION}"

  printf '%s' "${buildargs}"
}

# _BI_create_docker_build_dir creates a docker build directory in
# /var/tmp/tmp.XXXXXXXX
# Args: None expected
_BI_create_docker_build_dir() {

  _BI[dockerbuildtmpdir]="$(mktemp -d -p /var/tmp)" || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }

  # The following comments should not be removed or changed.
  # embed-dockerfile.sh adds a base64 encoded tarball and
  # unpacking code between them.

  #mok-image-tarball-start 
  cat <<EnD | base64 -d | tar xz -C "${_BI[dockerbuildtmpdir]}" 
H4sIAAAAAAAAA+w9/XPbtpL9WX8FqmRe7dYk9Wnn3NF7T7GVVBNHzthOe51cxgORkMSIJFSClKze
3f9+uwuQomTJX3HV61ToNJLJBbBY7Cc+VqEcW37Ih8L55g8rFShHzSZ+Vo+aleJnVr6pNo4qjdph
vd6A59V646j+DWv+cSgtSqoSHjP2TegGPB4rGW2Au+/9X7SE+fyfSncs4oEfiOfuAyf4sNHYMP+1
etPM/2Gtctis4vw3G4cw/5XnRmRd+ZvP/wt2Iifz2B+OElarVF+xq5Fg79K+iCORCMXaaTKSsbJL
L0ov2JnvikgJj6WRJ2KWAGh7wl34MG8O2M8iVr6MWM2usD0EKJtX5f0foYW5TFnI5yySCUuVgCZ8
xZDnmLhxxSRhfsRcGU4Cn0euYDM/GVE3phFAg/1qmpD9hAM0B/gJ/DUowjGeEMJYRkkyOXac2Wxm
c0LWlvHQCTSgcs66J53eZccChKnKxygQSrFY/Jb6MQy1P2d8Avi4vA9YBnzGZMz4MBbwLpGI7yz2
Ez8aHjAlB8mMxwJa8XyVxH4/TZaIlWEHYy4CALl4xMrtS9a9LLPX7cvu5QG08Uv36qfzj1fsl/bF
Rbt31e1csvMLdnLeO+1edc978Ncb1u79yt51e6cHTACpoBtxM4kRf0DSRzIKD2l2KcQSAgOpEVIT
4foD34VxRcMUtAAbyilMPQyHTUQc+gonUwF6HrQS+KGf8ISe3BqUXQKIsR95MLeeYH2O40TFQlR9
Ax2quUpE6LEfmEeqBiYuGvjDNKYmkR2A2iKQM6CkwXcgA/gbsYnFQMQCeEIdQ3M4pwom1TRp+9IB
uly1u73OxXW3d9W5eNM+6TiIEop3wgaxDJkn+sBWTME4DjTnEYI4HbHgINowxXOmQh4EjMOgdV2i
hfQj4CiiG2fjhXjQWKmVA+YnMDChou8SHBkxZ5i6I7bHozn0Fg3/tc9mAmAQIgL+gQYJC+hmiLwO
3foR/AGfQD6YFRQMIj4Dxh0DkCq1L94ih3Suu+/bbzstPaTjvpTjmYxDC8dWenNx/p69XEAx4Cyc
jxLVfvfxdeei17nqXF7/3Lm4BE5qTat2vUovTy665yuPAUuSMBiOwtk3aMFjRFS5sT9JNJIeCIyb
yNhHpGPB0OizvXh2w2KL/t83lSIZWXlFBATrgIAWANH/+6WT8w+/MstyR6H0WtQQ9eqkKnYC6fLA
6fuR8z1bebBSD9vV9ZAzHaY/NgKBMQQY/BcQJSAZBUb+YUwg7gR3QOoL+TMbMVAnUSIYoA6gF0vC
Qxph4N8AfwMRLz72NJtr7Qb6C9GwN464gNQmEBoVDp8tvm4cpFF4l0i8xfeN4CJxHZgqNwnsOQ8D
Rg/ug5b0j40CbnvY0drnd7YCoo195rXzv++rhQrBfBbqFp8+pgWU9UAkthLxFBTdEj53w21mRQC1
BqBxIwE0RZLGUia3HqPgdY068MREgMKNXB+5b+DHyqg0PklQlYlI/xkDDqh4QW/1oR6abdY7v+oc
o+JBeysjQQwIrBz6Eejz39GmzUVm4dH6L1Q3CCsoRm/ORqQOtVKCZmIF+kiAIofuGdgwbD3KDaJG
OZQg2JnaQjw+mO8ZBICj7PdjOQb0PTmL4A00sCfASJNNBIMTiX3U91beEvWje4pT0Eia3IrtmfnY
XwuNerugtdHDAEpEidoIDYCgUMdokuAtfCgQc62mQWgXba1tAHwGVALGCoClA1QTPxQEDHrBXdQg
iwkkVUaDLLeXjHjCJrGc+mBmlAh9y0WyFoYySCMXzScP/GQOlduDBPozJCbTlbUFc+QCd0TpBPDT
RI1FCE0DUBrNeISuSGajM7oSGPgqYBkRbhyqIeqwLzKNoUuPXDzglkAOGZCTNP9MpgEacjLvqYJq
+8RaPXGTaPs3iwLJPTIZ8CzmLhhM0jD06KTXZZMgHUI3oMc4tUnMnU7AZRI8tJeaA98jjbW3QHK5
oI0T8sgfCJWogp4WN+B4KZv1wFoChZBk2qBzL3cQHBZPwoxwZjx5NzzRRls3lHG/ITjqeXC/RmA0
+qkfJIsRaAzg+QyFFWrge4/QXvgQemRvoE6AkCB/3heITxhMyUT7AtkMAvsDhasoxOBCMk6zXgY3
ICkTLjAcdImrzZCEGl0dBVSFOZob4Jn4bkrOCCIPDiwHWy4SaFr7OIjUAY2uLwbIc4gNGbLAHwvA
DjBIYvoAl1OCiwU8AFRJXLuECoa0HkMTlZsk9o9/sP8qoUsu3JFk5e6CSXPdYNt22QAB9Gnndbfd
uwZ/Bly63mkL/AZQEQI5xp8adrYyhaNrsZyFQTdZwFyRQuws8hiZyy1XgEsHLi9H6RlOhmCx4Xte
G5g2QpYcM/BO0OUHoR6YLz5IIlC7BqMcJVIGLE38wIIBpDeg7kDEQT5g0FlTgd9XwkVdU2MTf/g7
yKoSFvrXoHEHKoeLBgrEOgxB5UlQ8xboB+Xnb0Hpjm7h7aZxwL78hqrBnagFwQaoTSC26a+aJ/jA
WbbBMAzBSqG0K4dZEQ8hQjOwVmK4zCJGyExZmVkemjax6CYOmTVY20+YBolvoYlY7ur7W5XXWeuN
wGt6Ip/PGqj7+llHDAw/ktWaqSemX1EdyQsC/qAWyJBuRFxLxwWI8Lv3aghMX2b//OcywTL9S57U
omYQMUux8su92cgHG5qZxDJzFLqEiGLRqwBn3zrH8ARcdz3DxmpBVIbRjAvaNiGDbRy4yHdAs9pg
ZEnEkQlhBi7P8nhsMh4qe/xKYUCGlurYUSQ7x87L22GHA+rWudAeiz0Wc/Y/ZiQolRYwHY/BiWCW
1L2DPDsAFYO+UAUtb6Gcm+c21lyhI3TCPil/GAnP6s9bj2nq81eMiznlfDyJEIshKJg6MKx2AOYD
vMRF7/Rkgf091OUeqG54CIbTkgV0igHc1xCY2v1q2q5tZT1ZHzygh1KWGlohKmICMgeuhMeLCi17
ntkSa86oOjNufe4h4Cc6Kuu0WS4eEE3lfnemW0H+BmEeHuhgPxZDwI6WUZBa2v3VgNfkJWoxBss9
Rh4JrGEgwa0n4dMT0ImMY+aw09xJy31iMKasYE01Koi9iGgxayVmuQMyjTxpkYmzRmAb1V1VQq7G
m4a9uQeKCw1YaWmE4HfRCDc5d4URhmNws5g12QxMK0IjHpNDj94dUFy7PUPJpmbtEj0gcs+w38yD
MzOKfhBNHjq4sVRkuic+ER7rQeA/QNcSVy/1opIqeGA8UBJmlXw7vTDFh7hORCs2tCCHBrkQgKED
xsF5HNDqFy5BTQKeYA/kK9PyBC2UkXdYiF8y/HEd0WBMqzgIvOKaknMNrQIjEk1ooUM3GqFXiM/2
1L5eVrKsDIHWy9cfu2enH87aV2/OL24tOA2lRTg800oO1jNLRg6IS+xdT4B8c2foh6HQ/z6mBTK9
luveqvOCoWeXk5InmpIWhm9EblrKwfjbRAQYVvEo1xx5uEWTIHGBJ3ZHfgJaA6AVcbYHeg/wAo1n
FV8CZHjYQD7eCBB6ALAwEUv+72ZHcQi2PORjCMfHQ8uYd90IcbAeoFAKGAzCAEv3sv4VYajrLtxb
sCTTY11r9SHCo8iBCoWgGJGgxX5gMBsYxAgcrTy+zbW8lv4psB54Mnpmyy//e/H+f8v7BZk30cfb
86vz87OTn9rdXqs8lMvwC+i3568BYHnSUfQzIgKpRmkf3KrQGUo5DIC1pJXtFfwbhUQlZlV5KJYV
BcT4rpaRjPVp3ZUoSO9wlFfwTwf+OfmpOGB8A4M+yVdey9OqDf/Vy4tXJ2fnvc71x4uzVjkznwVk
MXDIlxuUg/2ViY44926AUZ5lAelByFsQRIvjCtJ0uWGgE1UsMJi3+oSaGwl3DIFQ3sIaOv9B05dD
IwVbLwvUXLw8OWm93MsFfL/4Bhrt9NqvzzqnrWrBaqBoLA9zTQcFPgAtPUV64geooWTUcq6zlVRm
b2APvcKxiUHM27tZBFyhayTT5T3MUPBowTnTXhhptXLWzMnV2RKv1YHZHsAvaxBApsnbX+acNY9X
2WcZlb80A5ExvAbtcv2hffVTy3b0DJuFrWfhLMcNPbMWv4nJIt/Sa2dqI6dF/n1s1utefzj7+Lbb
u1xikibyyCrA3ZyYqySznAo4Oga/h7Dbun6I4RbDXGG5dS9uMd3t8W2B87RvapPB+WPZEcyZnnOI
X6g/ZyRVYpG9Yxb6QlMB/jwiY2jl+BMeFqHuaCuQcoJL4htaCnkR5o52Jsnkribw9V21Yfwh39iC
SHgO8hyily3GsXtptgyzTI2NQ1ypVMAe5VwPXTvjOioI+Bx5mRx3Sdv+2nHXMk/hQybvmROMsK2F
M6LtujbuBW+IlonIWUHhpLdW7qVtaul67Y5itm2M652ZFtQjwcAlWy+/3aYBXVgPrUid7Pl6H39N
Aw9Aa7HVoNbghiQohJRyklCID92u6zXyl9TPqtwVq6/Fel39nHOeVBv562kVjeQ8qPIGMqN9+i3F
kIR29sDhRyWPgQEeT4HIinYdD2g7DXmZR3Pc7hsKCvZnGPMQi1NcC9G8Zm2I33jijm7jwhyGUwsR
E0Px8XjCD1iIeyd9s8mhdz0oxia8dGysQ7lE4EkGs29AWzxgMnxa+DRHVfbggQ6i0ZDk52cWO3wi
mu4/4mBKp/fzonJLd4IkMziIGz9RuAd62X17cfW+2/uhrg8dwN/QxntmVnhjYYkb4aa0SpsUEein
w98BX27HwoMBkTVWIzm7hhe2O/T/5Xutaq1SPWwelS6vzj9Aw732WaE/PAqFm3d6JSCFoYPVAWWJ
xlSGIQqKEiLUW7F9kR+Yslk75L9DRQqVzcoW2n4czhsBipqz+hEMAPdR3WEs04maVs0ykBZA2jRk
H6QHvezrDddI0v7inA7imDD+229LLzq9q4tfP5wDZdknVl5RDosa5QN4ma+Bl9nn0sn7U6pxe3Xe
Q+BADq1ATEXQ8qOBxCcpVGwtb6NgO3/2+b2vLYvzn3pV5o/o46Hnf/H8Z71Z+6ZSbTSPjnbnf7dR
Vuc/1+DP2Mfjz38fViq13fxvo2yc/4tO+/R951n6uPv8Nx4Br67O/2Fzd/57K+WtZEF2KJiOdf7Z
CO3KVsuq/OPG2XP38Xj936zD653+30JZN/+F477P0sd9+r9ara/MP7w92un/bRRzMtUSkUeR0jFF
OjcQQTpTHuNaUOHcNp58KpcQHmLzY1YpeQLCyWM24IESO8vxVywb5F/+yf5/vdLY6f9tlI3zX7yo
8ZV9PHr+a5VG5XA3/9soD5r/atXK/3xCH/fa/3ptZf5rjVpjZ/+3UT7RxBov4DMY9AFPg+TaPGAt
Vnbhe7kEUx/K6Fov2OLjifTgKf15HfIIOCgmaHoyUOWdO/CXKOvk3zDBs7kAT7D/R0c7+7+Vctf8
m/PBX93H/et/jVX7X28c7vT/NgpeXzjrXF13/vPqon3dvnh72dpp7r9RWSf/+VXrZ+rj8fr/CJeE
dvp/C+XO+a9WLHNwzwIQ331iAHCP/q/Wq9VV//+osdv/2Up5wU4lnSyBqVU+5nTJDx1xz6OzOgqT
oYSYCQWTp9AlK0wv4wmV+JHO3TIb4al+vB2rj9VYTGeT0oc3XKCxDLMr9Upfd4e2RNgXHt6yOO1d
0q2lrILpmVWPanYF/qtWqc1CWiKIPpS5c5tfoYYqMpgSj2Z5OOZ4N+M7nWqI08gKA6PjKZwO+tA9
mhgTD9BlJDpYl7WrL2Vjkh2AwFw/dC8fL34EgTWO8HSTOSSEw8hRrx0Z1CmDEKU8WaWsbRIuYL0k
5gNMxOPKkK4SUXIHHKY+djTCw4mY8wAvIOMXHI3LAzxhlvepD+L02lfCw/xBI0EplERe2Vy1ojau
qToQE6eSqIlYUF/IDThRiF6B5KGf+EOejX4ilfKxNSXcFIgyBzKqFO/C6Dw+c92bPkCEFJ4go2CT
sRgc58eUoqlnR3hfbyinzjQNInA+E+4HzsnPHasGjqD1qtl8VcJrdf5k2tALEjwI7OVBtKo7p+Vp
5aH6P5vmp5iA+/z/Wn3V/683682d/t9GAQ2UxhEdNdSavW2Uyc8i1rfIUL9jnjXKTpWIeMBduiKI
dxFjMRV4Hk+GmEtMygHKO08SuiO6IrUmqrTjybU56V9dJ9eFt382bf4OZYP803nI5+rjCf5/pbHb
/99KuWv+TbaKr+7jCfs/9cPd+t9WygPmfyVNwOP7uC/+azYPV+1/o1rZ2f9tlBeYDnM4wsxUofTA
4mP+AAg+ilk2114tLX7tB7Lv9PmrgcsHfPDKbVZqvNFscNd7ddg/qr1yXzWP/qNeazab9WrT3Ofx
RF+tslbp08fITz6XToU+4Q+uR8uAHK8mpu1hyNceYlIEiDXTEL6Qr9Iy+V4LiVV86UCEppw8KQcl
XfPE1KdwZim5GERNsQ6wptLH65tcjTBu03Et5XHAJJ/se4iSvmcqndBNPI4eS3ZZIssZYm7a410y
hpdchiNbZ2NANyqiexN5rxQjQfQZmZwP+l5KllMP41qdnCerkOfToxRvsYRILGR76KMVcsOZi1vK
ZNo12SX0lRq8XIM5c2Mh9u3SiYw8H6n3AZDtUGazFp3/wesRZjyOHg8dCyuVPl3qKftc6twI9xJz
Wehr9XjJwtQoXQhKctHiwYzPVYmgzjCJbBcdySkPWpWHz4nJlhnIGYTapuVL4ZYWX1tVjOnbkU7a
63nZhOS4UkJBpbNvlk4+fGy7Li4hAFwriVNRei9CGc9Xn17iAdlWzqr4V+kdBMrvgQNbmIEL1xJK
n0xWpc+lXyiV3ut561YyrP+HHu3j9f/j14Ufb//rR5Wd/7eV8qT5r1YskxDpQcsB99n/o8NV+3/Y
2J3/3E7ZhpVfYRdU+TIRx8aaxmhc9QqsXh7OM6xiwi28D5gZVEyKUv2haHqiqR/LCG1/q5ztZOLn
yXnvTfet3s60LEyLCZaETwgNbcZaqymiloGQ3ym3nnVXnSJkeT02y5hk7dxhWsvFdFE6NT6tUpcz
iugbjEiX/NEX6UdlBr6QiMl6Arg5wHPAJnKSBjzJbGGRSu3T94QYA3R8Whr25hEPfZcSoxaG8waw
aFm3sDbdY9LiobJFNN2AOjkuCq+Bc0rzTtdn8QJ27HvoigyW3CawlEqnXw84+EC4qh8nNvtAGeAx
Q/vBokE1ouSs8J0W8wWz0S28oLxqOq28/U4328FEs21sWva/CJd+aGCR7TDLQa99I5NA1Wa3N8ez
HvvC7IR42WaB+R0Dew3d1pypKHhNdzhQ7OUGpl68WPtwaXJf3h5FwQ95mv6vWuiuPXQt+D7936gd
rej/5lF1p/+3UsxvNuQ/BIFus/6FB8qKtWDsgtp9wc4jc3UbdLIWx5xlzXMMZyh9qJdJ2q3721lm
YVBV9IMT2Z355fZr97aP0YHN9rLfuMDb6Zjae3O/2e19nZ/P3l9IICiZFgmgGjFLpC4r+wP2iTI8
AnbOQDm6e/OBApDEMggg0GKff9SJ2Bcp+DWCmT2xdB1rWrPV6EegKWp60Dm/XJ7VdBLWCVhFyrMG
plCn9aBfCZEqz5KQZXRdRSfLG1CgyiLfwYIAB8wzyRTzu/B2prNpJT+lvgNQfrSbmNF8wHWCQwxF
kUz0Ax3Hd3sOOvUU0YJ2BpVTq9fq95L62wcSGxO6ELS3gRY5w2TzssjkcSe8npk/Wyy3Vh6j/4Mn
rf49YP+vsnr+o16pV3f6fxtlzYobzbP+OZ7/Y+9bu9o4lkU/b/2KjuAega3RWwK0g3OIkR2tYwMb
cLJzbUceaUYwsaRRNBKYnfj+9luv7ukZjXiFzV5ZB63ESDP9rK6urqquh2RZsNRuZSUMVe57ot5c
WgfDRr3QiM6IbFVKhs7lPw2A/+WfW+z/VcF/b93Hjft/K+3/0aw+2X89zidj/7+D9WZ7JzawokXP
UWKR1G4XEpDW4lus4unV1N8NJz6ITbbME/NIy8h1/pfVpf4VP+n9TwvzwH3c/f6/2aw9xX95lE/m
+nPsl9L8y5/3/cDPzfR/yf+/huv/RP///R/WwcZp7DAVIpnichh5Ogbe/1L9yLZfGIJyuphNwwhz
euXe4o3xFUqGZA+MOcroh1GtzUkQJwVfupuDw1N9fYo5KnM/4B0fBuubuWfhBFvHbmMhkxROKFPq
hBFPB8BDfDL3Px7MD9jH3el/C1nCJ/r/CJ+V63+N8uqufdyw/nVU9qbk/3rzSf/7KJ+1b2i1MXkE
xmy1k0HXqk/JoJ+SQd83GTSm/HBC5c9mGMxW/5yApAdf9c9pMPVRuZxD3a8of/M3an/z6qModXN/
oyxBhc7x8eFxW7Ips5JfLuoQtzBVDyccDa17C4W+M1FBvfivGjQDY1TV3DCIMzdxYhdxHvqEiT+U
E32CxsjFRdopof0PXXhiRy6mdFoAnZCrQJgV4MZUOb9dqMIvlfXCCs02N3LjlNAcLLq2CfYA8sfT
+ZXawHUVdKS1mYdTjmmrxx4t+mj/1RPQbgosAEPCYkbH3LhAkq8XRu5iMjhPXN78Te4TpCqAMLkE
dF26MlBvKbEUnGKnlxrnxqb6Pfc3DqtNE9ldr2K3P6GWP+OuAAaDOStVfjBdKPgfcW9M6kkVIAp6
Ub6I9bOhgtURinNM24kUKP8c23kuDT2Xlp5DU8+pLQVzQLLo+KoQlVVZPS+fFeTXL+Xn5YL6No3i
66sx/cX1ZVODzee+Uhp2ufoQuhWR84ZmyTVYNoLJYLQghv18cebPR/1NyvR3490L44F7AfuWyGAw
gS5T1YxhQ+Yw+QD5KU4aLPnYboOlNAQ3Ive7otmNMgO9EZHsoWOKXAHSmQK0W7ugrEAsVc6tuiTS
1/arKur3a5LQSyccNvcm9ERf0wkN8mYB0Neb+hSLwxt6llJ3Pv9X8n+skwOy4i0Gc4de3oP1o88N
/F+jtXT/X2u2nuT/R/k88X9P/N+/hf9LsgFkEcYi5UuTM+E8DD+r99WPbCUGjNJIstZxygErsTlz
DcuWHJjGnu4ohE71KKEx2VLIg8Ui8NiiXjyqry0I2BOQxYpkQEQqC8iHGdzDcD6ks087PdpnKqdd
4z76aE8zljvOpNl9SZ2cu7PE47g0nGXzS9+fZDUMRzUaqwhoMA3dZACoOEDTc92cKV7UQ8Q3gZ65
KRtM2F9z4JISD9Ec1+BWSeUoVCjiCRuDjl1MX6qtF8feGq+wqePgCkd3lQVgQB1JNTG6otSBmFEL
PfpdPt2ZAQkmgOLBPLbAs0DA3AX5vU9CsfORapxcAtONUALMq4zaRUIMeETJYjS20iCQ1ozQhX9C
+eNVHoWIvNogIyqKQhBX0NZTCOhNk9yD/EEE7if3saJpNqtUeQ/QRAidSeW5zLQDBSKuTiwLMSEk
JhJFK0rcFXM21xTrSUrzITOj6TJpwCKUd4goMCDXHHYkHJsTz515ivOfy6wkMxWlQCukEgu1k1w/
/4xf0Bf+Cf8UchIcoQ/EBYMW+MLT8RZAjokda0IL4sSlEJSL1lMdyw5GDDwm4jpNeOpGYuKADSKm
FgB2cw/Z2T+/J+QFbgrqF9rkmeyub/z6m3JmqsS/N3O5wVSMxjQteoZpx/h1+7uvZaY95bxIydpA
ChiSKCp746AcxFWJrhnxWAlpcTByRJFojd1yXjedqJ1Z4toOSVi7xeCIxt57cFT7boPDKhmDQzcj
IIfli2CGJm+POcxbdI0DfjT+byX/n3Exf98+buD/q83l+J+V2lP8t0f5XMf/15/4/yf+/3H0vwil
EJWtaG5otLSRuqjFpPtOimFcbNIkVkSpazdapSzu7oRYSSR0KaadkgMSNsL78wC4Opj8gPJY2+bU
uQWfDEi9B2Xd+h9/qL+QYeMS/Yfdjg49k4k/Kl09TAKI6+0/qtVqRfQ/9XqlXsf8X1utp/u/x/mI
mD52J8EQrzgk+WUkDhJC94LJcOYSoRDUyI4OIC+dINRfyzN/RIJrmXOnlzEb5Ch0vSVEE3Z/CDs5
vKQbBd/TmQZZjCHKG3Psbh+2qRk4bU4PdezTWXABqHzme5KYIvEEt2a5EJe++AJD4ESdZ5fwwp0G
cmq1gU7kkB1qqwPgcSM4LvycTi7ZBgIzcvv+KGoTqfm8HTkwvraBDz6chl4cNysZj8CfADAHIP3F
Y4MqyEu3lQ2ZnOM42WMSE0sxp77LwLiX5G+a3Q1dz/ruoOQSCxD8i53rxBTHDOrlaIHSz3E4uhOo
kiOaLYAQtXMOLHjwmmgqVnRUPg9/0B0Q/e7kGUaugy9Ar/vyBE1Db1UVpfWMuvh3BOcxfbmkbKO3
b66Mst4i1eqUG/lT0Pw+INOqPwFUaOTYH2JpPZlrxgCllhc03WS0IE9KWqpMnLw/qgEI9CwxOS1F
B/s1wjd/0HR/l7TJeWww31Z5KFXJF/VT+CVN4btKqV6qxi91/vG2em+SL/9uvkGB+dWU2pTBmZr0
0gN6hlEQoYBdCd6cu8FsGkwwKkSe6UwxWSCI9vn+6TXUv3SvpJRV6Kv5/rV4/dgkRW9ybANgafvB
CBhQP1oeH1Z5CziCCVmv7Vq+fczpXxO0/1m5BAccIRBHVa2Uao0Gxr0sV1sxxDsUd/Lg1Sn+wb6J
LJvX34N46U+8xIjzpzJRocz5nD24r3qDkOIRJrVyXyzR5ExCDQCbtWkHZxJhZzA8uwPyQvNRvIn3
XX8cTk781ST6YcZIdHDVEJG1x84iwF60wOSOx0iY3lgjyRhL5mjmPkgTgMTSjDUv/IwSLWa2uWKO
S/NUSo+cGhoO0WXxKm4ai+0tPVWGcdknd8cTkPO8BXowds8moXncoczJuGSJjYJtngicTkHsiZKv
HQZbh0UrFH+S77HEZ/+qrZIHfhilSikVTtFdHxZDdSdLLy/c0cJfapoPp8niizyPNZG6pEP+83E9
RzlOMHXGbvRb4hmhB1Bw3Nvjs5l5JxyX3QClAUclgSyVZ975kwu7IGPl0eF+72DvbccaOk3mFUWV
sucyDKAxOZSWnmMkorbBrRKpGVd1dXK09/Lf0B+zfOlOOz92Dk57/3jXedfp7XeOTn9IdwxUqwly
Td48J/mqLVGCSxZzLH/bF0A3m6WtGK2X+UD9KsF1xA9/A2SZp9BlMF20VbVSGSeesr1KWzUrbwPz
QnOpeDfnf5nb7diHSrJ91/PSW+Ogc9rb23/bPch4frz3k/U0zZObVxfhaDH23yIDkUBjErV5kSgr
XRowGmrwbkUtHbxDw7S8VDdJ71f1/GVO51hpBOu51IS8dKyXeITJIZmYK1Ktl7fZwEN7M6bnLfsT
WB57j163nwfTW2Omg9wXM0zti2qpWapq4NVSyCpyo1XhTitqTWEJpEtN3gSipYVO8JDpktgtxqGl
sEZaIMXSIgU8BBxX7HALaHeCVmLYWfB6wB0AGzUk0oD3KwdUiK/YHDwoMS/YHAPGSOkoIQEcpNh/
/MxBlOBoKxbK+8MhnLcgaIdyVsf0ID4lOS5dzgaT1QTuMpqmTWRWk4s0sbi2gSzsXImb17STvW7p
VXMkKA3wte2lBcrgS69fvxshs4KcoaTRVhjB5nD2kq71U10lKN1/Wo319LnnJ63/xZv4h+7jHv6f
T/kfH+mTtf5sovFwfdzD/6v5FP/xcT6r1//hnABvu/6trWaV7omqW4AJT+v/GJ/r138w8t2JI2zq
vfu4Yf1rtWo6/icgwFP+j0f5iP3HsvVHdevJ+uPJ+uP+1t972g7VnwzcaaRjkLokScM0OUEY25WC
NILBBWgsQmyoW4pw7qOxphjkAkYgRcKXiymHAQVxBy2b0ZJXqipMVTZ0B3NKsOWXzkoqQccUjIpE
F+X35QsIXJP5DLpbslsh8xO1vqZ2VUXFxiXko/fiv2oqfxCacWoY+h7q/iw/Nnc6d86gXXZzsn6e
zVzPV86VeaSH6FwpBwRsPWRn5nNYQy9S+fX/zpvyNDFsYDZWzmyoPqCQRoFaB4jfGH8XhcnyM+sN
hnCF+mXUb0TJN+GZ+T0fTxPv7N9kuHsO6I1x9bOfOn038jNejd1JxlM+cZ49iZGP/rn+/I9tnf5M
H9ef/61qo9VI8n+1aqP+ZP/zKJ9r7D+rO08cwBMH8Gj2n3D4UDaTc38EvUU5+N0LJsOQ3L3lxM13
D14dttV6NU+u6l+pEEB5kigEMDpIF4JxhLNEKXGwj4vBGLpDMeaM/NGwvAi83tidqkZtp7HT2qrt
NAHX2ICiiBak4luD88a7nMAdcVRyc3dYVEHJL4l/SUSxdg9xYS6DyLca4Oyg2U2Usi3tlt1QxP3k
oormF85ssFPDg96U0cEc6fa4dBauvalWdpw31ep2DjucRLv5fByvoPPbhcpX3r9vszHBx4/PEz9i
gOQz4GWYJN1wFdkhvZyqoOM908yTs1UbgLLIFWI2n9FmgbgnHFLPRbPA3iSky3dZxzUeLeJXBNwZ
7Bx6W1RV/D4J9c8a/iQEgEpUBXkoNNR9D6zdd2p3F2p8/MgoMPPP/C89PwKm1e8FU2QNYRNAB90j
k2gVdytMYL3KmVipisNV0B8KeFl3lEs1tLH5OxlgSGCAtQ+ltQ/wvw4NsPbhPfx+b/3+CL8/4u9v
v/02D1iKw7twRwGykD0GrcBBLKT/hV4n/OJryhJ65s8XM/yK8FScOhYAhLS2BwwY2R7Gv3bz6xsL
2t/K+WGymc+q0cOFGgDB2s23GnLbzeOAQVjlYCTOaJ56aCqnx6m3s8q/g3kcnLSVLqmO33Tfdk97
B4evum86OgbBHGNVR3O1ovUiULDUy695A4X7G5aTISydTtOFDiWBsR/+rrxQX+4O1Tc6+MelWr9F
TGurfQ0KwtkYFtBKXD4RlENbpXmx0YGIH/xjyHdLXjjxefqAS0jbR+7VMOpNKbUC5lbwlzGKESoF
AKKUQsDCxRwTR8tuL0rcFMU5n5QbRYuxr0xneNxZ/VnYqSpmZdbUvt/HbNPVCkl+1aoOFRfZLU2k
T50aKk+n1LxHV55AbHp67J+RgRmxIWaR2kffR87dLF6hKGfBeChxNE6Msn+xryjAMYMCj8P+Ff8j
jpmNWr1Si2HnC1qNQ7zOLMuwy1N3BsRujkTbHm1kD3dpSxDdNGggs4l8fxxpuGivBYYM+2lmN89+
nzQ/rOQtfOZccP5o5nFVytuLUrUW5eW5P/hsdSMhQKhWkXijOVqGzSVUPDtHYIh5qEwNHFprZ+EM
4oS9GHFoEc2axFbhfpxdgy5/KS84A+TFrmpivu0NnCB9Q9yBLzX2BOZ1olS3nTfktEoRgErqVfCF
0xRA2XppU1p914fhLwTa8kzQUlZgw0ASqi8DkqLkc/KCDEQolUpqQAAlQ3bd68lV1A/RvAvk7d31
jfFnhKhyPHxvAoUANYXXX8ujvPm6iL9exl/HQpa/0T6Mc718yH1RKjVocte0VwRs4ke62SKarVgP
oHHdQtzJbdCVsuYhp494S5kEJHeewSeNeKzJkNazkBE4C55OYprpekJH5pjs5fLcJ4ZYLzwgXIcs
8BGlNgDJjmizAAHdRDxGuj2lPAkxcwO4PSuL97QilKYsRhy7gGmelmM+nUGvbOD/SRuOcA47Ha5G
HwbQsh7P/GrKiXcISDQ/icEZ83klXk05VlS+N2/DWq8YZD5Bryk4EqXZ4eUIIp1+4wKxnraKBR0Z
vldUQxivE+/5MQmHmP7GHaKnPJPL6QyDMrgKz24CKe4MiogljNdmScaRQUnnIaYC9CLmTcsIsGBe
3hq6NX9rx231+zu1xtBt9Gue39xqtTy3X68OK8PGVr/p9lsr+AY9FzNes94lPLtQ9MTdqccHGDai
tBmAmGayRTWfUQAComgfPqFs1ev886hz3H3bOTjde4PZd073uged4/3eycHe0ckPh6ennePdJMw+
fFKlvMZcc9bBCaxzD3E0H1piTw5g5reiiTvFyNkYeXv999t233a+MvIHdEZLFAQMWDHzXe9KZ17y
BCGsToqaghNfu8BNSoawSY7AqrDEFlzGMZ0iOIUG5KBfmICceOEXUA4tJGFTQHL8ryFb9Rgo9GJH
fuRF0akC+TRnoP7PKbvKbzJd0BxnVs088vWFf2EfiUHKML3Q0jv46v++OrEhYXZqOFTRZ/9SHx4X
kZHmtMWTtUZ5nmhegIFT1XHoUP6+Sm0m4pXkfQyt1IZD6sTNblKzQDFunDQ20R99Xpp4YqzJfvSY
Y/mUEnUlxwI9Jxg5CbWVYOZuSCiXEdCittVMzMyZJNhOzPTyjcrkVu82Odp/mpc5dymshDAgG+ih
j6qezRjVJ6uZX58cGtAWFwTBwbwXhuNeNABi2nO9X6kMyXkBOphlF1K74pu28jU7qonNmCEPOtbK
PByPrNnQTi9c+PbeRs0UbGGHt7DvpTe7xmUJilbUQdjizpKwWL3t4zOfMtiS857VDwVY+ZCP6WEe
0fxDosUP+bwNtzwcjVYLu8nqS++SLZXzN0MtQX3h/PxyZXQKHGiNovBIclcfNYADP5AcvFRcHwuR
FVcuZ2M/qhiHqBj0o8/zcEp6Rq0TNBk28DZEvjv8lyxPS+dzGmgcGW45LQcX9NCEcwDk8dtvO4ev
1ItrCtKwHRmqY/HRnJTx/Vt34p75M8wFQUUS6Qx/OD096h0dH/7zZziI4h9w1AADgr9PEm9P7NcH
h+ad/oovcjBgXIdh8IWFFHP0aUURrQRik4iUPjls+MwclYUHxEhHLPDwZnVm/tidFmgt4qtBTi+J
PJBdijkd3MueDlqOlJ1FpHN3NkaSQC2d6ig7VyqOjmclAwThhdXDSEiImaJjl7YcnPgYgypA/Bic
o5iDhdpUEk63y/MACD81uJmPHyzkCVUC2UE50W1Ky2h1Ekbk3t0ZvKMjGWC49w4Ouv7ijPlW5o74
pPt06n+Zc6o3lpCjq08IlU/UdMzIUvbkEmmRx8g/ej7sshGKdLkV1H9JVN5pNrYsfVHqgE/PcpMP
NXexdJTHqOIRn49xSRd4rg7kBjm6mgwKTFjgm6X/MrpI3zj943bBUFGeg8jCCKT3ZjBxXCeOKCTr
TkuMNRi9sIEECHRM1CAsG06t1z0AFu3V3stOmcuCDHaBnJfmnDjx2/ycaAuRzk9sVk6hERwndpwA
trLEggjfjuPlycg9A8oFTPm5C5LchPRDY/ezL7O7BA5vHELL80Q/RkDnkG1zn3ZGwM5SvG1ipS0J
7sxmx/E3A04SJ6qHzt7Ll52TUkr2xEBc9LU4C2k81kredObaa6ZZfBofjonbx/4LwkhE2ljZ0oJZ
x3/cFsDGtAAzx8toj5ceJS8TW27qntFVR84EA3IQqs6Ma6gy64756oJTZwEtYD2UBOjsscavh9s+
t/INxvdktEkIAlYJDHZr5ANdeHdda55EDWxVQB3rkipYK9uSSgXT3tdyqgndeqIQ7csl5SnFxU32
GVMkRHHfK8VsZhE1hLCSksce6bV28OcGpQFkgzFo2wT4JV9HUN0E+oYbEZgoOLBQg9M5ODw5esnC
Jh6LyUnx2Er4J69eXDvjRNnrmxv741s3R2U16BMhcAFxAOUwRCFK8nZcwITmIDSAswmUEHJUA0sY
XQkxu5gElISDAikCjRKZH2PbYXUdKJiyOpJ6QaO3jnO1GiVuQJisDYFHvazqyh2Qhfemm4ixny/w
TI/xaxgVeifD8QHseffVyS6TZ2cWbxWjo7/FHoyzjibx/s71JQbwUiuikF+zz2kkPKSYJPEqlRw1
J9IrHTheKFR/KdhwTJYL0gy8vMCAN0TMWfDFeALYHDEpmZGJNV3+ZhWwd9Wz7Gyaz5Lk+x6wym7X
cO8Gt0hDZgL7FHEr+Xh3NdEBpTF0j6Yla/dKXFqv1epQte9GrKGTqOxxJlqEJ8DrChF9uBjRmBYR
h5FE7mJE8gNGXVSXbjQpULQSnfuGuMbFZJCKUATEDniDUiJy0UVNs8IjnzTawqpCCaghk6VLT4ry
KQpWYiLs0JhIQxGnCEfwOiYEDngc5fB4vvB7CDAr2nZiQ6be7RZSy4TvCxbeOJ5aT9XJupmMj6NY
lqTR0OFMC2jq52P971LTf/xhqQKRIUCLi+yyrDLGs+9WrWQXzSeI8GUAMqMHJSh+VGrYxI+biw2i
6YgeM9/R9yR6b1MzGGXTh/cBxs7FwFhxXbntik8I2cUYxoeaogb6vuL1JARblcMxJxfizgXwQrh2
qWBWL3gjDJHZkWfpQ2K5RLINLePxz+QF4z3uXjN4fpMquiDMwvdwSoqBKQH5KPTGKD+y2uYlFT84
sbNB1ITk2kHiqS1p8QSvsyLawEZ1qE/uMfIsQryNjZI0TDFKo/liOCxq7ZjF8MM2xICr0g4Hz6Xa
eU0M87ohfdWt9egbsaLOztIsDPgnSddDMub7vG7sI93CIDb56Ev5iXXffE+1Vt1p7WwmJn2aOZJk
Zm87n7O2u8IarjfWzqBJSL5/tfePtvrpnO85ZM7LveAG+e6jvrzQqTgsEEk5mq6dGgArFpcuWpLY
lZHigXJmaODuwUpe+fM4BQhadSWzJ8zDW7YNGBUuZsDTXaDBMdllmeFJd9dl9JDThVN6uHO9zUlv
k4Ar5ecUNTJSTQlrTBqOjLDZQrOKhngBezBYmOjbseZLDJxIbOGeGPDQRp4ziAO9m/p5fqwvhPCM
YqDpyioNGNyYq5a/ZJ0NSyfD8savFoSbBnkeyoUk0+m7Y9kKtBPNM8wEEpNmeUyN6Cs+gUBJ4gD6
GBNtAdsL1SZ2k4nI0SQ2T0ox/8qNaaZXpR7srm+IvZUq/PL+l/bHZ+0N+lPc/A6GuFF8/0sRfm1+
1y49K9iXkTLxP6A9oMNeGyhpXauu8WYg0QuyaagUvRUVnUSaiBKhQ+RntcRMAiYajsqAj+kH26fP
I1akIVcqAdxlKbNYC+lJEzA6t/DKjZQWqI00DFGZIn2x0gqNTnBPGJ1bwGyttJYX9gZwiYNXASO2
YDvOS5/u52eLAZ63FPwRzUPhzB4OfVp1ASwibCkmPsJoM0NHHLQXElNOuD6GXlC0IY8EPOVHlCkR
r2zsbWMib+ug26hh9Aahx9QfzmuTRYQrsFVlJmdeNDAjNQ9ARvJ/8Npmik4sxC4LVBtDOL/HeJ6P
UMEEpIECjBQ5zS6aDBhsY2R9RdJAAsVQ7lLu5WdV+J2vgtdrXwubMetv9CWovcIdnyR518sIK4SP
JRJB2xdzN9HBhRcrJvOkxkU43F19RrL3CGz9+YJkhSiYL0jJA7WYEphMUVR+EpotopXGJXU4wcj+
8I/nXqEqmmWAGaMy6getluJ6pM2QGz8jviATwnrPczdC9NSFY55kk9V9h2gNTVtBtHzF1CyR+lr8
H9lQwzYfwQGXsy7LC2ZcdMRwd9+oI4rYqOIkVzCyoj1OAcgSNAq8BImo9l4t+I0ErD46l4g06yDL
6LAq0XEdS/aSLevAspC+NZgswkXkoBLjbKZVcGvqpTudL2ax2S2HdhflxlhnJbXUmnhHgDRqhHdh
LPEaVIqpijugTYsosJgtnQRaYyMmbRnnSKCN0siKm2Lp2xkBoqLR1rL21WYo9EU0ZYWAwdHpEptO
JYAKxHFLDNfRYgJ+QukzkFTxhea7S1v6Gikm9kClSPDjhRStJ55+ONgYIoXVCpjc49MQNMNnKmLx
fVnLh1hs7Mh01P8FB/mndlCDnjyvjRF2CZAkjBJooZtE/a8/w1QUyOiwCmbDGHYThYpZY0yAEKHd
DGArK9hdzrdBmnZORMb6/PIX+MiO7k4oSwTaEsuw5QoEj5NLl1lrum2xxuc48AvKALWYgXzDyIUn
LG3WxYQ80TaxCYKBaO5TmS6AzqD/hDBi+rgdkqk0qYYSMOET0CUe8coAiOFS5IdE+YCCfI4zK0Rz
65YCeSiWTweYhQQt34lOIQlJoPv1Whr7q6hpqpWd6nbNoO5iYlQsvVh0zXh6Z/RNGqOj7HwnfGY1
PV11LA8mzaaR0mXCLIGoPTNrcVDGDMUnVLbMkmP1ymJibr5YDyHalnWooK2IjZkdPstUi1D8bK1g
iSuytuT6elqjomvFxsmELGw+zEcYc5yk5bqZ2VzBalKrr2Bj+O7gfImKFLW6gMwUbeWKlR+Gl9fm
DQTFiQaI8JtuuUSdklkoHNtssqrSIh/bkJeFMHw7CLwXynmRXco61QLZS3iBj+fH/2imEEUr17sI
opAVIKyZWoynaWtacYpYIyUG+bDCAaZ5S1g1Pd5PcOSN3dlVD0YUW6tFpbOw3dj6qF6ZVcX9Igpd
674Ujmc+Z/KlUilW9LJ+IP8pOSUyTZQ7aZZ5vp0CQAQKn0yyTYoZxfzR/NzOpFTSh74104zb8Jlv
qRPCWXAWTMyJl2NLEGMBQUxYyJuFz24bQzRWxYuePkD5qKVWv8z84Q0q6PIYGBv8WZ4uRqPyTrOy
TVU7X1zk5GCNpgsxf6bnjLttlfxodGq2am6ztbPdcrcb/frAq297LbdecweN+tAbDgbbrtfwao2t
ujsY1rbrO4P+sNnYqW3Vh/XmoFZppdFQUpjgbfIkjBaBV0Q25wL+RQONIllSUr4duhttVxt1xUlx
2rU6BrcSQSZuRb7SVKakqluayijow5ve1MUdKL8cGHFj2N/ZagHd33b9pjdoVgf9Lb/W6O8Ma1vN
mttwh1v97UrN3d5p7AwrLXerXxvW6q2626/4O+b+/OUoXHjq5ByEfKtnWhAUO8t9vHQcoqhQht91
r9X3XbdeqTR2qnV/2G9tD/zKVt3bqjd2Gv1K2R0MvOFOY3sLunTh0bBe3fJ33EqzugWdDzyvut2v
N4dQpL7jDz10hh1Wt/r9QbO1vbU1aGTv+xvhLUCu7sRA1uLsZTGmHep1MP9h0SdmF5331nbqlUZb
leV379ewX66gyS0MCKBX3fZqbqUyqG5VG9u1fqNVqWw1ttzhoN7acne8IYBisAMQqQJuNQeeu12p
7+zccwaCMbVWjDGNayeT2F2WNgWO8EL5/fu2O5osxu2PH0vPUiMqPSs9428JvYociXA+ShaHlD3g
74kOl72X6LQmOdYI/vFPGN85HcoTVWWnrqXmtEKnoArKGVZZgjaWCD1W4gGFXt9IXYGuaEHVNq3D
f80mWkSw7Ga1x4b8fJ6eCJ0SCcX/0sV/xiNNhIb9CmB4y4MNuVWvuPUBIMxwsDUc1v16o+lV/cZW
o1bfarYGfrPRqOz4rZZfqe5Uq323X6u2KoZ/QRAzX4ZuC9aIv+pfxmIBP2SAotk79A2gql/zKW+r
hGuFFIlfpu7E7U7zGTWWvK0eVsn1sCquh1Fw3VG9dV/l1i2VSY8tod5ZdaXNHl3U1fu9wDPWp/tk
wsFKeHntBJ7yx33f8/jKBV+RYoGDp+CSnfkTjJJJrOvEvwS22NdMkLa70ZaQmrXq4x3ZZ4th1CqJ
8RRqI29NsuolXTRP9KpFiVGhWmbGhiWwxOjFDkizCKJzzoZQSugeMFTJLBY3ZMhkeYdGq3GzhRw7
8wzTL3LKGOTFDx20r5xqiNpZ6QxM58YcMhqjogMKmsQ+rAX0UL4n53PAWZK3cZBYjmRLtdaotXL3
sG3navdI25dQ2rCN2g2VeY/lsfd8IRYXC/igoF6kMgyacNpLue2Wy93Qc06bZNjwxzx2Bv6nxsBE
vXvX3WeNxILQhqRUkrD233bVReBiQfK84UsoNEwg7yigidSW4D/l2ySVCV+I+e5EE05Y4A0jemwy
JjJnYfRrufjWXk9F4YiLRrWRLI+Di12+2jQhPZPEDEQROw/5UhHtACQghLayGXKEC2Z2Wccj1qSE
lZjXZj7HwBQeo56VptOSXowznXika2WNoCsgnGsGgQMkT88ABB6kz3qwpftgdLVSQ9NdNu4YprBF
EieixwZaywljBcjDTmflGewqaJ+KpTGSMh/eaq+k0zPeaa9QZd4rPJrCbbYB1bohzaSc9H8q0+Sq
qdymGRcP/9HojvO5TT5KvcHZk6Snw2eZ/Y2hntAG+laGVbq2cznD430WcdyKna1+pTps1N1tf9sD
XnG7URkOQI5r+tv1ulvfGlS8OggZtaX6OkSWPytF57mYCQfaDrx/D/3iB1e9ERCDiB5MhnP+BWXT
BYBNUBumA37jRHgAijjwdxVMW6tfb6raC4RoeYKJdDUnMVCFX5yCLVEkxkGdovgTotsyUAOskTej
gHLUh921fpa/a8fahjc9cYzScObrN2ZoKdNhBOouV8tZVtb0GOrklky4tOukCbiGXIK+b8ZqbYXc
tOcT68z+R47FXaKOGyPFmPp5kzM4xgPdAlIUDYIbWmtlNde6rj1tw+RjaDnKUp4wi3OnASqz/Flv
MJuTO95u3kRbF53O9HNQNuVKUC6fUf2zf3Wr6lBOfD1OPgdTXFc6Ig4Q7bWND952ULhwUy1nGeYN
AfTLw/6K5JsDoyyV0WP7em1skSQLawHMmKnG47kv70oKuxGSnHi2rIu39LSqe3RbBjRrpKSclHd2
CKyjbsyfZkMwE2ZQR5tF4aWlmp4j8zKgyDIxPByHvdJUeRx+LkuF0pU7Jgzke9behHNJgPRwFgw4
rMwakX6HL7/EXcSIDPsHJ8T9zlW1toXRgUrVartZN9jH5Xu6fM+bREDjdwtxabnYHQazaG67+PJe
Rrei7pEWNYfkTO2yERL5F/Jw5Boo0SU+g65yKvUAnX6VVpZU1bcWeSTXeuiSzPUuGqpAgZV04gWR
RwqbS5oUQwXZZDNgZT1snYRFHEXKQkQcheG0j3nedcgfjXZyE6/OOIdXLhl9JzkN0g/pMEPJV2r3
/6lfAMAfSu8rzs7H5+m/68k9lgLPOhxSymnA4Y7ucMA/XppxJedNRkF6X1L4E2mqEMVElfLtWR7b
4YJvWhFvukc4Q01q6ayj2I3QD575H0Tj8WlNV5bVxrr7B3unceN0o45XrIgsn0xNjJMSldFM+Pds
PPyaeKkhWz7L251bOEneTxik7UpuL80I8KpR9EczTCU1UBvECqPSZTMxogKMaE8dvjs9eneqPmyU
nn3YVM6vav/w5f90jnv8vPyh8mECpY6OO8fwpHvwWn2oLpcqXA+jkxhGt4SUgy69pLtQsIkTv5eg
hAXO8tYA4JTmNQ8mKOgD9eNQJUBZ55c+dFgtbZe2OeYOfNtSIQaBQmRwHI+NydHDDMO3moF/smco
zrO6NBU84XJFHSLlrtb3lWYjDYUpARqHQPP3SB3Gxjur8WhqhtWs36e+Qbk/4h2BVkbhzOcNBtTX
uKoyHEgiFfpr/I09TSpxoWmDDcTDF5M7jS7IH3fpQUnfUNEV53TkDnwK1CURxQAoq0eeuX1WdrCZ
iOVFUSdgCr2Tzt7xyx+efxG3ryWn+IOQZhrBIYtCrT8vql9RcTh10aXrHGjVGdkqBFGsnciv66nk
xXfZGlDOCgmA1DU1kqUBdMhGVvp39NUx6gM0RyDvQIZDx4fsYfxhDOLzv3D5VUMz9rsnZsq36VZs
KDxPm2JorOBi1KZOhMijk/pLAPh7otT1c+CyXzOnYgeFI+VEbx72mH/e3aB6aWZUZ92N8IXHDMr1
5ZKM361rxBf4DivLb181kkxC19TIaF1Aslw2bi4ussSk0VMdY1mUq7oEZu05i0r+5AKKbRqAs/an
l5Iudik6hHBdqHjvHtHVvJmj3F0iisGGvmjcgWWCkvgVdXeb+Rs4pViWM3Jb9wjaELYI5TczhNhL
FLUfCBvg0R18k5Ai4SGPeH2DlER2wc2kDiTuFLn9dMe6oa86dknkYh5Iiaql4zKRk7Zr9mKsMLM4
t3UzhyyvY4nCxw1NloaiONaRJXZY7za+2dS3QmlXZIvGxjNR3+zqewf9JB3DJRtfrLxycCJQ3Z54
7O/mo7UP/fWNdGTLRMebH/prdr9rZ+Y2Swc7hPIp6vD+vz/iTZq5YNT3XCIrxchKFmzosojxaBFI
aKTKm88BojXxTTZm/sTuQevDJQjIHClOyPrv6dnSjdwwvrwb6rRach0XO4JbN7urEIAoq9z8Wkvy
IoG0Fovthbj8LWtjtm69MVsPsDFbWRuztXJjtrI2ZitjY7Zu2pitjI3ZesCN2br9xmxdszFbyxtz
xV5sLe3F1p/Yi63b78VWei+2/nJ7sfUwe7F1415spfdiy+xFaG49e3nsOK7JNzn7JotOZ+KgMXeu
0XWjMR96To/kDragb+ALrJVazPt0Q4OssJEukf1/u3fyDwev8lm6psaQY9P3MSwkTEJgm6H9gfhu
S1QauoQSvY/OhUFpJ1CdGanfFoE/H7F1jzcLp1N0TXhHwUvngynZ/YlcwhEp2U6dDX7Ywq/abNdR
KVSqVOrNWk1d+PPzit+oDJt1Vx0BqLpHymT3bpXq9fp2Rb3ARzstVBFVSl44doNJWzVr1Wrtudr7
Tp2FIYAJ5buS2qhtb6p/3ydjDg3MqFhRaFr9EIOnHrS9WNxTtdXcrhK0dnYqvusPW0vQqknr3GNi
ENKhqpYr5YraU9VGrVRrQqFKpdRoqY1mYzOjv0ZydQ4X84fu71S0P4xheK/E9kExxAiNL9GJmdW/
vtyBxqMo8u1mUdveE8biXmDzonCoLgKKqwdngGAybwfgkrzAI5fn6DNSPIb5nudx/hjcSKRRQJrG
t8iwX0nfHJBNpFFsOXOMnKdQSXN4cqq1NE6krDz1aGDmpR9M1cJLawuw23ed4739zgN1ATtzdRcU
4UBH+2b3lnTwbwpWvpggGafY8SwoYLIc9IFqM/0Ixtg+O+7xsQssipE5n4lKNxAr6nBGcfxDCX88
cweUfCcrTmU6fFocxsty9k4ZuSxZaCyZDKSvGDMocaYWHGGBnvPaQ1HHqtow4cP5ylfMRzbl51F3
v0oeq2iGSNF757n4voCConDMI4BljspQ8p3/dM6Oh/yk87/gYfrQfdw6/1+t0qpvVTH/Z731lP/z
UT5Z63/c2dt/23m4PijLD+b1uTH/Y61V26pj/k8glU/5fx7jE68/xwaIHnz33yv/L2DA0/5/jM/y
+rNFrDMYPFgfN6x/tbmc/xeLP+3/R/isfUM2MJzs7UJl5QGr1Z/ygD3lAbt/JlBaTok8M3anqJcL
Rt4Xdbp3/LpzijdZCLP1ly/TScOshGHJZGFk+Ltu1afYs+5s3JIbBK0rKrh4+dVqOOQo75xNFs7Z
YFBQf8frMHfsLZX/st3qrSj+TIqSGh8f+ZE7+MvLAhn0/zyYkafd/OqR83/H9H+rWX3K//0on+vX
/ywYj/0/jQV3Xn+QA6vVp/V/jM9t1l9Ow3v3cYP8V6tWaun877T+T/zfv/+DnN3b7qlhAjbgx2Yu
F/N/G4NNzAXbdOCfbUUIwddFyKcAE5jLHRmegLz+/JlPKZRcTGBUVJgDARmxwTnKFUUOQ3+FjESE
cXaIX9OJwadXOR2xSbNNEnAkCgcBhRz0wsGCskOSsRbpLISlPJEa+c0i26a6o5x4C+lXxDri3avO
ugFtFNEWbrQg5bJ+HfM0HN4BARHl2GqrSOMsSpQh+OvTtKaL/iiIzosWD1fEeAAjzQPDPMpkVjwa
5aCFADORDROjY8MgDgWNZncMIjIJvDyXGBRmJkGUGy6AJ4vOxRQXPRqpx18pwlGYivQAS+YFxKW1
czlcdMo6RnPhdQbmG8PumlDyMaenX0XnLscVZYCxM6JrTYejLKO2GWMyUVo6HH9qmsATnv7QUSeH
r06Bie0Ae6uOjg9/7O539jW7W0yzuT8n2drOP4+OOyfI+ea6b4/edDvwrHvw8s27fdS+fw/1Dg4B
pTFhJDR6eqiwQ5tjfqXedoBvhJ9733ffdE9/LuZedU8PsM1XwE7vqaO949Puy3dv9o7V0bvjo8OT
DnS/D80edA9eHUMvHUzBVIJe4Znq/Ag/1MkPe2/eYFe5vXcw+mPhzI9+Pu6+/uFU/XD4Zr8DD7/v
wMj2vn/T4a5gUi/f7HXfFtX+3tu918zPH0IrxzksxqNTP/3QwUfY3x789xJ5fZwG5hU4hp9FmOXx
qan6U/ekU1R7x90TBMir48O3xRyCE2ocUiNQ76DDrSCoVWJFoAj+fnfSMQ2q/c7eG2jrBCvjFHXh
0l+eA/7f/bnN+c/64NLYu2cfN+l/a9Wt1Plfq2xVns7/x/is8ZGOZ4I4SU8oopNH0cOMGuU9lfqo
w7tyYFBOcYNnz+VkFLoYrDpnoiWxL4Y/B3IvlTPdA+cz9yKInEHAuPafBsf/us9t9v+fXZnr5b8W
Xfak+f/mE///KJ8s/e+augjGbQzOMwV2cO722/Not9aOLuEfVIc+V+odBgtrq/UN9P2lIAHrlU31
nkycPwK1CJ0L1vnCD/nmYOK+4MtHqu/Qv6IXRpvB1923bzu9H4FBAp7kK701Mkj83nBTXEILLe+O
38RlRFrtwcOvVl9ddhNWZ+E3CvXZM478OF6M5gHG1JpfTZklF39iUWmasPtF1jsXMKdeAbhg496m
w8VTJ0OtcpVymPGS84YVkLiKatUnb20e7unPR8CqsVxFsWHYJINtJSk054R90zCgKfZxFiaGWFLs
KNn3gRwHGCrIvaKU4EFkwsdOZ+EFp3suOMOy41Bu1zL9W8CRcJfTMAo4UQz1A+LagsOMx0A8nLLY
hcvcpif645wrx8GUHJSXQznslUaSBD2YY3IxFC5Qfyo1nR+hjmCH0n9NTd88ImvFVF2qP1QyF8X/
Gu8LrK2BlgYYmgZq08fpDCE2NwWSUxpB8yP0CqR/HP6j3c09bFdGGGWO7jNUZ49M/lca4B/XVJY5
cV1HsjI6JnudJBmQtouSpkvcbenehdKOULVIN4mupez0QZGR6a9jvrkG1BpB2QpIPy7qNXFTa6i3
1nC08FnqQyJy4c4EOxwLHozurw/1Jof+da/xAqiNZ8edf7zrHnf2nxU1Kp8FmOMvA08RRzeliwQB
6YF8+Kr7T+iCiQ5tpHjlDOQ3tNtkIUWBpIGvhWICJZY+6RFGPgraK4YYf7gvurpwFDn32CBYGhQW
xEhDaWB+3z3YO/65d3iCM/XcGUj6jrm9kXSF0WKIAFhuNK6c1XTn4MdMIOL6itZlqcW4jtWiWfbX
3dPecectxud2AGBz2qvibA0/HY4isRoIiSaSQ04O/fAEOgij60F6eJLZhNDkt0fQBGVe56gpGLxu
uQ0oltVITNehET0CPF7sNF8bfEAUzfEA39iNs0DhewsAksw5Wp+MEUGn9pD4affg5HTvzZve8d5L
e0ho3mfNz6UEEnjPijevQCTRX1bSYlw7jK74UtszBbIfT4xtC/noiPMKLrXKg93vfP/uNYxSkrWA
fEBJ2u3xpKZ3cEiYt/emu4crLwcfhzTmcO6EtQV3FLhRgS+WiZiGTHpp/3H4AHJST2+Fk+6bzsEp
9oF4pR1iCzEFLyiMlsEGsHp/xK0I5/L6/7d37c1tG0n+b/JTYCE5JBUBFOXY60hhEvmZ1MVRynI2
dWfZDCVCNDcioRCgJEfmfvbrX3fPCwRlJ7tVV3VlVtkUgZmed0+/G72E2OexGxwrQlk4SsA0qG94
bh49Gjw9fDEQVSdCIc7zojCLZJJfran7+PCXH384PHg8eHhwhHXX3MAZx2sBzYTFZxCWgVvdUQGQ
OkTxw/dHLwf/9SMVq22Cgz6s3Hir7TgwthF5wc8Gjw4effdk8PwA2EhwrH/hoRFz19IGY0NZfrja
TgWcaYwuKlE+Z0266i5KmPAi8Mf4PD9xT0Z5GT4gokYeVDXU8Pi/8Tb0UsMiccHrZhNBmZisCW6d
fnzZS++lX8TV95bu7ce1kvndnRrJ/AoUjzLux4YXnw+vUuHHYVaM+pISeIU171aJdKMXipsIej4v
w7GED+0Awsdej5pNolLH8+GULYPhNWVZi3hzJ+7EyJmGCK1CGesp7x896vV6f28iuDR8NCIOzHcW
ff3ZbhTfKfaiO8XxjGM0+tAlauMW/GWWzdFEYrk0JEA1DHwb6qvHVti/GHGHWBfn2MgahuvtROLb
PGNngVYRiXerJpiAtQh73CCa+obemmh+FH335ODxtzeg0JYp2E+RqvBSITSkYM6uuvWb04n86wRn
UnKKG43PN4wu4FY8AToxceAWsMxx/TaREUw+uJ2U0wEOC+F3nuVBaVPqHk3xmKPD/zOfJ/bkcoWo
zRqSCBEyEmDo38RMOnrxpFMLjBNjnOdUyABiO5w2ByG09ubD2SznKHwWH2lYFMTfH2JLa+4zREj7
zRig0MfEhWGvqgvulu2V5sJANoX8PB8jgx/38SeCOxgW1EI50E4NhIwTI3nN8gCTJdgl7TbpBj38
5cnjwc8/Hb188eTguSUVXzzpt9686iVfvubYHTc723eXbQ3kgf+GyR8Hyf8MErz5ctn5fLPFNkUv
OcIjTRqnEZJQcBxYXlK1F7yUHEh/cVGUdJSnJsEF8oOcIFrD6TlyDSA14aIEtc54T0irizwqEalh
Hp3Mh7PTtwlvDmYwJesYx2hRrwxxyAAcZmsHhEKy0cC2y1Y8g1E+OF3Mz6OY/qPzg+0cN81TOUFe
FNU2/aWH92Z3iePbbNAdbgzzk8uIgbmoVeqW1Wjw86Q4+gEeZzc9hKbKFYof5YpKauShBjy+KsCv
ENSzBjg/T363kA//NOSzDIRCDWh54cH+mF6z4RGQVYudGffUX/F8m0fAlKDAPQPCaYWYaVC8He7e
u0/71C6HfSILEnbdFf+spv8eMMGB52Ht8e3Vx6v1i0zA4lkyjOitvjIpPAvFDYwRtmlfz0actrsH
DyOhR3vpl9t8AHXv99Jdqvh0nmUPjx4LABwHK0dI8Ag1ZjYdHQc2xeUNY0WHOZNEIkCdJzM66PPJ
KVeVYJPwuIO35L7IYRCtbHhKfEVvJ+3tpve3bQfowd3t6OeTxaxcRC/ni4KoU5o2hhT2KfrKBWir
mT+Lg1CWb7IaGLiuZFpXitNMb4ASv4K1HjAHbZh5oih8QgQ3tpJEAHITjqZBw2TWo1CcrCAdY4Bt
IBZOJQrkhAiU56Nt8DBvYcdXGaDNeWRye0AVTFypidA/+6aD/QBv0ScIsXOcthlHEq58v9npdNOd
neNed7wfuVeV93jdit4TlIbOTu0SSgFqhxvZ2dnqplSv2Vg2ceYcKiv02ChKe8VfaZq+tmhNYhw2
zvpyppu0mydnJZ8r7/AhXt/mzdkylUdx7fmwiU6x+xucIZbwnLjyfqueuw0GbBHt5g19Ca1yZiNW
N2oL2aaDjrgqDY0R0tYs1q5MJ4oYfPS1/zgtpxcxV5xeRisvQghcjONs/9k5oY8QXa6e5gfB/LRQ
vxV75VqaEoplrzkRNtcl7veReMkREdmSwlos41+YbvO/wb38k52QGxLJTaa4aVbJIFiVocS6z/Xa
A8mWjv+gXxxapanFZK9IVA+t0Me2Mc84rh9uBPMAtenBXXqAvdZvU8fiesarO843bxToMvWEGMnm
DcAsTZ+ajQ5vT3Fmt8U4Zk9LREQtMCJxjRjI8+5uuB795S4lNU24bjJcNMKO6/S7IyfDhKhkEEhd
2BrOp63IdWwD9B/kAJj+6eV9OrmXhYQawoNYpYRt8aKGzLIlaRvhTo2wXxP2GVWDnWzU+Y8Mlvph
t8UGoeBeev8kK4e70WfyY37a+3fA368D3vvwLPobIGrR4hNpXfiz+e+PPP1jcuG17CFXiVEgCMz1
UUkX4W2qJ6uYn9otomXkWH3UAektAwBUuEbjPM5h105fXXSfKH5T1T9BwSh264cghFlMhC71lX/c
SgX3HBWMQAcjedYF8x0cPF6MU33NB8UTlhZZmQDtS6wut8KhcNTWsjRpkkA0R+e+8pR4hELWLqRL
UYy4CyKihKCtbcV0UaaDKSVYz3lrynOzEf34cI+IEMgsMrCNQyT3FkbYFoXuoRxR9aYF5ONTSLX5
Et77htod5wQYP3fxs9mQtHxziINYvl9eTU4zIp6BAEYLjvmpztNi0jcsPZXHFZGPKr8nfpJgnQ9B
eGo9FtGl0aoUQCZRWxL+HT3gx1DVESAFwaos1zy4/G0Tx/xUIhc3PZyNoeK4/it6I9zj2eub+9vL
TX+PyIAlRRZYNI0QPizYjHKKSaYrFS74GWsjIZtFBBqiiDmxA4MQxjAqWUZB3aZRfl+RLThYNurE
s5y5Vk0AJfiYVpNmZkQUe5TNOM6bRri7QBC8t5moDoYhR5o2ZY8mj2jUvKIxFFLCnyUJIvF70/H+
fWTv5gox1RTKFwX93kPG8ubGpt5bomV+9uaNEL7l/J0ulJym7iaDuOJo7ETxnmYaruMqa400m/E/
FzOb2I4FOpI9DECQJnA4HmpGNZVkwOp1eIr4IAgNkprtTP2/hInkPD/JBnISINAC90/vLmlI3qs+
jdi87bdeffvmX3s3y9et2i2zacF4u8WHRVPWCCohyM23JlCpHDPMUqxTWyLnFz1llsQu1w2v17Ju
wQhWkvgsL5gWJqxoxBgK9brd9rrU6fg0Mgqhj6bdKDaL43YCsNvKeyDxoMRNZXJonCXdVCqItfW1
uuQbor6uwJ9nZ3CKHBfru+CKrPTCjdvIEtpteVY/bpPFenjCYVhzneHh7B0d9m2oQZA3XjanwTua
QEBKQprGcEQcHmRGvRjOOSgMJ7EWhMxpYs8llws6XvhzH8wNzZoM6BLC2bqtcJmggUz4wsnZO707
eD7e3ORsmYxLUCG5+du8ocpL8/xjQScJDXxe9nu7DkJ10hsbgu4dBBYQS7hbvm/8jOWSUi6wPSiy
zNyJ6oh2ZveOZRc2pUG9CIkrwZmv8gpCJ+jLFUoBRIZ/C/Rky25pff84Q2CcXDvp2CNDo9CElPPJ
ReLlcOlZOcxi9geCBjvx1Mi0ang8+htU0ZZ7btI46isnuBlw0pXBSZ6X1OTwoll9UMMLEfkW99Le
A5oK+vq7fN2Xr3vy9YV83ZWvXfnqydcOf33J/wsMASEQBMAXcYdvA8jQrc0M89qXymmbvrhoWQ1+
77hIn6ryFNpCBi/jrRgRHE1VobMTphItCC9qPvjPQG0hJG3flwc2Gs8OXxwevhw8pP+OXr44+InD
uip9HML1o/yDmMtZ3yj1O8IpG/1KBSa/c9emMsTCAvP/Zt6El/3wrLkspu0BDoRhlXmW3BR+d3jE
Lpp87r1pWdPNfrzGEEPn32dA0tU2muEgLZfvCVrjn1WxnEe8ZzGJdtuqDtdYDuVznY5VyYDRk+ux
1p+y7dsyPRKD9feVMSrhT5xKF3msUtjcrZGPVI9VhQziNfRZBctbgKvwcYYS9BkhuWR0dk3d8qpT
T5reihweuVVgzvHZIWbXPbRzrVU83bYr5D0MyvoKba+0/5gxoSIPzNDgPB+LBE4mjCod6vpzz5Yp
FXDDj0PNq6a22A2YrEbq5h7C7d2vP+tF74kW5iNnGqW6PeyZcNYVoQYgPvs6rLa6Th1sHD4paigx
gP2FFdNzwgXbc99iIxTLhGJEmZQTJn9ia4GRsGUHXW/cJOGPcHtCBPi1bQpGLF3wAClAfPVV68nh
01YTEbng+Q1SvylBpIjSKuImEu3yU4GVF+mT60nZ3sHwqGa1SwhQVd+UuSwJf5mrcXYpQH32mACB
LqALLwohC8FqJxnoS4gjza2HlofRY5Z4GVsous9/gGf3th8wHhJH0ABqsQk64IxmkaP/02u2uEhk
AoETGEMIdkabqDQl8gmMHGFNOesqLqaD8/SHg2d0nOJK5w118ZmftaUyGiO6IBazLDns8LQ7Gl4S
Istm2bsuCLtF0f3ibu/eg97uA+RA/fLuF/d2H6CuCa9J/ZceSQryyTRzuXWvMglCriIxoxOWuZpI
JuDFzL7GcRST2D3CbxvMdHGyqQd/h5YS9hj5Hp5G0Y/5tkeWDoRPHbDtg/ZGbRkZx65rX9zhiiFy
HWIgLOFTnpfTuICdQnNQpMaiQbYJZ8oYipwBeO0BM58XWQ4r3/o2eayrIzXw8/xcecpf2RLi18gk
ByPWuzASBRlaMpkl2NN8hxSp3jyOsGuHOyTcFnKZ4zo7POoIyxIgYg8PSHI3IUmBDfdbltKTVwE6
bwVwWjFKGzHhn+gVkG2lX3IXrO8Z3q/vm9wrrQo02z+9tuOAWOi30LvWfsynpNYkZHend78ZtvXT
wUttSZFKa2/zBg+X3JifxKNq9VU3PGfMBKLCTCcvtcVrAzY4E+xGY5hdJqqkte987G8b9s3Zapp2
xHlFR/3vby9WC/wnt8LGqtGv5TqHKgbSOJGMdzW8YNTqtiwBgNwMjk6oUuRV+N3ucbc7GCyZSAd1
Y3grzs5CoHjqzokKKs7co3qKH3JAuqsUkpl8A8Tf0GZNhD3iS97QkObKLYwMGLFKGnIfdewgTWmo
dW8ngasDrqeILYVWAU9j+fi5vAW0mZT9/WZD7sL/zFiIEv33ew0VgNe/LXQtWBNDDtCNGz4317rl
679RGBzqxWIJJkX8YboDAkqlCF5TT6qHYpZdZWxJXcgt7drPphMiNc4R+weiVBbYwrZ0297aUld8
9gALieABmZ3u5tm+gJXE9iMj9+H76fTtcDZGsCKOwZ0XmdecynFx38qlPR6KgHq6LXmKf0M84ohu
u4lanQb3aQZhpjrPM6RRviBMnPy+yF1+LbUkYRdxNo5PjTUAJ9w5br96s//6uLPZPe7td1vRVyuT
yJDFzFGNNE7z+SybJ3y6rtilR+mLgYZ+BqIxNqkzG1iZzUJ0xKeTc8LETDLmoO9gxMcy3cQkk4oe
iw3ps5wz+srFLsSJtjaR6eMrT40qJmoOcZKJy4aRnl/Nc/ZIgQrKlriYsInJ4iJlOD8Qs4eFRzxz
JemR/NN6XEqr+9F0gfWEPgck6SYus4DxLKLWG3MNo0YLgtmVWXUsEa/FTJfjTXBvSg6kY2zzvXRr
s1u5kOlebR33+Gu/e7Fm7ZQQEq5zI3oiIGx060si+iSmrlFasOoF24ezws3NXrNynQpxYLAD6IOg
cZAKleuywsz78gunvFLlvnv5IQW/6vOdgp+qDcrxHw55MQe0TqGarqjyHRTVd90iGrkFYADpVmR6
a7cYpzZVe2BKitbh5hbjyOUqq/bR2mkzgZs3+tcdnRzWOuti+qIn26vYVpEfak4Q8OVOUlsprDO+
Wn52WXltJAY6s9Uaa3boMYRmHoXog/SBdY7j2FIUvjZclaLz0zXbq/5SrOwrVP/gvlp3RzsQf/V2
Njtppchf2lIDJzCtAQgthEzWbXvAFdEfdXvACv7WF6kKeW4rq1vKe222lM7tX95SDqQPzGwpNdKO
BrO8HBiZCQgMBOcxrM2ppnFkq+sKWSuJqVWxzCbI8GUZns2z4m0ktsWTaVanOUdkHgEJoQRsDKa5
TbUJy2XEDMzFbNNYGG6L3hrOsDqzetGy0kt5/khlNohKOCxKa514lSXF8Erv4AWY/ZJjjmtcnLPz
yWmpwSy/P+NolKar8yzhOeHRlcmwZPc65xbJXRDRw+oYmNqRXYmnJs/pKML+t8HrYYuOrOJCpLHj
Kr1l0oAlHvPsTLwx1emo5Vy2WHXFYd5hIAuLVZm5eaYLeTUk8Lxu40lgTkE/P3T0Y7/sLWcckuYP
MgpG683upiOYCTLzfkB7DWpTQ3Wq8agsKxcVSRFsK9hSn03jJY79FduobhjTDc9VFUEjrXSPbYp1
ckEhpjjC1lJlHbLQ+eH0IrUCugAPuNIfxgPryioe8F4bPKDz/5fxgAPpA7NXy9XkIjPWxP4WAQzJ
RLwOt/c+yCBajklYIoVYEWhPo2QOXrw9vPotSp4ex8T+C2HZNf480eZutGyFMDqxVj4Ln1suHM7W
ZmCepAV5jUfRuo3v66gqRiYyLZpMyABuNioPWDfuq+V8nR36vFr+pvJoY2OL5nf5UWXv3AnWYGsp
UrFe2hMj+l66C2bpZDjaj/4gxAxb+V8JY8J/TW2mB/BgYzvyXxmlcwgI5uEkMS6yrA/ncpY40dI7
tqcRgSjOVSrKwlGgOq1BKFtx0Nd4SzWJOrFQTnFKy5uRm4GG91j/rBmyE8NoGTyD4o9OUWApT7+v
3uLUzjkf19y0qj2RMLDZrALJSejsQxV8VVYj3NkOHHFEfbNzWhAYGjZIWCJWUWLLitP+QGz9BmzA
Idt4cjYAQstGso9v84SzwpOLfjzO269e7Q3PaaX3Xh+nr7c6x0x/bcGMVJ/TJV8SIOgFyqHz0CR2
2IBCD9bfFBKlwNRLy+vS4vvReYhAmDyV8qNzDzswmkMrS7XOoZn5W9RucxgEnQaZmk7HvOXTPiAW
OZsPaBPS8manhQfHNlp1+IxXxKlSY/XAWzVU3cDZDlGoUGvFIex1PV5pOptSV8hzehUB5bnisGYj
3KaQAXl691fS7VlmaGVa7eXq1qNCDw+OvoO95sHLR9+96omJsNGKM5tumqw5KYvZ5HdWFPIEpcSF
x565vM7zZ75vk9iRuOLe7Ho17ShXVsAugMXfvPj+tcQP2MG6Yf8Ezv2Is8PWt9DNh1dDxT0L2lFZ
SAsfXeuYpKrpmpkSovqpxtCOJ7PL/DcJ462SL6xXHEFWte1y1eRGo8VZchczbhOeUSVMR23eXKZq
DOWjHo1DbnZBVGXB0dLLbC40OfuWWEiwsSv8BtmDTPwoYZa6UAcpgCfCwkX4kjib3Cpn12mdn0vd
XSLqn7I8JoNnj9SGXrgUryK+cWBUm+cc56ZHNKjScyGhUZWKF5z0h8W146wccJY3eRYcTpbI0smv
FEf+vHWly8lFx574UuzVK0W20usO276x24gVHJst2vPE6VWakfZfz709ODp68uLl4ODh4YuX/Za0
0pKDW+9vultn+VGxYlE/mdUwLaIMM+vtjWvXF12LwbBmXEyvNSiIFQvROrC+50567YRFcLwFG9Vv
teTU6Yn76NNGd4yRcPp+YtkoMHhA4565c/r688DSWcZtAtVcwPUDjkBaL71u0c5x/v40tLPJDELD
cCYwheJx+2t6/Wtkw1EMacbVuGyq1yD/TK+diIPzJ/fjN9Jkt5t2j4/TZftYPHypv51vjjfZCF2z
ZokTsjopVzH5JYxMGZFbOZoicc3yLHeK58HEa2BKOsxt1tvmTQQeHeodunrHDevuuHB3y1TLntRt
pRk0jWpevbJ46lvikuqw9i5jbRrnORyabyVUdnd27tH9KtdrjzoMvYn1UNOH9OjiCtuIpiN45zlV
9MSalAt2g4gBeMMdqmCSQH7GT9aTNvJeCZW1BIeUoml/cP+LnR078+aIyGu/oJIX6olnn5rOOjzm
99Xiu/XdtUU+1GNbcG2nbYlK8bDr/guPfL1tonsOvxAl5KJQiEaEk3DosL6Z9hEzrEo4WY9I1yXJ
P5pCXaK6i3EuCovuca/bCgtbKkQfoVrQezuotbPvjcE+H1x7V9Lguk8osrLxiEwQBjeNWvDW3dxN
EkLPDWVwe1GcxuBz8RUD/SA0SaN6cQbTPrhWt83qQuC0D6b5aMAWP+VwGtjjYltojA0Zi7mHnTUl
i+RxJYvHIPV966RgTzmYHWEG78DN+8aAWhplKyfOcOVOozv/XVuObyV0tW6PVjtbmfThOONifaN2
l8dloTZgxjeDOVgWjbHUkqkuxVW45bdBm7gYMri1CgmbxtqlsuCLbnUqzXhCc9yOL54h7NputwlR
waD48ztFB9Gk6P+vbd87Yg5YRw8YzPmQnaZZigrqy3o3Ub8h2qGhiVc2HWk99tEUAsNVIRqgiR8L
3SuQszH1yILFjBWiMwj5UrXq+oehi09Z2MqhvoVgOPXaBK/fSx+wj2PMRGO+mEvQDBvoiUlHtsDP
5hp7Qqld7oC4pWsovn1dNg7wxmHT7a0DBy1qi+7oIlfjNg3OEe/iKVY43o2dE5VvxhNI9qoXYyXw
woqxCsKXIFtOy68QIwfM3ioR2Eu/SHvEi+0sI44tU1OHX5pyUmTzxqcX9xJQ2MvIuIuIaHgvWkED
p6wUNjaKiyJq1+4lkdKzixNiy4ileyE6VjVhMxDdYZlphMH0WtmOiRHQ8kaS2AipEFT2FWu6Z+UQ
mZHhL/fTC+IBTpG9CTuWWQHOp5lhxXN4gqQrlk+hDgjOD9f+ktWQ3e06/LgKTA7n7VP9gb58DkkK
h1PYe/26k4Y/t9Za6GKWvuPd7+IuFu+mJ7lscD2BRRpp7AbWlKheAaEcspKVJAAzJx4yn7IPFvzo
mM6ReC1mnnEuhRZWc4OZs4cFBL5Dx8P5CSx72WjARXipjp8jyYmYCyauPIF1L6veq39Gv1CnFiAa
RP1qPcm1cE9+OV77PyHH74ThEyzF7MOsSO+AgucIvwPERphqCkIG9xgcPiWk3YzpeniTy+2hSWaB
e8WflXCLghLEtx8NF6MJYevJ+aSUmKag461Plo14ylGWoIka52DW2Ra1UeGGRkFsRDPuFnrRqoxM
oyjUnKDKDDQroRIsA1ofrWYFYwKBzLPTfDyb/OFtyFYzwIU0KBev11+z5lp8iNsyu+bLaICtOwDu
o+1rbsuf5K4wgaRURi2mhZq2rYjoQrlkDRwRXZe0lGPJWoGlPJnl15N8wTSE82HNz85MbBQR6Mw/
glrqsH2LWJ7vRS9xfz+XHMhoKTZRUeJt63Y2GmmQmlSsmTVqHcOZZjDcmhRTjh9cTk5/e8eUC+qV
mmnEpImnrb7tRjvLxULMjnWboy+OsulFjiBvURv7z4j5TaiuJGEhEb3hKL8dbLxyuign5+gnL4Ei
2m9XiDnevjPVNH7/9KhPh9ByvskQsVCL6KuvIHfsdbuv3iC6SzfCsmvYtlbvzs7dkf+vJcYbY+d5
PyjzwTgHr1wvRdKUbx1lGjkrXByJQCfyGN7I7/qeb46yR+T7gvFrUkAPR0zvqz2anmy+97qFvxGk
C393qEd71b3wV2tDb4a6bnzgdRXStBPXNPYnqzgFHlW6+e7w+RMOP4DYfrAaDAtXxN3VCkZ6GlZ6
+fwnlKSvx9+/2Eu65fRiKdEDw3JBIIG9/m1RGqBfrjRCt89eH7fSEjKmjwmk6ld30Uj2+nlx3dtJ
H4Twg8ASrnOj83TMcf60f2ElJ8r3huOY2tF5WLyildjr93Ye7OxATi5iKnMRaORdJuxBNNOhPyF8
jTMPKUszREYrykw6D13a9WB3sN0h0fTw8NPJNUcvrKkr5IHxDCZkXVeIzm3dY9zNIpBZpwvxO1Hm
66GbJIuVYSq+BQMxvtqiMzYt3hWDWYnhbUTPJ7MJ3dUItf3sx5+Z5v1FLMtMdw+P+tbYbMUaTa3Y
+1Frcv/Bfd8Yzb3vx3cf3Hc24P4LTiopchLXfVFkqSlAf6e5qtiih00RFCJy6EaUjMtoh8kRyAqr
KC55S4PWcOvvI/26GpYsC4f8aHIG7pUwMFA0EHELLgoNCCBa3Tcbx59HUZdjhhGjvjhpm0fbUUy3
EiL577t3yebKc5VZsB8p6+V34hXNqqeyarB9cMyLfhxv4g2sD4z7qdwUm6bj4ixIVK6RzCf/4NGa
I/HeHA5fPB9soOUqiDmDMBT4e0NLylWNA6cEnujyiPyy2iEOrU8oe9/lPTGaFA41T60sLhgM5+lS
Wl8MsDXmJ9vx0C4bFqwRWswN9H22R+LKK4wMNPVogzvkMWoFR+2dlEV2fpZafSBvmSzaDSjYOuZI
fEc4tp8lgqt02F5SIYU/jstqOtfI0SRzQnuDvCqWOhrcAEWMVlIWzVrdJ+e8anyU37MaurOivVtZ
6d+4jgQ/eC+KC1dL9RiVKmdcRVIIvJdUAqgSntqeKV0XnV9rBQ8diOCgWzgTqqXAjeKJbjMJjk2z
NFpMp+9sEgZfJXUCriTQ7khUOvF09he2F6xjHfUPsRrNvF9pt6bSCoLnfQSeIMTMijwJR0ki3Y4X
6b7PqBHXEL0LXhAyxWPN33srJ/63fmSjUYDWMSTnWr7/q6BUL73XqRcDxcrRBCPB4WfTOqGNM41k
OCm8YNahnAfMNuJz3QPpwb4aFhf1Qpe7Kv8AZpqlp3EQns35tnOklvW+Vh5xEThT79GdVJcEOV66
W4pmfitcqvk0WnP5eh1aWWbzrnap7ctguaNK8w7E+i4EO4I6oYrgVZHcqhSe23O647VVnBKm43pR
r75lRqhprFXMiYahShQY161Bmk3fU9L+ICK16Zw77Z/s4+H7dOgPz9nePPH3ABGVzw57vd7zw8c/
//AkYgRSuOjzz3K9TyxoW7bZ9GOUrKEy6ywEYyVk2R0JEGha4Lg7hYM6+E7JSZMVLIk+zefcExaC
vB2ORH5tE3bA/gA3qwrsg5twPCcyDufy7WI2mkMKQ3CeP0SQUnvToD05yoifjQjnozAktsYa4Kxn
xs25PRQJNjyWCJC4WdlgyeKI1IH3CEEfsMmDaBLUggIC+8VswsHEWEQ0ypBBSmyE1dJXo60XEnx5
ZWhOsqqSj5F6n7ODUqQSkLReMHKbKdI6qt1qb9dX7sTN6lqvqelvBpjecITQ8CCrHNHziIxuddRz
jh714r4AN3q+ibVufhZq5ScErKhL353wCRjNKqy/1LUPtOwMT/hO+V7JTpAREefhyasZP9KqtuEl
9eVjGOPUv54sRWEuldU+GBNQiJGGclwl+awkx6qTR6Yhvxe1xY/LxnjnfCHVDCYuBj9dUf/XOdI+
fT59Pn0+fT59Pn0+fT59Pn0+ff6/fP4X7319oQC4AQA=
EnD
  #mok-image-tarball-end
}

# Initialise _BI
_BI_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
#!/usr/bin/env bash

declare -A JSONPath

JSONPath_new() {
  JSONPath[DEBUG]=0
  JSONPath[INCLEMPTY]=0
  JSONPath[NOCASE]=0
  JSONPath[WHOLEWORD]=0
  JSONPath[FILE]=
  JSONPath[NO_HEAD]=0
  JSONPath[NORMALIZE_SOLIDUS]=0
  JSONPath[BRIEF]=0
  JSONPath[PASSTHROUGH]=0
  JSONPath[JSON]=0
  JSONPath[MULTIPASS]=0
  JSONPath[FLATTEN]=0
  JSONPath[STDINFILE]=/var/tmp/JSONPath.$$.stdin
  JSONPath[STDINFILE2]=/var/tmp/JSONPath.$$.stdin2
  JSONPath[PASSFILE]=/var/tmp/JSONPath.$$.pass1
  declare -a INDEXMATCH_QUERY
}

# JSONPath reads JSON from stdin and applies a JSON Path query.
# Args: arg1-N - command line arguments to be parsed.
JSONPath() {

  JSONPath_sanity_checks
  JSONPath_parse_options "$@"

  trap JSONPath_cleanup EXIT

  if [[ ${QUERY} == *'?(@'* ]]; then
    # This will be a multipass query

    [[ -n ${JSONPath[FILE]} ]] && JSONPath[STDINFILE]=${JSONPath[FILE]}
    [[ -z ${JSONPath[FILE]} ]] && cat >"${JSONPath[STDINFILE]}"

    while true; do
      JSONPath_tokenize_path
      JSONPath_create_filter

      JSONPath_tokenize | JSONPath_parse | JSONPath_filter |
        JSONPath_indexmatcher >"${JSONPath[PASSFILE]}" <"${JSONPath[STDINFILE]}"

      [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && {
        # replace filter expression with index sequence
        SET=$(sed -rn 's/.*[[,"]+([0-9]+)[],].*/\1/p' "${JSONPath[PASSFILE]}" | tr '\n' ,)
        SET=${SET%,}
        #QUERY=$(sed "s/?(@[^)]\+)/${SET}/" <<<"${QUERY}")
        # Testing:
        QUERY="${QUERY//\?\(@*)/${SET}}"
        [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "QUERY=${QUERY}" >/dev/stderr
        JSONPath_reset
        continue
      }

      JSONPath_flatten | JSONPath_json | JSONPath_brief <<<"${JSONPath[PASSFILE]}"

      break
    done

  else

    JSONPath_tokenize_path
    JSONPath_create_filter

    if [[ ${JSONPath[PASSTHROUGH]} -eq 1 ]]; then
      JSONPath[JSON]=1
      JSONPath_flatten | JSONPath_json
    elif [[ -z ${JSONPath[FILE]} ]]; then
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten | JSONPath_json | JSONPath_brief
    else
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten <"${JSONPath[FILE]}"
      JSONPath_json | JSONPath_brief
    fi

  fi
}

JSONPath_sanity_checks() {

  local binary

  # Reset some vars
  for binary in gawk grep sed; do
    if ! command -v "${binary}" >&/dev/null; then
      echo "ERROR: ${binary} binary not found in path. Aborting."
      exit 1
    fi
  done
}

JSONPath_reset() {

  # Reset some vars
  declare -a INDEXMATCH_QUERY
  PATHTOKENS=
  FILTER=
  OPERATOR=
  RHS=
  JSONPath[MULTIPASS]=0
}

JSONPath_cleanup() {

  [[ -e ${JSONPath[PASSFILE]} ]] && rm -f "${PASSFILE}"
  [[ -e ${JSONPath[STDINFILE2]} ]] && rm -f "${JSONPath[STDINFILE2]}"
  [[ -z ${JSONPath[FILE]} && -e ${JSONPath[STDINFILE]} ]] &&
    rm -f "${JSONPath[STDINFILE]}"
}

JSONPath_usage() {

  echo
  echo "Usage: JSONPath.sh [-b] [j] [-h] [-f FILE] [pattern]"
  echo
  echo "pattern - the JSONPath query. Defaults to '$.*' if not supplied."
  echo "-b      - Brief. Only show values."
  echo "-j      - JSON output."
  echo "-u      - Strip unnecessary leading path elements."
  echo "-i      - Case insensitive."
  echo "-p      - Pass-through to the JSON parser."
  echo "-w      - Match whole words only (for filter script expression)."
  echo "-f FILE - Read a FILE instead of stdin."
  echo "-h      - This help text."
  echo
}

JSONPath_parse_options() {

  set -- "$@"
  local ARGN=$#
  while [[ ${ARGN} -ne 0 ]]; do
    case $1 in
    -h)
      JSONPath_usage
      exit 0
      ;;
    -f)
      shift
      JSONPath[FILE]=$1
      ;;
    -i)
      JSONPath[NOCASE]=1
      ;;
    -j)
      JSONPath[JSON]=1
      ;;
    -n)
      JSONPath[NO_HEAD]=1
      ;;
    -b)
      JSONPath[BRIEF]=1
      ;;
    -u)
      JSONPath[FLATTEN]=1
      ;;
    -p)
      JSONPath[PASSTHROUGH]=1
      ;;
    -w)
      JSONPath[WHOLEWORD]=1
      ;;
    -s)
      JSONPath[NORMALIZE_SOLIDUS]=1
      ;;
    *)
      QUERY=$1
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done
  [[ -z ${QUERY} ]] && QUERY='$.*'
}

JSONPath_awk_egrep() {
  local pattern_string=$1

  gawk '{
    while ($0) {
      start=match($0, pattern);
      token=substr($0, start, RLENGTH);
      print token;
      $0=substr($0, start+RLENGTH);
    }
  }' pattern="${pattern_string}"
}

JSONPath_tokenize() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    ESCAPE='(\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
    ESCAPE='(\\\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\\\]'
  fi

  local STRING="\"${CHAR}*(${ESCAPE}${CHAR}*)*\""
  local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'
  local KEYWORD='null|false|true'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  ${GREP} "${STRING}|${NUMBER}|${KEYWORD}|${SPACE}|." | grep -Ev "^${SPACE}$"
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

JSONPath_tokenize_path() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
  fi

  local WILDCARD='\*'
  local WORD='[ A-Za-z0-9_-]*'
  local INDEX="\\[${WORD}(:${WORD}){0,2}\\]"
  local INDEXALL='\[\*\]'
  local STRING="[\\\"'][^[:cntrl:]\\\"']*[\\\"']"
  local SET="\\[(${WORD}|${STRING})(,(${WORD}|${STRING}))*\\]"
  local FILTER='\?\(@[^)]+'
  local DEEPSCAN='\.\.'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  readarray -t PATHTOKENS < <(echo "${QUERY}" |
    ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
    grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$")
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    echo "grep -Eo '${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|.'" >/dev/stderr
    echo -n "TOKENISED QUERY="
    echo "${QUERY}" |
      ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
      grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$" >/dev/stderr
  }
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

# JSONPath_create_filter creates the filter from the user's query.
# Filter works in a single pass through the data, unless a filter (script)
#  expression is used, in which case two passes are required (MULTIPASS=1).
JSONPath_create_filter() {

  local len=${#PATHTOKENS[*]}

  local -i i=0
  local a query="^\[" comma=
  while [[ i -lt len ]]; do
    case "${PATHTOKENS[i]}" in
    '"')
      :
      ;;
    '..')
      query+="${comma}[^]]*"
      comma=
      ;;
    '[*]')
      query+="${comma}[^,]*"
      comma=","
      ;;
    '*')
      query+="${comma}(\"[^\"]*\"|[0-9]+[^],]*)"
      comma=","
      ;;
    '?(@'*)
      a=${PATHTOKENS[i]#?(@.}
      elem="${a%%[<>=!]*}"
      rhs="${a##*[<>=!]}"
      a="${a#${elem}}"
      elem="${elem//./[\",.]+}" # Allows child node matching
      operator="${a%${rhs}}"
      [[ -z ${operator} ]] && {
        operator="=="
        rhs=
      }
      if [[ ${rhs} == *'"'* || ${rhs} == *"'"* ]]; then
        case ${operator} in
        '==' | '=')
          OPERATOR=
          if [[ ${elem} == '?(@' ]]; then
            # To allow search on @.property such as:
            #   $..book[?(@.title==".*Book 1.*")]
            query+="${comma}[0-9]+[],][[:space:]\"]*${rhs//\"/}"
          else
            # To allow search on @ (this node) such as:
            #   $..reviews[?(@==".*Fant.*")]
            query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs//\"/}"
          fi
          FILTER="${query}"
          ;;
        '>=' | '>')
          OPERATOR=">"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=' | '<')
          OPERATOR="<"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      else
        case ${operator} in
        '==' | '=')
          OPERATOR=
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs}"
          FILTER="${query}"
          ;;
        '>=')
          OPERATOR="-ge"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '>')
          OPERATOR="-gt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=')
          OPERATOR="-le"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<')
          OPERATOR="-lt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      fi
      JSONPath[MULTIPASS]=1
      ;;
    "["*)
      if [[ ${PATHTOKENS[i]} =~ , ]]; then
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          # converts only one comma: s/("[^"]+),([^"]+")/\1`\2/g;s/"//g
          #a=$(echo $a | sed 's/\([[:alpha:]]*\)/"\1"/g')
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        fi
        query+="${comma}(${a//,/|})"
      elif [[ ${PATHTOKENS[i]} =~ : ]]; then
        if ! [[ ${PATHTOKENS[i]} =~ [0-9][0-9] || ${PATHTOKENS[i]} =~ :] ]]; then
          if [[ ${PATHTOKENS[i]#*:} =~ : ]]; then
            INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
            query+="${comma}[^,]*"
          else
            # Index in the range of 0-9 can be handled by regex
            query+="${comma}$(echo "${PATHTOKENS[i]}" |
              gawk '/:/ { a=substr($0,0,index($0,":")-1);
                         b=substr($0,index($0,":")+1,index($0,"]")-index($0,":")-1);
                         if(b>0) { print a ":" b-1 "]" };
                         if(b<=0) { print a ":]" } }' |
              sed 's/\([0-9]\):\([0-9]\)/\1-\2/;
                       s/\[:\([0-9]\)/[0-\1/;
                       s/\([0-9]\):\]/\1-9999999]/')"
          fi
        else
          INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
          query+="${comma}[^,]*"
        fi
      else
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        else
          [[ ${i} -gt 0 ]] && comma=","
        fi
        query+="${comma}${a}"
      fi
      comma=","
      ;;
    *)
      PATHTOKENS[i]=${PATHTOKENS[i]//\'/\"}
      query+="${comma}\"${PATHTOKENS[i]//\"/}\""
      comma=","
      ;;
    esac
    i=$((i + 1))
  done

  [[ -z ${FILTER} ]] && FILTER="${query}[],]"
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
}

JSONPath_parse_array() {

  local index=0
  local ary=''
  read -r token
  case "${token}" in
  ']') ;;

  *)
    while :; do
      JSONPath_parse_value "$1" "${index}"
      index=$((index + 1))
      ary="${ary}""${value}"
      read -r token
      case "${token}" in
      ']') break ;;
      ',') ary="${ary}," ;;
      *) JSONPath_throw "EXPECTED , or ] GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_object() {

  local key
  local obj=''
  read -r token
  case "${token}" in
  '}') ;;

  *)
    while :; do
      case "${token}" in
      '"'*'"') key=${token} ;;
      *) JSONPath_throw "EXPECTED string GOT ${token:-EOF}" ;;
      esac
      read -r token
      case "${token}" in
      ':') ;;
      *) JSONPath_throw "EXPECTED : GOT ${token:-EOF}" ;;
      esac
      read -r token
      JSONPath_parse_value "$1" "${key}"
      obj="${obj}${key}:${value}"
      read -r token
      case "${token}" in
      '}') break ;;
      ',') obj="${obj}," ;;
      *) JSONPath_throw "EXPECTED , or } GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_value() {

  local jpath="${1:+$1,}$2" isleaf=0 isempty=0 print=0
  case "${token}" in
  '{') JSONPath_parse_object "${jpath}" ;;
  '[') JSONPath_parse_array "${jpath}" ;;
    # At this point, the only valid single-character tokens are digits.
  '' | [!0-9]) JSONPath_throw "EXPECTED value GOT ${token:-EOF}" ;;
  *)
    value=${token}
    # if asked, replace solidus ("\/") in json strings with normalized value: "/"
    # Testing:
    #[ "${JSONPath[NORMALIZE_SOLIDUS]}" -eq 1 ] && value=$(echo "${value}" | sed 's#\\/#/#g')
    [[ ${JSONPath[NORMALIZE_SOLIDUS]} -eq 1 ]] && value=$(${value//\\\///})
    isleaf=1
    [[ ${value} == '""' ]] && isempty=1
    ;;
  esac
  [[ -z ${JSONPath[INCLEMPTY]} ]] && [[ ${value} == '' ]] && return
  [[ ${JSONPath[NO_HEAD]} -eq 1 ]] && [[ -z ${jpath} ]] && return

  [[ ${isleaf} -eq 1 ]] && [[ ${isempty} -eq 0 ]] && print=1
  [[ ${print} -eq 1 ]] && printf "[%s]\t%s\n" "${jpath}" "${value}"
  :
}

JSONPath_flatten() {

  local path a prevpath pathlen

  if [[ ${JSONPath[FLATTEN]} -eq 1 ]]; then
    cat >"${JSONPath[STDINFILE2]}"

    highest=9999

    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      [[ -z ${prevpath} ]] && {
        prevpath=("${path[@]}")
        highest=$((${#path[*]} - 1))
        continue
      }

      pathlen=$((${#path[*]} - 1))

      for i in $(seq 0 "${pathlen}"); do
        [[ ${path[i]} != "${prevpath[i]}" ]] && {
          high=${i}
          break
        }
      done

      [[ ${high} -lt ${highest} ]] && highest=${high}

      prevpath=("${path[@]}")
    done <"${JSONPath[STDINFILE2]}"

    if [[ ${highest} -gt 0 ]]; then
      sed -r 's/\[(([0-9]+|"[^"]+")[],]){'$((highest))'}(.*)/[\3/' \
        "${JSONPath[STDINFILE2]}"
    else
      cat "${JSONPath[STDINFILE2]}"
    fi
  else
    cat
  fi
}

# JSONPath_indexmatcher is for double digit or greater indexes match each line
# individually Single digit indexes are handled more efficiently by regex
JSONPath_indexmatcher() {

  local a b

  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
      echo "INDEXMATCH_QUERY[${i}]=${INDEXMATCH_QUERY[i]}" >/dev/stderr
    done
  }

  matched=1

  step=
  if [[ ${#INDEXMATCH_QUERY[*]} -gt 0 ]]; then
    while read -r line; do
      for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
        [[ ${INDEXMATCH_QUERY[i]#*:} =~ : ]] && {
          step=${INDEXMATCH_QUERY[i]##*:}
          step=${step%]}
          INDEXMATCH_QUERY[i]="${INDEXMATCH_QUERY[i]%:*}]"
        }
        q=${INDEXMATCH_QUERY[i]:1:-1} # <- strip '[' and ']'
        a=${q%:*}                     # <- number before ':'
        b=${q#*:}                     # <- number after ':'
        [[ -z ${b} ]] && b=99999999999
        readarray -t num < <((grep -Eo '[0-9]+[],]' | tr -d ,]) <<<"${line}")
        if [[ ${num[i]} -ge ${a} && ${num[i]} -lt ${b} && matched -eq 1 ]]; then
          matched=1
          [[ ${i} -eq $((${#INDEXMATCH_QUERY[*]} - 1)) ]] && {
            if [[ ${step} -gt 1 ]]; then
              [[ $(((num[i] - a) % step)) -eq 0 ]] && {
                [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
                echo "${line}"
              }
            else
              [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
              echo "${line}"
            fi
          }
        else
          matched=0
          continue
        fi
      done
      matched=1
    done
  else
    cat -
  fi
}

JSONPath_brief() {
  # Only show the value

  if [[ ${JSONPath[BRIEF]} -eq 1 ]]; then
    sed 's/^[^\t]*\t//;s/^"//;s/"$//;'
  else
    cat
  fi
}

JSONPath_json() {
  # Turn output into JSON

  local a tab="$'\t'"
  local UP=1 DOWN=2 SAME=3
  local prevpathlen=-1 prevpath=() path a
  declare -a closers

  if [[ ${JSONPath[JSON]} -eq 0 ]]; then
    cat -
  else
    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      value=${line#*${tab}}

      # Not including the object itself (last item)
      pathlen=$((${#path[*]} - 1))

      # General direction

      direction=${SAME}
      [[ ${pathlen} -gt ${prevpathlen} ]] && direction=${DOWN}
      [[ ${pathlen} -lt ${prevpathlen} ]] && direction=${UP}

      # Handle jumps UP the tree (close previous paths)

      [[ ${prevpathlen} != -1 ]] && {
        for i in $(seq 0 $((pathlen - 1))); do
          [[ ${prevpath[i]} == "${path[i]}" ]] && continue
          [[ ${path[i]} != '"'* ]] && {
            # Testing double quotes:
            a="(${!arrays[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                arrays[k]=
              done
            }
            a="(${!comma[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                comma[k]=
              done
            }
            for j in $(seq $((prevpathlen)) -1 $((i + 2))); do
              arrays[j]=
              [[ -n ${closers[j]} ]] && {
                indent=$((j * 4))
                printf "\n%${indent}s${closers[j]}" ""
                unset "closers[j]"
                comma[j]=
              }
            done
            direction=${DOWN}
            break
          }
          direction=${DOWN}
          for j in $(seq $((prevpathlen)) -1 $((i + 1))); do
            arrays[j]=
            [[ -n ${closers[j]} ]] && {
              indent=$((j * 4))
              printf "\n%${indent}s${closers[j]}" ""
              unset "closers[j]"
              comma[j]=
            }
          done
          a="(${!arrays[*]})"
          [[ -n ${a} ]] && {
            for k in $(seq "${i}" "${a[-1]}"); do
              arrays[k]=
            done
          }
          break
        done
      }

      [[ ${direction} -eq ${UP} ]] && {
        [[ ${prevpathlen} != -1 ]] && comma[prevpathlen]=
        for i in $(seq $((prevpathlen + 1)) -1 $((pathlen + 1))); do
          arrays[i]=
          [[ -n ${closers[i]} ]] && {
            indent=$((i * 4))
            printf "\n%${indent}s${closers[i]}" ""
            unset "closers[i]"
            comma[i]=
          }
        done
        a="(${!arrays[*]})"
        [[ -n ${a} ]] && {
          for k in $(seq "${i}" "${a[-1]}"); do
            arrays[k]=
          done
        }
      }

      # Opening braces (the path leading up to the key)

      broken=
      for i in $(seq 0 $((pathlen - 1))); do
        [[ -z ${broken} && ${prevpath[i]} == "${path[i]}" ]] && continue
        [[ -z ${broken} ]] && {
          broken=${i}
          [[ ${prevpathlen} -ne -1 ]] && broken=$((i + 1))
        }
        if [[ ${path[i]} == '"'* ]]; then
          # Object
          [[ ${i} -ge ${broken} ]] && {
            indent=$((i * 4))
            printf "${comma[i]}%${indent}s{\n" ""
            closers[i]='}'
            comma[i]=
          }
          indent=$(((i + 1) * 4))
          printf "${comma[i]}%${indent}s${path[i]}:\n" ""
          comma[i]=",\n"
        else
          # Array
          if [[ ${arrays[i]} != 1 ]]; then
            indent=$((i * 4))
            printf "%${indent}s" ""
            echo "["
            closers[i]=']'
            arrays[i]=1
            comma[i]=
          else
            indent=$(((i + 1) * 4))
            printf "\n%${indent}s${closers[i - 1]}" ""
            direction=${DOWN}
            comma[i + 1]=",\n"
          fi
        fi
      done

      # keys & values

      if [[ ${path[-1]} == '"'* ]]; then
        # Object
        [[ ${direction} -eq ${DOWN} ]] && {
          indent=$((pathlen * 4))
          printf "${comma[pathlen]}%${indent}s{\n" ""
          closers[pathlen]='}'
          comma[pathlen]=
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${path[-1]}:${value}"
        comma[pathlen]=",\n"
      else
        # Array
        [[ ${arrays[i]} != 1 ]] && {
          indent=$(((pathlen - 0) * 4))
          printf "%${indent}s[\n" ""
          closers[pathlen]=']'
          comma[pathlen]=
          arrays[i]=1
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${value}"
        comma[pathlen]=",\n"
      fi

      prevpath=("${path[@]}")
      prevpathlen=${pathlen}
    done

    # closing braces

    for i in $(seq $((pathlen)) -1 0); do
      indent=$((i * 4))
      printf "\n%${indent}s${closers[i]}" ""
    done
    echo
  fi
}

JSONPath_filter() {
  # Apply the query filter

  local a tab=$'\t' v

  [[ ${JSONPath[NOCASE]} -eq 1 ]] && opts+="i"
  [[ ${JSONPath[WHOLEWORD]} -eq 1 ]] && opts+="w"
  if [[ -z ${OPERATOR} ]]; then
    [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && FILTER="${FILTER}[\"]?$"
    grep "-E${opts}" "${FILTER}"
    [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
  else
    grep "-E${opts}" "${FILTER}" |
      while read -r line; do
        v=${line#*${tab}}
        case ${OPERATOR} in
        '-ge')
          if gawk '{exit !($1>=$2)}' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-gt')
          if gawk '{exit !($1>$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-le')
          if gawk '{exit !($1<=$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-lt')
          if gawk '{exit !($1<$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '>')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} > ${RHS,,} ]] && echo "${line}"
          ;;
        '<')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} < ${RHS,,} ]] && echo "${line}"
          ;;
        *) return 1 ;;
        esac
      done
  fi
}

JSONPath_parse() {
  # Parses json

  read -r token
  JSONPath_parse_value
  read -r token
  case "${token}" in
  '') ;;
  *)
    JSONPath_throw "EXPECTED EOF GOT ${token}"
    exit 1
    ;;
  esac
}

JSONPath_throw() {
  echo "$*" >&2
  exit 1
}

JSONPath_new || exit 1

# vi: expandtab sw=2 ts=2
# shellcheck shell=bash disable=SC2148
# MA - execution starts here

# MA is an associative array that holds data specific to this file
declare -A _MA

# Defined in GL (globals.sh)
declare OK ERROR STOP STDERR TRUE

# Getters/Setters -------------------------------------------------------------

# MA_program_args getter outputs the program arguments sent by the user.
MA_program_args() {
  printf '%s' "${_MA[program_args]}"
}

# Public Functions ------------------------------------------------------------

# main is the start point for this application.
# Args: arg1-N - the command line arguments entered by the user.
MA_main() {
  local retval="${OK}"

  CU_podman_or_docker

  trap MA_cleanup EXIT
  MA_sanity_checks || return
  PA_run "$@" || retval=$?

  exit "${retval}"
}

# MA_version outputs the version information the exits.
MA_version() {
  printf 'Version: %s\n' "${MOKVERSION}"
  exit "${OK}"
}

# MA_process_global_options is called by the parser when a global option is
# encountered for processing.
# Args: arg1 - the global option that was found.
MA_process_global_options() {
  case "$1" in
  -h | --help)
    PA_usage
    return "${STOP}"
    ;;
  -p | --plain)
    UT_set_plain "${TRUE}"
    ;;
  *)
    printf 'INTERNAL ERROR: Invalid global option, "%s".' "$1"
    return "${ERROR}"
    ;;
  esac
}

# MA_cleanup is called from an EXIT trap only, when the program exits, and
# calls every other function matching the pattern '^.._cleanup'.
# Args: No args expected.
MA_cleanup() {
  local retval="${OK}" funcs func
  funcs=$(declare -F | awk '{print $NF;}' | grep '^.._cleanup')
  for func in ${funcs}; do
    [[ ${func} == "${FUNCNAME[0]}" ]] && continue
    eval "${func}" || retval=$?
  done
  return "${retval}"
}

# MA_sanity_checks is expected to run some quick and simple checks to
# see if key components are available before MA_main is called.
# Args: No args expected.
MA_sanity_checks() {

  local binary

  if [[ ${_CU[podmantype]} == "native" ]]; then
    binaries="gawk tac column tput grep sed ip cut"
  else
    binaries="gawk tac column tput grep sed cut"
  fi

  for binary in ${binaries}; do
    if ! command -v "${binary}" >&/dev/null; then
      printf 'ERROR: "%s" binary not found in path. Aborting.' "${binary}" \
        >"${STDERR}"
      return "${ERROR}"
    fi
  done

  # Disable terminal escapes (colours) if stdout is not a terminal
  [ -t 1 ] || UT_disable_colours
}

# MA_usage outputs help text for all components then quits with no error.  This
# is registered as a callback in the Parser, see _MA_new
# Args: None expected.
MA_usage() {

  cat <<'EnD'
Usage: mok [-h] <command> [subcommand] [ARGS...]
 
Global options:
  --help
  -h     - This help text
  --plain
  -p     - Plain output. No colours or animations.
 
Where command can be one of:
  create  - Add item(s) to the system.
  delete  - Delete item(s) from the system.
  build   - Build item(s) used by the system.
  get     - Get details about items in the system.
  exec    - 'Log in' to the container.
  version - Display version information.

For help on a specific command, run:
  mok <command> --help
EnD
}

# MA_new sets the initial values for the _MA associative array
_MA_new() {
  _MA[program_args]="$*"

  # Program the parser's state machine
  PA_add_state "COMMAND" "version" "END" "MA_version"

  # Set up the parser's option callbacks
  PA_add_option_callback "" "MA_process_global_options"

  # Set up the parser's usage callbacks
  PA_add_usage_callback "" "MA_usage"
}

# Initialise _MA
_MA_new "$@" || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
if [ "$0" = "${BASH_SOURCE[0]}" ] || [ -z "${BASH_SOURCE[0]}" ]; then
  MA_main "$@"
fi
