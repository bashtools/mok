#!/usr/bin/env bash
# shellcheck shell=bash disable=SC2148

__check_os() {
  local majorversion system_ok=1 install_bash=0 install_coreutils=0 install_gawk=0
  local install_podman=0 install_sed=0 __mokostype=linux

  if [[ -d /System/Library/CoreServices ]]; then
    [[ -e /opt/homebrew/bin/bash ]] && eval "$(/opt/homebrew/bin/brew shellenv)"
    # We're on macOS, check for a recent Bash
    if command -v bash &>/dev/null; then
      majorversion=$(bash --version | head -n 1 | sed 's/^.*version \([0-9]*\).*/\1/')
    else
      echo "No version of Bash was found which is strange. Aborting."
      exit 1
    fi
    if [[ ${majorversion} -lt 5 ]]; then
      install_bash=1
      system_ok=0
    fi
    if ! command -v tac &>/dev/null; then
      install_coreutils=1
      system_ok=0
    fi
    if ! command -v gawk &>/dev/null; then
      install_gawk=1
      system_ok=0
    fi
    if ! command -v gsed &>/dev/null; then
      install_sed=1
      system_ok=0
    fi
    if ! command -v podman &>/dev/null; then
      install_podman=1
      system_ok=0
    fi

    if [[ ${system_ok} -eq 0 ]]; then
      echo "Your system requires some extra packages to be installed."
      echo "This script can install them for you."
      echo
      read -r -p 'Install extra packages? (y/N) ' ans
      if [[ ${ans} == "y" ]]; then
        if ! command -v brew &>/dev/null; then
          echo 'Homebrew is required to install extra packages.'
          echo 'You can install this yourself by following the instructions at https://brew.sh'
          echo
          read -r -p 'Should I install Homebrew now? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            # Install Homebrew
            echo -n "Installing Homebrew, with:"
            echo " /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
            echo
            /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            retval=$?
            if [[ retval -ne 0 ]]; then
              echo "Homebrew install failed."
              echo "Please try to install Homebrew manually using the above commmand."
              exit 1
            fi
            if [[ ! -e /opt/homebrew/bin/brew ]]; then
              echo "Homebrew did not seem install to /opt/homebrew."
              echo "Mok expects 'brew' to be in /opt/homebrew/bin/brew but it's not there."
              echo "Cannot continue. Please report this issue on GitHub."
              exit 1
            fi
            eval "$(/opt/homebrew/bin/brew shellenv)"
          else
            echo "Aborting due to missing 'Homebrew'."
            exit 1
          fi
        fi
        if [[ ! -e /opt/homebrew/bin/brew ]]; then
          echo "Mok expects 'brew' to be in /opt/homebrew/bin/brew but it's not there."
          echo "Cannot continue. Please report this issue on GitHub."
          exit 1
        fi
        eval "$(/opt/homebrew/bin/brew shellenv)"
        if [[ ${install_bash} -eq 1 ]]; then
          read -r -p 'Bash 5 is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install bash
          else
            echo "Aborting due to missing 'Bash 5'."
            exit 1
          fi
        fi
        if [[ ${install_coreutils} -eq 1 ]]; then
          read -r -p 'Coreutils is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install coreutils
          else
            echo "Aborting due to missing 'coreutils'."
            exit 1
          fi
        fi
        if [[ ${install_gawk} -eq 1 ]]; then
          read -r -p 'Gawk is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install gawk
          else
            echo "Aborting due to missing 'gawk'."
            exit 1
          fi
        fi
        if [[ ${install_sed} -eq 1 ]]; then
          read -r -p 'GNU-Sed is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install gnu-sed
          else
            echo "Aborting due to missing 'sed'."
            exit 1
          fi
        fi
        if [[ ${install_podman} -eq 1 ]]; then
          read -r -p 'Podman is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install podman
          else
            echo "Aborting due to missing 'podman'."
            exit 1
          fi
        fi
      else
        echo "Aborting due to missing packages."
        exit 1
      fi
    fi
  fi
}

[[ __homebrew -ne 1 ]] && __check_os

[[ -d /System/Library/CoreServices && -e /opt/homebrew/bin/bash && __homebrew -ne 1 ]] && {
  eval "$(/opt/homebrew/bin/brew shellenv)"
  export __mokostype=macos
  export __homebrew=1
  sed() {
    gsed "$@"
  }
  export -f sed
  exec bash "$0" "$@"
}

__mokostype="${__mokostype:-linux}"
# shellcheck shell=bash disable=SC2148

declare __mokostype

set_arch() {
  if [[ ${__mokostype} == "linux" ]]; then
    # Is this machine x86 or arm?
    if [[ $(uname -m) == "x86_64" ]]; then
      export __mokarch=x86_64
    elif [[ $(uname -m) == "aarch64" ]]; then
      export __mokarch=arm64
    fi
  elif [[ ${__mokostype} == "macos" ]]; then
    # Is this machine x86 or arm?
    if [[ $(uname -m) == "x86_64" ]]; then
      export __mokarch=x86_64
    elif [[ $(uname -m) == "arm64" ]]; then
      export __mokarch=arm64
    fi
  else
    printf 'ERROR: Unknown OS type: %s\n' "${__mokostype}" >"${STDERR}"
    exit "${ERROR}"
  fi
}

set_arch
# shellcheck shell=bash disable=SC2148
# PA - PArser

# _PA holds data specific to parsing the command line arguments.
declare -A _PA

# Declare externally defined variables ----------------------------------------

# Defined in ER (globals.sh)
declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# PA_command getter outputs the _PA[command] array member. This contains the
# command the user requested.
PA_command() {
  printf '%s' "${_PA[command]}"
}

# PA_subcommand getter outputs the _PA[subcommand] array member. This contains
# the subcommand the user requested.
PA_subcommand() {
  printf '%s' "${_PA[subcommand]}"
}

# PA_shift outputs the _PA[shift] array member, returned by the caller
# when an extra shift is required whilst consuming option values.
#
# Example code:
# ```
#XX_process_options_callback() {
#
#  case "$1" in
#  -h | --help)
#    CC_usage
#    return "${STOP}"
#    ;;
#    ... omitted ...
#  --k8sver)
#    _CC[k8sver]="$2"
#    return "$(PA_shift)"
#    ;;
#  --with-lb)
#    ... omitted ..
# ```
PA_shift() {
  printf '%s' "${_PA[shift]}"
}

# PA_set_state setter sets the initial state of the parser, which should be one
# of COMMAND, SUBCOMMAND, or ARG1.
# Args: arg1 - the initial state to set.
PA_set_state() {
  _PA[state]="$1"
}

# Public Functions ------------------------------------------------------------

# PA_add_option_callback adds a callback to the list of callbacks used for
# processing options.
# Args: arg1 - Null string (for global options), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_option_callback() {
  _PA[optscallbacks]+="$1,$2 "
}

# PA_add_usage_callback adds a callback to the list of callbacks used for
# output of help text.
# Args: arg1 - Null string (for global help), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_usage_callback() {
  _PA[usagecallbacks]+="$1,$2 "
}

# PA_add_state adds a callback to the list of callbacks used for
# programming the state machine.
# Args: arg1 - Current state to match.
#       arg2 - The value of the state to match.
#       arg3 - The new state if arg1 and arg2 match.
#       arg4 - The function to call, optional.
PA_add_state() {
  _PA[statecallbacks]+="$1,$2,$3,$4 "
}

# PA_add_run_callback adds a callback to the list of callbacks used for
# running the user defined entrypoint function.
# Args: arg1 - The value of the state to match. Probably like:
#              "commandsubcommand" "function"
#       arg2 - The function to call.
PA_add_run_callback() {
  _PA[runcallbacks]+="$1,$2 "
}

# PA_run implements an interleaved state machine to process the
# user request. It allows for strict checking of arguments and args. All
# command line arguments are processed in order from left to right.
#
# Each COMMAND can have a different set of requirements which are controlled
# by setting the next state at each transition.
#
# --global-options COMMAND --command-options SUBCOMMAND --subcommand-options \
#  ARG1 --subcommand-options ARG2 --subcommand-options ...
#
# --global-options are those before COMMAND.
# --command-options can be after the COMMAND but before SUBCOMMAND.
# --subcommand-options can be anywhere after the SUBCOMMAND.
#
# Args: arg1-N - The arguments given to mok by the user on the command line
PA_run() {

  local retval=${OK}

  set -- "$@"
  local ARGN=$# ARGNUM=0 retval=0
  while [ "${ARGN}" -ne 0 ]; do
    case "$1" in
    --* | -*)
      _PA_process_option "$1" "$2" || {
        retval=$?
        if [[ ${retval} == "${_PA[shift]}" ]]; then
          ARGN=$((ARGN - 1))
          shift
        else
          return "${retval}"
        fi
      }
      ;;
    *)
      case "${_PA[state]}" in
      COMMAND)
        _PA_check_token "${1}" "COMMAND" "command"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid COMMAND, "%s".\n\n' "$1" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      SUBCOMMAND)
        _PA_check_token "$1" "SUBCOMMAND" "subcommand"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid SUBCOMMAND for %s, "%s".\n\n' "${_PA[command]}" "${1}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      ARG*)
        ((ARGNUM++))
        _PA_check_token "${1}" "ARG${ARGNUM}"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid ARG1 for %s %s, "%s".\n\n' "${_PA[command]}" \
            "${_PA[subcommand]}" "${1}" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      END)
        PA_usage
        printf 'ERROR No more args expected, "%s" is unexpected for "%s %s"\n' \
          "${1}" "${_PA[command]}" "${_PA[subcommand]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      *)
        printf 'Internal ERROR. Invalid state "%s"\n' "${_PA[state]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      esac
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done

  # Run the user defined entrypoint function:
  for item in ${_PA[runcallbacks]}; do
    IFS=, read -r stateval func <<<"${item}"
    [[ ${stateval} == "${_PA[command]}${_PA[subcommand]}" ]] && {
      eval "${func}" || retval=$?
      return "${retval}"
    }
  done

  PA_usage

  return "${OK}"
}

# PA_usage outputs help text for a single component if help was asked for when
# a command was specified, or for all components otherwise.
# Args: None expected.
PA_usage() {

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[usagecallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func}"
      return
    }
  done

  eval "${_PA[usage]}"
}

# Private Functions -----------------------------------------------------------

# PA_new sets the initial values for the PArser's associative array.
# Args: None expected.
_PA_new() {
  _PA[command]=
  _PA[subcommand]=
  _PA[state]="COMMAND"
  _PA[optscallbacks]=
  _PA[usagecallbacks]=
  _PA[statecallbacks]=
  _PA[runcallbacks]=
  # The return value if the caller asked for an extra shift:
  _PA[shift]=126
}

# _PA_check_token checks for a valid token in arg2 state. The logic is
# most easily understood by reading the full original version at:
# https://github.com/mclarkson/my-own-kind/blob/master/docs/package.md#scripted-cluster-creation-and-deletion
# This function is a reduction of all the check_xxx_token functions.
# Args: arg1 - the token to check.
#       arg2 - the current state.
#       arg3 - the state value to set, optional. This should only be sent
#              for command and subcommand states.
_PA_check_token() {

  local item

  if [[ -n ${_PA[subcommand]} ]]; then
    cmdsubcommand="${_PA[command]}${_PA[subcommand]}"
  elif [[ -n ${_PA[command]} && ${_PA[state]} != "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}$1"
  elif [[ -n ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}"
  elif [[ -z ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand=
  else
    cmdsubcommand="$1"
  fi

  for item in ${_PA[statecallbacks]}; do
    IFS=, read -r state component newstate func <<<"${item}"
    [[ ${state} == "$2" ]] && {
      [[ ${component} == "${cmdsubcommand}" ]] && {
        [[ -n $3 ]] && _PA["$3"]="$1"
        _PA[state]="${newstate}"
        [[ -n ${func} ]] && {
          eval "${func} $1" || return
        }
        return "${OK}"
      }
    }
  done
}

# _PA_process_option checks that the user-provided option is valid for the
# command-subcommand or global states.
# Args: arg1 - The option to check.
#       arg2 - TODO The value of the option if present, optional.
_PA_process_option() {

  local item curcmdsubcmd

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[optscallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func} \"$1\" \"$2\""
      return $?
    }
  done

  return "${ERROR}"
}

# Initialise _PA
_PA_new

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GL - Globals

# Private Functions -----------------------------------------------------------

# GL_new sets the only global variables that should be in use anywhere.  The
# only other globals are the associative arrays. All the globals are constant
# (readonly) variables. Declare these globals, where needed, in other files
# so that shellcheck passes.
# Args: None expected.
_GL_new() {

  declare -rg MOKVERSION="0.8.29"
  declare -rg K8SVERSION="1.33.0"
  declare -rg GO_VERSION="1.23.4"

  # Returns, exit codes
  declare -rg OK=0
  declare -rg SUCCESS=0
  declare -rg ERROR=1
  declare -rg FAILURE=1

  # For setting flags
  declare -rg TRUE=1
  declare -rg FALSE=0

  # To signal main() to exit with SUCCESS in the PArser
  declare -rg STOP=2

  declare -rg STDOUT="/dev/stdout"
  declare -rg STDERR="/dev/stderr"

  # The following just keep shellcheck happy
  local dummy dumb
  dummy="${OK}"
  dummy="${ERROR}"
  dummy="${STOP}"
  dummy="${STDOUT}"
  dummy="${STDERR}"
  dummy="${TRUE}"
  dummy="${FALSE}"
  dummy="${SUCCESS}"
  dummy="${FAILURE}"
  dummy="${MOKVERSION}"
  dummy="${GO_VERSION}"
  dummy="${K8SVERSION}"
  dumb="${dummy}${dumb}"
}

# Initialise GL
_GL_new || exit 1

# vim helpers -----------------------------------------------------------------

# The following lines allow the use of '[C-i' and '[I' (do ':help [I') in vim.
#include buildimage.sh
#include containerutils.sh
#include createcluster.sh
#include deletecluster.sh
#include embed-dockerfile.sh
#include error.sh
#include exec.sh
#include getcluster.sh
#include main.sh
#include lib/parser.sh
#include util.sh
#include versions.sh

# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# ER - Error handling

# ER is an associative array that holds data specific to error handling.
declare -A ER

# Declare externally defined associative arrays -------------------------------

# Defined in GL (globals.sh)
declare ERROR TRUE STDERR

# Public Functions ------------------------------------------------------------

# ER_err outputs a stacktrace and returns ERROR status.
# Args: None expected.
ER_err() {

  # In case of error print the function call stack
  # No args expected

  [[ ${ER[errcalled]} == "${TRUE}" ]] && return "${ERROR}"
  ER[errcalled]="${TRUE}"
  local frame=0
  printf '\n' >"${STDERR}"
  while caller "${frame}"; do
    ((frame++))
  done | tac >"${STDERR}"
  printf '\n' >"${STDERR}"
  return "${ERROR}"
}

# err is a synonym for ER_err to aid with code readability.
err() {
  ER_err
  return
}

# Private Functions -----------------------------------------------------------

# ER_new sets the initial values for the ER associative array.
# Args: None expected.
_ER_new() {
  ER[errcalled]=
}

# Initialise ER
_ER_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# UT - Utilities

# _UT is an associative array that holds data specific to general utilities.
declare -A _UT

# Declare externally defined global variables ---------------------------------

declare OK STDERR FALSE TRUE

# Getters/Setters -------------------------------------------------------------

# UT_runlogfile getter outputs the value of _UT[runlogfile], which contains the
# name of the file written to when running UT_run_with_progress.
UT_runlogfile() {
  printf '%s' "${_UT[runlogfile]}"
}

# UT_tailf getter indicates whether a log will be shown in real-time during the
# 'run', TRUE, or not, FALSE.
# Args
UT_tailf() {
  printf '%s' "${_UT[tailf]}"
}

# UT_tailf setter indicates whether a log should be shown during the 'run',
# TRUE, or not, FALSE.
# Args: arg1 - Whether to tail, TRUE or FALSE.
UT_set_tailf() {
  _UT[tailf]="$1"
}

# UT_set_plain setter sets plain output, with no colour, animations, or UTF
# high byte characters.
# Args: arg1 - Whether to show plain output, TRUE or FALSE.
UT_set_plain() {
  _UT[plain]="$1"
  UT_disable_colours
}

# Public Functions ------------------------------------------------------------

# UT_disable_colours resets variables used for colourised output so that they
# contain no colour terminal escapes. Useful if stdin is not a terminal.
UT_disable_colours() {
  _UT[yellow]=
  _UT[green]=
  _UT[red]=
  _UT[normal]=
  _UT[probablysuccess]="!"
  _UT[success]="✓"
  _UT[failure]="✕"
}

# UT_run_with_progress displays a progress spinner, item text, and a tick or
# cross based on the exit code.
# Args: arg1   - the text to display.
#       arg2-N - remaining args are the program to run and its arguments.
UT_run_with_progress() {

  local displaytext=$1 retval int spinner=()

  _UT[runlogfile]=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }
  shift

  if [[ ${_UT[tailf]} == "${FALSE}" && ${_UT[plain]} == "${TRUE}" ]]; then

    # Output with no colours or spinny

    printf '%s' "${displaytext}"

    eval "$*" &>"${_UT[runlogfile]}"
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 0 ]]; then
      printf ' .. %s\n' "${_UT[success]}"
    else
      printf ' .. %s\n' "${_UT[failure]}"
    fi

  elif [[ ${_UT[tailf]} == "${FALSE}" ]]; then

    # Output with colours and spinny

    while read -r char; do
      spinner+=("${char}")
    done <<<"$(grep -o . <<<"${_UT[spinnerchars]}")"

    (
      eval "$*" &>"${_UT[runlogfile]}"
    ) &

    # Turn the cursor off
    tput civis

    # Start the spin animation
    printf ' %s' "${displaytext}"
    (while true; do
      for int in {0..3}; do
        printf '\r  %s ' "${spinner[int]}"
        sleep .1
      done
    done) &
    _UT[spinnerpid]=$!
    disown

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Kill the spinner
    kill "${_UT[spinnerpid]}" 2>/dev/null
    _UT[spinnerpid]=

    sleep .5

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\r  %s\n' "${_UT[probablysuccess]}"
    elif [[ ${retval} -eq 0 ]]; then
      printf '\r  %s\n' "${_UT[success]}"
    else
      printf '\r  %s\n' "${_UT[failure]}"
    fi

    # Restore the cursor
    tput cnorm
    sleep .5

  else

    # Tailf output

    printf 'COMMAND: %s\n\n' "$*"

    (
      eval "$*" &>/dev/stdout
    ) &
    sleep 1

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\n\nSTATUS: OK - (Probably)\n\n'
    elif [[ ${retval} -eq 0 ]]; then
      printf '\n\nSTATUS: OK\n\n'
    else
      printf '\n\nSTATUS: FAIL\n\n'
    fi
  fi

  return "${retval}"
}

# UT_cleanup removes any artifacts that were created during execution.
# This is called by 'MA_cleanup' trap only.
UT_cleanup() {

  # Called when the script exits.

  local int

  # Kill the spinny, and anything else, if they're running
  if [[ ${_UT[tailf]} == "${FALSE}" ]]; then
    [[ -n ${_UT[spinnerpid]} ]] && {
      printf '%s\r  ✕%s\n' "${_UT[red]}" "${_UT[normal]}"
      kill "${_UT[spinnerpid]}"
    }
    # If progress spinner crashed make sure the cursor is shown
    [ -t 1 ] && tput cnorm
  else
    kill "${_UT[spinnerpid]}" &>/dev/null
  fi

  return "${OK}"
}

# UT_sed_json_block returns the value of the query_key between
# block_start_key:block_start_val and block_end_key.
# Args:
#  Arg 1: data
#  Arg 2: block_start_key
#  Arg 3: block_start_val
#  Arg 4: block_end_key
#  Arg 5: query_key
UT_sed_json_block() {
  local data block_start_key block_start_val block_end_key query_key
  data="$1"
  block_start_key="$2"
  block_start_val="$3"
  block_end_key="$4"
  query_key="$5"
  echo "$data" | sed -rn \
    '/'"${block_start_key}"'.*'"${block_start_val}"'/,/'"${block_end_key}"'/ { s/^ *"'"${query_key}"'": *//p }' \
    | tr -d ',"'
}

# Private Functions -----------------------------------------------------------

# _UT_new sets the initial values for the _UT associative array.
# Args: None expected.
_UT_new() {
  _UT[tailf]="${FALSE}"
  _UT[yellow]=$(tput setaf 3)
  _UT[green]=$(tput setaf 2)
  _UT[red]=$(tput setaf 1)
  _UT[normal]=$(tput sgr0)
  _UT[probablysuccess]="${_UT[yellow]}✓${_UT[normal]}"
  _UT[success]="${_UT[green]}✓${_UT[normal]}"
  _UT[failure]="${_UT[red]}✕${_UT[normal]}"
  _UT[runlogfile]=
  _UT[spinnerchars]="|/-\\"
  _UT[spinnerpid]=
}

# Initialise _UT
_UT_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GC - Get Cluster

# _GC is an associative array that holds data specific to the get cluster command.
declare -A _GC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# GC_showheader getter outputs the value of the showheader array member.
GC_showheader() {
  printf '%s' "${_GC[showheader]}"
}

# GC_set_showheader setter sets the value of the showheader array member.
# If $TRUE the header will be shown, or $FALSE, then it won't be shown.
GC_set_showheader() {
  _GC[showheader]="$1"
}

# GC_set_clustername setter sets the cluster name to show information about.
GC_set_clustername() {
  _GC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# GC_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted. It is called by
# MA_cleanup.
GC_cleanup() {
  :
}

# GC_process_options checks if arg1 is in a list of valid get cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
GC_process_options() {

  case "$1" in
  -h | --help)
    GC_usage
    return "${STOP}"
    ;;
  *)
    GC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# GC_usage outputs help text for the create cluster component.
# It is called by PA_usage().
# Args: None expected.
GC_usage() {

  cat <<'EnD'
GET subcommands are:
 
  cluster[s] - list all mok managed clusters.
 
get cluster[s] options:
 
 Format:
  get cluster(s) [NAME]
  NAME        - (optional) The name of the cluster to get
                details about.

EnD
}

# GC_run gets information about cluster(s).
# This function is called in main.sh.
# Args: None expected.
GC_run() {

  _GC_sanity_checks || return

  local ids id info output labelkey
  local containerhostname containerip

  declare -a nodes

  ids=$(CU_get_cluster_container_ids "${_GC[clustername]}") || return

  if [[ -z ${ids} ]]; then
    printf 'No clusters found\n'
    return "${OK}"
  fi

  readarray -t nodes <<<"${ids}"

  # Use 'docker inspect' to get the value of the label $LABELKEY

  output=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  # Output the header
  [[ ${_GC[showheader]} -eq ${TRUE} ]] && {
    printf 'MOK_Cluster Docker_ID Container_Name IP_Address\n' >"${output}"
  }

  labelkey=$(CU_labelkey) || err || return

  for id in "${nodes[@]}"; do

    info=$(CU_get_container_info "${id}") || return

    clustname=$(JSONPath ".[0].Config.Labels.${labelkey}" -b <<<"${info}") ||
      err || return

    containerhostname=$(JSONPath '.[0].Config.Hostname' -b <<<"${info}") ||
      err || return

    containerip=$(JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}") ||
      err || return

    printf '%s %s %s %s\n' "${clustname}" "${id}" "${containerhostname}" "${containerip}"

  done | sort -k 3 >>"${output}"

  column -t "${output}" || err
}

# Private Functions -----------------------------------------------------------

# _GC_new sets the initial values for the _GC associative array.
# Args: None expected.
_GC_new() {
  _GC[showheader]="${TRUE}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "get" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "getcluster" "ARG1" ""
  PA_add_state "SUBCOMMAND" "getclusters" "ARG1" ""
  PA_add_state "ARG1" "getcluster" "END" "GC_set_clustername"
  PA_add_state "ARG1" "getclusters" "END" "GC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "get" "GC_process_options" || return
  PA_add_option_callback "getcluster" "GC_process_options" || return
  PA_add_option_callback "getclusters" "GC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "get" "GC_usage" || return
  PA_add_usage_callback "getcluster" "GC_usage" || return
  PA_add_usage_callback "getclusters" "GC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "getcluster" "GC_run"
  PA_add_run_callback "getclusters" "GC_run"
}

# GC_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_GC_sanity_checks() {

  # Only show the usage if we are in 'get' mode and have not specified a
  # subcommand. This allows internal code to call GC_run()
  if [[ $(PA_command) == "get" && -z $(PA_subcommand) ]]; then
    GC_usage
    exit "${OK}"
  fi
}

# Initialise _GC
_GC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# MU - Machine Utilities for Podman

# _MU is an associative array that holds data specific to machine utils.
declare -A _MU

# Declare externally defined variables ----------------------------------------

declare ERROR STDERR STOP

# Getters/Setters -------------------------------------------------------------

# Public Functions ------------------------------------------------------------

# MU_cleanup removes artifacts that were created during execution. This function
# is run automatically by the Parser library. Currently this does nothing and
# this function could be deleted.
MU_cleanup() { :; }

# MU_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_process_options() {
  case "$1" in
  -h | --help)
    MU_usage
    return "${STOP}"
    ;;
  *)
    MU_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_usage() {

  cat <<'EnD'
MACHINE subcommands are:
 
  list    - List the currently created Podman machines. Only one machine
            is currently supported and it will be named 'mok-machine'.
  create  - Create a Podman machine named 'mok-machine'. This will also
            setup the Podman machine to run Kubernetes so there is no
            need to run 'machine setup'.
  destroy - Completely removes the Podman machine named 'mok-machine'.
  start   - Start the Podman machine named 'mok-machine'.
  stop    - Stop the Podman machine named 'mok-machine'.
  setup   - Apply the correct settings to the Podman machine to run
            Kubernetes.
 
For more information:

  machine list -h
  machine create -h
  machine destroy -h
  machine start -h
  machine stop -h
  machine setup -h
 
EnD
}

# Private Functions -----------------------------------------------------------

# _MU_new sets the initial values for the Machine Utils associative array and
# sets up the Parser to call functions in machine*.sh files.
# Args: None expected.
_MU_new() {
  # Program the parser's state machine
  PA_add_state "COMMAND" "machine" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "machinelist" "END" ""
  PA_add_state "SUBCOMMAND" "machinecreate" "END" ""
  PA_add_state "SUBCOMMAND" "machinedestroy" "END" ""
  PA_add_state "SUBCOMMAND" "machinesetup" "END" ""
  PA_add_state "SUBCOMMAND" "machinestart" "END" ""
  PA_add_state "SUBCOMMAND" "machinestop" "END" ""

  # Set up the parser's option callbacks
  PA_add_option_callback "machine" "MU_process_options" || return
  PA_add_option_callback "machinelist" "MU_list_process_options" || return
  PA_add_option_callback "machinecreate" "MU_create_process_options" || return
  PA_add_option_callback "machinedestroy" "MU_destroy_process_options" || return
  PA_add_option_callback "machinesetup" "MU_setup_process_options" || return
  PA_add_option_callback "machinestart" "MU_start_process_options" || return
  PA_add_option_callback "machinestop" "MU_stop_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "machine" "MU_usage" || return
  PA_add_usage_callback "machinelist" "MU_list_usage" || return
  PA_add_usage_callback "machinecreate" "MU_create_usage" || return
  PA_add_usage_callback "machinedestroy" "MU_destroy_usage" || return
  PA_add_usage_callback "machinesetup" "MU_setup_usage" || return
  PA_add_usage_callback "machinestart" "MU_start_usage" || return
  PA_add_usage_callback "machinestop" "MU_stop_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "machinelist" "MU_list_run"
  PA_add_run_callback "machinecreate" "MU_create_run"
  PA_add_run_callback "machinedestroy" "MU_destroy_run"
  PA_add_run_callback "machinesetup" "MU_setup_run"
  PA_add_run_callback "machinestart" "MU_start_run"
  PA_add_run_callback "machinestop" "MU_stop_run"
}

# Initialise _MU
_MU_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148

# MACHINE STOP ================================================================

# MU_stop_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_stop_process_options() {
  case "$1" in
  -h | --help)
    MU_stop_usage
    return "${STOP}"
    ;;
  *)
    MU_stop_usage
    printf 'ERROR: "%s" is not a valid "stop" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_stop_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_stop_usage() {

  cat <<EnD
machine stop options:
 
 Format:
  machine stop [flags]
 
 Flags:
  -h - This help text.

 Description:
  This will stop a Podman machine named 'mok-machine'.
  Stop the podman machine with: $(MA_program_name) machine stop
EnD
}

# MU_stop_run lists Podman machines.
# Args: None expected.
MU_stop_run() {
  UT_run_with_progress \
    "    Stopping Podman machine: mok-machine" \
    podman machine stop mok-machine
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}


# shellcheck shell=bash disable=SC2148

# MACHINE START ===============================================================

# MU_start_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_start_process_options() {
  case "$1" in
  -h | --help)
    MU_start_usage
    return "${STOP}"
    ;;
  -v | --verbose)
    UT_set_tailf "${TRUE}" || err || return
    ;;
  *)
    MU_start_usage
    printf 'ERROR: "%s" is not a valid "start" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_start_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_start_usage() {

  cat <<EnD
machine start options:
 
 Format:
  machine start [flags]
 
 Flags:
  -h, --help - This help text.
  -v, --verbose - Verbose output. Useful if there was a problem.

 Description:
  This will start a Podman machine named 'mok-machine'.
  Start the podman machine with: $(MA_program_name) machine start
EnD
}

# MU_start_run lists Podman machines.
# Args: None expected.
MU_start_run() {
  UT_run_with_progress \
    "    Starting Podman machine: mok-machine" \
    podman machine start mok-machine
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}

# shellcheck shell=bash disable=SC2148

# MACHINE CREATE ==============================================================

# MU_create_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_create_process_options() {
  case "$1" in
  -h | --help)
    MU_create_usage
    return "${STOP}"
    ;;
  -v | --verbose)
    UT_set_tailf "${TRUE}" || err || return
    ;;
  *)
    MU_create_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_create_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_create_usage() {

  cat <<EnD
machine create options:
 
 Format:
  machine create [flags]
 
 Flags:
  -h, --help - This help text.
  -v, --verbose - Verbose output. Useful if there was a problem.

 Description:
  This will create a Podman machine named 'mok-machine' and setup the
  machine to run Kubernetes.
EnD
}

# MU_create_run lists Podman machines.
# Args: None expected.
MU_create_run() {
  UT_run_with_progress \
    "    Creating the Podman machine: mok-machine" \
    podman machine init --now --rootful --user-mode-networking mok-machine
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Loading module in mok-machine" \
    podman machine ssh --username root mok-machine modprobe nf_conntrack
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Persisting nf_conntrack module in mok-machine" \
    podman machine ssh --username root mok-machine \
      bash -c \
      "\"\\\"echo nf_conntrack \
      >/etc/modules-load.d/nf_conntrack.conf\\\"\""
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Setting nf_conntrack_max in mok-machine" \
    podman machine ssh --username root mok-machine sysctl -q \
      -w net.netfilter.nf_conntrack_max=163840
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Persisting nf_conntrack_max in mok-machine" \
    podman machine ssh --username root mok-machine \
      bash -c \
      "\"\\\"echo net.netfilter.nf_conntrack_max=163840 \
      >/etc/sysctl.d/99-nf_conntrack_max.conf\\\"\""
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}

# shellcheck shell=bash disable=SC2148

# MACHINE LIST ================================================================

# MU_list_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_list_process_options() {
  case "$1" in
  -h | --help)
    MU_list_usage
    return "${STOP}"
    ;;
  *)
    MU_list_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_list_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_list_usage() {

  cat <<'EnD'
machine list options:
 
 Format:
  machine list [flags]
 
 Flags:
  -h - This help text.

EnD
}

# MU_list_run lists Podman machines.
# Args: None expected.
MU_list_run() {
  info=$(podman machine list --format json) || err || return

  running=$(UT_sed_json_block "${info}" \
    'Name' 'mok-machine' '}' \
    'Running' \
    ) || err || return

  exists=$(UT_sed_json_block "${info}" \
    'Name' 'mok-machine' '}' \
    'Name' \
    ) || err || return

  if [[ ${exists} != "mok-machine" ]]; then
    printf 'mok-machine: does not exist.\n'
  else
    if [[ ${running} == "true" ]]; then
      printf 'mok-machine: running.\n'
    else
      printf 'mok-machine: stopped.\n'
    fi
  fi
}

# shellcheck shell=bash disable=SC2148

# MACHINE DESTROY ==============================================================

# MU_destroy_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_destroy_process_options() {
  case "$1" in
  -h | --help)
    MU_destroy_usage
    return "${STOP}"
    ;;
  -v | --verbose)
    UT_set_tailf "${TRUE}" || err || return
    ;;
  *)
    MU_destroy_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_destroy_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_destroy_usage() {

  cat <<'EnD'
machine destroy options:
 
 Format:
  machine destroy [flags]
 
 Flags:
  -h, --help - This help text.
  -v, --verbose - Verbose output. Useful if there was a problem.

 Description:
  This will completely remove a Podman machine named 'mok-machine'.
  A machine must be stopped before it can be destroyed.

EnD
}

# MU_destroy_run deletes a Podman machine.
# Args: None expected.
MU_destroy_run() {
  printf 'This will completely remove the podman machine named "mok-machine"\n'
  printf "Are you sure you want to destroy the machine? (y/N) >"
  read -r ans
  [[ ${ans} != "y" ]] && {
    printf 'Cancelling by user request.\n'
    return "${OK}"
  }
  UT_run_with_progress \
    "    Deleting the Podman machine: mok-machine" \
    podman machine rm -f mok-machine
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}

# shellcheck shell=bash disable=SC2148

# MACHINE SETUP ===============================================================

# MU_setup_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_setup_process_options() {
  case "$1" in
  -h | --help)
    MU_setup_usage
    return "${STOP}"
    ;;
  -v | --verbose)
    UT_set_tailf "${TRUE}" || err || return
    ;;
  *)
    MU_setup_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}


# MU_setup_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_setup_usage() {

  cat <<'EnD'
machine setup options:
 
 Format:
  machine setup [flags]
 
 Flags:
  -h, --help - This help text.
  -v, --verbose - Verbose output. Useful if there was a problem.

EnD
}

# MU_setup_run sets up a Podman machine.
# Args: None expected.
MU_setup_run() {
  UT_run_with_progress \
    "    Loading module in mok-machine" \
    podman machine ssh --username root mok-machine modprobe nf_conntrack
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Persisting nf_conntrack module in mok-machine" \
    podman machine ssh --username root mok-machine \
      bash -c \
      "\"\\\"echo nf_conntrack \
      >/etc/modules-load.d/nf_conntrack.conf\\\"\""
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Setting nf_conntrack_max in mok-machine" \
    podman machine ssh --username root mok-machine sysctl -q \
      -w net.netfilter.nf_conntrack_max=163840
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Persisting nf_conntrack_max in mok-machine" \
    podman machine ssh --username root mok-machine \
      bash -c \
      "\"\\\"echo net.netfilter.nf_conntrack_max=163840 \
      >/etc/sysctl.d/99-nf_conntrack_max.conf\\\"\""
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}

# shellcheck shell=bash disable=SC2148
# EX - EXec

# EX is an associative array that holds data specific to the exec cluster command.
declare -A _EX

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# EX_set_containername setter sets the containername to be used to 'log in' to.
EX_set_containername() {
  _EX[containername]="$1"
}

# Public Functions ------------------------------------------------------------

# EX_process_options checks if arg1 is in a list of valid exec options. This
# function is called by the parser, via a callback in _EX_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
EX_process_options() {

  case "$1" in
  -h | --help)
    EX_usage
    return "${STOP}"
    ;;
  *)
    EX_usage
    printf 'ERROR: "%s" is not a valid "exec" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# EX_usage outputs help text for the create exec component.  It is called in
# this file and by PA_usage(), via a callback in _EX_new.
# Args: None expected.
EX_usage() {

  cat <<'EnD'
'Log in' to a container. EXEC has no subcommands.
 
exec options:
 
 Format:
  exec [NAME]
  NAME        - (optional) The name of the container to 'log in' to.
                If NAME is not given then the user will be offered
                a choice of containers to log in to. If there is only
                one cluster and one node then it will 'log in' to the
                only available container.

EnD
}

# Execs 'bash' in the container referenced by _EX[containername]. If just
# 'mok exec' is called without options then the user is offered a selection
# of existing clusters to exec into.
# Args: None expected.
# ---------------------------------------------------------------------------
EX_run() {

  _EX_sanity_checks || return

  local names int ans lines containernames gcoutput

  GC_set_showheader "${TRUE}" || err || return
  gcoutput=$(GC_run) || return
  names=$(printf '%s' "${gcoutput}" | awk '{ print $3; }')
  readarray -t containernames <<<"${names}"

  if [[ -n ${_EX[containername]} ]]; then

    # The caller gave a specific name for exec.
    # Check if the container name exists

    if grep -qs "^${_EX[containername]}$" <<<"${names}"; then
      _EX_exec "${_EX[containername]}" || return
      return "${OK}"
    else
      printf 'ERROR: Cannot exec into non-existent container: "%s".\n' \
        "${_EX[containername]}"
      return "${ERROR}"
    fi

  elif [[ ${#containernames[*]} == 2 ]]; then

    # If there's only one container just log into it without asking
    _EX_exec "${containernames[1]}"

  elif [[ ${#containernames[*]} == 1 ]]; then

    printf 'No containers found.\n'
    return "${OK}"

  else

    # The caller supplied no container name.
    # Present some choices

    printf 'Choose the container to log in to:\n\n'

    readarray -t lines <<<"${gcoutput}" || return

    # Print the header then print the items in the loop
    printf '   %s\n' "${lines[0]}"
    for int in $(seq 1 $((${#lines[*]} - 1))); do
      printf '%00d) %s\n' "${int}" "${lines[int]}"
    done | sort -k 4

    printf "\nChoose a number (Enter to cancel)> "
    read -r ans

    [[ -z ${ans} || ${ans} -lt 0 || ${ans} -gt $((${#lines[*]} - 1)) ]] && {
      printf '\nInvalid choice. Aborting.\n'
      return "${OK}"
    }

    _EX_exec "${containernames[ans]}"
  fi
}

# Private Functions -----------------------------------------------------------

# _EX_new sets the initial values for the _EX associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
_EX_new() {
  _EX[containername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "exec" "ARG1" ""
  PA_add_state "ARG1" "exec" "END" "EX_set_containername"

  # Set up the parser's option callbacks
  PA_add_option_callback "exec" "EX_process_options" || return
  PA_add_usage_callback "exec" "EX_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "exec" "EX_run"
}

# EX_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For exec this does nothing.
# Args: None expected.
_EX_sanity_checks() { :; }

# _EX_exec runs a command in a docker container using bash as the command by
# default.
# Args: arg1 - docker container name
#       arg2 - command to run
_EX_exec() {

  local cmd=${2:-bash} url port

  containerrt=$(CU_containerrt) || err || return
  podmantype=$(CU_podmantype) || err || return

  if [[ $containerrt == "podman" && $podmantype == "machine" ]]; then
    # TODO: A named podman machine does not work the same way
    #       as the default podman machine. Rootful doesn't work
    #       for a named machine so need to use '--url'. Ask
    #       Podman developers about this.
    port=$(podman machine inspect mok-machine | grep Port | grep -o '[0-9]\+')
    url="ssh://root@127.0.0.1:$port/run/podman/podman.sock"
    # TODO: This would be preferred to using '--url'
    # podman -c mok-machine exec -ti "$1" "${cmd}" 
    read -rt 0.1
    podman --url "${url}" exec -ti "$1" "${cmd}" 
  elif [[ $containerrt == "podman" ]]; then
    read -rt 0.1
    exec podman exec -ti "$1" "${cmd}"
  elif [[ $containerrt == "docker" ]]; then
    read -rt 0.1
    exec docker exec -ti "$1" "${cmd}"
  fi
}

# Initialise EX
_EX_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# DC - Delete Cluster

# _DC is an associative array that holds data specific to deleting a cluster.
declare -A _DC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR STOP TRUE

# Getters/Setters -------------------------------------------------------------

# DC_set_clustername setter sets the cluster name to be deleted. This is
# called by the parser, via a callback in _DC_new.
DC_set_clustername() {
  _DC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# DC_process_options checks if arg1 is in a list of valid delete cluster
# options. This function is called by the parser, via a callback in _DC_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
DC_process_options() {

  case "$1" in
  -h | --help)
    DC_usage
    return "${STOP}"
    ;;
  *)
    DC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# DC_usage outputs help text for the create cluster component.
# It is called by PA_usage(), via a callback in _DC_new.
# Args: None expected.
DC_usage() {

  cat <<'EnD'
DELETE subcommands are:
 
  cluster - Delete a local kubernetes cluster.
 
delete cluster options:
 
 Format:
  delete cluster NAME
  NAME        - The name of the cluster to delete

EnD
}

# DC_run starts the delete cluster process.
# Args: None expected.
DC_run() {

  _DC_sanity_checks || return

  # Mutate functions make system changes.

  declare -i numnodes=0
  local id ids r

  numnodes=$(CU_get_cluster_size "${_DC[clustername]}") || return

  [[ ${numnodes} -eq 0 ]] && {
    printf '\nERROR: No cluster exists with name, "%s". Aborting.\n\n' \
      "${_DC[clustername]}" >"${STDERR}"
    return "${ERROR}"
  }

  ids=$(CU_get_cluster_container_ids "${_DC[clustername]}") || return

  printf 'The following containers will be deleted:\n\n'

  GC_set_showheader "${TRUE}"
  GC_set_clustername "${_DC[clustername]}"
  GC_run "${_DC[clustername]}" || return

  printf "\nAre you sure you want to delete the cluster? (y/N) >"

  read -r ans

  [[ ${ans} != "y" ]] && {
    printf '\nCancelling by user request.\n'
    return "${OK}"
  }

  printf '\n'

  for id in ${ids}; do
    UT_run_with_progress \
      "    Deleting id, '${id}' from cluster '${_DC[clustername]}'." \
      _DC_delete "${id}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n\n' >"${STDERR}"
      err
      return "${r}"
    }
  done

  printf '\n'
}

# Private Functions -----------------------------------------------------------

# _DC_new sets the initial values for the _DC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_DC_new() {
  _DC[clustername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "delete" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "deletecluster" "ARG1" ""
  PA_add_state "ARG1" "deletecluster" "END" "DC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "delete" "DC_process_options" || return
  PA_add_option_callback "deletecluster" "DC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "delete" "DC_usage" || return
  PA_add_usage_callback "deletecluster" "DC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "deletecluster" "DC_run"
}

# DC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before DC_run is called.
# Args: None expected.
_DC_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    DC_usage
    exit "${OK}"
  fi

  if [[ -z ${_DC[clustername]} ]]; then
    DC_usage
    printf 'Please provide the Cluster NAME to delete.\n' >"${STDERR}"
    return "${ERROR}"
  fi
}

# _DC_delete stops and removes a docker container.
# Args: arg1 - docker id to delete.
_DC_delete() {

  docker stop -t 5 "${id}"
  docker rm "${id}" || err
}

# Initialise _DC
_DC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE K8SVERSION

# Getters/Setters -------------------------------------------------------------

# CC_set_clustername setter sets the clustername array item.
CC_clustername() {
  printf '%s' "${_CC[clustername]}"
}

# CC_publish getter outputs the publish array item.
CC_publish() {
  printf '%s' "${_CC[publish]}"
}

# CC-withlb getter outputs the withlb array item.
CC_withlb() {
  printf '%s' "${_CC[withlb]}"
}

# CC_set_clustername setter sets the clustername array item.
CC_set_clustername() {
  _CC[clustername]="$1"
}

# CC_set_nummasters setter sets the nummasters array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_nummasters() {
  _CC[nummasters]="$1"
}

# CC_set_numworkers setter sets the numworkers array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_numworkers() {
  _CC[numworkers]="$1"
}

# Public Functions ------------------------------------------------------------

# CC_process_options checks if arg1 is in a list of valid create cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option. For example, '--masters' should be sent
#              with a value but boolean options, like 'skiplbsetup' should not.
CC_process_options() {

  case "$1" in
  -h | --help)
    CC_usage
    return "${STOP}"
    ;;
  --skiplbsetup)
    _CC[skiplbsetup]="${TRUE}"
    return
    ;;
  --k8sver)
    _CC[k8sver]="$2"
    return "$(PA_shift)"
    ;;
  --with-lb)
    _CC[withlb]="${TRUE}"
    return
    ;;
  --skipmastersetup)
    _CC[skipmastersetup]="${TRUE}"
    return
    ;;
  --skipworkersetup)
    _CC[skipworkersetup]="${TRUE}"
    return
    ;;
  --masters)
    _CC[nummasters]="$2"
    return "$(PA_shift)"
    ;;
  --workers)
    _CC[numworkers]="$2"
    return "$(PA_shift)"
    ;;
  --tailf)
    _CC[tailf]="${TRUE}"
    return "${OK}"
    ;;
  --publish)
    _CC[publish]="${TRUE}"
    return
    ;;
  *)
    CC_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# CC_usage outputs help text for the create cluster component.  It is called in
# this file and by PA_usage(), via a callback set in _CC_new.
# Args: None expected.
CC_usage() {

  cat <<'EnD'
CREATE subcommands are:
 
  cluster - Create a local kubernetes cluster.
 
create cluster [flags] options:
 
 Format:
  create cluster NAME [ [NUM_MASTERS] [NUM_WORKERS] ]
  NAME        - The name of the cluster. This will be used as
                the prefix in the name for newly created
                docker containers.
  NUM_MASTERS - The number of master containers.
  NUM_WORKERS - The number of worker containers. If NUM_WORKERS is
                zero then the 'node-role.kubernetes.io/master' taint
                will be removed from master nodes so that pods are
                schedulable.
 
 Flags:
  --skipmastersetup - Create the master container but don't set it
         up. Useful for manually installing kubernetes. Kubeadm, 
         kubelet and kubectl will be installed at the requested 
         version. With this option the worker will also be skipped.
         See also '--k8sver' flag.
  --skipworkersetup - The same as '--skipmastersetup', but skips
         setting up the worker only.
  --with-lb - Add a haproxy load balancer. The software will be installed
         and set up to reverse proxy to the master node(s), unless
         --skiplbsetup is used.
  --k8sver VERSION - The Kubernetes version, e.g. "1.32.0".
         A previous version will need to be downloaded first with:
           mok build image --get-prebuilt-image --k8sver VERSION
  --masters NUM - The number of master containers to create.
  --workers NUM - The number of worker containers to create. When workers
                  is zero then the master node taint will be removed from
                  master nodes so that pods are schedulable on those nodes.
  --tailf - Show the log output whilst creating the cluster.
  --publish - Publish port 6443 for the master node, or the load balancer if
              it's enabled, for external kubectl access to the cluster. The IP
              address of the default route interface is added to the cert.

EnD
}

# CC_run creates the kubernetes cluster.
# Args: None expected.
CC_run() {

  _CC_sanity_checks || return

  [[ ${_CC[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  declare -i numnodes=0

  numnodes=$(CU_get_cluster_size "${_CC[clustername]}") || return

  [[ ${numnodes} -gt 0 ]] && {
    printf '\nERROR: Cluster, "%s", exists! Aborting.\n\n' "${_CC[clustername]}" \
      >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_create_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_create_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_setup_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_setup_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[numworkers]} -gt 0 ]] && {
    _CC_create_worker_nodes "${_CC[numworkers]}" || return
  }

  printf '\n'

  [[ -z ${_CC[skipmastersetup]} ]] && {
    printf 'Cluster, "%s", can be accessed using:\n\n' "${_CC[clustername]}"
    printf 'export KUBECONFIG=/var/tmp/admin-%s.conf\n\n' "${_CC[clustername]}"
  }

  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CC_new sets the initial values for the _CC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_CC_new() {
  _CC[tailf]="${FALSE}"
  _CC[skipmastersetup]=
  _CC[skipworkersetup]=
  _CC[skiplbsetup]=
  _CC[withlb]=
  _CC[clustername]=
  _CC[nummasters]=0
  _CC[numworkers]=0
  _CC[publish]=0
  _CC[k8sver]="${K8SVERSION}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "create" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "createcluster" "ARG2" ""

  # Support for the legacy style of create (less to type):
  PA_add_state "ARG1" "createcluster" "ARG2" "CC_set_clustername"
  PA_add_state "ARG2" "createcluster" "ARG3" "CC_set_nummasters"
  PA_add_state "ARG3" "createcluster" "END" "CC_set_numworkers"

  # Set up the parser's option callbacks
  PA_add_option_callback "create" "CC_process_options" || return
  PA_add_option_callback "createcluster" "CC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "create" "CC_usage" || return
  PA_add_usage_callback "createcluster" "CC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "createcluster" "CC_run"
  PA_add_run_callback "createclusters" "CC_run"
}

# CC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before CC_run is called.
# Args: None expected.
_CC_sanity_checks() {

  declare -i host_max=0 cpus=0 should_be=0

  if [[ -z $(PA_subcommand) ]]; then
    CC_usage
    exit "${OK}"
  fi

  if [[ -z ${_CC[clustername]} ]]; then
    CC_usage
    printf 'Please provide the Cluster NAME to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[nummasters]} || ${_CC[nummasters]} -le 0 ]]; then
    CC_usage
    printf 'Please provide the number of Masters to create. Must be 1 or more.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[numworkers]} ]]; then
    CC_usage
    printf 'Please provide the number of Workers to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/sys/net/nf_conntrack_max ]]; then
    host_max=$(cat /proc/sys/net/nf_conntrack_max)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    host_max=$(podman machine ssh mok-machine cat /proc/sys/net/nf_conntrack_max)
  else
    printf '\nWARNING: /proc/sys/net/nf_conntrack_max not found.\n' >"${STDERR}"
    printf '         kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/cpuinfo ]]; then
    cpus=$(grep -cw ^processor /proc/cpuinfo)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    cpus=$(podman machine ssh mok-machine cat /proc/cpuinfo | grep -cw ^processor)
  else
    printf '\nWARNING: /proc/cpuinfo not found.\n' >"${STDERR}"
    printf '         I have no idea how many CPUs I have\n' >"${STDERR}"
    printf '         and kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  # These are the default values that kube-proxy expects:
  # conntrack:
  #   max: null
  #   maxPerCore: 32768
  #   min: 131072
  if [[ $((32768*cpus)) -lt 131072 ]]; then
    should_be=131072
  else
    should_be=$((32768*cpus))
  fi
  if [[ ${should_be} -ne $host_max ]]; then
    printf '\nERROR: /proc/sys/net/nf_conntrack_max should be set to %d.\n' \
      "${should_be}" >"${STDERR}"
    printf '     kube-proxy will not start with an incorrect nf_conntrack_max.\n' >"${STDERR}"
    printf '     To fix this, run the following command:\n\n' >"${STDERR}"
    if [[ $(CU_podmantype) == "native" ]]; then
      printf '       sudo sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
    elif [[ $(CU_podmantype) == "machine" ]]; then
      printf '       %s machine setup\n\n' "$(MA_program_name)" >"${STDERR}"
    else
      printf 'Internal ERROR. Invalid podman type.\n' >"${STDERR}"
      return "${ERROR}"
    fi
    
    printf 'Press ENTER to continue or CTRL-C to abort.\n' >"${STDERR}"
    read -r
    printf '\n' >"${STDERR}"
  fi
}

# _CC_create_master_nodes creates the master node containers.
# Args: arg1 - number of master nodes to create
_CC_create_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating master container, '${_CC[clustername]}-master-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-master-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }
  done

  return "${OK}"
}

# _CC_setup_master_nodes sets up the master node containers.
# Args: arg1 - number of master nodes to create
_CC_setup_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile lbaddr hostaddr
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-master-${int}'" \
      _CC_set_up_master_node "${_CC[clustername]}-master-${int}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  done

  # For now, copy admin.conf from master to /var/tmp/admin-CLUSTERNAME.conf

  if [[ -z ${_CC[skipmastersetup]} ]]; then
    if [[ ${_CC[publish]} -eq ${TRUE} ]]; then
      # On MacOS we need to use localhost, on linux use the host IP
      if [[ $(CU_podmantype) == "native" ]]; then
        hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
      else
        hostaddr="localhost"
      fi
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${hostaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    elif [[ ${_CC[withlb]} -eq ${TRUE} ]]; then
      lbaddr=$(CU_get_container_ip "${_CC[clustername]}-lb") || err || return
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${lbaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    else
      [[ -n ${_CC[skipmastersetup]} ]] || {
        docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
          "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      }
    fi

    chmod 666 "/var/tmp/admin-${_CC[clustername]}.conf" || {
      printf 'ERROR: Could not "chown 666 /var/tmp/admin-%s.conf"' "${_CC[clustername]}"
      err || return
    }
  fi

  return "${OK}"
}

# _CC_set_up_master_node calls the correct set up function based on the version
# Args: arg1 - the container ID to set up
_CC_set_up_master_node() {

  case "${_CC[k8sver]}" in
  "1.31."* | "1.32."* | "1.33."*)
    _CC_set_up_master_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# _CC_get_master_join_details uses 'docker exec' or 'podman exec' to run a
# script on the master to get CA hash, a token, and the master IP.  The caller
# can eval the output of this function to set the variables: cahash, token, and
# masterip. See also:
# https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/#token-based-discovery-with-ca-pinning
# Args: arg1 - id/name of master container
_CC_get_master_join_details() {

  local joinvarsfile master1ip

  joinvarsfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  master1ip=$(CU_get_container_ip "${_CC[clustername]}-master-1") || err || return

  cat <<EnD >"${joinvarsfile}"
#!/bin/bash
set -e

sed 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${master1ip}"'\2#' \
  /etc/kubernetes/super-admin.conf >/etc/kubernetes/admin2.conf

cahash=\$(openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | \
        openssl rsa -pubin -outform der 2>/dev/null | \
        openssl dgst -sha256 -hex | sed 's/^.* //')
token=\$(kubeadm token create --kubeconfig=/etc/kubernetes/admin2.conf 2>/dev/null)
ip=\$(ip ro get 8.8.8.8 | cut -d" " -f 7)

printf 'cahash=%s\ntoken=%s\nmasterip=%s' "\$cahash" "\$token" "\$ip"

exit 0
EnD

  docker cp "${joinvarsfile}" "$1":/root/joinvars.sh 2>"${STDERR}" ||
    err || return
  rm -f "${joinvarsfile}" 2>"${STDERR}" || err || return

  [[ -z ${_CC[skipworkersetup]} ]] && {
    docker exec "$1" bash /root/joinvars.sh 2>"${STDERR}" || err || return
  }

  return "${OK}"
}

# _CC_create_lb_node creates the load balancer node container.
# Args: None expected.
_CC_create_lb_node() {

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  # Create container
  UT_run_with_progress \
    "    Creating load balancer container, '${_CC[clustername]}-lb'" \
    CU_create_container \
    "${_CC[clustername]}-lb" \
    "${labelkey}=${_CC[clustername]}" \
    "${_CC[k8sver]}"

  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    printf '\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
    printf '%s\n' "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  return "${OK}"
}

# _CC_setup_lb_node sets up the load balancer node container.
# Args: None expected.
_CC_setup_lb_node() {

  local runlogfile

  # Set up
  [[ -z ${_CC[skiplbsetup]} ]] && {
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-lb'" \
      _CC_set_up_lb_node_real "${_CC[clustername]}-lb"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _CC_set_up_lb_node_real sets up the lb node.
# Args: arg1 - the container ID to set up
_CC_set_up_lb_node_real() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masteriplist=
  nl=
  gotamaster="${FALSE}"
  for idx in $(seq 1 "${_CC[nummasters]}"); do
    ip=$(CU_get_container_ip "${_CC[clustername]}-master-${idx}") || continue
    gotamaster="${TRUE}"
    masteriplist="${masteriplist}${nl}    server master-${idx} ${ip}:6443 check fall 3 rise 2"
    nl='\n'
  done

  [[ ${gotamaster} == "${FALSE}" ]] && {
    printf 'ERROR: Did not manage to get an IP address for any master nodes\n'
    err || return
  }

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

systemctl stop kubelet crio
systemctl disable kubelet crio

apt -y install haproxy

INTERNAL_IP=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")

cat <<EOF | tee /etc/haproxy/haproxy.cfg 
frontend kubernetes
    bind \$INTERNAL_IP:6443
    option tcplog
    mode tcp
    default_backend kubernetes-master-nodes
backend kubernetes-master-nodes
    mode tcp
    balance roundrobin
    option tcp-check
\$(echo -e "${masteriplist}")
EOF

systemctl restart haproxy
systemctl enable haproxy

EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# _CC_create_worker_nodes creates the worker nodes.
# Args: arg1 - number of worker nodes to create
_CC_create_worker_nodes() {

  local cahash token t masterip
  declare -i int=0

  [[ -n ${_CC[skipmastersetup]} ]] || {
    # Runs a script on master node to get details
    t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1") || {
      printf '\nERROR: Problem with "_CC_get_master_join_details".\n\n' >"${STDERR}"
      return "${ERROR}"
    }

    # Sets cahash, token, and masterip:
    eval "${t}"
  }

  local labelkey
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating worker container, '${_CC[clustername]}-worker-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-worker-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }

    [[ -n ${_CC[skipworkersetup]} || -n ${_CC[skipmastersetup]} ]] || {
      UT_run_with_progress \
        "    Setting up '${_CC[clustername]}-worker-${int}'" \
        _CC_set_up_worker_node "${_CC[clustername]}-worker-${int}" \
        "${cahash}" "${token}" "${masterip}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n' >"${STDERR}"
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
        printf '%s\n' "${runlogfile}" >"${STDERR}"
        return "${ERROR}"
      }

      UT_run_with_progress \
        "    Waiting for system to become ready" \
        _CC_wait_for_cluster \
        "${_CC[clustername]}-master-1" \
        "${_CC[clustername]}-worker-${int}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n'
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Wait timed out.\n' >"${STDERR}"
        return "${ERROR}"
      }
    }
  done

  return "${OK}"
}

# _CC_wait_for_cluster runs a `kubectl` command in the master-1 container,
# which doesn't exit until the all pods are fully up and running before it
# returns.
# Args: arg1 - the master container name to log into
#       arg2 - the worker container name to wait for
_CC_wait_for_cluster() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  cat <<'EnD' >"${setupfile}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
found=0
for i in $(seq 1 20); do
  if kubectl get pods &>/dev/null; then
    found=1
    break
  fi
  sleep 1
done
[[ $found == 0 ]] && {
  printf '# kubectl get pods\n'
  kubectl get pods
  printf '\nWaited for 20 seconds for kubectl to work.\n'
  printf 'Kubectl cannot contact master. Aborting.\n'
  exit 1
}
counter=0
while ! kubectl get nodes | grep -qs "$1"; do
  ((counter++))
  [[ ${counter} -gt 60 ]] && {
    printf '# kubectl get nodes\n'
    kubectl get nodes
    printf '\nWaited for 2 minutes for node to appear in master. Aborting.\n'
    exit 1
  }
  sleep 2
done
counter=0
while kubectl get pods -A | tail -n +2 | awk '{ print $3; }' | grep -qs 0; do
  ((counter++))
  [[ ${counter} -gt 120 ]] && {
    printf '# kubectl get pods -A\n'
    kubectl get pods -A
    printf '\nWaited for 3 minutes for pods to be ready. Aborting.\n'
    exit 1
  }
  sleep 2
done
exit 0
EnD

  docker cp "${setupfile}" "$1":/root/wait.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/wait.sh "$2" || err
}

# _CC_set_up_worker_node calls the correct set up function based on the version.
# Args: arg1 - the container ID to set up
#       arg2 - the CA hash
#       arg3 - the token
#       arg4 - the master IP
_CC_set_up_worker_node() {

  case "${_CC[k8sver]}" in
  "1.31."* | "1.32."* | "1.33."*)
    _CC_set_up_worker_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# Initialise _CC
_CC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster - versions file

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR TRUE

# _CC_set_up_master_node_v1_30_0 uses kubeadm to set up the master node.
# Args: arg1 - the container to set up.
_CC_set_up_master_node_v1_30_0() {

  local setupfile lbaddr certSANs="{}" certkey masternum t lbip
  # Set by _CC_get_master_join_details:
  local cahash token masterip

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masternum="${1##*-}" # <- eg. for xxx-master-1, masternum=1

  if [[ ${_CC[skipmastersetup]} != "${TRUE}" ]]; then

    if [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -eq 1 ]]; then

      # This is the first master node

      # Sets cahash, token, and masterip:
      lbip=$(CU_get_container_ip "${_CC[clustername]}-lb")
      lbaddr=", '${lbip}'"
      uploadcerts="--upload-certs"
      certkey="CertificateKey: f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07"

    elif [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -ne 1 ]]; then

      # This is not the first master node, so join with the master
      # https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/

      # Keep trying to get join details until apiserver is ready or we run out of tries
      for try in $(seq 1 9); do
        # Runs a script on master node to get join details
        t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1")
        retval=$?
        [[ ${retval} -eq 0 ]] && break
        [[ ${try} -eq 9 ]] && {
          printf '\nERROR: Problem with "_CC_get_master_join_details". Tried %d times\n\n' "${try}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        sleep 5
      done
      eval "${t}"
    fi
  fi

  # Always set certSANs for the host whether we need it or not
  hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
  certSANs="
  certSANs: [ '${hostaddr}'${lbaddr}, '127.0.0.1', 'localhost' ]"

  # Write the file regardless, so the user can use it if required

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

# Use a custom configuration. Default config created from kubeadm with:
#   kubeadm config print init-defaults
# then edited.

ipaddr=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")
podsubnet="10.244.0.0/16"
servicesubnet="10.96.0.0/16"

cat <<EOF >kubeadm-init-defaults.yaml
apiVersion: kubeadm.k8s.io/v1beta4
bootstrapTokens:
- groups:
  - system:bootstrappers:kubeadm:default-node-token
  token: abcdef.0123456789abcdef
  ttl: 24h0m0s
  usages:
  - signing
  - authentication
kind: InitConfiguration
${certkey}
localAPIEndpoint:
  advertiseAddress: \$ipaddr
  bindPort: 6443
nodeRegistration:
  criSocket: unix:///var/run/crio/crio.sock
  imagePullPolicy: IfNotPresent
  imagePullSerial: true
  name: $1
  taints:
  - effect: NoSchedule
    key: node-role.kubernetes.io/control-plane
timeouts:
  controlPlaneComponentHealthCheck: 4m0s
  discovery: 5m0s
  etcdAPICall: 2m0s
  kubeletHealthCheck: 4m0s
  kubernetesAPICall: 1m0s
  tlsBootstrap: 5m0s
  upgradeManifests: 5m0s
---
apiServer: ${certSANs}
apiVersion: kubeadm.k8s.io/v1beta4
caCertificateValidityPeriod: 87600h0m0s
certificateValidityPeriod: 8760h0m0s
certificatesDir: /etc/kubernetes/pki
clusterName: ${_CC[clustername]}-cluster
controlPlaneEndpoint: ${lbaddr:-\$ipaddr}:6443
controllerManager: {}
dns: {}
encryptionAlgorithm: RSA-2048
etcd:
  local:
    dataDir: /var/lib/etcd
imageRepository: registry.k8s.io
kind: ClusterConfiguration
kubernetesVersion: v${_CC[k8sver]}
networking:
  dnsDomain: cluster.local
  podSubnet: \${podsubnet}
  serviceSubnet: \${servicesubnet}
proxy: {}
scheduler: {}
EOF

mkdir -p /mok
cp kubeadm-init-defaults.yaml /mok/kubeadm.yaml

if [[ -z "${masterip}" ]]; then
  # Run the preflight phase
  kubeadm init \\
    --ignore-preflight-errors Swap \\
    --config=kubeadm-init-defaults.yaml \\
    phase preflight

  # Set up the kubelet
  kubeadm init phase kubelet-start

  # Edit the kubelet configuration file
  echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
  sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

  # Tell kubeadm to carry on from here
  kubeadm init \\
    --config=kubeadm-init-defaults.yaml \\
    --ignore-preflight-errors Swap \\
    ${uploadcerts} \\
    --skip-phases=preflight,kubelet-start

  export KUBECONFIG=/etc/kubernetes/super-admin.conf

  # Flannel - 10.244.0.0./16
  kubectl apply -f /root/kube-flannel.yml
else
  kubeadm join ${masterip}:6443 \\
    --ignore-preflight-errors Swap \\
    --control-plane \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --certificate-key f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07
fi

systemctl enable kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  # Run the file
  [[ -z ${_CC[skipmastersetup]} ]] && {
    docker exec "$1" bash /root/setup.sh || err || return

    # Remove the taint if we're setting up a single node cluster

    [[ ${_CC[numworkers]} -eq 0 ]] && {

      removetaint=$(mktemp -p /var/tmp) || {
        printf 'ERROR: mktmp failed.\n' >"${STDERR}"
        return "${ERROR}"
      }

      # Write the file
      cat <<'EnD' >"${removetaint}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
kubectl taint nodes --all node-role.kubernetes.io/control-plane:NoSchedule-
EnD

      docker cp "${removetaint}" "$1":/root/removetaint.sh || err || {
        rm -f "${removetaint}"
        return "${ERROR}"
      }

      # Run the file
      docker exec "$1" bash /root/removetaint.sh || err
    }
  }

  return "${OK}"
}

# _CC_set_up_worker_node_v1_30_0 uses kubeadm to set up the worker node.
# Args: arg1 - the container to set up.
_CC_set_up_worker_node_v1_30_0() {

  local setupfile cahash="$2" token="$3" masterip="$4"

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  if [[ ${_CC[withlb]} == "${TRUE}" ]]; then
    masterip=$(CU_get_container_ip "${_CC[clustername]}-lb") || return
  fi

  cat <<EnD >"${setupfile}"
# Wait for the master API to become ready
while true; do
  curl -k https://${masterip}:6443/
  [[ \$? -eq 0 ]] && break
  sleep 1
done

# Do the preflight tests (ignoring swap error)
kubeadm join \\
  phase preflight \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --ignore-preflight-errors Swap \\
    ${masterip}:6443

# Set up the kubelet
kubeadm join \\
  phase kubelet-start \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    ${masterip}:6443 &

while true; do
  [[ -e /var/lib/kubelet/config.yaml ]] && break
    sleep 1
  done

# Edit the kubelet configuration file
echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

systemctl enable --now kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh 2>"${STDERR}" || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CU - Container Utilities

# _CU is an associative array that holds data specific to container utils.
declare -A _CU

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# CU_containerrt getter outputs the container runtime (podman or docker)
# that has been chosen.
CU_containerrt() {
  printf '%s' "${_CU[containerrt]}"
}

# CU_imgprefix getter outputs the prefix to be used with docker build. For
# podman it is 'localhost/'. For docker it is empty.
CU_imgprefix() {
  printf '%s' "${_CU[imgprefix]}"
}

# CU_labelkey getter outputs the key value of the label that is applied to all
# cluster member's container labels for podman or docker.
CU_labelkey() {
  printf '%s' "${_CU[labelkey]}"
}

# CU_podmantype getter outputs the container runtime type (native or machine).
CU_podmantype() {
  printf '%s' "${_CU[podmantype]}"
}

# Public Functions ------------------------------------------------------------

# CU_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted.
CU_cleanup() { :; }

# CU_get_cluster_container_ids outputs just the container IDs, one per line
# for any MOK cluster, unless arg1 is set, in which case just the IDs
# for the requested cluster name are output.
# Args: arg1 - The cluster name, optional.
CU_get_cluster_container_ids() {

  local value output

  [[ -n $1 ]] && value="=$1"

  output=$(docker ps -a -f label="${_CU[labelkey]}${value}" -q) || {
    printf 'ERROR: %s command failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  output=$(printf '%s' "${output}" | sed 's/$//')

  printf '%s' "${output}"

  return "${OK}"
}

# CU_get_cluster_size searches for an existing cluster using labels and outputs
# the number of containers in that cluster. All cluster nodes are labelled with
# "${_CU[labelkey]}=${CC[clustername]}"
# Args: arg1 - The cluster name to search for.
CU_get_cluster_size() {

  local output
  declare -a nodes

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Cluster name cannot be empty.\n' >"${STDERR}"
    err || return
  }

  output=$(CU_get_cluster_container_ids "$1") || err || return

  # readarray will read null as an array item so don't run
  # through readarray if it's null
  [[ -z ${output} ]] && {
    printf '0'
    return "${OK}"
  }

  # read the nodes array and delete blank lines
  readarray -t nodes <<<"${output}"

  printf '%d' "${#nodes[*]}"
}

# CU_get_container_ip outputs the IP address of the container.
# Args: arg1 - docker container id or container name to query.
CU_get_container_ip() {

  local info

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  info=$(CU_get_container_info "$1") || return
  JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}" ||
    err || return
}

# CU_get_container_info uses 'docker/podman inspect $id' to output
# container details.
# Args: arg1 - docker container id
CU_get_container_info() {

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  docker inspect "$1" || {
    printf 'ERROR: %s inspect failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_create_container creates and runs a container with settings suitable for
# running privileged containers that can manipulate cgroups.
# Args: arg1 - The string used to set the name and hostname.
#       arg2 - The label to assign to the container.
#       arg3 - The k8s base image version to use.
CU_create_container() {

  local imagename img allimgs systemd_always clustername parg pval root_user url port

  [[ -z $1 || -z $2 || -z $3 ]] && {
    printf 'INTERNAL ERROR: Neither arg1, arg2 nor arg3 can be empty.\n' \
      >"${STDERR}"
    err || return
  }

  img="$(BI_baseimagename)_$(MA_arch)"

  local imglocal="${_CU[imgprefix]}local/${img}"
  local imgremote="myownkind/${img}"
  local imgtag="${3}"

  # Prefer a locally built container over one downloaded from a registry
  allimgs=$(docker images | tail -n +2) || {
    printf 'ERROR: %s returned an error\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  if echo "${allimgs}" | grep -qs "${imglocal} *${imgtag}"; then
    imagename="${imglocal}:${imgtag}"
  elif echo "${allimgs}" | grep -qs "${imgremote} *${imgtag}"; then
    imagename="${imgremote}:${imgtag}"
  else
    cat <<EnD
ERROR: No container base image found. Use either:

  $ mok build image
OR
  $ mok build image --get-prebuilt-image

Then try running 'mok create ...' again.
EnD
    return "${ERROR}"
  fi

  clustername=$(CC_clustername) || err || return

  if [[ ${_CU[containerrt]} == "podman" ]];
  then 
    docker network exists "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  else
    docker network inspect "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  fi

  [[ ${create_network} -ne 0 ]] && {
    docker network create "${clustername}_network" || {
      printf 'ERROR: docker network create failed\n' >"${STDERR}"
      err || return
    }
  }

  # Docker does not have the --systemd option
  [[ ${_CU[containerrt]} == "podman" ]] && systemd_always="--systemd=always"
  [[ ${_CU[podmantype]} == "machine" ]] && {
    root_user="--user=root"
    # TODO: A named podman machine does not work the same way
    #       as the default podman machine. Rootful doesn't work
    #       for a named machine so need to use '--url'. Ask
    #       Podman developers about this.
    port=$(podman machine inspect mok-machine | grep Port | grep -o '[0-9]\+')
    url="--url ssh://root@127.0.0.1:$port/run/podman/podman.sock"
  }

  [[ $(CC_publish) == "${TRUE}" ]] && {
    if [[ $(CC_withlb) == "${TRUE}" ]]; then
      if echo "$1" | grep -qs -- '-lb$'; then
        parg='-p'
        pval='6443:6443'
      fi
    else
      if echo "$1" | grep -qs -- '-master-1$'; then
        parg='-p'
        pval='6443:6443'
      fi
    fi
  }

  # shellcheck disable=SC2086
  docker ${url} run --privileged ${systemd_always} ${root_user} \
    --network "${clustername}_network" \
    -v /lib/modules:/lib/modules:ro \
    --detach ${parg} ${pval} \
    --name "$1" \
    --hostname "$1" \
    --label "$2" \
    "${imagename}" \
    /usr/local/bin/entrypoint /lib/systemd/systemd log-level=info unit=sysinit.target || {
    printf 'ERROR: %s run failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_podman_or_docker checks to see if docker and/or podman are installed and
# sets the imgprefix and containerrt array members accordingly. It also defines
# the docker function to run the detected container runtime. Podman is
# preferred if both are installed.
# Args: No args expected.
CU_podman_or_docker() {
  if type podman &>/dev/null; then
    _CU[imgprefix]="localhost/"
    _CU[containerrt]="podman"
    _CU_podman_checks || return
  elif type docker &>/dev/null; then
    _CU[imgprefix]=""
    _CU[containerrt]="docker"
    _CU_docker_checks || return
  else
    printf 'ERROR: Neither "podman" nor "docker" were found.\n' \
      >"${STDERR}"
    printf 'Please install one of "podman" or "docker".\nAborting.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi
  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CU_docker_checks checks to see if the current user has permission to write
# to the docker socket. If not, it prints an error message and exits.
# Args: No args expected.
_CU_docker_checks() {
  if [[ ! -e /proc/sys/kernel/hostname ]]; then
    printf 'ERROR: Docker is currently supported on Linux only'
    exit "${ERROR}"
  fi

  if docker ps >/dev/stdout 2>&1 | grep -qs 'docker.sock.*permission denied'; then
    cat <<EnD >"${STDERR}"
Not enough permissions to write to 'docker.sock'.

Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  fi

  _CU[podmantype]="native"
  return "${OK}"
}

# _CU_podman_checks sets the _CU[podmantype] member to "native" or "machine"
# depending on whether this is linux or macos. We assume linux won't be using
# a podman machine, and macos will always be using a podman machine.
# Args: No args expected.
_CU_podman_checks() {
  local info running exists

  if [[ -e /proc/sys/kernel/hostname ]]; then
    # We're on linux
    _CU[podmantype]="native"
    _CU_podman_native_checks || return
  elif [[ -d /System/Library/CoreServices ]]; then
    # We're on macOS
    [[ $(id -u) -eq 0 ]] && {
      printf 'ERROR: Cannot run mok as root on macOS.\n' >"${STDERR}"
      exit "${ERROR}"
    }

    info=$(podman machine list --format json) || err || return
    running=$(UT_sed_json_block "${info}" \
      'Name' 'mok-machine' '}' \
      'Running' \
      ) || err || return
    exists=$(UT_sed_json_block "${info}" \
      'Name' 'mok-machine' '}' \
      'Name' \
      ) || err || return

    if [[ $(MA_arg_1) != "machine" && ${exists} != "mok-machine" ]]; then
      printf 'ERROR: Podman machine does not exist.\n' >"${STDERR}"
      printf '       Create a Podman machine with: %s machine create\n' \
        "$(MA_program_name)" >"${STDERR}"
      exit "${ERROR}"
    elif [[ ${running} == "true" ]]; then
      _CU[podmantype]="machine"
    elif [[ $(MA_arg_1) != "machine" ]]; then
      # Don't check for a podman machine if we're running 'machine' commands
      printf 'ERROR: Podman machine is not running.\n' >"${STDERR}"
      printf '       Try starting the machine with: %s machine start\n' \
        "$(MA_program_name)" >"${STDERR}"
      exit "${ERROR}"
    fi
  else
    printf 'ERROR: Unknown OS. Aborting.\n' >"${STDERR}"
    exit "${ERROR}"
  fi
}

# _CU_podman_native_checks checks to see if the current user is root. If not,
# it prints an error message and exits.
# Args: No args expected.
_CU_podman_native_checks() {
  [[ $(id -u) -ne 0 ]] && {
    cat <<EnD >"${STDERR}"
Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  }
}

# _CU_new sets the initial values for the Container Utils associative array.
# Args: None expected.
_CU_new() {
  _CU[imgprefix]=
  _CU[labelkey]="MokCluster"
  _CU[containerrt]=

  # _CU[podmantype] will only be set only if _CU[containerrt]=podman.
  # podmantype will be "native" or "machine".
  _CU[podmantype]=
}

# Override `docker` depending on _CU[containerrt]
# [[ -n ${_CU[containerrt]} ]] && {
  docker() {
    local cmd port url

    if [[ "${_CU[containerrt]}" == "podman" && "${_CU[podmantype]}" == "machine" ]]; then
      # TODO: A named podman machine does not work the same way
      #       as the default podman machine. Rootful doesn't work
      #       for a named machine so need to use '--url'. Ask
      #       Podman developers about this.
      port=$(podman machine inspect mok-machine | grep Port | grep -o '[0-9]\+')
      url="ssh://root@127.0.0.1:$port/run/podman/podman.sock"

      # TODO: This would be preferred to '--url'
      # podman -c mok-machine "$@"
      podman --url "${url}" "$@"
    elif [[ "${_CU[containerrt]}" == "podman" ]]; then
      podman "$@"
    else
      cmd=$(which -a docker | tail -n 1)
      $cmd "$@"
    fi
  }
# }

# Override `ip` depending on _CU[podmantype]
ip() {
  local cmd
  if [[ "${_CU[podmantype]}" == "machine" ]]; then
    podman machine ssh mok-machine ip "$@"
  else
    cmd=$(which -a ip | tail -n 1)
    $cmd "$@"
  fi
}

# Initialise _CU
_CU_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# BI - Build Image

# _BI is an associative array that holds data specific to building an image.
declare -A _BI

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE

# Getters/Setters -------------------------------------------------------------

# BI_setflag_useprebuiltimage setter sets the useprebuiltimage array item.
# This is called by the parser, via a callback in _BI_new.
BI_setflag_useprebuiltimage() {
  _BI[useprebuiltimage]="$1"
}

# BI_baseimagename getter outputs the value of the _BI[baseimagename].
# Args: None expected.
BI_baseimagename() {
  printf '%s' "${_BI[baseimagename]}"
}

# Public Functions ------------------------------------------------------------

# BI_usage outputs help text for the build image component.
# It is called by PA_usage(), via a callback in _BI_new.
# Args: None expected.
BI_usage() {

  cat <<'EnD'
BUILD subcommands are:
 
  image - Creates the docker 'mok-image' container image.
 
build image options:
 
 Format:
  build image [flags]

 Flags:
  --get-prebuilt-image - Instead of building a 'node' image
         locally, download it from a container registry instead.
  --k8sver VERSION - The Kubernetes version, e.g. "1.32.0"
         A previous version cannot be built from scratch hence this option
         must be used with '--get-prebuilt-image'. To build a previous
         version of kubernetes it must be built with a previous version
         of mok.
  --tailf - Show the build output whilst building.

EnD
}

# BI_cleanup removes temporary files created during the build.
# This function is called by the 'MA_cleanup' trap only.
# Args: None expected.
BI_cleanup() {
  [[ -e ${_BI[dockerbuildtmpdir]} ]] &&
    [[ ${_BI[dockerbuildtmpdir]} == "/var/tmp/"* ]] && {
    rm -rf "${_BI[dockerbuildtmpdir]}" || {
      printf 'ERROR: "rm -rf %s" failed.\n' "${_BI[dockerbuildtmpdir]}" \
        >"${STDERR}"
      err || return
    }
  }
}

# BI_check_valid_options checks if arg1 is in a list of valid build image
# options. This function is called by the parser, via a callback in _BI_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
BI_process_options() {

  case "$1" in
  -h | --help)
    BI_usage
    return "${STOP}"
    ;;
  --tailf)
    _BI[tailf]="${TRUE}"
    return "${OK}"
    ;;
  --k8sver)
    _BI[k8sver]="$2"
    return "$(PA_shift)"
    ;;
  --get-prebuilt-image)
    _BI[useprebuiltimage]="${TRUE}"
    return "${OK}"
    ;;
  *)
    BI_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# BI_run builds the base image used for masters and workers.
# This function is called in main.sh.
# Args: None expected.
BI_run() {

  _BI_sanity_checks || return

  [[ ${_BI[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  local retval=0
  _BI_build_container_image
  retval=$?

  if [[ ${retval} -eq ${OK} ]]; then
    : # We only need the tick - no text
  else
    printf 'Image build failed\n' >"${STDERR}"
    err
  fi

  return "${retval}"
}

# Private Functions -----------------------------------------------------------

# _BI_new resets the initial values for the _BI associative array.
# Args: None expected.
_BI_new() {
  _BI[tailf]="${FALSE}"
  _BI[baseimagename]="mok-image"
  _BI[useprebuiltimage]="${FALSE}"
  _BI[dockerbuildtmpdir]=
  _BI[k8sver]="${K8SVERSION}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "build" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "buildimage" "END" ""

  # Set up the parser's option callbacks
  PA_add_option_callback "build" "BI_process_options" || return
  PA_add_option_callback "buildimage" "BI_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "build" "BI_usage" || return
  PA_add_usage_callback "buildimage" "BI_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "buildimage" "BI_run"
}

# BI_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_BI_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    BI_usage
    exit "${OK}"
  fi
}

# _BI_build_container_image creates the docker build directory in
# dockerbuildtmpdir then calls docker build to build the image.
# Args: No args expected.
_BI_build_container_image() {

  local cmd retval tagname buildargs text buildtype basename

  _BI_create_docker_build_dir || return

  buildargs=$(_BI_get_build_args_for_latest) || return
  basename="${_BI[baseimagename]}_$(MA_arch)"
  tagname="${_BI[k8sver]}"

  local imgprefix
  imgprefix=$(CU_imgprefix) || err || return
  if [[ ${_BI[useprebuiltimage]} == "${FALSE}" ]]; then
    # Each mok release can build the hardcoded version only
    # so reset the tagname to that version
    tagname="${K8SVERSION}"
    buildtype="create"
    cmd="docker build \
      -t "${imgprefix}local/${basename}:${tagname}" \
      --force-rm \
      ${buildargs} \
      ${_BI[dockerbuildtmpdir]}/${_BI[baseimagename]}"
    text="Creating"
  else
    # We can download and run any available version
    buildtype="download"
    cmd="docker pull docker.io/myownkind/${basename}:${tagname}"
    text="Downloading"
  fi

  UT_run_with_progress \
    "    ${text} base image, '${basename}:${tagname}'" "${cmd}"

  retval=$?
  [[ ${retval} -ne ${OK} ]] && {
    local runlogfile
    runlogfile=$(UT_runlogfile) || err || return
    printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\n' >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${buildtype} == "create" ]] && {
    cmd="_BI_modify_container_image"

    UT_run_with_progress \
      "    Modifying base image (pulling kubernetes images)" "${cmd}"

    retval=$?
    [[ ${retval} -ne ${OK} ]] && {
      local runlogfile
      runlogfile=$(UT_runlogfile) || err || return
      printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\n' >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _BI_modify_container_image starts a container suitable for running kubernetes
# components (since the docker/podman build environment isn't suitable), makes
# some modifications and then 'commits' the image. The modifications allow
# `mok create ...` to complete more quickly.
# Args: No args expected.
_BI_modify_container_image() {

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify &>/dev/null
  docker rm mok-build-modify &>/dev/null

  CC_set_clustername "build" || err || return

  # Start container
  CU_create_container "mok-build-modify" "mok-build-modify" "${K8SVERSION}" ||
    return

  # Wait for crio to become ready
  local counter
  printf '\n\n ** WAITING FOR CRIO TO BECOME READY **\n\n'
  while ! docker exec mok-build-modify systemctl status crio; do
    sleep 1
    [[ ${counter} -gt 10 ]] && {
      printf '\nERROR: CRI-O did not start after %d tries.\n' "${counter}"
      err || return
    }
    ((counter++))
  done

  # Modify container
  docker exec mok-build-modify kubeadm config images pull \
    --kubernetes-version "${K8SVERSION}" || err || return

  # Stop container
  docker stop -t 5 "mok-build-modify"

  # Write image
  local imgprefix tagname basename
  imgprefix=$(CU_imgprefix) || err || return
  basename="${_BI[baseimagename]}_$(MA_arch)"
  tagname="${K8SVERSION}"
  docker commit mok-build-modify "${imgprefix}local/${basename}:${tagname}" || err || return

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify
  docker rm mok-build-modify || err || return

  return "${OK}"
}

# _BI_get_build_args_for_latest sets the buildargs variable that is added
# to the 'podman build ...' command line.  Only the latest version is built
# from scratch.  Earlier versions are downloaded using '--get-prebuilt-image'.
# Args: None expected
_BI_get_build_args_for_latest() {

  local buildargs

  buildargs="--build-arg GO_VERSION=${GO_VERSION}"

  printf '%s' "${buildargs}"
}

# _BI_create_docker_build_dir creates a docker build directory in
# /var/tmp/tmp.XXXXXXXX
# Args: None expected
_BI_create_docker_build_dir() {

  _BI[dockerbuildtmpdir]="$(mktemp -d -p /var/tmp)" || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }

  # The following comments should not be removed or changed.
  # embed-dockerfile.sh adds a base64 encoded tarball and
  # unpacking code between them.

  #mok-image-tarball-start 
  cat <<EnD | base64 -d | tar xz -C "${_BI[dockerbuildtmpdir]}" 
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
vd76dv5/jU+0/hIbJvziu/+z8r8TBnzb/1/js7z+4hHh9PtfrI2P8f/ry/nfUfzb/v8Kn0z+P5kH
st74lgfyWx7Iz88EzcupI4+RXIQrk+HI+6DOdk+etc9gyYA5W93bSyeNjCWMTCaLZMeP1Vh9jj3u
zsYtfblr1PgFF8YPrabDgVKc88nCOe/3C+oHmEO4Y2+p/IfNVveO4o91Ub5hxSM/dPv/9bJHBv2/
GM7Y03p+/YV4gU8//zfWa41v5//X+Ny//ufD8dj/01jwyetfr7ZqtW/r/zU+D1l/fRp+dhsfkf/q
tWo9tf41Xv9v/N///gec3YvOmWUC1uhHMZeL+L+1fhG5wNcd+rOpGCHkJh98CjGBudyx5QnY69uf
+ZxCz0UCu5JCDhwwYv0LyBUlSUNyDUYiRJw15tfk/gwsW85E7DNskw44FQb9IYec9YL+grMDs7Eu
6yw0S3mqa+SLJfFNcEc57S1qXjHrCLMYk3WJYJRgCz1a8B2eeR3xNBLeBxMR5sRqt8T9LOkoc/Sv
z8OaLnqjYXhRivFwJcSDGRkemMZRYbeS0ShHEIbIRDlI9E4MQyUVAMyuZYrYJPzqQscgsiMZhrnB
gniy8EK7YsCjnVv8jSPcBalIP7Rk3pC5tO1cDovOWSd5LLLOxHwj7LpNJRJxeuZVeOFKXGmZMHFG
d2PDkSj7uNRDTD5OS4r+p4ZJPOHZ87Y6PXp6Rkxsm9hbdXxy9I/OfnvfsLulNJv7ryRb2/7nMQwm
iPPNdV4cH3Ta9KxzuHfwch+XnL9QvcMjQmkkDCagZ0cKDcY55qfqRfsE9hZnu790Djpn/yrlnnbO
DgHzKbHTu+p49+Sss/fyYPdEHb88OT46bVPz+wT2sHP49IRaaSMFX5lapWeq/Q/6oU6f7x4coKnc
7kvq/YnmzI//ddJ59vxMPT862G/Tw1/a1LPdXw7a0hQNau9gt/OipPZ3X+w+E37+iKCc5FBMeqd+
fd7GI7S3S//tgdfHMJBX5oR+lmiUJ2e26q+d03ZJ7Z50TjEhT0+OXpRymE6qccRAqN5hW6BgqlVi
RagIfr88bVuAar+9e0CwTlEZQzSFy//1HPD/7c9Dzn/RB5fH3me28TH9b722kTr/69WN6rfz/2t8
VuRIx5mgg2RMOKKfx9EjrRrlFZd6Y8J7S2BoSXGGs+dqMgpcJCvI2Wh54ovnz4nc68qZ7uHzmXs5
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
8lk+y2f5LJ//6uf/APEKsdgA4AEA
EnD
  #mok-image-tarball-end
}

# Initialise _BI
_BI_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
#!/usr/bin/env bash

declare -A JSONPath

JSONPath_new() {
  JSONPath[DEBUG]=0
  JSONPath[INCLEMPTY]=0
  JSONPath[NOCASE]=0
  JSONPath[WHOLEWORD]=0
  JSONPath[FILE]=
  JSONPath[NO_HEAD]=0
  JSONPath[NORMALIZE_SOLIDUS]=0
  JSONPath[BRIEF]=0
  JSONPath[PASSTHROUGH]=0
  JSONPath[JSON]=0
  JSONPath[MULTIPASS]=0
  JSONPath[FLATTEN]=0
  JSONPath[STDINFILE]=/var/tmp/JSONPath.$$.stdin
  JSONPath[STDINFILE2]=/var/tmp/JSONPath.$$.stdin2
  JSONPath[PASSFILE]=/var/tmp/JSONPath.$$.pass1
  declare -a INDEXMATCH_QUERY
}

# JSONPath reads JSON from stdin and applies a JSON Path query.
# Args: arg1-N - command line arguments to be parsed.
JSONPath() {

  JSONPath_sanity_checks
  JSONPath_parse_options "$@"

  trap JSONPath_cleanup EXIT

  if [[ ${QUERY} == *'?(@'* ]]; then
    # This will be a multipass query

    [[ -n ${JSONPath[FILE]} ]] && JSONPath[STDINFILE]=${JSONPath[FILE]}
    [[ -z ${JSONPath[FILE]} ]] && cat >"${JSONPath[STDINFILE]}"

    while true; do
      JSONPath_tokenize_path
      JSONPath_create_filter

      JSONPath_tokenize | JSONPath_parse | JSONPath_filter |
        JSONPath_indexmatcher >"${JSONPath[PASSFILE]}" <"${JSONPath[STDINFILE]}"

      [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && {
        # replace filter expression with index sequence
        SET=$(sed -rn 's/.*[[,"]+([0-9]+)[],].*/\1/p' "${JSONPath[PASSFILE]}" | tr '\n' ,)
        SET=${SET%,}
        #QUERY=$(sed "s/?(@[^)]\+)/${SET}/" <<<"${QUERY}")
        # Testing:
        QUERY="${QUERY//\?\(@*)/${SET}}"
        [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "QUERY=${QUERY}" >/dev/stderr
        JSONPath_reset
        continue
      }

      JSONPath_flatten | JSONPath_json | JSONPath_brief <<<"${JSONPath[PASSFILE]}"

      break
    done

  else

    JSONPath_tokenize_path
    JSONPath_create_filter

    if [[ ${JSONPath[PASSTHROUGH]} -eq 1 ]]; then
      JSONPath[JSON]=1
      JSONPath_flatten | JSONPath_json
    elif [[ -z ${JSONPath[FILE]} ]]; then
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten | JSONPath_json | JSONPath_brief
    else
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten <"${JSONPath[FILE]}"
      JSONPath_json | JSONPath_brief
    fi

  fi
}

JSONPath_sanity_checks() {

  local binary

  # Reset some vars
  for binary in gawk grep sed; do
    if ! command -v "${binary}" >&/dev/null; then
      echo "ERROR: ${binary} binary not found in path. Aborting."
      exit 1
    fi
  done
}

JSONPath_reset() {

  # Reset some vars
  declare -a INDEXMATCH_QUERY
  PATHTOKENS=
  FILTER=
  OPERATOR=
  RHS=
  JSONPath[MULTIPASS]=0
}

JSONPath_cleanup() {

  [[ -e ${JSONPath[PASSFILE]} ]] && rm -f "${PASSFILE}"
  [[ -e ${JSONPath[STDINFILE2]} ]] && rm -f "${JSONPath[STDINFILE2]}"
  [[ -z ${JSONPath[FILE]} && -e ${JSONPath[STDINFILE]} ]] &&
    rm -f "${JSONPath[STDINFILE]}"
}

JSONPath_usage() {

  echo
  echo "Usage: JSONPath.sh [-b] [j] [-h] [-f FILE] [pattern]"
  echo
  echo "pattern - the JSONPath query. Defaults to '$.*' if not supplied."
  echo "-b      - Brief. Only show values."
  echo "-j      - JSON output."
  echo "-u      - Strip unnecessary leading path elements."
  echo "-i      - Case insensitive."
  echo "-p      - Pass-through to the JSON parser."
  echo "-w      - Match whole words only (for filter script expression)."
  echo "-f FILE - Read a FILE instead of stdin."
  echo "-h      - This help text."
  echo
}

JSONPath_parse_options() {

  set -- "$@"
  local ARGN=$#
  while [[ ${ARGN} -ne 0 ]]; do
    case $1 in
    -h)
      JSONPath_usage
      exit 0
      ;;
    -f)
      shift
      JSONPath[FILE]=$1
      ;;
    -i)
      JSONPath[NOCASE]=1
      ;;
    -j)
      JSONPath[JSON]=1
      ;;
    -n)
      JSONPath[NO_HEAD]=1
      ;;
    -b)
      JSONPath[BRIEF]=1
      ;;
    -u)
      JSONPath[FLATTEN]=1
      ;;
    -p)
      JSONPath[PASSTHROUGH]=1
      ;;
    -w)
      JSONPath[WHOLEWORD]=1
      ;;
    -s)
      JSONPath[NORMALIZE_SOLIDUS]=1
      ;;
    *)
      QUERY=$1
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done
  [[ -z ${QUERY} ]] && QUERY='$.*'
}

JSONPath_awk_egrep() {
  local pattern_string=$1

  gawk '{
    while ($0) {
      start=match($0, pattern);
      token=substr($0, start, RLENGTH);
      print token;
      $0=substr($0, start+RLENGTH);
    }
  }' pattern="${pattern_string}"
}

JSONPath_tokenize() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    ESCAPE='(\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
    ESCAPE='(\\\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\\\]'
  fi

  local STRING="\"${CHAR}*(${ESCAPE}${CHAR}*)*\""
  local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'
  local KEYWORD='null|false|true'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  ${GREP} "${STRING}|${NUMBER}|${KEYWORD}|${SPACE}|." | grep -Ev "^${SPACE}$"
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

JSONPath_tokenize_path() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
  fi

  local WILDCARD='\*'
  local WORD='[ A-Za-z0-9_-]*'
  local INDEX="\\[${WORD}(:${WORD}){0,2}\\]"
  local INDEXALL='\[\*\]'
  local STRING="[\\\"'][^[:cntrl:]\\\"']*[\\\"']"
  local SET="\\[(${WORD}|${STRING})(,(${WORD}|${STRING}))*\\]"
  local FILTER='\?\(@[^)]+'
  local DEEPSCAN='\.\.'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  readarray -t PATHTOKENS < <(echo "${QUERY}" |
    ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
    grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$")
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    echo "grep -Eo '${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|.'" >/dev/stderr
    echo -n "TOKENISED QUERY="
    echo "${QUERY}" |
      ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
      grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$" >/dev/stderr
  }
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

# JSONPath_create_filter creates the filter from the user's query.
# Filter works in a single pass through the data, unless a filter (script)
#  expression is used, in which case two passes are required (MULTIPASS=1).
JSONPath_create_filter() {

  local len=${#PATHTOKENS[*]}

  local -i i=0
  local a query="^\[" comma=
  while [[ i -lt len ]]; do
    case "${PATHTOKENS[i]}" in
    '"')
      :
      ;;
    '..')
      query+="${comma}[^]]*"
      comma=
      ;;
    '[*]')
      query+="${comma}[^,]*"
      comma=","
      ;;
    '*')
      query+="${comma}(\"[^\"]*\"|[0-9]+[^],]*)"
      comma=","
      ;;
    '?(@'*)
      a=${PATHTOKENS[i]#?(@.}
      elem="${a%%[<>=!]*}"
      rhs="${a##*[<>=!]}"
      a="${a#${elem}}"
      elem="${elem//./[\",.]+}" # Allows child node matching
      operator="${a%${rhs}}"
      [[ -z ${operator} ]] && {
        operator="=="
        rhs=
      }
      if [[ ${rhs} == *'"'* || ${rhs} == *"'"* ]]; then
        case ${operator} in
        '==' | '=')
          OPERATOR=
          if [[ ${elem} == '?(@' ]]; then
            # To allow search on @.property such as:
            #   $..book[?(@.title==".*Book 1.*")]
            query+="${comma}[0-9]+[],][[:space:]\"]*${rhs//\"/}"
          else
            # To allow search on @ (this node) such as:
            #   $..reviews[?(@==".*Fant.*")]
            query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs//\"/}"
          fi
          FILTER="${query}"
          ;;
        '>=' | '>')
          OPERATOR=">"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=' | '<')
          OPERATOR="<"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      else
        case ${operator} in
        '==' | '=')
          OPERATOR=
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs}"
          FILTER="${query}"
          ;;
        '>=')
          OPERATOR="-ge"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '>')
          OPERATOR="-gt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=')
          OPERATOR="-le"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<')
          OPERATOR="-lt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      fi
      JSONPath[MULTIPASS]=1
      ;;
    "["*)
      if [[ ${PATHTOKENS[i]} =~ , ]]; then
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          # converts only one comma: s/("[^"]+),([^"]+")/\1`\2/g;s/"//g
          #a=$(echo $a | sed 's/\([[:alpha:]]*\)/"\1"/g')
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        fi
        query+="${comma}(${a//,/|})"
      elif [[ ${PATHTOKENS[i]} =~ : ]]; then
        if ! [[ ${PATHTOKENS[i]} =~ [0-9][0-9] || ${PATHTOKENS[i]} =~ :] ]]; then
          if [[ ${PATHTOKENS[i]#*:} =~ : ]]; then
            INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
            query+="${comma}[^,]*"
          else
            # Index in the range of 0-9 can be handled by regex
            query+="${comma}$(echo "${PATHTOKENS[i]}" |
              gawk '/:/ { a=substr($0,0,index($0,":")-1);
                         b=substr($0,index($0,":")+1,index($0,"]")-index($0,":")-1);
                         if(b>0) { print a ":" b-1 "]" };
                         if(b<=0) { print a ":]" } }' |
              sed 's/\([0-9]\):\([0-9]\)/\1-\2/;
                       s/\[:\([0-9]\)/[0-\1/;
                       s/\([0-9]\):\]/\1-9999999]/')"
          fi
        else
          INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
          query+="${comma}[^,]*"
        fi
      else
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        else
          [[ ${i} -gt 0 ]] && comma=","
        fi
        query+="${comma}${a}"
      fi
      comma=","
      ;;
    *)
      PATHTOKENS[i]=${PATHTOKENS[i]//\'/\"}
      query+="${comma}\"${PATHTOKENS[i]//\"/}\""
      comma=","
      ;;
    esac
    i=$((i + 1))
  done

  [[ -z ${FILTER} ]] && FILTER="${query}[],]"
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
}

JSONPath_parse_array() {

  local index=0
  local ary=''
  read -r token
  case "${token}" in
  ']') ;;

  *)
    while :; do
      JSONPath_parse_value "$1" "${index}"
      index=$((index + 1))
      ary="${ary}""${value}"
      read -r token
      case "${token}" in
      ']') break ;;
      ',') ary="${ary}," ;;
      *) JSONPath_throw "EXPECTED , or ] GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_object() {

  local key
  local obj=''
  read -r token
  case "${token}" in
  '}') ;;

  *)
    while :; do
      case "${token}" in
      '"'*'"') key=${token} ;;
      *) JSONPath_throw "EXPECTED string GOT ${token:-EOF}" ;;
      esac
      read -r token
      case "${token}" in
      ':') ;;
      *) JSONPath_throw "EXPECTED : GOT ${token:-EOF}" ;;
      esac
      read -r token
      JSONPath_parse_value "$1" "${key}"
      obj="${obj}${key}:${value}"
      read -r token
      case "${token}" in
      '}') break ;;
      ',') obj="${obj}," ;;
      *) JSONPath_throw "EXPECTED , or } GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_value() {

  local jpath="${1:+$1,}$2" isleaf=0 isempty=0 print=0
  case "${token}" in
  '{') JSONPath_parse_object "${jpath}" ;;
  '[') JSONPath_parse_array "${jpath}" ;;
    # At this point, the only valid single-character tokens are digits.
  '' | [!0-9]) JSONPath_throw "EXPECTED value GOT ${token:-EOF}" ;;
  *)
    value=${token}
    # if asked, replace solidus ("\/") in json strings with normalized value: "/"
    # Testing:
    #[ "${JSONPath[NORMALIZE_SOLIDUS]}" -eq 1 ] && value=$(echo "${value}" | sed 's#\\/#/#g')
    [[ ${JSONPath[NORMALIZE_SOLIDUS]} -eq 1 ]] && value=$(${value//\\\///})
    isleaf=1
    [[ ${value} == '""' ]] && isempty=1
    ;;
  esac
  [[ -z ${JSONPath[INCLEMPTY]} ]] && [[ ${value} == '' ]] && return
  [[ ${JSONPath[NO_HEAD]} -eq 1 ]] && [[ -z ${jpath} ]] && return

  [[ ${isleaf} -eq 1 ]] && [[ ${isempty} -eq 0 ]] && print=1
  [[ ${print} -eq 1 ]] && printf "[%s]\t%s\n" "${jpath}" "${value}"
  :
}

JSONPath_flatten() {

  local path a prevpath pathlen

  if [[ ${JSONPath[FLATTEN]} -eq 1 ]]; then
    cat >"${JSONPath[STDINFILE2]}"

    highest=9999

    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      [[ -z ${prevpath} ]] && {
        prevpath=("${path[@]}")
        highest=$((${#path[*]} - 1))
        continue
      }

      pathlen=$((${#path[*]} - 1))

      for i in $(seq 0 "${pathlen}"); do
        [[ ${path[i]} != "${prevpath[i]}" ]] && {
          high=${i}
          break
        }
      done

      [[ ${high} -lt ${highest} ]] && highest=${high}

      prevpath=("${path[@]}")
    done <"${JSONPath[STDINFILE2]}"

    if [[ ${highest} -gt 0 ]]; then
      sed -r 's/\[(([0-9]+|"[^"]+")[],]){'$((highest))'}(.*)/[\3/' \
        "${JSONPath[STDINFILE2]}"
    else
      cat "${JSONPath[STDINFILE2]}"
    fi
  else
    cat
  fi
}

# JSONPath_indexmatcher is for double digit or greater indexes match each line
# individually Single digit indexes are handled more efficiently by regex
JSONPath_indexmatcher() {

  local a b

  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
      echo "INDEXMATCH_QUERY[${i}]=${INDEXMATCH_QUERY[i]}" >/dev/stderr
    done
  }

  matched=1

  step=
  if [[ ${#INDEXMATCH_QUERY[*]} -gt 0 ]]; then
    while read -r line; do
      for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
        [[ ${INDEXMATCH_QUERY[i]#*:} =~ : ]] && {
          step=${INDEXMATCH_QUERY[i]##*:}
          step=${step%]}
          INDEXMATCH_QUERY[i]="${INDEXMATCH_QUERY[i]%:*}]"
        }
        q=${INDEXMATCH_QUERY[i]:1:-1} # <- strip '[' and ']'
        a=${q%:*}                     # <- number before ':'
        b=${q#*:}                     # <- number after ':'
        [[ -z ${b} ]] && b=99999999999
        readarray -t num < <((grep -Eo '[0-9]+[],]' | tr -d ,]) <<<"${line}")
        if [[ ${num[i]} -ge ${a} && ${num[i]} -lt ${b} && matched -eq 1 ]]; then
          matched=1
          [[ ${i} -eq $((${#INDEXMATCH_QUERY[*]} - 1)) ]] && {
            if [[ ${step} -gt 1 ]]; then
              [[ $(((num[i] - a) % step)) -eq 0 ]] && {
                [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
                echo "${line}"
              }
            else
              [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
              echo "${line}"
            fi
          }
        else
          matched=0
          continue
        fi
      done
      matched=1
    done
  else
    cat -
  fi
}

JSONPath_brief() {
  # Only show the value

  if [[ ${JSONPath[BRIEF]} -eq 1 ]]; then
    sed 's/^[^\t]*\t//;s/^"//;s/"$//;'
  else
    cat
  fi
}

JSONPath_json() {
  # Turn output into JSON

  local a tab="$'\t'"
  local UP=1 DOWN=2 SAME=3
  local prevpathlen=-1 prevpath=() path a
  declare -a closers

  if [[ ${JSONPath[JSON]} -eq 0 ]]; then
    cat -
  else
    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      value=${line#*${tab}}

      # Not including the object itself (last item)
      pathlen=$((${#path[*]} - 1))

      # General direction

      direction=${SAME}
      [[ ${pathlen} -gt ${prevpathlen} ]] && direction=${DOWN}
      [[ ${pathlen} -lt ${prevpathlen} ]] && direction=${UP}

      # Handle jumps UP the tree (close previous paths)

      [[ ${prevpathlen} != -1 ]] && {
        for i in $(seq 0 $((pathlen - 1))); do
          [[ ${prevpath[i]} == "${path[i]}" ]] && continue
          [[ ${path[i]} != '"'* ]] && {
            # Testing double quotes:
            a="(${!arrays[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                arrays[k]=
              done
            }
            a="(${!comma[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                comma[k]=
              done
            }
            for j in $(seq $((prevpathlen)) -1 $((i + 2))); do
              arrays[j]=
              [[ -n ${closers[j]} ]] && {
                indent=$((j * 4))
                printf "\n%${indent}s${closers[j]}" ""
                unset "closers[j]"
                comma[j]=
              }
            done
            direction=${DOWN}
            break
          }
          direction=${DOWN}
          for j in $(seq $((prevpathlen)) -1 $((i + 1))); do
            arrays[j]=
            [[ -n ${closers[j]} ]] && {
              indent=$((j * 4))
              printf "\n%${indent}s${closers[j]}" ""
              unset "closers[j]"
              comma[j]=
            }
          done
          a="(${!arrays[*]})"
          [[ -n ${a} ]] && {
            for k in $(seq "${i}" "${a[-1]}"); do
              arrays[k]=
            done
          }
          break
        done
      }

      [[ ${direction} -eq ${UP} ]] && {
        [[ ${prevpathlen} != -1 ]] && comma[prevpathlen]=
        for i in $(seq $((prevpathlen + 1)) -1 $((pathlen + 1))); do
          arrays[i]=
          [[ -n ${closers[i]} ]] && {
            indent=$((i * 4))
            printf "\n%${indent}s${closers[i]}" ""
            unset "closers[i]"
            comma[i]=
          }
        done
        a="(${!arrays[*]})"
        [[ -n ${a} ]] && {
          for k in $(seq "${i}" "${a[-1]}"); do
            arrays[k]=
          done
        }
      }

      # Opening braces (the path leading up to the key)

      broken=
      for i in $(seq 0 $((pathlen - 1))); do
        [[ -z ${broken} && ${prevpath[i]} == "${path[i]}" ]] && continue
        [[ -z ${broken} ]] && {
          broken=${i}
          [[ ${prevpathlen} -ne -1 ]] && broken=$((i + 1))
        }
        if [[ ${path[i]} == '"'* ]]; then
          # Object
          [[ ${i} -ge ${broken} ]] && {
            indent=$((i * 4))
            printf "${comma[i]}%${indent}s{\n" ""
            closers[i]='}'
            comma[i]=
          }
          indent=$(((i + 1) * 4))
          printf "${comma[i]}%${indent}s${path[i]}:\n" ""
          comma[i]=",\n"
        else
          # Array
          if [[ ${arrays[i]} != 1 ]]; then
            indent=$((i * 4))
            printf "%${indent}s" ""
            echo "["
            closers[i]=']'
            arrays[i]=1
            comma[i]=
          else
            indent=$(((i + 1) * 4))
            printf "\n%${indent}s${closers[i - 1]}" ""
            direction=${DOWN}
            comma[i + 1]=",\n"
          fi
        fi
      done

      # keys & values

      if [[ ${path[-1]} == '"'* ]]; then
        # Object
        [[ ${direction} -eq ${DOWN} ]] && {
          indent=$((pathlen * 4))
          printf "${comma[pathlen]}%${indent}s{\n" ""
          closers[pathlen]='}'
          comma[pathlen]=
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${path[-1]}:${value}"
        comma[pathlen]=",\n"
      else
        # Array
        [[ ${arrays[i]} != 1 ]] && {
          indent=$(((pathlen - 0) * 4))
          printf "%${indent}s[\n" ""
          closers[pathlen]=']'
          comma[pathlen]=
          arrays[i]=1
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${value}"
        comma[pathlen]=",\n"
      fi

      prevpath=("${path[@]}")
      prevpathlen=${pathlen}
    done

    # closing braces

    for i in $(seq $((pathlen)) -1 0); do
      indent=$((i * 4))
      printf "\n%${indent}s${closers[i]}" ""
    done
    echo
  fi
}

JSONPath_filter() {
  # Apply the query filter

  local a tab=$'\t' v

  [[ ${JSONPath[NOCASE]} -eq 1 ]] && opts+="i"
  [[ ${JSONPath[WHOLEWORD]} -eq 1 ]] && opts+="w"
  if [[ -z ${OPERATOR} ]]; then
    [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && FILTER="${FILTER}[\"]?$"
    grep "-E${opts}" "${FILTER}"
    [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
  else
    grep "-E${opts}" "${FILTER}" |
      while read -r line; do
        v=${line#*${tab}}
        case ${OPERATOR} in
        '-ge')
          if gawk '{exit !($1>=$2)}' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-gt')
          if gawk '{exit !($1>$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-le')
          if gawk '{exit !($1<=$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-lt')
          if gawk '{exit !($1<$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '>')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} > ${RHS,,} ]] && echo "${line}"
          ;;
        '<')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} < ${RHS,,} ]] && echo "${line}"
          ;;
        *) return 1 ;;
        esac
      done
  fi
}

JSONPath_parse() {
  # Parses json

  read -r token
  JSONPath_parse_value
  read -r token
  case "${token}" in
  '') ;;
  *)
    JSONPath_throw "EXPECTED EOF GOT ${token}"
    exit 1
    ;;
  esac
}

JSONPath_throw() {
  echo "$*" >&2
  exit 1
}

JSONPath_new || exit 1

# vi: expandtab sw=2 ts=2
# shellcheck shell=bash disable=SC2148
# MA - execution starts here

# MA is an associative array that holds data specific to this file
declare -A _MA

# Defined in GL (globals.sh)
declare OK ERROR STOP STDERR TRUE __mokostype __mokarch

# Getters/Setters -------------------------------------------------------------

# MA_program_args getter outputs the program arguments sent by the user.
MA_program_args() {
  printf '%s' "${_MA[program_args]}"
}

# MA_arg_1 getter outputs the first argument sent by the user.
# Used by _CU_podman_checks so it doesn't check for a podman machine
# if we're running 'machine' commands
# FIXME: The command might not be the first argument. It could be '-p'
MA_arg_1() {
  printf '%s' "${_MA[arg_1]}"
}

# MA_program_name getter outputs the name of the program.
MA_program_name() {
  printf '%s' "${_MA[arg_0]##*/}"
}

# MA_ostype getter outputs the OS type.
MA_ostype() {
  printf '%s' "${_MA[ostype]}"
}

# MA_ostype getter outputs the machine architecture.
MA_arch() {
  printf '%s' "${_MA[arch]}"
}

# Public Functions ------------------------------------------------------------

# main is the start point for this application.
# Args: arg1-N - the command line arguments entered by the user.
MA_main() {
  local retval="${OK}"

  CU_podman_or_docker

  trap MA_cleanup EXIT
  MA_sanity_checks || return
  PA_run "$@" || retval=$?

  exit "${retval}"
}

# MA_version outputs the version information the exits.
MA_version() {
  printf 'Version: %s\n' "${MOKVERSION}"
  exit "${OK}"
}

# MA_process_global_options is called by the parser when a global option is
# encountered for processing.
# Args: arg1 - the global option that was found.
MA_process_global_options() {
  case "$1" in
  -h | --help)
    PA_usage
    return "${STOP}"
    ;;
  -p | --plain)
    UT_set_plain "${TRUE}"
    ;;
  *)
    printf 'INTERNAL ERROR: Invalid global option, "%s".' "$1"
    return "${ERROR}"
    ;;
  esac
}

# MA_cleanup is called from an EXIT trap only, when the program exits, and
# calls every other function matching the pattern '^.._cleanup'.
# Args: No args expected.
MA_cleanup() {
  local retval="${OK}" funcs func
  funcs=$(declare -F | awk '{print $NF;}' | grep '^.._cleanup')
  for func in ${funcs}; do
    [[ ${func} == "${FUNCNAME[0]}" ]] && continue
    eval "${func}" || retval=$?
  done
  return "${retval}"
}

# MA_sanity_checks is expected to run some quick and simple checks to
# see if key components are available before MA_main is called.
# Args: No args expected.
MA_sanity_checks() {

  local binary binaries

  if [[ $(CU_podmantype) == "native" ]]; then
    binaries="gawk tac column tput grep sed ip cut"
  else
    binaries="gawk tac column tput grep sed cut"
  fi

  for binary in ${binaries}; do
    if ! command -v "${binary}" >&/dev/null; then
      printf 'ERROR: "%s" binary not found in path. Aborting.' "${binary}" \
        >"${STDERR}"
      return "${ERROR}"
    fi
  done

  # Disable terminal escapes (colours) if stdout is not a terminal
  [ -t 1 ] || UT_disable_colours
}

# MA_usage outputs help text for all components then quits with no error.  This
# is registered as a callback in the Parser, see _MA_new
# Args: None expected.
MA_usage() {

  cat <<'EnD'
Usage: mok [-h] <command> [subcommand] [ARGS...]
 
Global options:
  --help
  -h     - This help text
  --plain
  -p     - Plain output. No colours or animations.
 
Where command can be one of:
  create  - Add item(s) to the system.
  delete  - Delete item(s) from the system.
  build   - Build item(s) used by the system.
  get     - Get details about items in the system.
  exec    - 'Log in' to the container.
  machine - Manage a podman machine (MacOS only).
  version - Display version information.

For help on a specific command, run:
  mok <command> --help
EnD
}

# MA_new sets the initial values for the _MA associative array
_MA_new() {
  _MA[program_args]="$*"
  _MA[arg_0]="$0"
  _MA[arg_1]="$1"
  _MA[ostype]="${__mokostype}" # linux or macos
  _MA[arch]="${__mokarch}" # x86_64 or arm64

  # Program the parser's state machine
  PA_add_state "COMMAND" "version" "END" "MA_version"

  # Set up the parser's option callbacks
  PA_add_option_callback "" "MA_process_global_options"

  # Set up the parser's usage callbacks
  PA_add_usage_callback "" "MA_usage"
}

# Initialise _MA
_MA_new "$@" || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
if [ "$0" = "${BASH_SOURCE[0]}" ] || [ -z "${BASH_SOURCE[0]}" ]; then
  MA_main "$@"
fi
