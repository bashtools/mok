#!/usr/bin/env bash
# shellcheck shell=bash disable=SC2148
# MA - execution starts here

# MA is an associative array that holds data specific to this file
declare -A _MA

# Defined in GL (globals.sh)
declare OK ERROR STOP STDERR TRUE

# Getters/Setters -------------------------------------------------------------

# MA_program_args getter outputs the program arguments sent by the user.
MA_program_args() {
  printf '%s' "${_MA[program_args]}"
}

# Public Functions ------------------------------------------------------------

# main is the start point for this application.
# Args: arg1-N - the command line arguments entered by the user.
MA_main() {

  trap MA_cleanup EXIT
  MA_sanity_checks || return
  MA_register_parser_global_options || return

  local retval="${OK}"
  PA_run "$@" || retval=$?
  if [[ ${retval} -eq ${ERROR} ]]; then
    return "${ERROR}"
  elif [[ ${retval} -eq ${STOP} ]]; then
    return "${OK}"
  fi

  local cmd subcmd
  cmd=$(PA_command) || err || return
  subcmd=$(PA_subcommand) || err || return
  case "${cmd}${subcmd}" in
  create | createcluster) CC_run ;;
  delete | deletecluster) DC_run ;;
  build | buildimage) BI_run ;;
  get | getcluster | getclusters) GC_run ;;
  exec) EX_run ;;
  *)
    PA_usage
    printf '\nERROR: No COMMAND specified.\n'
    ;;
  esac
}

# MA_register_parser_global_options adds the options callback and usage
# callback to the Parser.
MA_register_parser_global_options() {
  PA_add_state "COMMAND" "version" "END" "MA_version"
  PA_add_option_callback "" "MA_process_global_options"
  PA_add_usage_callback "" "MA_usage"
}

# MA_version outputs the version information the exits.
MA_version() {
  printf 'Version: %s\n' "${MOKVERSION}"
  exit "${OK}"
}

# MA_process_global_options is called by the parser when a global option is
# encountered for processing.
# Args: arg1 - the global option that was found.
MA_process_global_options() {
  case "$1" in
  -h | --help)
    PA_usage
    return "${STOP}"
    ;;
  -p | --plain)
    UT_set_plain "${TRUE}"
    ;;
  *)
    printf 'INTERNAL ERROR: Invalid global option, "%s".' "$1"
    return "${ERROR}"
    ;;
  esac
}

# MA_cleanup is called from an EXIT trap only, when the program exits, and
# calls every other function matching the pattern '^.._cleanup'.
# Args: No args expected.
MA_cleanup() {
  local retval="${OK}" funcs func
  funcs=$(declare -F | awk '{print $NF;}' | grep '^.._cleanup')
  for func in ${funcs}; do
    [[ ${func} == "${FUNCNAME[0]}" ]] && continue
    eval "${func}" || retval=$?
  done
  return "${retval}"
}

# MA_sanity_checks is expected to run some quick and simple checks to
# see if key components are available before MA_main is called.
# Args: No args expected.
MA_sanity_checks() {

  local binary

  for binary in tac column tput grep sed; do
    if ! command -v "${binary}" >&/dev/null; then
      printf 'ERROR: "%s" binary not found in path. Aborting.' "${binary}" \
        >"${STDERR}"
      return "${ERROR}"
    fi
  done

  # Disable terminal escapes (colours) if stdout is not a terminal
  [ -t 1 ] || UT_disable_colours
}

# MA_usage outputs help text for all components then quits with no error.  This
# is registered as a callback in the Parser in
# MA_register_parser_global_options.
# Args: None expected.
MA_usage() {

  cat <<'EnD'
Usage: mok [-h] <command> [subcommand] [ARGS...]
 
Global options:
  --help
  -h     - This help text
  --plain
  -p     - Plain output. No colours or animations.
 
Where command can be one of:
  create  - Add item(s) to the system.
  delete  - Delete item(s) from the system.
  build   - Build item(s) used by the system.
  get     - Get details about items in the system.
  exec    - 'Log in' to the container.
  version - Display version information.

For help on a specific command, run:
  mok <command> --help
EnD
}

# MA_new sets the initial values for the _MA associative array
_MA_new() {
  _MA[program_args]="$*"
}

# Initialise _MA
_MA_new "$@" || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# PA - PArser

# _PA holds data specific to parsing the command line arguments.
declare -A _PA

# Declare externally defined variables ----------------------------------------

# Defined in ER (globals.sh)
declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# PA_command getter outputs the _PA[command] array member. This contains the
# command the user requested.
PA_command() {
  printf '%s' "${_PA[command]}"
}

# PA_subcommand getter outputs the _PA[subcommand] array member. This contains
# the subcommand the user requested.
PA_subcommand() {
  printf '%s' "${_PA[subcommand]}"
}

# PA_shift outputs the _PA[shift] array member, returned by the caller
# when an extra shift is required whilst consuming option values.
#
# Example code:
# ```
#XX_process_options_callback() {
#
#  case "$1" in
#  -h | --help)
#    CC_usage
#    return "${STOP}"
#    ;;
#    ... omitted ...
#  --k8sver)
#    _CC[k8sver]="$2"
#    return "$(PA_shift)"
#    ;;
#  --with-lb)
#    ... omitted ..
# ```
PA_shift() {
  printf '%s' "${_PA[shift]}"
}

# PA_set_state setter sets the initial state of the parser, which should be one
# of COMMAND, SUBCOMMAND, or ARG1.
# Args: arg1 - the initial state to set.
PA_set_state() {
  _PA[state]="$1"
}

# Public Functions ------------------------------------------------------------

# PA_add_option_callback adds a callback to the list of callbacks used for
# processing options.
# Args: arg1 - Null string (for global options), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_option_callback() {
  _PA[optscallbacks]+="$1,$2 "
}

# PA_add_usage_callback adds a callback to the list of callbacks used for
# output of help text.
# Args: arg1 - Null string (for global help), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_usage_callback() {
  _PA[usagecallbacks]+="$1,$2 "
}

# PA_add_state adds a callback to the list of callbacks used for
# programming the state machine.
# Args: arg1 - Current state to match.
#       arg2 - The value of the state to match.
#       arg3 - The new state if arg1 and arg2 match.
#       arg4 - The function to call, optional.
PA_add_state() {
  _PA[statecallbacks]+="$1,$2,$3,$4 "
}

# PA_run implements an interleaved state machine to process the
# user request. It allows for strict checking of arguments and args. All
# command line arguments are processed in order from left to right.
#
# Each COMMAND can have a different set of requirements which are controlled
# by setting the next state at each transition.
#
# --global-options COMMAND --command-options SUBCOMMAND --subcommand-options \
#  ARG1 --subcommand-options ARG2 --subcommand-options ...
#
# --global-options are those before COMMAND.
# --command-options can be after the COMMAND but before SUBCOMMAND.
# --subcommand-options can be anywhere after the SUBCOMMAND.
#
# Args: arg1-N - The arguments given to mok by the user on the command line
PA_run() {

  set -- "$@"
  local ARGN=$# ARGNUM=0 retval=0
  while [ "${ARGN}" -ne 0 ]; do
    case "$1" in
    --* | -*)
      _PA_process_option "$1" "$2" || {
        retval=$?
        if [[ ${retval} == "${_PA[shift]}" ]]; then
          ARGN=$((ARGN - 1))
          shift
        else
          return "${retval}"
        fi
      }
      ;;
    *)
      case "${_PA[state]}" in
      COMMAND)
        _PA_check_token "${1}" "COMMAND" "command"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid COMMAND, "%s".\n\n' "$1" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      SUBCOMMAND)
        _PA_check_token "$1" "SUBCOMMAND" "subcommand"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid SUBCOMMAND for %s, "%s".\n\n' "${_PA[command]}" "${1}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      ARG*)
        ((ARGNUM++))
        _PA_check_token "${1}" "ARG${ARGNUM}"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid ARG1 for %s %s, "%s".\n\n' "${_PA[command]}" \
            "${_PA[subcommand]}" "${1}" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      END)
        PA_usage
        printf 'ERROR No more args expected, "%s" is unexpected for "%s %s"\n' \
          "${1}" "${_PA[command]}" "${_PA[subcommand]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      *)
        printf 'Internal ERROR. Invalid state "%s"\n' "${_PA[state]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      esac
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done

  return "${OK}"
}

# PA_usage outputs help text for a single component if help was asked for when
# a command was specified, or for all components otherwise.
# Args: None expected.
PA_usage() {

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[usagecallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func}"
      return
    }
  done

  eval "${_PA[usage]}"
}

# Private Functions -----------------------------------------------------------

# PA_new sets the initial values for the PArser's associative array.
# Args: None expected.
_PA_new() {
  _PA[command]=
  _PA[subcommand]=
  _PA[state]="COMMAND"
  _PA[optscallbacks]=
  _PA[usagecallbacks]=
  # The return value if the caller asked for an extra shift:
  _PA[shift]=126
}

# _PA_check_token checks for a valid token in arg2 state. The logic is
# most easily understood by reading the full original version at:
# https://github.com/mclarkson/my-own-kind/blob/master/docs/package.md#scripted-cluster-creation-and-deletion
# This function is a reduction of all the check_xxx_token functions.
# Args: arg1 - the token to check.
#       arg2 - the current state.
#       arg3 - the state value to set, optional. This should only be sent
#              for command and subcommand states.
_PA_check_token() {

  local item

  if [[ -n ${_PA[subcommand]} ]]; then
    cmdsubcommand="${_PA[command]}${_PA[subcommand]}"
  elif [[ -n ${_PA[command]} && ${_PA[state]} != "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}$1"
  elif [[ -n ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}"
  elif [[ -z ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand=
  else
    cmdsubcommand="$1"
  fi

  for item in ${_PA[statecallbacks]}; do
    IFS=, read -r state component newstate func <<<"${item}"
    [[ ${state} == "$2" ]] && {
      [[ ${component} == "${cmdsubcommand}" ]] && {
        [[ -n $3 ]] && _PA["$3"]="$1"
        _PA[state]="${newstate}"
        [[ -n ${func} ]] && {
          eval "${func} $1" || return
        }
        return "${OK}"
      }
    }
  done
}

# _PA_process_option checks that the user-provided option is valid for the
# command-subcommand or global states.
# Args: arg1 - The option to check.
#       arg2 - TODO The value of the option if present, optional.
_PA_process_option() {

  local item curcmdsubcmd

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[optscallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func} \"$1\" \"$2\""
      return $?
    }
  done

  return "${ERROR}"
}

# Initialise _PA
_PA_new

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GL - Globals

# Private Functions -----------------------------------------------------------

# GL_new sets the only global variables that should be in use anywhere.  The
# only other globals are the associative arrays. All the globals are constant
# (readonly) variables. Declare these globals, where needed, in other files
# so that shellcheck passes.
# Args: None expected.
_GL_new() {

  declare -rg MOKVERSION="0.8.16"
  declare -rg K8SVERSION="1.31.1"
  declare -rg GO_VERSION="1.23.2"

  # Returns, exit codes
  declare -rg OK=0
  declare -rg SUCCESS=0
  declare -rg ERROR=1
  declare -rg FAILURE=1

  # For setting flags
  declare -rg TRUE=1
  declare -rg FALSE=0

  # To signal main() to exit with SUCCESS in the PArser
  declare -rg STOP=2

  declare -rg STDOUT="/dev/stdout"
  declare -rg STDERR="/dev/stderr"

  # The following just keep shellcheck happy
  local dummy dumb
  dummy="${OK}"
  dummy="${ERROR}"
  dummy="${STOP}"
  dummy="${STDOUT}"
  dummy="${STDERR}"
  dummy="${TRUE}"
  dummy="${FALSE}"
  dummy="${SUCCESS}"
  dummy="${FAILURE}"
  dummy="${MOKVERSION}"
  dummy="${GO_VERSION}"
  dummy="${K8SVERSION}"
  dumb="${dummy}${dumb}"
}

# Initialise GL
_GL_new || exit 1

# vim helpers -----------------------------------------------------------------

# The following lines allow the use of '[C-i' and '[I' (do ':help [I') in vim.
#include buildimage.sh
#include containerutils.sh
#include createcluster.sh
#include deletecluster.sh
#include embed-dockerfile.sh
#include error.sh
#include exec.sh
#include getcluster.sh
#include main.sh
#include lib/parser.sh
#include util.sh
#include versions.sh

# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# ER - Error handling

# ER is an associative array that holds data specific to error handling.
declare -A ER

# Declare externally defined associative arrays -------------------------------

# Defined in GL (globals.sh)
declare ERROR TRUE STDERR

# Public Functions ------------------------------------------------------------

# ER_err outputs a stacktrace and returns ERROR status.
# Args: None expected.
ER_err() {

  # In case of error print the function call stack
  # No args expected

  [[ ${ER[errcalled]} == "${TRUE}" ]] && return "${ERROR}"
  ER[errcalled]="${TRUE}"
  local frame=0
  printf '\n' >"${STDERR}"
  while caller "${frame}"; do
    ((frame++))
  done | tac >"${STDERR}"
  printf '\n' >"${STDERR}"
  return "${ERROR}"
}

# err is a synonym for ER_err to aid with code readability.
err() {
  ER_err
  return
}

# Private Functions -----------------------------------------------------------

# ER_new sets the initial values for the ER associative array.
# Args: None expected.
_ER_new() {
  ER[errcalled]=
}

# Initialise ER
_ER_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# UT - Utilities

# _UT is an associative array that holds data specific to general utilities.
declare -A _UT

# Declare externally defined global variables ---------------------------------

declare OK STDERR FALSE TRUE

# Getters/Setters -------------------------------------------------------------

# UT_runlogfile getter outputs the value of _UT[runlogfile], which contains the
# name of the file written to when running UT_run_with_progress.
UT_runlogfile() {
  printf '%s' "${_UT[runlogfile]}"
}

# UT_tailf getter indicates whether a log will be shown in real-time during the
# 'run', TRUE, or not, FALSE.
# Args
UT_tailf() {
  printf '%s' "${_UT[tailf]}"
}

# UT_tailf setter indicates whether a log should be shown during the 'run',
# TRUE, or not, FALSE.
# Args: arg1 - Whether to tail, TRUE or FALSE.
UT_set_tailf() {
  _UT[tailf]="$1"
}

# UT_set_plain setter sets plain output, with no colour, animations, or UTF
# high byte characters.
# Args: arg1 - Whether to show plain output, TRUE or FALSE.
UT_set_plain() {
  _UT[plain]="$1"
  UT_disable_colours
}

# Public Functions ------------------------------------------------------------

# UT_disable_colours resets variables used for colourised output so that they
# contain no colour terminal escapes. Useful if stdin is not a terminal.
UT_disable_colours() {
  _UT[yellow]=
  _UT[green]=
  _UT[red]=
  _UT[normal]=
  _UT[probablysuccess]="PROBABLY SUCCESS (!)"
  _UT[success]="SUCCESS"
  _UT[failure]="FAIL"
}

# UT_run_with_progress displays a progress spinner, item text, and a tick or
# cross based on the exit code.
# Args: arg1   - the text to display.
#       arg2-N - remaining args are the program to run and its arguments.
UT_run_with_progress() {

  local displaytext=$1 retval int spinner=()

  _UT[runlogfile]=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }
  shift

  if [[ ${_UT[tailf]} == "${FALSE}" && ${_UT[plain]} == "${TRUE}" ]]; then

    # Output with no colours or spinny

    printf '%s' "${displaytext}"

    eval "$*" &>"${_UT[runlogfile]}"
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 0 ]]; then
      printf ' .. %s\n' "${_UT[success]}"
    else
      printf ' .. %s\n' "${_UT[failure]}"
    fi

  elif [[ ${_UT[tailf]} == "${FALSE}" ]]; then

    # Output with colours and spinny

    while read -r char; do
      spinner+=("${char}")
    done <<<"$(grep -o . <<<"${_UT[spinnerchars]}")"

    (
      eval "$*" &>"${_UT[runlogfile]}"
    ) &

    # Turn the cursor off
    tput civis

    # Start the spin animation
    printf ' %s' "${displaytext}"
    (while true; do
      for int in {0..3}; do
        printf '\r  %s ' "${spinner[int]}"
        sleep .1
      done
    done) &
    _UT[spinnerpid]=$!
    disown

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Kill the spinner
    kill "${_UT[spinnerpid]}" 2>/dev/null
    _UT[spinnerpid]=

    sleep .5

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\r  %s\n' "${_UT[probablysuccess]}"
    elif [[ ${retval} -eq 0 ]]; then
      printf '\r  %s\n' "${_UT[success]}"
    else
      printf '\r  %s\n' "${_UT[failure]}"
    fi

    # Restore the cursor
    tput cnorm
    sleep .5

  else

    # Tailf output

    printf 'COMMAND: %s\n\n' "$*"

    (
      eval "$*" &>/dev/stdout
    ) &
    sleep 1

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\n\nSTATUS: OK - (Probably)\n\n'
    elif [[ ${retval} -eq 0 ]]; then
      printf '\n\nSTATUS: OK\n\n'
    else
      printf '\n\nSTATUS: FAIL\n\n'
    fi
  fi

  return "${retval}"
}

# UT_cleanup removes any artifacts that were created during execution.
# This is called by 'MA_cleanup' trap only.
UT_cleanup() {

  # Called when the script exits.

  local int

  # Kill the spinny, and anything else, if they're running
  if [[ ${_UT[tailf]} == "${FALSE}" ]]; then
    [[ -n ${_UT[spinnerpid]} ]] && {
      printf '%s\r  ✕%s\n' "${_UT[red]}" "${_UT[normal]}"
      kill "${_UT[spinnerpid]}"
    }
    # If progress spinner crashed make sure the cursor is shown
    [ -t 1 ] && tput cnorm
  else
    kill "${_UT[spinnerpid]}" &>/dev/null
  fi

  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _UT_new sets the initial values for the _UT associative array.
# Args: None expected.
_UT_new() {
  _UT[tailf]="${FALSE}"
  _UT[yellow]=$(tput setaf 3)
  _UT[green]=$(tput setaf 2)
  _UT[red]=$(tput setaf 1)
  _UT[normal]=$(tput sgr0)
  _UT[probablysuccess]="${_UT[yellow]}✓${_UT[normal]}"
  _UT[success]="${_UT[green]}✓${_UT[normal]}"
  _UT[failure]="${_UT[red]}✕${_UT[normal]}"
  _UT[runlogfile]=
  _UT[spinnerchars]="|/-\\"
  _UT[spinnerpid]=
}

# Initialise _UT
_UT_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GC - Get Cluster

# _GC is an associative array that holds data specific to the get cluster command.
declare -A _GC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# GC_showheader getter outputs the value of the showheader array member.
GC_showheader() {
  printf '%s' "${_GC[showheader]}"
}

# GC_set_showheader setter sets the value of the showheader array member.
# If $TRUE the header will be shown, or $FALSE, then it won't be shown.
GC_set_showheader() {
  _GC[showheader]="$1"
}

# GC_set_clustername setter sets the cluster name to show information about.
GC_set_clustername() {
  _GC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# GC_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted. It is called by
# MA_cleanup.
GC_cleanup() {
  :
}

# GC_process_options checks if arg1 is in a list of valid get cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
GC_process_options() {

  case "$1" in
  -h | --help)
    GC_usage
    return "${STOP}"
    ;;
  *)
    GC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# GC_usage outputs help text for the create cluster component.
# It is called by PA_usage().
# Args: None expected.
GC_usage() {

  cat <<'EnD'
GET subcommands are:
 
  cluster(s) - list all mok managed clusters.
 
get cluster(s) options:
 
 Format:
  get cluster(s) [NAME]
  NAME        - (optional) The name of the cluster to get
                details about.

EnD
}

# GC_run gets information about cluster(s).
# This function is called in main.sh.
# Args: None expected.
GC_run() {

  _GC_sanity_checks || return

  local ids id info output labelkey
  local containerhostname containerip

  declare -a nodes

  ids=$(CU_get_cluster_container_ids "${_GC[clustername]}") || return

  if [[ -z ${ids} ]]; then
    printf 'No clusters found\n'
    return "${OK}"
  fi

  readarray -t nodes <<<"${ids}"

  # Use 'docker inspect' to get the value of the label $LABELKEY

  output=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  # Output the header
  [[ ${_GC[showheader]} -eq ${TRUE} ]] && {
    printf 'MOK_Cluster Docker_ID Container_Name IP_Address\n' >"${output}"
  }

  labelkey=$(CU_labelkey) || err || return

  for id in "${nodes[@]}"; do

    info=$(CU_get_container_info "${id}") || return

    clustname=$(JSONPath ".[0].Config.Labels.${labelkey}" -b <<<"${info}") ||
      err || return

    containerhostname=$(JSONPath '.[0].Config.Hostname' -b <<<"${info}") ||
      err || return

    containerip=$(JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}") ||
      err || return

    printf '%s %s %s %s\n' "${clustname}" "${id}" "${containerhostname}" "${containerip}"

  done | sort -k 3 >>"${output}"

  column -t "${output}" || err
}

# Private Functions -----------------------------------------------------------

# _GC_new sets the initial values for the _GC associative array.
# Args: None expected.
_GC_new() {
  _GC[showheader]="${TRUE}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "get" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "getcluster" "ARG1" ""
  PA_add_state "SUBCOMMAND" "getclusters" "ARG1" ""
  PA_add_state "ARG1" "getcluster" "END" "GC_set_clustername"
  PA_add_state "ARG1" "getclusters" "END" "GC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "get" "GC_process_options" || return
  PA_add_option_callback "getcluster" "GC_process_options" || return
  PA_add_option_callback "getclusters" "GC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "get" "GC_usage" || return
  PA_add_usage_callback "getcluster" "GC_usage" || return
  PA_add_usage_callback "getclusters" "GC_usage" || return
}

# GC_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_GC_sanity_checks() {

  # Only show the usage if we are in 'get' mode and have not specified a
  # subcommand. This allows internal code to call GC_run()
  if [[ $(PA_command) == "get" && -z $(PA_subcommand) ]]; then
    GC_usage
    exit "${OK}"
  fi
}

# Initialise _GC
_GC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# EX - EXec

# EX is an associative array that holds data specific to the exec cluster command.
declare -A _EX

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# EX_set_containername setter sets the containername to be used to 'log in' to.
EX_set_containername() {
  _EX[containername]="$1"
}

# Public Functions ------------------------------------------------------------

# EX_process_options checks if arg1 is in a list of valid exec options. This
# function is called by the parser, via a callback in _EX_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
EX_process_options() {

  case "$1" in
  -h | --help)
    EX_usage
    return "${STOP}"
    ;;
  *)
    EX_usage
    printf 'ERROR: "%s" is not a valid "exec" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# EX_usage outputs help text for the create exec component.  It is called in
# this file and by PA_usage(), via a callback in _EX_new.
# Args: None expected.
EX_usage() {

  cat <<'EnD'
'Log in' to a container. EXEC has no subcommands.
 
exec options:
 
 Format:
  exec [NAME]
  NAME        - (optional) The name of the container to 'log in' to.
                If NAME is not given then the user will be offered
                a choice of containers to log in to. If there is only
                one cluster and one node then it will 'log in' to the
                only available container.

EnD
}

# Execs 'bash' in the container referenced by _EX[containername]. If just
# 'mok exec' is called without options then the user is offered a selection
# of existing clusters to exec into.
# Args: None expected.
# ---------------------------------------------------------------------------
EX_run() {

  _EX_sanity_checks || return

  local names int ans lines containernames gcoutput

  GC_set_showheader "${TRUE}" || err || return
  gcoutput=$(GC_run) || return
  names=$(printf '%s' "${gcoutput}" | awk '{ print $3; }')
  readarray -t containernames <<<"${names}"

  if [[ -n ${_EX[containername]} ]]; then

    # The caller gave a specific name for exec.
    # Check if the container name exists

    if grep -qs "^${_EX[containername]}$" <<<"${names}"; then
      _EX_exec "${_EX[containername]}" || return
      return "${OK}"
    else
      printf 'ERROR: Cannot exec into non-existent container: "%s".\n' \
        "${_EX[containername]}"
      return "${ERROR}"
    fi

  elif [[ ${#containernames[*]} == 2 ]]; then

    # If there's only one container just log into it without asking
    _EX_exec "${containernames[1]}"

  elif [[ ${#containernames[*]} == 1 ]]; then

    printf 'No containers found.\n'
    return "${OK}"

  else

    # The caller supplied no container name.
    # Present some choices

    printf 'Choose the container to log in to:\n\n'

    readarray -t lines <<<"${gcoutput}" || return

    # Print the header then print the items in the loop
    printf '   %s\n' "${lines[0]}"
    for int in $(seq 1 $((${#lines[*]} - 1))); do
      printf '%00d) %s\n' "${int}" "${lines[int]}"
    done | sort -k 4

    printf "\nChoose a number (Enter to cancel)> "
    read -r ans

    [[ -z ${ans} || ${ans} -lt 0 || ${ans} -gt $((${#lines[*]} - 1)) ]] && {
      printf '\nInvalid choice. Aborting.\n'
      return "${OK}"
    }

    _EX_exec "${containernames[ans]}"
  fi
}

# Private Functions -----------------------------------------------------------

# _EX_new sets the initial values for the _EX associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
_EX_new() {
  _EX[containername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "exec" "ARG1" ""
  PA_add_state "ARG1" "exec" "END" "EX_set_containername"

  # Set up the parser's option callbacks
  PA_add_option_callback "exec" "EX_process_options" || return
  PA_add_usage_callback "exec" "EX_usage" || return
}

# EX_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For exec this does nothing.
# Args: None expected.
_EX_sanity_checks() { :; }

# _EX_exec runs a command in a docker container using bash as the command by
# default.
# Args: arg1 - docker container name
#       arg2 - command to run
_EX_exec() {

  local cmd=${2:-bash}

  containerrt=$(CU_containerrt) || err || return

  read -rt 0.1
  if [[ ${containerrt} == "podman" ]]; then
    exec podman exec -ti "$1" "${cmd}"
  elif [[ ${containerrt} == "docker" ]]; then
    exec docker exec -ti "$1" "${cmd}"
  fi
}

# Initialise EX
_EX_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# DC - Delete Cluster

# _DC is an associative array that holds data specific to deleting a cluster.
declare -A _DC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR STOP TRUE

# Getters/Setters -------------------------------------------------------------

# DC_set_clustername setter sets the cluster name to be deleted. This is
# called by the parser, via a callback in _DC_new.
DC_set_clustername() {
  _DC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# DC_process_options checks if arg1 is in a list of valid delete cluster
# options. This function is called by the parser, via a callback in _DC_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
DC_process_options() {

  case "$1" in
  -h | --help)
    DC_usage
    return "${STOP}"
    ;;
  *)
    DC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# DC_usage outputs help text for the create cluster component.
# It is called by PA_usage(), via a callback in _DC_new.
# Args: None expected.
DC_usage() {

  cat <<'EnD'
DELETE subcommands are:
 
  cluster - Delete a local kubernetes cluster.
 
delete cluster options:
 
 Format:
  delete cluster NAME
  NAME        - The name of the cluster to delete

EnD
}

# DC_run starts the delete cluster process.
# Args: None expected.
DC_run() {

  _DC_sanity_checks || return

  # Mutate functions make system changes.

  declare -i numnodes=0
  local id ids r

  numnodes=$(CU_get_cluster_size "${_DC[clustername]}") || return

  [[ ${numnodes} -eq 0 ]] && {
    printf '\nERROR: No cluster exists with name, "%s". Aborting.\n\n' \
      "${_DC[clustername]}" >"${STDERR}"
    return "${ERROR}"
  }

  ids=$(CU_get_cluster_container_ids "${_DC[clustername]}") || return

  printf 'The following containers will be deleted:\n\n'

  GC_set_showheader "${TRUE}"
  GC_set_clustername "${_DC[clustername]}"
  GC_run "${_DC[clustername]}" || return

  printf "\nAre you sure you want to delete the cluster? (y/N) >"

  read -r ans

  [[ ${ans} != "y" ]] && {
    printf '\nCancelling by user request.\n'
    return "${OK}"
  }

  printf '\n'

  for id in ${ids}; do
    UT_run_with_progress \
      "    Deleting id, '${id}' from cluster '${_DC[clustername]}'." \
      _DC_delete "${id}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n\n' >"${STDERR}"
      err
      return "${r}"
    }
  done

  printf '\n'
}

# Private Functions -----------------------------------------------------------

# _DC_new sets the initial values for the _DC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_DC_new() {
  _DC[clustername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "delete" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "deletecluster" "ARG1" ""
  PA_add_state "ARG1" "deletecluster" "END" "DC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "delete" "DC_process_options" || return
  PA_add_option_callback "deletecluster" "DC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "delete" "DC_usage" || return
  PA_add_usage_callback "deletecluster" "DC_usage" || return
}

# DC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before DC_run is called.
# Args: None expected.
_DC_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    DC_usage
    exit "${OK}"
  fi

  if [[ -z ${_DC[clustername]} ]]; then
    DC_usage
    printf 'Please provide the Cluster NAME to delete.\n' >"${STDERR}"
    return "${ERROR}"
  fi
}

# _DC_delete stops and removes a docker container.
# Args: arg1 - docker id to delete.
_DC_delete() {

  docker stop -t 5 "${id}"
  docker rm "${id}" || err
}

# Initialise _DC
_DC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE K8SVERSION

# Getters/Setters -------------------------------------------------------------

# CC_set_clustername setter sets the clustername array item.
CC_clustername() {
  printf '%s' "${_CC[clustername]}"
}

# CC_set_clustername setter sets the clustername array item.
CC_set_clustername() {
  _CC[clustername]="$1"
}

# CC_set_nummasters setter sets the nummasters array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_nummasters() {
  _CC[nummasters]="$1"
}

# CC_set_numworkers setter sets the numworkers array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_numworkers() {
  _CC[numworkers]="$1"
}

# Public Functions ------------------------------------------------------------

# CC_process_options checks if arg1 is in a list of valid create cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option. For example, '--masters' should be sent
#              with a value but boolean options, like 'skiplbsetup' should not.
CC_process_options() {

  case "$1" in
  -h | --help)
    CC_usage
    return "${STOP}"
    ;;
  --skiplbsetup)
    _CC[skiplbsetup]="${TRUE}"
    return
    ;;
  --k8sver)
    _CC[k8sver]="$2"
    return "$(PA_shift)"
    ;;
  --with-lb)
    _CC[withlb]="${TRUE}"
    return
    ;;
  --skipmastersetup)
    _CC[skipmastersetup]="${TRUE}"
    return
    ;;
  --skipworkersetup)
    _CC[skipworkersetup]="${TRUE}"
    return
    ;;
  --masters)
    _CC[nummasters]="$2"
    return "$(PA_shift)"
    ;;
  --workers)
    _CC[numworkers]="$2"
    return "$(PA_shift)"
    ;;
  --tailf)
    _CC[tailf]="${TRUE}"
    return "${OK}"
    ;;
  *)
    CC_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# CC_usage outputs help text for the create cluster component.  It is called in
# this file and by PA_usage(), via a callback set in _CC_new.
# Args: None expected.
CC_usage() {

  cat <<'EnD'
CREATE subcommands are:
 
  cluster - Create a local kubernetes cluster.
 
create cluster [flags] options:
 
 Format:
  create cluster NAME [ [NUM_MASTERS] [NUM_WORKERS] ]
  NAME        - The name of the cluster. This will be used as
                the prefix in the name for newly created
                docker containers.
  NUM_MASTERS - The number of master containers.
  NUM_WORKERS - The number of worker containers. If NUM_WORKERS is
                zero then the 'node-role.kubernetes.io/master' taint
                will be removed from master nodes so that pods are
                schedulable.
 
 Flags:
  --skipmastersetup - Create the master container but don't set it
         up. Useful for manually installing kubernetes. Kubeadm, 
         kubelet and kubectl will be installed at the requested 
         version. With this option the worker will also be skipped.
         See also '--k8sver' flag.
  --skipworkersetup - The same as '--skipmastersetup', but skips
         setting up the worker only.
  --with-lb - Add a haproxy load balancer. The software will be installed
         and set up to reverse proxy to the master node(s), unless
         --skiplbsetup is used.
  --k8sver VERSION - Unimplemented.
  --masters NUM - The number of master containers to create.
  --workers NUM - The number of worker containers to create. When workers
                  is zero then the master node taint will be removed from
                  master nodes so that pods are schedulable on those nodes.
  --tailf - Show the log output whilst creating the cluster.

EnD
}

# CC_run creates the kubernetes cluster.
# Args: None expected.
CC_run() {

  _CC_sanity_checks || return

  [[ ${_CC[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  declare -i numnodes=0

  numnodes=$(CU_get_cluster_size "${_CC[clustername]}") || return

  [[ ${numnodes} -gt 0 ]] && {
    printf '\nERROR: Cluster, "%s", exists! Aborting.\n\n' "${_CC[clustername]}" \
      >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_create_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_create_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_setup_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_setup_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[numworkers]} -gt 0 ]] && {
    _CC_create_worker_nodes "${_CC[numworkers]}" || return
  }

  printf '\n'

  [[ -z ${_CC[skipmastersetup]} ]] && {
    printf 'Cluster, "%s", can be accessed using:\n\n' "${_CC[clustername]}"
    printf 'export KUBECONFIG=/var/tmp/admin-%s.conf\n\n' "${_CC[clustername]}"
  }

  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CC_new sets the initial values for the _CC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_CC_new() {
  _CC[tailf]="${FALSE}"
  _CC[skipmastersetup]=
  _CC[skipworkersetup]=
  _CC[skiplbsetup]=
  _CC[withlb]=
  _CC[clustername]=
  _CC[nummasters]=0
  _CC[numworkers]=0
  _CC[k8sver]="${K8SVERSION}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "create" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "createcluster" "ARG2" ""

  # Support for the legacy style of create (less to type):
  PA_add_state "ARG1" "createcluster" "ARG2" "CC_set_clustername"
  PA_add_state "ARG2" "createcluster" "ARG3" "CC_set_nummasters"
  PA_add_state "ARG3" "createcluster" "END" "CC_set_numworkers"

  # Set up the parser's option callbacks
  PA_add_option_callback "create" "CC_process_options" || return
  PA_add_option_callback "createcluster" "CC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "create" "CC_usage" || return
  PA_add_usage_callback "createcluster" "CC_usage" || return
}

# CC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before CC_run is called.
# Args: None expected.
_CC_sanity_checks() {

  declare -i host_max=0 cpus=0 should_be=0

  if [[ -z $(PA_subcommand) ]]; then
    CC_usage
    exit "${OK}"
  fi

  if [[ -z ${_CC[clustername]} ]]; then
    CC_usage
    printf 'Please provide the Cluster NAME to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[nummasters]} || ${_CC[nummasters]} -le 0 ]]; then
    CC_usage
    printf 'Please provide the number of Masters to create. Must be 1 or more.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[numworkers]} ]]; then
    CC_usage
    printf 'Please provide the number of Workers to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -e /proc/sys/net/nf_conntrack_max ]]; then
    host_max=$(cat /proc/sys/net/nf_conntrack_max)
  else
    printf '\nWARNING: /proc/sys/net/nf_conntrack_max not found.\n' >"${STDERR}"
    printf '         kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  if [[ -e /proc/cpuinfo ]]; then
    cpus=$(grep -cw ^processor /proc/cpuinfo)
  else
    printf '\nWARNING: /proc/cpuinfo not found.\n' >"${STDERR}"
    printf '         I have no idea how many CPUs I have\n' >"${STDERR}"
    printf '         and kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  # These are the default values that kube-proxy expects:
  # conntrack:
  #   max: null
  #   maxPerCore: 32768
  #   min: 131072
  if [[ $((32768*cpus)) -lt 131072 ]]; then
    should_be=131072
  else
    should_be=$((32768*cpus))
  fi
  if [[ ${should_be} -ne $host_max ]]; then
    printf '\nWARNING: /proc/sys/net/nf_conntrack_max should be set to %d.\n' \
      "${should_be}" >"${STDERR}"
    printf '         If kube-proxy does not start then try:\n' >"${STDERR}"
    printf '           sudo sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
      "${should_be}" >"${STDERR}"
  fi
}

# _CC_create_master_nodes creates the master node containers.
# Args: arg1 - number of master nodes to create
_CC_create_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating master container, '${_CC[clustername]}-master-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-master-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }
  done

  return "${OK}"
}

# _CC_setup_master_nodes sets up the master node containers.
# Args: arg1 - number of master nodes to create
_CC_setup_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-master-${int}'" \
      _CC_set_up_master_node "${_CC[clustername]}-master-${int}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  done

  # For now, copy admin.conf from master to /var/tmp/admin-CLUSTERNAME.conf

  if [[ -z ${_CC[skipmastersetup]} ]]; then
    if [[ ${_CC[withlb]} -eq ${TRUE} ]]; then
      lbaddr=$(CU_get_container_ip "${_CC[clustername]}-lb") || err || return
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${lbaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    else
      [[ -n ${_CC[skipmastersetup]} ]] || {
        docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
          "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      }
    fi

    chmod 666 "/var/tmp/admin-${_CC[clustername]}.conf" || {
      printf 'ERROR: Could not "chown 666 /var/tmp/admin-%s.conf"' "${_CC[clustername]}"
      err || return
    }
  fi

  return "${OK}"
}

# _CC_set_up_master_node calls the correct set up function based on the version
# Args: arg1 - the container ID to set up
_CC_set_up_master_node() {

  case "${_CC[k8sver]}" in
  "1.30.0" | "1.30.1" | "1.31.1")
    _CC_set_up_master_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# _CC_get_master_join_details uses 'docker exec' or 'podman exec' to run a
# script on the master to get CA hash, a token, and the master IP.  The caller
# can eval the output of this function to set the variables: cahash, token, and
# masterip. See also:
# https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/#token-based-discovery-with-ca-pinning
# Args: arg1 - id/name of master container
_CC_get_master_join_details() {

  local joinvarsfile master1ip

  joinvarsfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  master1ip=$(CU_get_container_ip "${_CC[clustername]}-master-1") || err || return

  cat <<EnD >"${joinvarsfile}"
#!/bin/bash
set -e

sed 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${master1ip}"'\2#' \
  /etc/kubernetes/super-admin.conf >/etc/kubernetes/admin2.conf

cahash=\$(openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | \
        openssl rsa -pubin -outform der 2>/dev/null | \
        openssl dgst -sha256 -hex | sed 's/^.* //')
token=\$(kubeadm token create --kubeconfig=/etc/kubernetes/admin2.conf 2>/dev/null)
ip=\$(ip ro get 8.8.8.8 | cut -d" " -f 7)

printf 'cahash=%s\ntoken=%s\nmasterip=%s' "\$cahash" "\$token" "\$ip"

exit 0
EnD

  docker cp "${joinvarsfile}" "$1":/root/joinvars.sh 2>"${STDERR}" ||
    err || return
  rm -f "${joinvarsfile}" 2>"${STDERR}" || err || return

  [[ -z ${_CC[skipworkersetup]} ]] && {
    docker exec "$1" bash /root/joinvars.sh 2>"${STDERR}" || err || return
  }

  return "${OK}"
}

# _CC_create_lb_node creates the load balancer node container.
# Args: None expected.
_CC_create_lb_node() {

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  # Create container
  UT_run_with_progress \
    "    Creating load balancer container, '${_CC[clustername]}-lb'" \
    CU_create_container \
    "${_CC[clustername]}-lb" \
    "${labelkey}=${_CC[clustername]}" \
    "${_CC[k8sver]}"

  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    printf '\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
    printf '%s\n' "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  return "${OK}"
}

# _CC_setup_lb_node sets up the load balancer node container.
# Args: None expected.
_CC_setup_lb_node() {

  local runlogfile

  # Set up
  [[ -z ${_CC[skiplbsetup]} ]] && {
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-lb'" \
      _CC_set_up_lb_node_real "${_CC[clustername]}-lb"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _CC_set_up_lb_node_real sets up the lb node.
# Args: arg1 - the container ID to set up
_CC_set_up_lb_node_real() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masteriplist=
  nl=
  gotamaster="${FALSE}"
  for idx in $(seq 1 "${_CC[nummasters]}"); do
    ip=$(CU_get_container_ip "${_CC[clustername]}-master-${idx}") || continue
    gotamaster="${TRUE}"
    masteriplist="${masteriplist}${nl}    server master-${idx} ${ip}:6443 check fall 3 rise 2"
    nl='\n'
  done

  [[ ${gotamaster} == "${FALSE}" ]] && {
    printf 'ERROR: Did not manage to get an IP address for any master nodes\n'
    err || return
  }

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

systemctl stop kubelet crio
systemctl disable kubelet crio

apt -y install haproxy

INTERNAL_IP=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")

cat <<EOF | tee /etc/haproxy/haproxy.cfg 
frontend kubernetes
    bind \$INTERNAL_IP:6443
    option tcplog
    mode tcp
    default_backend kubernetes-master-nodes
backend kubernetes-master-nodes
    mode tcp
    balance roundrobin
    option tcp-check
\$(echo -e "${masteriplist}")
EOF

systemctl restart haproxy
systemctl enable haproxy

EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# _CC_create_worker_nodes creates the worker nodes.
# Args: arg1 - number of worker nodes to create
_CC_create_worker_nodes() {

  local cahash token t masterip
  declare -i int=0

  [[ -n ${_CC[skipmastersetup]} ]] || {
    # Runs a script on master node to get details
    t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1") || {
      printf '\nERROR: Problem with "_CC_get_master_join_details".\n\n' >"${STDERR}"
      return "${ERROR}"
    }

    # Sets cahash, token, and masterip:
    eval "${t}"
  }

  local labelkey
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating worker container, '${_CC[clustername]}-worker-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-worker-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }

    [[ -n ${_CC[skipworkersetup]} || -n ${_CC[skipmastersetup]} ]] || {
      UT_run_with_progress \
        "    Setting up '${_CC[clustername]}-worker-${int}'" \
        _CC_set_up_worker_node "${_CC[clustername]}-worker-${int}" \
        "${cahash}" "${token}" "${masterip}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n' >"${STDERR}"
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
        printf '%s\n' "${runlogfile}" >"${STDERR}"
        return "${ERROR}"
      }

      UT_run_with_progress \
        "    Waiting for system to become ready" \
        _CC_wait_for_cluster \
        "${_CC[clustername]}-master-1" \
        "${_CC[clustername]}-worker-${int}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n'
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Wait timed out.\n' >"${STDERR}"
        return "${ERROR}"
      }
    }
  done

  return "${OK}"
}

# _CC_wait_for_cluster runs a `kubectl` command in the master-1 container,
# which doesn't exit until the all pods are fully up and running before it
# returns.
# Args: arg1 - the master container name to log into
#       arg2 - the worker container name to wait for
_CC_wait_for_cluster() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  cat <<'EnD' >"${setupfile}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
found=0
for i in $(seq 1 20); do
  if kubectl get pods &>/dev/null; then
    found=1
    break
  fi
  sleep 1
done
[[ $found == 0 ]] && {
  printf '# kubectl get pods\n'
  kubectl get pods
  printf '\nWaited for 20 seconds for kubectl to work.\n'
  printf 'Kubectl cannot contact master. Aborting.\n'
  exit 1
}
counter=0
while ! kubectl get nodes | grep -qs "$1"; do
  ((counter++))
  [[ ${counter} -gt 60 ]] && {
    printf '# kubectl get nodes\n'
    kubectl get nodes
    printf '\nWaited for 2 minutes for node to appear in master. Aborting.\n'
    exit 1
  }
  sleep 2
done
counter=0
while kubectl get pods -A | tail -n +2 | awk '{ print $3; }' | grep -qs 0; do
  ((counter++))
  [[ ${counter} -gt 120 ]] && {
    printf '# kubectl get pods -A\n'
    kubectl get pods -A
    printf '\nWaited for 3 minutes for pods to be ready. Aborting.\n'
    exit 1
  }
  sleep 2
done
exit 0
EnD

  docker cp "${setupfile}" "$1":/root/wait.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/wait.sh "$2" || err
}

# _CC_set_up_worker_node calls the correct set up function based on the version.
# Args: arg1 - the container ID to set up
#       arg2 - the CA hash
#       arg3 - the token
#       arg4 - the master IP
_CC_set_up_worker_node() {

  case "${_CC[k8sver]}" in
  "1.30.0" | "1.30.1" | "1.31.1")
    _CC_set_up_worker_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# Initialise _CC
_CC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster - versions file

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR TRUE

# _CC_set_up_master_node_v1_30_0 uses kubeadm to set up the master node.
# Args: arg1 - the container to set up.
_CC_set_up_master_node_v1_30_0() {

  local setupfile lbaddr certSANs="{}" certkey masternum t
  # Set by _CC_get_master_join_details:
  local cahash token masterip

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masternum="${1##*-}" # <- eg. for xxx-master-1, masternum=1

  if [[ ${_CC[skipmastersetup]} != "${TRUE}" ]]; then

    if [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -eq 1 ]]; then

      # This is the first master node

      # Sets cahash, token, and masterip:
      lbaddr=$(CU_get_container_ip "${_CC[clustername]}-lb")
      certSANs="
  certSANs: [ '${lbaddr}' ]"
      uploadcerts="--upload-certs"
      certkey="CertificateKey: f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07"

    elif [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -ne 1 ]]; then

      # This is not the first master node, so join with the master
      # https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/

      # Keep trying to get join details until apiserver is ready or we run out of tries
      for try in $(seq 1 9); do
        # Runs a script on master node to get join details
        t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1")
        retval=$?
        [[ ${retval} -eq 0 ]] && break
        [[ ${try} -eq 9 ]] && {
          printf '\nERROR: Problem with "_CC_get_master_join_details". Tried %d times\n\n' "${try}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        sleep 5
      done
      eval "${t}"
    fi
  fi

  # Apply the dns hack if there are no workers (single node cluster)
  if [[ ${_CC[numworkers]} -eq 0 ]]; then
    # I don't know why DNS resolution on single node clusters doesn't work but
    # I hope someone will finally figure it out. I've spent too long trying!
    dns_hack='sed -i "s/^ *- 10.96.0.10.*/- 10.244.0.2\n- 10.244.0.3/" /var/lib/kubelet/config.yaml'
  fi

  # Write the file regardless, so the user can use it if required

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

# Use a custom configuration. Default config created from kubeadm with:
#   kubeadm config print init-defaults
# then edited.

ipaddr=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")
podsubnet="10.244.0.0/16"
servicesubnet="10.96.0.0/16"

cat <<EOF >kubeadm-init-defaults.yaml
apiVersion: kubeadm.k8s.io/v1beta4
bootstrapTokens:
- groups:
  - system:bootstrappers:kubeadm:default-node-token
  token: abcdef.0123456789abcdef
  ttl: 24h0m0s
  usages:
  - signing
  - authentication
kind: InitConfiguration
${certkey}
localAPIEndpoint:
  advertiseAddress: \$ipaddr
  bindPort: 6443
nodeRegistration:
  criSocket: unix:///var/run/crio/crio.sock
  imagePullPolicy: IfNotPresent
  imagePullSerial: true
  name: $1
  taints:
  - effect: NoSchedule
    key: node-role.kubernetes.io/control-plane
timeouts:
  controlPlaneComponentHealthCheck: 4m0s
  discovery: 5m0s
  etcdAPICall: 2m0s
  kubeletHealthCheck: 4m0s
  kubernetesAPICall: 1m0s
  tlsBootstrap: 5m0s
  upgradeManifests: 5m0s
---
apiServer: ${certSANs}
apiVersion: kubeadm.k8s.io/v1beta4
caCertificateValidityPeriod: 87600h0m0s
certificateValidityPeriod: 8760h0m0s
certificatesDir: /etc/kubernetes/pki
clusterName: ${_CC[clustername]}-cluster
controlPlaneEndpoint: ${lbaddr:-\$ipaddr}:6443
controllerManager: {}
dns: {}
encryptionAlgorithm: RSA-2048
etcd:
  local:
    dataDir: /var/lib/etcd
imageRepository: registry.k8s.io
kind: ClusterConfiguration
networking:
  dnsDomain: cluster.local
  podSubnet: \${podsubnet}
  serviceSubnet: \${servicesubnet}
proxy: {}
scheduler: {}
EOF

if [[ -z "${masterip}" ]]; then
  # Run the preflight phase
  kubeadm init \\
    --ignore-preflight-errors Swap \\
    --config=kubeadm-init-defaults.yaml \\
    phase preflight

  # Set up the kubelet
  kubeadm init phase kubelet-start

  # Edit the kubelet configuration file
  echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
  sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml
  ${dns_hack}

  # Tell kubeadm to carry on from here
  kubeadm init \\
    --config=kubeadm-init-defaults.yaml \\
    --ignore-preflight-errors Swap \\
    ${uploadcerts} \\
    --skip-phases=preflight,kubelet-start

  export KUBECONFIG=/etc/kubernetes/super-admin.conf

  # Flannel - 10.244.0.0./16
  kubectl apply -f /root/kube-flannel.yml
else
  kubeadm join ${masterip}:6443 \\
    --ignore-preflight-errors Swap \\
    --control-plane \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --certificate-key f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07
fi

systemctl enable kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  # Run the file
  [[ -z ${_CC[skipmastersetup]} ]] && {
    docker exec "$1" bash /root/setup.sh || err || return

    # Remove the taint if we're setting up a single node cluster

    [[ ${_CC[numworkers]} -eq 0 ]] && {

      removetaint=$(mktemp -p /var/tmp) || {
        printf 'ERROR: mktmp failed.\n' >"${STDERR}"
        return "${ERROR}"
      }

      # Write the file
      cat <<'EnD' >"${removetaint}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
kubectl taint nodes --all node-role.kubernetes.io/control-plane:NoSchedule-
EnD

      docker cp "${removetaint}" "$1":/root/removetaint.sh || err || {
        rm -f "${removetaint}"
        return "${ERROR}"
      }

      # Run the file
      docker exec "$1" bash /root/removetaint.sh || err
    }
  }

  return "${OK}"
}

# _CC_set_up_worker_node_v1_30_0 uses kubeadm to set up the worker node.
# Args: arg1 - the container to set up.
_CC_set_up_worker_node_v1_30_0() {

  local setupfile cahash="$2" token="$3" masterip="$4"

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  if [[ ${_CC[withlb]} == "${TRUE}" ]]; then
    masterip=$(CU_get_container_ip "${_CC[clustername]}-lb") || return
  fi

  cat <<EnD >"${setupfile}"
# Wait for the master API to become ready
while true; do
  curl -k https://${masterip}:6443/
  [[ \$? -eq 0 ]] && break
  sleep 1
done

# Do the preflight tests (ignoring swap error)
kubeadm join \\
  phase preflight \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --ignore-preflight-errors Swap \\
    ${masterip}:6443

# Set up the kubelet
kubeadm join \\
  phase kubelet-start \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    ${masterip}:6443 &

while true; do
  [[ -e /var/lib/kubelet/config.yaml ]] && break
    sleep 1
  done

# Edit the kubelet configuration file
echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

systemctl enable --now kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh 2>"${STDERR}" || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CU - Container Utilities

# _CU is an associative array that holds data specific to container utils.
declare -A _CU

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# CU_containerrt getter outputs the container runtime (podman or docker)
# that has been chosen.
CU_containerrt() {
  printf '%s' "${_CU[containerrt]}"
}

# CU_imgprefix getter outputs the prefix to be used with docker build. For
# podman it is 'localhost/'. For docker it is empty.
CU_imgprefix() {
  printf '%s' "${_CU[imgprefix]}"
}

# CU_labelkey getter outputs the key value of the label that is applied to all
# cluster member's container labels for podman or docker.
CU_labelkey() {
  printf '%s' "${_CU[labelkey]}"
}

# Public Functions ------------------------------------------------------------

# CU_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted.
CU_cleanup() { :; }

# CU_get_cluster_container_ids outputs just the container IDs, one per line
# for any MOK cluster, unless arg1 is set, in which case just the IDs
# for the requested cluster name are output.
# Args: arg1 - The cluster name, optional.
CU_get_cluster_container_ids() {

  local value output

  [[ -n $1 ]] && value="=$1"

  output=$(docker ps -a -f label="${_CU[labelkey]}${value}" -q) || {
    printf 'ERROR: %s command failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  output=$(printf '%s' "${output}" | sed 's/$//')

  printf '%s' "${output}"

  return "${OK}"
}

# CU_get_cluster_size searches for an existing cluster using labels and outputs
# the number of containers in that cluster. All cluster nodes are labelled with
# "${_CU[labelkey]}=${CC[clustername]}"
# Args: arg1 - The cluster name to search for.
CU_get_cluster_size() {

  local output
  declare -a nodes

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Cluster name cannot be empty.\n' >"${STDERR}"
    err || return
  }

  output=$(CU_get_cluster_container_ids "$1") || err || return

  # readarray will read null as an array item so don't run
  # through readarray if it's null
  [[ -z ${output} ]] && {
    printf '0'
    return "${OK}"
  }

  # read the nodes array and delete blank lines
  readarray -t nodes <<<"${output}"

  printf '%d' "${#nodes[*]}"
}

# CU_get_container_ip outputs the IP address of the container.
# Args: arg1 - docker container id or container name to query.
CU_get_container_ip() {

  local info

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  info=$(CU_get_container_info "$1") || return
  JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}" ||
    err || return
}

# CU_get_container_info uses 'docker/podman inspect $id' to output
# container details.
# Args: arg1 - docker container id
CU_get_container_info() {

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  docker inspect "$1" || {
    printf 'ERROR: %s inspect failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_create_container creates and runs a container with settings suitable for
# running privileged containers that can manipulate cgroups.
# Args: arg1 - The string used to set the name and hostname.
#       arg2 - The label to assign to the container.
#       arg3 - The k8s base image version to use.
CU_create_container() {

  local imagename img allimgs systemd_always clustername

  [[ -z $1 || -z $2 || -z $3 ]] && {
    printf 'INTERNAL ERROR: Neither arg1, arg2 nor arg3 can be empty.\n' \
      >"${STDERR}"
    err || return
  }

  img=$(BI_baseimagename) || err || return

  local imglocal="${_CU[imgprefix]}local/${img}-v${3}"
  local imgremote="myownkind/${img}-v${3}"

  # Prefer a locally built container over one downloaded from a registry
  allimgs=$(docker images | tail -n +2) || {
    printf 'ERROR: %s returned an error\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  if echo "${allimgs}" | grep -qs "${imglocal}"; then
    imagename="${imglocal}"
  elif echo "${allimgs}" | grep -qs "${imgremote}"; then
    imagename="${imgremote}"
  else
    cat <<EnD
ERROR: No container base image found. Use either:

  $ mok build image
OR
  $ mok build image --get-prebuilt-image

Then try running 'mok create ...' again.
EnD
    return "${ERROR}"
  fi

  clustername=$(CC_clustername) || err || return

  if [[ ${_CU[containerrt]} == "podman" ]];
  then 
    docker network exists "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  else
    docker network inspect "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  fi

  [[ ${create_network} -ne 0 ]] && {
    docker network create "${clustername}_network" || {
      printf 'ERROR: docker network create failed\n' >"${STDERR}"
      err || return
    }
  }

  [[ ${_CU[containerrt]} == "podman" ]] && systemd_always="--systemd=always"

  docker run --privileged ${systemd_always} \
    --network "${clustername}_network" \
    -v /lib/modules:/lib/modules:ro \
    --detach \
    --name "$1" \
    --hostname "$1" \
    --label "$2" \
    "${imagename}" \
    /usr/local/bin/entrypoint /lib/systemd/systemd log-level=info unit=sysinit.target || {
    printf 'ERROR: %s run failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# Private Functions -----------------------------------------------------------

# _CU_new sets the initial values for the Container Utils associative array.
# Args: None expected.
_CU_new() {
  _CU[imgprefix]=
  _CU[labelkey]="MokCluster"
  _CU[containerrt]=

  _CU_podman_or_docker
}

# CU_podman_or_docker checks to see if docker and/or podman are installed and
# sets the imgprefix and containerrt array members accordingly. It also defines
# the docker function to run the detected container runtime. Docker is
# preferred if both are installed.
# Args: No args expected.
_CU_podman_or_docker() {

  local id

  if type podman &>/dev/null; then
    _CU[imgprefix]="localhost/"
    _CU[containerrt]="podman"
    local id
    id=$(id -u)
    [[ ${id} -ne 0 ]] && {
      cat <<EnD >"${STDERR}"
Please use 'sudo' to run this command.

  $ sudo mok $(MA_program_args)

Or set up an alias, for example:

  $ alias mok="sudo mok"

Then run the command again.
EnD
      return "${ERROR}"
    }
    docker() {
      podman "$@"
    }
  elif type docker &>/dev/null; then
    _CU[imgprefix]=""
    _CU[containerrt]="docker"
    if docker ps >/dev/stdout 2>&1 | grep -qs 'docker.sock.*permission denied'; then
      cat <<EnD >"${STDERR}"
Not enough permissions to write to 'docker.sock'.

Please use 'sudo' to run this command.

  $ sudo mok $(MA_program_args)

Or set up an alias, for example:

  $ alias mok="sudo mok"

Then run the command again.
EnD
      return "${ERROR}"
    fi
  else
    printf 'ERROR: Neither "podman" nor "docker" were found.\n' \
      >"${STDERR}"
    printf 'Please install one of "podman" or "docker".\nAborting.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi

  return "${OK}"
}

# Initialise _CU
_CU_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# BI - Build Image

# _BI is an associative array that holds data specific to building an image.
declare -A _BI

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE

# Getters/Setters -------------------------------------------------------------

# BI_setflag_useprebuiltimage setter sets the useprebuiltimage array item.
# This is called by the parser, via a callback in _BI_new.
BI_setflag_useprebuiltimage() {
  _BI[useprebuiltimage]="$1"
}

# BI_baseimagename getter outputs the value of the _BI[baseimagename].
# Args: None expected.
BI_baseimagename() {
  printf '%s' "${_BI[baseimagename]}"
}

# Public Functions ------------------------------------------------------------

# BI_usage outputs help text for the build image component.
# It is called by PA_usage(), via a callback in _BI_new.
# Args: None expected.
BI_usage() {

  # NOTE: This flag to be added back in the future
  # --get-prebuilt-image - Instead of building a 'node' image
  #        locally, download it from a container registry instead.

  cat <<'EnD'
BUILD subcommands are:
 
  image - Creates the docker 'mok-image' container image.
 
build image options:
 
 Format:
  build image

 Flags:
  --tailf - Show the build output whilst building.

EnD
}

# BI_cleanup removes temporary files created during the build.
# This function is called by the 'MA_cleanup' trap only.
# Args: None expected.
BI_cleanup() {
  [[ -e ${_BI[dockerbuildtmpdir]} ]] &&
    [[ ${_BI[dockerbuildtmpdir]} == "/var/tmp/"* ]] && {
    rm -rf "${_BI[dockerbuildtmpdir]}" || {
      printf 'ERROR: "rm -rf %s" failed.\n' "${_BI[dockerbuildtmpdir]}" \
        >"${STDERR}"
      err || return
    }
  }
}

# BI_check_valid_options checks if arg1 is in a list of valid build image
# options. This function is called by the parser, via a callback in _BI_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
BI_process_options() {

  case "$1" in
  -h | --help)
    BI_usage
    return "${STOP}"
    ;;
  --tailf)
    _BI[tailf]="${TRUE}"
    return "${OK}"
    ;;
  # NOTE: This flag to be added back in the future
  # --get-prebuilt-image)
  #   _BI[useprebuiltimage]="${TRUE}"
  #   return "${OK}"
  #   ;;
  *)
    BI_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# BI_run builds the base image used for masters and workers.
# This function is called in main.sh.
# Args: None expected.
BI_run() {

  _BI_sanity_checks || return

  [[ ${_BI[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  local retval=0
  _BI_build_container_image
  retval=$?

  if [[ ${retval} -eq ${OK} ]]; then
    : # We only need the tick - no text
  else
    printf 'Image build failed\n' >"${STDERR}"
    err
  fi

  return "${retval}"
}

# Private Functions -----------------------------------------------------------

# _BI_new resets the initial values for the _BI associative array.
# Args: None expected.
_BI_new() {
  _BI[tailf]="${FALSE}"
  _BI[baseimagename]="mok-image"
  _BI[useprebuiltimage]="${FALSE}"
  _BI[dockerbuildtmpdir]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "build" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "buildimage" "END" ""

  # Set up the parser's option callbacks
  PA_add_option_callback "build" "BI_process_options" || return
  PA_add_option_callback "buildimage" "BI_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "build" "BI_usage" || return
  PA_add_usage_callback "buildimage" "BI_usage" || return
}

# BI_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_BI_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    BI_usage
    exit "${OK}"
  fi
}

# _BI_build_container_image creates the docker build directory in
# dockerbuildtmpdir then calls docker build to build the image.
# Args: No args expected.
_BI_build_container_image() {

  local cmd retval tagname buildargs text buildtype

  _BI_create_docker_build_dir || return

  buildargs=$(_BI_get_build_args_for_latest) || return
  tagname="${_BI[baseimagename]}-v${K8SVERSION}"

  local imgprefix
  imgprefix=$(CU_imgprefix) || err || return
  if [[ ${_BI[useprebuiltimage]} == "${FALSE}" ]]; then
    buildtype="create"
    cmd="docker build \
      -t "${imgprefix}local/${tagname}" \
      --force-rm \
      ${buildargs} \
      ${_BI[dockerbuildtmpdir]}/${_BI[baseimagename]}"
    text="Creating"
  else
    buildtype="download"
    cmd="docker pull myownkind/${tagname}"
    text="Downloading"
  fi

  UT_run_with_progress \
    "    ${text} base image, '${tagname}'" "${cmd}"

  retval=$?
  [[ ${retval} -ne ${OK} ]] && {
    local runlogfile
    runlogfile=$(UT_runlogfile) || err || return
    printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\n' >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${buildtype} == "create" ]] && {
    cmd="_BI_modify_container_image"

    UT_run_with_progress \
      "    Modifying base image (pulling kubernetes images)" "${cmd}"

    retval=$?
    [[ ${retval} -ne ${OK} ]] && {
      local runlogfile
      runlogfile=$(UT_runlogfile) || err || return
      printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\n' >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _BI_modify_container_image starts a container suitable for running kubernetes
# components (since the docker/podman build environment isn't suitable), makes
# some modifications and then 'commits' the image. The modifications allow
# `mok create ...` to complete more quickly.
# Args: No args expected.
_BI_modify_container_image() {

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify &>/dev/null
  docker rm mok-build-modify &>/dev/null

  CC_set_clustername "build" || err || return

  # Start container
  CU_create_container "mok-build-modify" "mok-build-modify" "${K8SVERSION}" ||
    return

  # Wait for crio to become ready
  printf '\n\n ** WAITING FOR CRIO TO BECOME READY **\n\n'
  while ! docker exec mok-build-modify systemctl status crio; do
    sleep 1
    [[ ${counter} -gt 10 ]] && {
      printf '\nERROR: CRI-O did not start after %d tries.\n' "${counter}"
      err || return
    }
    ((counter++))
  done

  # Modify container
  docker exec mok-build-modify kubeadm config images pull \
    --kubernetes-version "${K8SVERSION}" || err || return

  # Stop container
  docker stop -t 5 "mok-build-modify"

  # Write image
  local imgprefix tagname
  imgprefix=$(CU_imgprefix) || err || return
  tagname="${_BI[baseimagename]}-v${K8SVERSION}"
  docker commit mok-build-modify "${imgprefix}local/${tagname}" || err || return

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify
  docker rm mok-build-modify || err || return

  return "${OK}"
}

# _BI_get_build_args_for_latest sets the buildargs variable that is added
# to the 'podman build ...' command line.  Only the latest version is built
# from scratch.  Earlier versions are downloaded using '--get-prebuilt-image'.
# Args: None expected
_BI_get_build_args_for_latest() {

  local buildargs

  buildargs="--build-arg GO_VERSION=${GO_VERSION}"

  printf '%s' "${buildargs}"
}

# _BI_create_docker_build_dir creates a docker build directory in
# /var/tmp/tmp.XXXXXXXX
# Args: None expected
_BI_create_docker_build_dir() {

  _BI[dockerbuildtmpdir]="$(mktemp -d -p /var/tmp)" || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }

  # The following comments should not be removed or changed.
  # embed-dockerfile.sh adds a base64 encoded tarball and
  # unpacking code between them.

  #mok-image-tarball-start 
  cat <<EnD | base64 -d | tar xz -C "${_BI[dockerbuildtmpdir]}" 
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
EnD
  #mok-image-tarball-end
}

# Initialise _BI
_BI_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
#!/usr/bin/env bash

declare -A JSONPath

JSONPath_new() {
  JSONPath[DEBUG]=0
  JSONPath[INCLEMPTY]=0
  JSONPath[NOCASE]=0
  JSONPath[WHOLEWORD]=0
  JSONPath[FILE]=
  JSONPath[NO_HEAD]=0
  JSONPath[NORMALIZE_SOLIDUS]=0
  JSONPath[BRIEF]=0
  JSONPath[PASSTHROUGH]=0
  JSONPath[JSON]=0
  JSONPath[MULTIPASS]=0
  JSONPath[FLATTEN]=0
  JSONPath[STDINFILE]=/var/tmp/JSONPath.$$.stdin
  JSONPath[STDINFILE2]=/var/tmp/JSONPath.$$.stdin2
  JSONPath[PASSFILE]=/var/tmp/JSONPath.$$.pass1
  declare -a INDEXMATCH_QUERY
}

# JSONPath reads JSON from stdin and applies a JSON Path query.
# Args: arg1-N - command line arguments to be parsed.
JSONPath() {

  JSONPath_sanity_checks
  JSONPath_parse_options "$@"

  trap JSONPath_cleanup EXIT

  if [[ ${QUERY} == *'?(@'* ]]; then
    # This will be a multipass query

    [[ -n ${JSONPath[FILE]} ]] && JSONPath[STDINFILE]=${JSONPath[FILE]}
    [[ -z ${JSONPath[FILE]} ]] && cat >"${JSONPath[STDINFILE]}"

    while true; do
      JSONPath_tokenize_path
      JSONPath_create_filter

      JSONPath_tokenize | JSONPath_parse | JSONPath_filter |
        JSONPath_indexmatcher >"${JSONPath[PASSFILE]}" <"${JSONPath[STDINFILE]}"

      [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && {
        # replace filter expression with index sequence
        SET=$(sed -rn 's/.*[[,"]+([0-9]+)[],].*/\1/p' "${JSONPath[PASSFILE]}" | tr '\n' ,)
        SET=${SET%,}
        #QUERY=$(sed "s/?(@[^)]\+)/${SET}/" <<<"${QUERY}")
        # Testing:
        QUERY="${QUERY//\?\(@*)/${SET}}"
        [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "QUERY=${QUERY}" >/dev/stderr
        JSONPath_reset
        continue
      }

      JSONPath_flatten | JSONPath_json | JSONPath_brief <<<"${JSONPath[PASSFILE]}"

      break
    done

  else

    JSONPath_tokenize_path
    JSONPath_create_filter

    if [[ ${JSONPath[PASSTHROUGH]} -eq 1 ]]; then
      JSONPath[JSON]=1
      JSONPath_flatten | JSONPath_json
    elif [[ -z ${JSONPath[FILE]} ]]; then
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten | JSONPath_json | JSONPath_brief
    else
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten <"${JSONPath[FILE]}"
      JSONPath_json | JSONPath_brief
    fi

  fi
}

JSONPath_sanity_checks() {

  local binary

  # Reset some vars
  for binary in gawk grep sed; do
    if ! command -v "${binary}" >&/dev/null; then
      echo "ERROR: ${binary} binary not found in path. Aborting."
      exit 1
    fi
  done
}

JSONPath_reset() {

  # Reset some vars
  declare -a INDEXMATCH_QUERY
  PATHTOKENS=
  FILTER=
  OPERATOR=
  RHS=
  JSONPath[MULTIPASS]=0
}

JSONPath_cleanup() {

  [[ -e ${JSONPath[PASSFILE]} ]] && rm -f "${PASSFILE}"
  [[ -e ${JSONPath[STDINFILE2]} ]] && rm -f "${JSONPath[STDINFILE2]}"
  [[ -z ${JSONPath[FILE]} && -e ${JSONPath[STDINFILE]} ]] &&
    rm -f "${JSONPath[STDINFILE]}"
}

JSONPath_usage() {

  echo
  echo "Usage: JSONPath.sh [-b] [j] [-h] [-f FILE] [pattern]"
  echo
  echo "pattern - the JSONPath query. Defaults to '$.*' if not supplied."
  echo "-b      - Brief. Only show values."
  echo "-j      - JSON output."
  echo "-u      - Strip unnecessary leading path elements."
  echo "-i      - Case insensitive."
  echo "-p      - Pass-through to the JSON parser."
  echo "-w      - Match whole words only (for filter script expression)."
  echo "-f FILE - Read a FILE instead of stdin."
  echo "-h      - This help text."
  echo
}

JSONPath_parse_options() {

  set -- "$@"
  local ARGN=$#
  while [[ ${ARGN} -ne 0 ]]; do
    case $1 in
    -h)
      JSONPath_usage
      exit 0
      ;;
    -f)
      shift
      JSONPath[FILE]=$1
      ;;
    -i)
      JSONPath[NOCASE]=1
      ;;
    -j)
      JSONPath[JSON]=1
      ;;
    -n)
      JSONPath[NO_HEAD]=1
      ;;
    -b)
      JSONPath[BRIEF]=1
      ;;
    -u)
      JSONPath[FLATTEN]=1
      ;;
    -p)
      JSONPath[PASSTHROUGH]=1
      ;;
    -w)
      JSONPath[WHOLEWORD]=1
      ;;
    -s)
      JSONPath[NORMALIZE_SOLIDUS]=1
      ;;
    *)
      QUERY=$1
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done
  [[ -z ${QUERY} ]] && QUERY='$.*'
}

JSONPath_awk_egrep() {
  local pattern_string=$1

  gawk '{
    while ($0) {
      start=match($0, pattern);
      token=substr($0, start, RLENGTH);
      print token;
      $0=substr($0, start+RLENGTH);
    }
  }' pattern="${pattern_string}"
}

JSONPath_tokenize() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    ESCAPE='(\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
    ESCAPE='(\\\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\\\]'
  fi

  local STRING="\"${CHAR}*(${ESCAPE}${CHAR}*)*\""
  local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'
  local KEYWORD='null|false|true'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  ${GREP} "${STRING}|${NUMBER}|${KEYWORD}|${SPACE}|." | grep -Ev "^${SPACE}$"
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

JSONPath_tokenize_path() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
  fi

  local WILDCARD='\*'
  local WORD='[ A-Za-z0-9_-]*'
  local INDEX="\\[${WORD}(:${WORD}){0,2}\\]"
  local INDEXALL='\[\*\]'
  local STRING="[\\\"'][^[:cntrl:]\\\"']*[\\\"']"
  local SET="\\[(${WORD}|${STRING})(,(${WORD}|${STRING}))*\\]"
  local FILTER='\?\(@[^)]+'
  local DEEPSCAN='\.\.'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  readarray -t PATHTOKENS < <(echo "${QUERY}" |
    ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
    grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$")
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    echo "grep -Eo '${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|.'" >/dev/stderr
    echo -n "TOKENISED QUERY="
    echo "${QUERY}" |
      ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
      grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$" >/dev/stderr
  }
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

# JSONPath_create_filter creates the filter from the user's query.
# Filter works in a single pass through the data, unless a filter (script)
#  expression is used, in which case two passes are required (MULTIPASS=1).
JSONPath_create_filter() {

  local len=${#PATHTOKENS[*]}

  local -i i=0
  local a query="^\[" comma=
  while [[ i -lt len ]]; do
    case "${PATHTOKENS[i]}" in
    '"')
      :
      ;;
    '..')
      query+="${comma}[^]]*"
      comma=
      ;;
    '[*]')
      query+="${comma}[^,]*"
      comma=","
      ;;
    '*')
      query+="${comma}(\"[^\"]*\"|[0-9]+[^],]*)"
      comma=","
      ;;
    '?(@'*)
      a=${PATHTOKENS[i]#?(@.}
      elem="${a%%[<>=!]*}"
      rhs="${a##*[<>=!]}"
      a="${a#${elem}}"
      elem="${elem//./[\",.]+}" # Allows child node matching
      operator="${a%${rhs}}"
      [[ -z ${operator} ]] && {
        operator="=="
        rhs=
      }
      if [[ ${rhs} == *'"'* || ${rhs} == *"'"* ]]; then
        case ${operator} in
        '==' | '=')
          OPERATOR=
          if [[ ${elem} == '?(@' ]]; then
            # To allow search on @.property such as:
            #   $..book[?(@.title==".*Book 1.*")]
            query+="${comma}[0-9]+[],][[:space:]\"]*${rhs//\"/}"
          else
            # To allow search on @ (this node) such as:
            #   $..reviews[?(@==".*Fant.*")]
            query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs//\"/}"
          fi
          FILTER="${query}"
          ;;
        '>=' | '>')
          OPERATOR=">"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=' | '<')
          OPERATOR="<"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      else
        case ${operator} in
        '==' | '=')
          OPERATOR=
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs}"
          FILTER="${query}"
          ;;
        '>=')
          OPERATOR="-ge"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '>')
          OPERATOR="-gt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=')
          OPERATOR="-le"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<')
          OPERATOR="-lt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      fi
      JSONPath[MULTIPASS]=1
      ;;
    "["*)
      if [[ ${PATHTOKENS[i]} =~ , ]]; then
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          # converts only one comma: s/("[^"]+),([^"]+")/\1`\2/g;s/"//g
          #a=$(echo $a | sed 's/\([[:alpha:]]*\)/"\1"/g')
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        fi
        query+="${comma}(${a//,/|})"
      elif [[ ${PATHTOKENS[i]} =~ : ]]; then
        if ! [[ ${PATHTOKENS[i]} =~ [0-9][0-9] || ${PATHTOKENS[i]} =~ :] ]]; then
          if [[ ${PATHTOKENS[i]#*:} =~ : ]]; then
            INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
            query+="${comma}[^,]*"
          else
            # Index in the range of 0-9 can be handled by regex
            query+="${comma}$(echo "${PATHTOKENS[i]}" |
              gawk '/:/ { a=substr($0,0,index($0,":")-1);
                         b=substr($0,index($0,":")+1,index($0,"]")-index($0,":")-1);
                         if(b>0) { print a ":" b-1 "]" };
                         if(b<=0) { print a ":]" } }' |
              sed 's/\([0-9]\):\([0-9]\)/\1-\2/;
                       s/\[:\([0-9]\)/[0-\1/;
                       s/\([0-9]\):\]/\1-9999999]/')"
          fi
        else
          INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
          query+="${comma}[^,]*"
        fi
      else
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        else
          [[ ${i} -gt 0 ]] && comma=","
        fi
        query+="${comma}${a}"
      fi
      comma=","
      ;;
    *)
      PATHTOKENS[i]=${PATHTOKENS[i]//\'/\"}
      query+="${comma}\"${PATHTOKENS[i]//\"/}\""
      comma=","
      ;;
    esac
    i=$((i + 1))
  done

  [[ -z ${FILTER} ]] && FILTER="${query}[],]"
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
}

JSONPath_parse_array() {

  local index=0
  local ary=''
  read -r token
  case "${token}" in
  ']') ;;

  *)
    while :; do
      JSONPath_parse_value "$1" "${index}"
      index=$((index + 1))
      ary="${ary}""${value}"
      read -r token
      case "${token}" in
      ']') break ;;
      ',') ary="${ary}," ;;
      *) JSONPath_throw "EXPECTED , or ] GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_object() {

  local key
  local obj=''
  read -r token
  case "${token}" in
  '}') ;;

  *)
    while :; do
      case "${token}" in
      '"'*'"') key=${token} ;;
      *) JSONPath_throw "EXPECTED string GOT ${token:-EOF}" ;;
      esac
      read -r token
      case "${token}" in
      ':') ;;
      *) JSONPath_throw "EXPECTED : GOT ${token:-EOF}" ;;
      esac
      read -r token
      JSONPath_parse_value "$1" "${key}"
      obj="${obj}${key}:${value}"
      read -r token
      case "${token}" in
      '}') break ;;
      ',') obj="${obj}," ;;
      *) JSONPath_throw "EXPECTED , or } GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_value() {

  local jpath="${1:+$1,}$2" isleaf=0 isempty=0 print=0
  case "${token}" in
  '{') JSONPath_parse_object "${jpath}" ;;
  '[') JSONPath_parse_array "${jpath}" ;;
    # At this point, the only valid single-character tokens are digits.
  '' | [!0-9]) JSONPath_throw "EXPECTED value GOT ${token:-EOF}" ;;
  *)
    value=${token}
    # if asked, replace solidus ("\/") in json strings with normalized value: "/"
    # Testing:
    #[ "${JSONPath[NORMALIZE_SOLIDUS]}" -eq 1 ] && value=$(echo "${value}" | sed 's#\\/#/#g')
    [[ ${JSONPath[NORMALIZE_SOLIDUS]} -eq 1 ]] && value=$(${value//\\\///})
    isleaf=1
    [[ ${value} == '""' ]] && isempty=1
    ;;
  esac
  [[ -z ${JSONPath[INCLEMPTY]} ]] && [[ ${value} == '' ]] && return
  [[ ${JSONPath[NO_HEAD]} -eq 1 ]] && [[ -z ${jpath} ]] && return

  [[ ${isleaf} -eq 1 ]] && [[ ${isempty} -eq 0 ]] && print=1
  [[ ${print} -eq 1 ]] && printf "[%s]\t%s\n" "${jpath}" "${value}"
  :
}

JSONPath_flatten() {

  local path a prevpath pathlen

  if [[ ${JSONPath[FLATTEN]} -eq 1 ]]; then
    cat >"${JSONPath[STDINFILE2]}"

    highest=9999

    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      [[ -z ${prevpath} ]] && {
        prevpath=("${path[@]}")
        highest=$((${#path[*]} - 1))
        continue
      }

      pathlen=$((${#path[*]} - 1))

      for i in $(seq 0 "${pathlen}"); do
        [[ ${path[i]} != "${prevpath[i]}" ]] && {
          high=${i}
          break
        }
      done

      [[ ${high} -lt ${highest} ]] && highest=${high}

      prevpath=("${path[@]}")
    done <"${JSONPath[STDINFILE2]}"

    if [[ ${highest} -gt 0 ]]; then
      sed -r 's/\[(([0-9]+|"[^"]+")[],]){'$((highest))'}(.*)/[\3/' \
        "${JSONPath[STDINFILE2]}"
    else
      cat "${JSONPath[STDINFILE2]}"
    fi
  else
    cat
  fi
}

# JSONPath_indexmatcher is for double digit or greater indexes match each line
# individually Single digit indexes are handled more efficiently by regex
JSONPath_indexmatcher() {

  local a b

  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
      echo "INDEXMATCH_QUERY[${i}]=${INDEXMATCH_QUERY[i]}" >/dev/stderr
    done
  }

  matched=1

  step=
  if [[ ${#INDEXMATCH_QUERY[*]} -gt 0 ]]; then
    while read -r line; do
      for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
        [[ ${INDEXMATCH_QUERY[i]#*:} =~ : ]] && {
          step=${INDEXMATCH_QUERY[i]##*:}
          step=${step%]}
          INDEXMATCH_QUERY[i]="${INDEXMATCH_QUERY[i]%:*}]"
        }
        q=${INDEXMATCH_QUERY[i]:1:-1} # <- strip '[' and ']'
        a=${q%:*}                     # <- number before ':'
        b=${q#*:}                     # <- number after ':'
        [[ -z ${b} ]] && b=99999999999
        readarray -t num < <((grep -Eo '[0-9]+[],]' | tr -d ,]) <<<"${line}")
        if [[ ${num[i]} -ge ${a} && ${num[i]} -lt ${b} && matched -eq 1 ]]; then
          matched=1
          [[ ${i} -eq $((${#INDEXMATCH_QUERY[*]} - 1)) ]] && {
            if [[ ${step} -gt 1 ]]; then
              [[ $(((num[i] - a) % step)) -eq 0 ]] && {
                [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
                echo "${line}"
              }
            else
              [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
              echo "${line}"
            fi
          }
        else
          matched=0
          continue
        fi
      done
      matched=1
    done
  else
    cat -
  fi
}

JSONPath_brief() {
  # Only show the value

  if [[ ${JSONPath[BRIEF]} -eq 1 ]]; then
    sed 's/^[^\t]*\t//;s/^"//;s/"$//;'
  else
    cat
  fi
}

JSONPath_json() {
  # Turn output into JSON

  local a tab="$'\t'"
  local UP=1 DOWN=2 SAME=3
  local prevpathlen=-1 prevpath=() path a
  declare -a closers

  if [[ ${JSONPath[JSON]} -eq 0 ]]; then
    cat -
  else
    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      value=${line#*${tab}}

      # Not including the object itself (last item)
      pathlen=$((${#path[*]} - 1))

      # General direction

      direction=${SAME}
      [[ ${pathlen} -gt ${prevpathlen} ]] && direction=${DOWN}
      [[ ${pathlen} -lt ${prevpathlen} ]] && direction=${UP}

      # Handle jumps UP the tree (close previous paths)

      [[ ${prevpathlen} != -1 ]] && {
        for i in $(seq 0 $((pathlen - 1))); do
          [[ ${prevpath[i]} == "${path[i]}" ]] && continue
          [[ ${path[i]} != '"'* ]] && {
            # Testing double quotes:
            a="(${!arrays[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                arrays[k]=
              done
            }
            a="(${!comma[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                comma[k]=
              done
            }
            for j in $(seq $((prevpathlen)) -1 $((i + 2))); do
              arrays[j]=
              [[ -n ${closers[j]} ]] && {
                indent=$((j * 4))
                printf "\n%${indent}s${closers[j]}" ""
                unset "closers[j]"
                comma[j]=
              }
            done
            direction=${DOWN}
            break
          }
          direction=${DOWN}
          for j in $(seq $((prevpathlen)) -1 $((i + 1))); do
            arrays[j]=
            [[ -n ${closers[j]} ]] && {
              indent=$((j * 4))
              printf "\n%${indent}s${closers[j]}" ""
              unset "closers[j]"
              comma[j]=
            }
          done
          a="(${!arrays[*]})"
          [[ -n ${a} ]] && {
            for k in $(seq "${i}" "${a[-1]}"); do
              arrays[k]=
            done
          }
          break
        done
      }

      [[ ${direction} -eq ${UP} ]] && {
        [[ ${prevpathlen} != -1 ]] && comma[prevpathlen]=
        for i in $(seq $((prevpathlen + 1)) -1 $((pathlen + 1))); do
          arrays[i]=
          [[ -n ${closers[i]} ]] && {
            indent=$((i * 4))
            printf "\n%${indent}s${closers[i]}" ""
            unset "closers[i]"
            comma[i]=
          }
        done
        a="(${!arrays[*]})"
        [[ -n ${a} ]] && {
          for k in $(seq "${i}" "${a[-1]}"); do
            arrays[k]=
          done
        }
      }

      # Opening braces (the path leading up to the key)

      broken=
      for i in $(seq 0 $((pathlen - 1))); do
        [[ -z ${broken} && ${prevpath[i]} == "${path[i]}" ]] && continue
        [[ -z ${broken} ]] && {
          broken=${i}
          [[ ${prevpathlen} -ne -1 ]] && broken=$((i + 1))
        }
        if [[ ${path[i]} == '"'* ]]; then
          # Object
          [[ ${i} -ge ${broken} ]] && {
            indent=$((i * 4))
            printf "${comma[i]}%${indent}s{\n" ""
            closers[i]='}'
            comma[i]=
          }
          indent=$(((i + 1) * 4))
          printf "${comma[i]}%${indent}s${path[i]}:\n" ""
          comma[i]=",\n"
        else
          # Array
          if [[ ${arrays[i]} != 1 ]]; then
            indent=$((i * 4))
            printf "%${indent}s" ""
            echo "["
            closers[i]=']'
            arrays[i]=1
            comma[i]=
          else
            indent=$(((i + 1) * 4))
            printf "\n%${indent}s${closers[i - 1]}" ""
            direction=${DOWN}
            comma[i + 1]=",\n"
          fi
        fi
      done

      # keys & values

      if [[ ${path[-1]} == '"'* ]]; then
        # Object
        [[ ${direction} -eq ${DOWN} ]] && {
          indent=$((pathlen * 4))
          printf "${comma[pathlen]}%${indent}s{\n" ""
          closers[pathlen]='}'
          comma[pathlen]=
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${path[-1]}:${value}"
        comma[pathlen]=",\n"
      else
        # Array
        [[ ${arrays[i]} != 1 ]] && {
          indent=$(((pathlen - 0) * 4))
          printf "%${indent}s[\n" ""
          closers[pathlen]=']'
          comma[pathlen]=
          arrays[i]=1
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${value}"
        comma[pathlen]=",\n"
      fi

      prevpath=("${path[@]}")
      prevpathlen=${pathlen}
    done

    # closing braces

    for i in $(seq $((pathlen)) -1 0); do
      indent=$((i * 4))
      printf "\n%${indent}s${closers[i]}" ""
    done
    echo
  fi
}

JSONPath_filter() {
  # Apply the query filter

  local a tab=$'\t' v

  [[ ${JSONPath[NOCASE]} -eq 1 ]] && opts+="i"
  [[ ${JSONPath[WHOLEWORD]} -eq 1 ]] && opts+="w"
  if [[ -z ${OPERATOR} ]]; then
    [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && FILTER="${FILTER}[\"]?$"
    grep "-E${opts}" "${FILTER}"
    [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
  else
    grep "-E${opts}" "${FILTER}" |
      while read -r line; do
        v=${line#*${tab}}
        case ${OPERATOR} in
        '-ge')
          if gawk '{exit !($1>=$2)}' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-gt')
          if gawk '{exit !($1>$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-le')
          if gawk '{exit !($1<=$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-lt')
          if gawk '{exit !($1<$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '>')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} > ${RHS,,} ]] && echo "${line}"
          ;;
        '<')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} < ${RHS,,} ]] && echo "${line}"
          ;;
        *) return 1 ;;
        esac
      done
  fi
}

JSONPath_parse() {
  # Parses json

  read -r token
  JSONPath_parse_value
  read -r token
  case "${token}" in
  '') ;;
  *)
    JSONPath_throw "EXPECTED EOF GOT ${token}"
    exit 1
    ;;
  esac
}

JSONPath_throw() {
  echo "$*" >&2
  exit 1
}

JSONPath_new || exit 1

# vi: expandtab sw=2 ts=2
if [ "$0" = "${BASH_SOURCE[0]}" ] || [ -z "${BASH_SOURCE[0]}" ]; then
  MA_main "$@"
fi
