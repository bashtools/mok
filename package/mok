#!/usr/bin/env bash
# shellcheck shell=bash disable=SC2148
# PA - PArser

# _PA holds data specific to parsing the command line arguments.
declare -A _PA

# Declare externally defined variables ----------------------------------------

# Defined in ER (globals.sh)
declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# PA_command getter outputs the _PA[command] array member. This contains the
# command the user requested.
PA_command() {
  printf '%s' "${_PA[command]}"
}

# PA_subcommand getter outputs the _PA[subcommand] array member. This contains
# the subcommand the user requested.
PA_subcommand() {
  printf '%s' "${_PA[subcommand]}"
}

# PA_shift outputs the _PA[shift] array member, returned by the caller
# when an extra shift is required whilst consuming option values.
#
# Example code:
# ```
#XX_process_options_callback() {
#
#  case "$1" in
#  -h | --help)
#    CC_usage
#    return "${STOP}"
#    ;;
#    ... omitted ...
#  --k8sver)
#    _CC[k8sver]="$2"
#    return "$(PA_shift)"
#    ;;
#  --with-lb)
#    ... omitted ..
# ```
PA_shift() {
  printf '%s' "${_PA[shift]}"
}

# PA_set_state setter sets the initial state of the parser, which should be one
# of COMMAND, SUBCOMMAND, or ARG1.
# Args: arg1 - the initial state to set.
PA_set_state() {
  _PA[state]="$1"
}

# Public Functions ------------------------------------------------------------

# PA_add_option_callback adds a callback to the list of callbacks used for
# processing options.
# Args: arg1 - Null string (for global options), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_option_callback() {
  _PA[optscallbacks]+="$1,$2 "
}

# PA_add_usage_callback adds a callback to the list of callbacks used for
# output of help text.
# Args: arg1 - Null string (for global help), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_usage_callback() {
  _PA[usagecallbacks]+="$1,$2 "
}

# PA_add_state adds a callback to the list of callbacks used for
# programming the state machine.
# Args: arg1 - Current state to match.
#       arg2 - The value of the state to match.
#       arg3 - The new state if arg1 and arg2 match.
#       arg4 - The function to call, optional.
PA_add_state() {
  _PA[statecallbacks]+="$1,$2,$3,$4 "
}

# PA_add_run_callback adds a callback to the list of callbacks used for
# running the user defined entrypoint function.
# Args: arg1 - The value of the state to match. Probably like:
#              "commandsubcommand" "function"
#       arg2 - The function to call.
PA_add_run_callback() {
  _PA[runcallbacks]+="$1,$2 "
}

# PA_run implements an interleaved state machine to process the
# user request. It allows for strict checking of arguments and args. All
# command line arguments are processed in order from left to right.
#
# Each COMMAND can have a different set of requirements which are controlled
# by setting the next state at each transition.
#
# --global-options COMMAND --command-options SUBCOMMAND --subcommand-options \
#  ARG1 --subcommand-options ARG2 --subcommand-options ...
#
# --global-options are those before COMMAND.
# --command-options can be after the COMMAND but before SUBCOMMAND.
# --subcommand-options can be anywhere after the SUBCOMMAND.
#
# Args: arg1-N - The arguments given to mok by the user on the command line
PA_run() {

  local retval=${OK}

  set -- "$@"
  local ARGN=$# ARGNUM=0 retval=0
  while [ "${ARGN}" -ne 0 ]; do
    case "$1" in
    --* | -*)
      _PA_process_option "$1" "$2" || {
        retval=$?
        if [[ ${retval} == "${_PA[shift]}" ]]; then
          ARGN=$((ARGN - 1))
          shift
        else
          return "${retval}"
        fi
      }
      ;;
    *)
      case "${_PA[state]}" in
      COMMAND)
        _PA_check_token "${1}" "COMMAND" "command"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid COMMAND, "%s".\n\n' "$1" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      SUBCOMMAND)
        _PA_check_token "$1" "SUBCOMMAND" "subcommand"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid SUBCOMMAND for %s, "%s".\n\n' "${_PA[command]}" "${1}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      ARG*)
        ((ARGNUM++))
        _PA_check_token "${1}" "ARG${ARGNUM}"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid ARG1 for %s %s, "%s".\n\n' "${_PA[command]}" \
            "${_PA[subcommand]}" "${1}" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      END)
        PA_usage
        printf 'ERROR No more args expected, "%s" is unexpected for "%s %s"\n' \
          "${1}" "${_PA[command]}" "${_PA[subcommand]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      *)
        printf 'Internal ERROR. Invalid state "%s"\n' "${_PA[state]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      esac
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done

  # Run the user defined entrypoint function:
  for item in ${_PA[runcallbacks]}; do
    IFS=, read -r stateval func <<<"${item}"
    [[ ${stateval} == "${_PA[command]}${_PA[subcommand]}" ]] && {
      eval "${func}" || retval=$?
      return "${retval}"
    }
  done

  PA_usage

  return "${OK}"
}

# PA_usage outputs help text for a single component if help was asked for when
# a command was specified, or for all components otherwise.
# Args: None expected.
PA_usage() {

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[usagecallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func}"
      return
    }
  done

  eval "${_PA[usage]}"
}

# Private Functions -----------------------------------------------------------

# PA_new sets the initial values for the PArser's associative array.
# Args: None expected.
_PA_new() {
  _PA[command]=
  _PA[subcommand]=
  _PA[state]="COMMAND"
  _PA[optscallbacks]=
  _PA[usagecallbacks]=
  _PA[statecallbacks]=
  _PA[runcallbacks]=
  # The return value if the caller asked for an extra shift:
  _PA[shift]=126
}

# _PA_check_token checks for a valid token in arg2 state. The logic is
# most easily understood by reading the full original version at:
# https://github.com/mclarkson/my-own-kind/blob/master/docs/package.md#scripted-cluster-creation-and-deletion
# This function is a reduction of all the check_xxx_token functions.
# Args: arg1 - the token to check.
#       arg2 - the current state.
#       arg3 - the state value to set, optional. This should only be sent
#              for command and subcommand states.
_PA_check_token() {

  local item

  if [[ -n ${_PA[subcommand]} ]]; then
    cmdsubcommand="${_PA[command]}${_PA[subcommand]}"
  elif [[ -n ${_PA[command]} && ${_PA[state]} != "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}$1"
  elif [[ -n ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}"
  elif [[ -z ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand=
  else
    cmdsubcommand="$1"
  fi

  for item in ${_PA[statecallbacks]}; do
    IFS=, read -r state component newstate func <<<"${item}"
    [[ ${state} == "$2" ]] && {
      [[ ${component} == "${cmdsubcommand}" ]] && {
        [[ -n $3 ]] && _PA["$3"]="$1"
        _PA[state]="${newstate}"
        [[ -n ${func} ]] && {
          eval "${func} $1" || return
        }
        return "${OK}"
      }
    }
  done
}

# _PA_process_option checks that the user-provided option is valid for the
# command-subcommand or global states.
# Args: arg1 - The option to check.
#       arg2 - TODO The value of the option if present, optional.
_PA_process_option() {

  local item curcmdsubcmd

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[optscallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func} \"$1\" \"$2\""
      return $?
    }
  done

  return "${ERROR}"
}

# Initialise _PA
_PA_new

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GL - Globals

# Private Functions -----------------------------------------------------------

# GL_new sets the only global variables that should be in use anywhere.  The
# only other globals are the associative arrays. All the globals are constant
# (readonly) variables. Declare these globals, where needed, in other files
# so that shellcheck passes.
# Args: None expected.
_GL_new() {

  declare -rg MOKVERSION="0.8.19"
  declare -rg K8SVERSION="1.31.1"
  declare -rg GO_VERSION="1.23.2"

  # Returns, exit codes
  declare -rg OK=0
  declare -rg SUCCESS=0
  declare -rg ERROR=1
  declare -rg FAILURE=1

  # For setting flags
  declare -rg TRUE=1
  declare -rg FALSE=0

  # To signal main() to exit with SUCCESS in the PArser
  declare -rg STOP=2

  declare -rg STDOUT="/dev/stdout"
  declare -rg STDERR="/dev/stderr"

  # The following just keep shellcheck happy
  local dummy dumb
  dummy="${OK}"
  dummy="${ERROR}"
  dummy="${STOP}"
  dummy="${STDOUT}"
  dummy="${STDERR}"
  dummy="${TRUE}"
  dummy="${FALSE}"
  dummy="${SUCCESS}"
  dummy="${FAILURE}"
  dummy="${MOKVERSION}"
  dummy="${GO_VERSION}"
  dummy="${K8SVERSION}"
  dumb="${dummy}${dumb}"
}

# Initialise GL
_GL_new || exit 1

# vim helpers -----------------------------------------------------------------

# The following lines allow the use of '[C-i' and '[I' (do ':help [I') in vim.
#include buildimage.sh
#include containerutils.sh
#include createcluster.sh
#include deletecluster.sh
#include embed-dockerfile.sh
#include error.sh
#include exec.sh
#include getcluster.sh
#include main.sh
#include lib/parser.sh
#include util.sh
#include versions.sh

# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# ER - Error handling

# ER is an associative array that holds data specific to error handling.
declare -A ER

# Declare externally defined associative arrays -------------------------------

# Defined in GL (globals.sh)
declare ERROR TRUE STDERR

# Public Functions ------------------------------------------------------------

# ER_err outputs a stacktrace and returns ERROR status.
# Args: None expected.
ER_err() {

  # In case of error print the function call stack
  # No args expected

  [[ ${ER[errcalled]} == "${TRUE}" ]] && return "${ERROR}"
  ER[errcalled]="${TRUE}"
  local frame=0
  printf '\n' >"${STDERR}"
  while caller "${frame}"; do
    ((frame++))
  done | tac >"${STDERR}"
  printf '\n' >"${STDERR}"
  return "${ERROR}"
}

# err is a synonym for ER_err to aid with code readability.
err() {
  ER_err
  return
}

# Private Functions -----------------------------------------------------------

# ER_new sets the initial values for the ER associative array.
# Args: None expected.
_ER_new() {
  ER[errcalled]=
}

# Initialise ER
_ER_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# UT - Utilities

# _UT is an associative array that holds data specific to general utilities.
declare -A _UT

# Declare externally defined global variables ---------------------------------

declare OK STDERR FALSE TRUE

# Getters/Setters -------------------------------------------------------------

# UT_runlogfile getter outputs the value of _UT[runlogfile], which contains the
# name of the file written to when running UT_run_with_progress.
UT_runlogfile() {
  printf '%s' "${_UT[runlogfile]}"
}

# UT_tailf getter indicates whether a log will be shown in real-time during the
# 'run', TRUE, or not, FALSE.
# Args
UT_tailf() {
  printf '%s' "${_UT[tailf]}"
}

# UT_tailf setter indicates whether a log should be shown during the 'run',
# TRUE, or not, FALSE.
# Args: arg1 - Whether to tail, TRUE or FALSE.
UT_set_tailf() {
  _UT[tailf]="$1"
}

# UT_set_plain setter sets plain output, with no colour, animations, or UTF
# high byte characters.
# Args: arg1 - Whether to show plain output, TRUE or FALSE.
UT_set_plain() {
  _UT[plain]="$1"
  UT_disable_colours
}

# Public Functions ------------------------------------------------------------

# UT_disable_colours resets variables used for colourised output so that they
# contain no colour terminal escapes. Useful if stdin is not a terminal.
UT_disable_colours() {
  _UT[yellow]=
  _UT[green]=
  _UT[red]=
  _UT[normal]=
  _UT[probablysuccess]="PROBABLY SUCCESS (!)"
  _UT[success]="SUCCESS"
  _UT[failure]="FAIL"
}

# UT_run_with_progress displays a progress spinner, item text, and a tick or
# cross based on the exit code.
# Args: arg1   - the text to display.
#       arg2-N - remaining args are the program to run and its arguments.
UT_run_with_progress() {

  local displaytext=$1 retval int spinner=()

  _UT[runlogfile]=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }
  shift

  if [[ ${_UT[tailf]} == "${FALSE}" && ${_UT[plain]} == "${TRUE}" ]]; then

    # Output with no colours or spinny

    printf '%s' "${displaytext}"

    eval "$*" &>"${_UT[runlogfile]}"
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 0 ]]; then
      printf ' .. %s\n' "${_UT[success]}"
    else
      printf ' .. %s\n' "${_UT[failure]}"
    fi

  elif [[ ${_UT[tailf]} == "${FALSE}" ]]; then

    # Output with colours and spinny

    while read -r char; do
      spinner+=("${char}")
    done <<<"$(grep -o . <<<"${_UT[spinnerchars]}")"

    (
      eval "$*" &>"${_UT[runlogfile]}"
    ) &

    # Turn the cursor off
    tput civis

    # Start the spin animation
    printf ' %s' "${displaytext}"
    (while true; do
      for int in {0..3}; do
        printf '\r  %s ' "${spinner[int]}"
        sleep .1
      done
    done) &
    _UT[spinnerpid]=$!
    disown

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Kill the spinner
    kill "${_UT[spinnerpid]}" 2>/dev/null
    _UT[spinnerpid]=

    sleep .5

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\r  %s\n' "${_UT[probablysuccess]}"
    elif [[ ${retval} -eq 0 ]]; then
      printf '\r  %s\n' "${_UT[success]}"
    else
      printf '\r  %s\n' "${_UT[failure]}"
    fi

    # Restore the cursor
    tput cnorm
    sleep .5

  else

    # Tailf output

    printf 'COMMAND: %s\n\n' "$*"

    (
      eval "$*" &>/dev/stdout
    ) &
    sleep 1

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\n\nSTATUS: OK - (Probably)\n\n'
    elif [[ ${retval} -eq 0 ]]; then
      printf '\n\nSTATUS: OK\n\n'
    else
      printf '\n\nSTATUS: FAIL\n\n'
    fi
  fi

  return "${retval}"
}

# UT_cleanup removes any artifacts that were created during execution.
# This is called by 'MA_cleanup' trap only.
UT_cleanup() {

  # Called when the script exits.

  local int

  # Kill the spinny, and anything else, if they're running
  if [[ ${_UT[tailf]} == "${FALSE}" ]]; then
    [[ -n ${_UT[spinnerpid]} ]] && {
      printf '%s\r  ✕%s\n' "${_UT[red]}" "${_UT[normal]}"
      kill "${_UT[spinnerpid]}"
    }
    # If progress spinner crashed make sure the cursor is shown
    [ -t 1 ] && tput cnorm
  else
    kill "${_UT[spinnerpid]}" &>/dev/null
  fi

  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _UT_new sets the initial values for the _UT associative array.
# Args: None expected.
_UT_new() {
  _UT[tailf]="${FALSE}"
  _UT[yellow]=$(tput setaf 3)
  _UT[green]=$(tput setaf 2)
  _UT[red]=$(tput setaf 1)
  _UT[normal]=$(tput sgr0)
  _UT[probablysuccess]="${_UT[yellow]}✓${_UT[normal]}"
  _UT[success]="${_UT[green]}✓${_UT[normal]}"
  _UT[failure]="${_UT[red]}✕${_UT[normal]}"
  _UT[runlogfile]=
  _UT[spinnerchars]="|/-\\"
  _UT[spinnerpid]=
}

# Initialise _UT
_UT_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GC - Get Cluster

# _GC is an associative array that holds data specific to the get cluster command.
declare -A _GC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# GC_showheader getter outputs the value of the showheader array member.
GC_showheader() {
  printf '%s' "${_GC[showheader]}"
}

# GC_set_showheader setter sets the value of the showheader array member.
# If $TRUE the header will be shown, or $FALSE, then it won't be shown.
GC_set_showheader() {
  _GC[showheader]="$1"
}

# GC_set_clustername setter sets the cluster name to show information about.
GC_set_clustername() {
  _GC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# GC_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted. It is called by
# MA_cleanup.
GC_cleanup() {
  :
}

# GC_process_options checks if arg1 is in a list of valid get cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
GC_process_options() {

  case "$1" in
  -h | --help)
    GC_usage
    return "${STOP}"
    ;;
  *)
    GC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# GC_usage outputs help text for the create cluster component.
# It is called by PA_usage().
# Args: None expected.
GC_usage() {

  cat <<'EnD'
GET subcommands are:
 
  cluster(s) - list all mok managed clusters.
 
get cluster(s) options:
 
 Format:
  get cluster(s) [NAME]
  NAME        - (optional) The name of the cluster to get
                details about.

EnD
}

# GC_run gets information about cluster(s).
# This function is called in main.sh.
# Args: None expected.
GC_run() {

  _GC_sanity_checks || return

  local ids id info output labelkey
  local containerhostname containerip

  declare -a nodes

  ids=$(CU_get_cluster_container_ids "${_GC[clustername]}") || return

  if [[ -z ${ids} ]]; then
    printf 'No clusters found\n'
    return "${OK}"
  fi

  readarray -t nodes <<<"${ids}"

  # Use 'docker inspect' to get the value of the label $LABELKEY

  output=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  # Output the header
  [[ ${_GC[showheader]} -eq ${TRUE} ]] && {
    printf 'MOK_Cluster Docker_ID Container_Name IP_Address\n' >"${output}"
  }

  labelkey=$(CU_labelkey) || err || return

  for id in "${nodes[@]}"; do

    info=$(CU_get_container_info "${id}") || return

    clustname=$(JSONPath ".[0].Config.Labels.${labelkey}" -b <<<"${info}") ||
      err || return

    containerhostname=$(JSONPath '.[0].Config.Hostname' -b <<<"${info}") ||
      err || return

    containerip=$(JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}") ||
      err || return

    printf '%s %s %s %s\n' "${clustname}" "${id}" "${containerhostname}" "${containerip}"

  done | sort -k 3 >>"${output}"

  column -t "${output}" || err
}

# Private Functions -----------------------------------------------------------

# _GC_new sets the initial values for the _GC associative array.
# Args: None expected.
_GC_new() {
  _GC[showheader]="${TRUE}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "get" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "getcluster" "ARG1" ""
  PA_add_state "SUBCOMMAND" "getclusters" "ARG1" ""
  PA_add_state "ARG1" "getcluster" "END" "GC_set_clustername"
  PA_add_state "ARG1" "getclusters" "END" "GC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "get" "GC_process_options" || return
  PA_add_option_callback "getcluster" "GC_process_options" || return
  PA_add_option_callback "getclusters" "GC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "get" "GC_usage" || return
  PA_add_usage_callback "getcluster" "GC_usage" || return
  PA_add_usage_callback "getclusters" "GC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "getcluster" "GC_run"
  PA_add_run_callback "getclusters" "GC_run"
}

# GC_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_GC_sanity_checks() {

  # Only show the usage if we are in 'get' mode and have not specified a
  # subcommand. This allows internal code to call GC_run()
  if [[ $(PA_command) == "get" && -z $(PA_subcommand) ]]; then
    GC_usage
    exit "${OK}"
  fi
}

# Initialise _GC
_GC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# EX - EXec

# EX is an associative array that holds data specific to the exec cluster command.
declare -A _EX

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# EX_set_containername setter sets the containername to be used to 'log in' to.
EX_set_containername() {
  _EX[containername]="$1"
}

# Public Functions ------------------------------------------------------------

# EX_process_options checks if arg1 is in a list of valid exec options. This
# function is called by the parser, via a callback in _EX_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
EX_process_options() {

  case "$1" in
  -h | --help)
    EX_usage
    return "${STOP}"
    ;;
  *)
    EX_usage
    printf 'ERROR: "%s" is not a valid "exec" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# EX_usage outputs help text for the create exec component.  It is called in
# this file and by PA_usage(), via a callback in _EX_new.
# Args: None expected.
EX_usage() {

  cat <<'EnD'
'Log in' to a container. EXEC has no subcommands.
 
exec options:
 
 Format:
  exec [NAME]
  NAME        - (optional) The name of the container to 'log in' to.
                If NAME is not given then the user will be offered
                a choice of containers to log in to. If there is only
                one cluster and one node then it will 'log in' to the
                only available container.

EnD
}

# Execs 'bash' in the container referenced by _EX[containername]. If just
# 'mok exec' is called without options then the user is offered a selection
# of existing clusters to exec into.
# Args: None expected.
# ---------------------------------------------------------------------------
EX_run() {

  _EX_sanity_checks || return

  local names int ans lines containernames gcoutput

  GC_set_showheader "${TRUE}" || err || return
  gcoutput=$(GC_run) || return
  names=$(printf '%s' "${gcoutput}" | awk '{ print $3; }')
  readarray -t containernames <<<"${names}"

  if [[ -n ${_EX[containername]} ]]; then

    # The caller gave a specific name for exec.
    # Check if the container name exists

    if grep -qs "^${_EX[containername]}$" <<<"${names}"; then
      _EX_exec "${_EX[containername]}" || return
      return "${OK}"
    else
      printf 'ERROR: Cannot exec into non-existent container: "%s".\n' \
        "${_EX[containername]}"
      return "${ERROR}"
    fi

  elif [[ ${#containernames[*]} == 2 ]]; then

    # If there's only one container just log into it without asking
    _EX_exec "${containernames[1]}"

  elif [[ ${#containernames[*]} == 1 ]]; then

    printf 'No containers found.\n'
    return "${OK}"

  else

    # The caller supplied no container name.
    # Present some choices

    printf 'Choose the container to log in to:\n\n'

    readarray -t lines <<<"${gcoutput}" || return

    # Print the header then print the items in the loop
    printf '   %s\n' "${lines[0]}"
    for int in $(seq 1 $((${#lines[*]} - 1))); do
      printf '%00d) %s\n' "${int}" "${lines[int]}"
    done | sort -k 4

    printf "\nChoose a number (Enter to cancel)> "
    read -r ans

    [[ -z ${ans} || ${ans} -lt 0 || ${ans} -gt $((${#lines[*]} - 1)) ]] && {
      printf '\nInvalid choice. Aborting.\n'
      return "${OK}"
    }

    _EX_exec "${containernames[ans]}"
  fi
}

# Private Functions -----------------------------------------------------------

# _EX_new sets the initial values for the _EX associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
_EX_new() {
  _EX[containername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "exec" "ARG1" ""
  PA_add_state "ARG1" "exec" "END" "EX_set_containername"

  # Set up the parser's option callbacks
  PA_add_option_callback "exec" "EX_process_options" || return
  PA_add_usage_callback "exec" "EX_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "exec" "EX_run"
}

# EX_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For exec this does nothing.
# Args: None expected.
_EX_sanity_checks() { :; }

# _EX_exec runs a command in a docker container using bash as the command by
# default.
# Args: arg1 - docker container name
#       arg2 - command to run
_EX_exec() {

  local cmd=${2:-bash}

  containerrt=$(CU_containerrt) || err || return

  read -rt 0.1
  if [[ ${containerrt} == "podman" ]]; then
    exec podman exec -ti "$1" "${cmd}"
  elif [[ ${containerrt} == "docker" ]]; then
    exec docker exec -ti "$1" "${cmd}"
  fi
}

# Initialise EX
_EX_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# DC - Delete Cluster

# _DC is an associative array that holds data specific to deleting a cluster.
declare -A _DC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR STOP TRUE

# Getters/Setters -------------------------------------------------------------

# DC_set_clustername setter sets the cluster name to be deleted. This is
# called by the parser, via a callback in _DC_new.
DC_set_clustername() {
  _DC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# DC_process_options checks if arg1 is in a list of valid delete cluster
# options. This function is called by the parser, via a callback in _DC_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
DC_process_options() {

  case "$1" in
  -h | --help)
    DC_usage
    return "${STOP}"
    ;;
  *)
    DC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# DC_usage outputs help text for the create cluster component.
# It is called by PA_usage(), via a callback in _DC_new.
# Args: None expected.
DC_usage() {

  cat <<'EnD'
DELETE subcommands are:
 
  cluster - Delete a local kubernetes cluster.
 
delete cluster options:
 
 Format:
  delete cluster NAME
  NAME        - The name of the cluster to delete

EnD
}

# DC_run starts the delete cluster process.
# Args: None expected.
DC_run() {

  _DC_sanity_checks || return

  # Mutate functions make system changes.

  declare -i numnodes=0
  local id ids r

  numnodes=$(CU_get_cluster_size "${_DC[clustername]}") || return

  [[ ${numnodes} -eq 0 ]] && {
    printf '\nERROR: No cluster exists with name, "%s". Aborting.\n\n' \
      "${_DC[clustername]}" >"${STDERR}"
    return "${ERROR}"
  }

  ids=$(CU_get_cluster_container_ids "${_DC[clustername]}") || return

  printf 'The following containers will be deleted:\n\n'

  GC_set_showheader "${TRUE}"
  GC_set_clustername "${_DC[clustername]}"
  GC_run "${_DC[clustername]}" || return

  printf "\nAre you sure you want to delete the cluster? (y/N) >"

  read -r ans

  [[ ${ans} != "y" ]] && {
    printf '\nCancelling by user request.\n'
    return "${OK}"
  }

  printf '\n'

  for id in ${ids}; do
    UT_run_with_progress \
      "    Deleting id, '${id}' from cluster '${_DC[clustername]}'." \
      _DC_delete "${id}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n\n' >"${STDERR}"
      err
      return "${r}"
    }
  done

  printf '\n'
}

# Private Functions -----------------------------------------------------------

# _DC_new sets the initial values for the _DC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_DC_new() {
  _DC[clustername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "delete" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "deletecluster" "ARG1" ""
  PA_add_state "ARG1" "deletecluster" "END" "DC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "delete" "DC_process_options" || return
  PA_add_option_callback "deletecluster" "DC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "delete" "DC_usage" || return
  PA_add_usage_callback "deletecluster" "DC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "deletecluster" "DC_run"
}

# DC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before DC_run is called.
# Args: None expected.
_DC_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    DC_usage
    exit "${OK}"
  fi

  if [[ -z ${_DC[clustername]} ]]; then
    DC_usage
    printf 'Please provide the Cluster NAME to delete.\n' >"${STDERR}"
    return "${ERROR}"
  fi
}

# _DC_delete stops and removes a docker container.
# Args: arg1 - docker id to delete.
_DC_delete() {

  docker stop -t 5 "${id}"
  docker rm "${id}" || err
}

# Initialise _DC
_DC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE K8SVERSION

# Getters/Setters -------------------------------------------------------------

# CC_set_clustername setter sets the clustername array item.
CC_clustername() {
  printf '%s' "${_CC[clustername]}"
}

# CC_publish getter outputs the publish array item.
CC_publish() {
  printf '%s' "${_CC[publish]}"
}

# CC-withlb getter outputs the withlb array item.
CC_withlb() {
  printf '%s' "${_CC[withlb]}"
}

# CC_set_clustername setter sets the clustername array item.
CC_set_clustername() {
  _CC[clustername]="$1"
}

# CC_set_nummasters setter sets the nummasters array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_nummasters() {
  _CC[nummasters]="$1"
}

# CC_set_numworkers setter sets the numworkers array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_numworkers() {
  _CC[numworkers]="$1"
}

# Public Functions ------------------------------------------------------------

# CC_process_options checks if arg1 is in a list of valid create cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option. For example, '--masters' should be sent
#              with a value but boolean options, like 'skiplbsetup' should not.
CC_process_options() {

  case "$1" in
  -h | --help)
    CC_usage
    return "${STOP}"
    ;;
  --skiplbsetup)
    _CC[skiplbsetup]="${TRUE}"
    return
    ;;
  --k8sver)
    _CC[k8sver]="$2"
    return "$(PA_shift)"
    ;;
  --with-lb)
    _CC[withlb]="${TRUE}"
    return
    ;;
  --skipmastersetup)
    _CC[skipmastersetup]="${TRUE}"
    return
    ;;
  --skipworkersetup)
    _CC[skipworkersetup]="${TRUE}"
    return
    ;;
  --masters)
    _CC[nummasters]="$2"
    return "$(PA_shift)"
    ;;
  --workers)
    _CC[numworkers]="$2"
    return "$(PA_shift)"
    ;;
  --tailf)
    _CC[tailf]="${TRUE}"
    return "${OK}"
    ;;
  --publish)
    _CC[publish]="${TRUE}"
    return
    ;;
  *)
    CC_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# CC_usage outputs help text for the create cluster component.  It is called in
# this file and by PA_usage(), via a callback set in _CC_new.
# Args: None expected.
CC_usage() {

  cat <<'EnD'
CREATE subcommands are:
 
  cluster - Create a local kubernetes cluster.
 
create cluster [flags] options:
 
 Format:
  create cluster NAME [ [NUM_MASTERS] [NUM_WORKERS] ]
  NAME        - The name of the cluster. This will be used as
                the prefix in the name for newly created
                docker containers.
  NUM_MASTERS - The number of master containers.
  NUM_WORKERS - The number of worker containers. If NUM_WORKERS is
                zero then the 'node-role.kubernetes.io/master' taint
                will be removed from master nodes so that pods are
                schedulable.
 
 Flags:
  --skipmastersetup - Create the master container but don't set it
         up. Useful for manually installing kubernetes. Kubeadm, 
         kubelet and kubectl will be installed at the requested 
         version. With this option the worker will also be skipped.
         See also '--k8sver' flag.
  --skipworkersetup - The same as '--skipmastersetup', but skips
         setting up the worker only.
  --with-lb - Add a haproxy load balancer. The software will be installed
         and set up to reverse proxy to the master node(s), unless
         --skiplbsetup is used.
  --k8sver VERSION - Unimplemented.
  --masters NUM - The number of master containers to create.
  --workers NUM - The number of worker containers to create. When workers
                  is zero then the master node taint will be removed from
                  master nodes so that pods are schedulable on those nodes.
  --tailf - Show the log output whilst creating the cluster.
  --publish - Publish port 6443 for the master node, or the load balancer if
              it's enabled, for external kubectl access to the cluster. The IP
              address of the default route interface is added to the cert.


EnD
}

# CC_run creates the kubernetes cluster.
# Args: None expected.
CC_run() {

  _CC_sanity_checks || return

  [[ ${_CC[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  declare -i numnodes=0

  numnodes=$(CU_get_cluster_size "${_CC[clustername]}") || return

  [[ ${numnodes} -gt 0 ]] && {
    printf '\nERROR: Cluster, "%s", exists! Aborting.\n\n' "${_CC[clustername]}" \
      >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_create_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_create_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_setup_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_setup_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[numworkers]} -gt 0 ]] && {
    _CC_create_worker_nodes "${_CC[numworkers]}" || return
  }

  printf '\n'

  [[ -z ${_CC[skipmastersetup]} ]] && {
    printf 'Cluster, "%s", can be accessed using:\n\n' "${_CC[clustername]}"
    printf 'export KUBECONFIG=/var/tmp/admin-%s.conf\n\n' "${_CC[clustername]}"
  }

  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CC_new sets the initial values for the _CC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_CC_new() {
  _CC[tailf]="${FALSE}"
  _CC[skipmastersetup]=
  _CC[skipworkersetup]=
  _CC[skiplbsetup]=
  _CC[withlb]=
  _CC[clustername]=
  _CC[nummasters]=0
  _CC[numworkers]=0
  _CC[publish]=0
  _CC[k8sver]="${K8SVERSION}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "create" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "createcluster" "ARG2" ""

  # Support for the legacy style of create (less to type):
  PA_add_state "ARG1" "createcluster" "ARG2" "CC_set_clustername"
  PA_add_state "ARG2" "createcluster" "ARG3" "CC_set_nummasters"
  PA_add_state "ARG3" "createcluster" "END" "CC_set_numworkers"

  # Set up the parser's option callbacks
  PA_add_option_callback "create" "CC_process_options" || return
  PA_add_option_callback "createcluster" "CC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "create" "CC_usage" || return
  PA_add_usage_callback "createcluster" "CC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "createcluster" "CC_run"
  PA_add_run_callback "createclusters" "CC_run"
}

# CC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before CC_run is called.
# Args: None expected.
_CC_sanity_checks() {

  declare -i host_max=0 cpus=0 should_be=0

  if [[ -z $(PA_subcommand) ]]; then
    CC_usage
    exit "${OK}"
  fi

  if [[ -z ${_CC[clustername]} ]]; then
    CC_usage
    printf 'Please provide the Cluster NAME to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[nummasters]} || ${_CC[nummasters]} -le 0 ]]; then
    CC_usage
    printf 'Please provide the number of Masters to create. Must be 1 or more.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[numworkers]} ]]; then
    CC_usage
    printf 'Please provide the number of Workers to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/sys/net/nf_conntrack_max ]]; then
    host_max=$(cat /proc/sys/net/nf_conntrack_max)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    host_max=$(podman machine ssh cat /proc/sys/net/nf_conntrack_max)
  else
    printf '\nWARNING: /proc/sys/net/nf_conntrack_max not found.\n' >"${STDERR}"
    printf '         kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/cpuinfo ]]; then
    cpus=$(grep -cw ^processor /proc/cpuinfo)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    cpus=$(podman machine ssh cat /proc/cpuinfo | grep -cw ^processor)
  else
    printf '\nWARNING: /proc/cpuinfo not found.\n' >"${STDERR}"
    printf '         I have no idea how many CPUs I have\n' >"${STDERR}"
    printf '         and kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  # These are the default values that kube-proxy expects:
  # conntrack:
  #   max: null
  #   maxPerCore: 32768
  #   min: 131072
  if [[ $((32768*cpus)) -lt 131072 ]]; then
    should_be=131072
  else
    should_be=$((32768*cpus))
  fi
  if [[ ${should_be} -ne $host_max ]]; then
    printf '\nERROR: /proc/sys/net/nf_conntrack_max should be set to %d.\n' \
      "${should_be}" >"${STDERR}"
    printf '     kube-proxy will not start with an incorrect nf_conntrack_max.\n' >"${STDERR}"
    printf '     To fix this, run the following command:\n\n' >"${STDERR}"
    if [[ ${_CU[podmantype]} == "native" ]]; then
      printf '       sudo sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
    elif [[ ${_CU[podmantype]} == "machine" ]]; then
      printf '       podman machine ssh sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
      printf '     If the above command fails, you may have to recreate the podman machine, for example:\n\n' >"${STDERR}"
      tput setaf 1 # red
      printf '     WARNING: The following commands will destroy your podman machine and all its data.\n' >"${STDERR}"
      printf '              All existing pods and containers will be gone.\n\n' >"${STDERR}"
      tput sgr0 # reset
      printf '       podman machine stop\n' >"${STDERR}"
      printf '       podman machine rm\n' >"${STDERR}"
      printf '       podman machine init --now --rootful --user-mode-networing\n' >"${STDERR}"
      printf '       podman machine ssh modprobe nf_conntrack\n' >"${STDERR}"
      printf '       podman machine ssh sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
    else
      printf 'Internal ERROR. Invalid podman type.\n' >"${STDERR}"
      return "${ERROR}"
    fi
    
    printf 'Press ENTER to continue or CTRL-C to abort.\n' >"${STDERR}"
    read -r
    printf '\n' >"${STDERR}"
  fi
}

# _CC_create_master_nodes creates the master node containers.
# Args: arg1 - number of master nodes to create
_CC_create_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating master container, '${_CC[clustername]}-master-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-master-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }
  done

  return "${OK}"
}

# _CC_setup_master_nodes sets up the master node containers.
# Args: arg1 - number of master nodes to create
_CC_setup_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile lbaddr hostaddr
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-master-${int}'" \
      _CC_set_up_master_node "${_CC[clustername]}-master-${int}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  done

  # For now, copy admin.conf from master to /var/tmp/admin-CLUSTERNAME.conf

  if [[ -z ${_CC[skipmastersetup]} ]]; then
    if [[ ${_CC[publish]} -eq ${TRUE} ]]; then
      # On MacOS we need to use localhost, on linux use the host IP
      if [[ $(CU_podmantype) == "native" ]]; then
        hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
      else
        hostaddr="localhost"
      fi
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${hostaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    elif [[ ${_CC[withlb]} -eq ${TRUE} ]]; then
      lbaddr=$(CU_get_container_ip "${_CC[clustername]}-lb") || err || return
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${lbaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    else
      [[ -n ${_CC[skipmastersetup]} ]] || {
        docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
          "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      }
    fi

    chmod 666 "/var/tmp/admin-${_CC[clustername]}.conf" || {
      printf 'ERROR: Could not "chown 666 /var/tmp/admin-%s.conf"' "${_CC[clustername]}"
      err || return
    }
  fi

  return "${OK}"
}

# _CC_set_up_master_node calls the correct set up function based on the version
# Args: arg1 - the container ID to set up
_CC_set_up_master_node() {

  case "${_CC[k8sver]}" in
  "1.30.0" | "1.30.1" | "1.31.1")
    _CC_set_up_master_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# _CC_get_master_join_details uses 'docker exec' or 'podman exec' to run a
# script on the master to get CA hash, a token, and the master IP.  The caller
# can eval the output of this function to set the variables: cahash, token, and
# masterip. See also:
# https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/#token-based-discovery-with-ca-pinning
# Args: arg1 - id/name of master container
_CC_get_master_join_details() {

  local joinvarsfile master1ip

  joinvarsfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  master1ip=$(CU_get_container_ip "${_CC[clustername]}-master-1") || err || return

  cat <<EnD >"${joinvarsfile}"
#!/bin/bash
set -e

sed 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${master1ip}"'\2#' \
  /etc/kubernetes/super-admin.conf >/etc/kubernetes/admin2.conf

cahash=\$(openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | \
        openssl rsa -pubin -outform der 2>/dev/null | \
        openssl dgst -sha256 -hex | sed 's/^.* //')
token=\$(kubeadm token create --kubeconfig=/etc/kubernetes/admin2.conf 2>/dev/null)
ip=\$(ip ro get 8.8.8.8 | cut -d" " -f 7)

printf 'cahash=%s\ntoken=%s\nmasterip=%s' "\$cahash" "\$token" "\$ip"

exit 0
EnD

  docker cp "${joinvarsfile}" "$1":/root/joinvars.sh 2>"${STDERR}" ||
    err || return
  rm -f "${joinvarsfile}" 2>"${STDERR}" || err || return

  [[ -z ${_CC[skipworkersetup]} ]] && {
    docker exec "$1" bash /root/joinvars.sh 2>"${STDERR}" || err || return
  }

  return "${OK}"
}

# _CC_create_lb_node creates the load balancer node container.
# Args: None expected.
_CC_create_lb_node() {

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  # Create container
  UT_run_with_progress \
    "    Creating load balancer container, '${_CC[clustername]}-lb'" \
    CU_create_container \
    "${_CC[clustername]}-lb" \
    "${labelkey}=${_CC[clustername]}" \
    "${_CC[k8sver]}"

  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    printf '\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
    printf '%s\n' "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  return "${OK}"
}

# _CC_setup_lb_node sets up the load balancer node container.
# Args: None expected.
_CC_setup_lb_node() {

  local runlogfile

  # Set up
  [[ -z ${_CC[skiplbsetup]} ]] && {
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-lb'" \
      _CC_set_up_lb_node_real "${_CC[clustername]}-lb"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _CC_set_up_lb_node_real sets up the lb node.
# Args: arg1 - the container ID to set up
_CC_set_up_lb_node_real() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masteriplist=
  nl=
  gotamaster="${FALSE}"
  for idx in $(seq 1 "${_CC[nummasters]}"); do
    ip=$(CU_get_container_ip "${_CC[clustername]}-master-${idx}") || continue
    gotamaster="${TRUE}"
    masteriplist="${masteriplist}${nl}    server master-${idx} ${ip}:6443 check fall 3 rise 2"
    nl='\n'
  done

  [[ ${gotamaster} == "${FALSE}" ]] && {
    printf 'ERROR: Did not manage to get an IP address for any master nodes\n'
    err || return
  }

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

systemctl stop kubelet crio
systemctl disable kubelet crio

apt -y install haproxy

INTERNAL_IP=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")

cat <<EOF | tee /etc/haproxy/haproxy.cfg 
frontend kubernetes
    bind \$INTERNAL_IP:6443
    option tcplog
    mode tcp
    default_backend kubernetes-master-nodes
backend kubernetes-master-nodes
    mode tcp
    balance roundrobin
    option tcp-check
\$(echo -e "${masteriplist}")
EOF

systemctl restart haproxy
systemctl enable haproxy

EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# _CC_create_worker_nodes creates the worker nodes.
# Args: arg1 - number of worker nodes to create
_CC_create_worker_nodes() {

  local cahash token t masterip
  declare -i int=0

  [[ -n ${_CC[skipmastersetup]} ]] || {
    # Runs a script on master node to get details
    t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1") || {
      printf '\nERROR: Problem with "_CC_get_master_join_details".\n\n' >"${STDERR}"
      return "${ERROR}"
    }

    # Sets cahash, token, and masterip:
    eval "${t}"
  }

  local labelkey
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating worker container, '${_CC[clustername]}-worker-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-worker-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }

    [[ -n ${_CC[skipworkersetup]} || -n ${_CC[skipmastersetup]} ]] || {
      UT_run_with_progress \
        "    Setting up '${_CC[clustername]}-worker-${int}'" \
        _CC_set_up_worker_node "${_CC[clustername]}-worker-${int}" \
        "${cahash}" "${token}" "${masterip}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n' >"${STDERR}"
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
        printf '%s\n' "${runlogfile}" >"${STDERR}"
        return "${ERROR}"
      }

      UT_run_with_progress \
        "    Waiting for system to become ready" \
        _CC_wait_for_cluster \
        "${_CC[clustername]}-master-1" \
        "${_CC[clustername]}-worker-${int}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n'
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Wait timed out.\n' >"${STDERR}"
        return "${ERROR}"
      }
    }
  done

  return "${OK}"
}

# _CC_wait_for_cluster runs a `kubectl` command in the master-1 container,
# which doesn't exit until the all pods are fully up and running before it
# returns.
# Args: arg1 - the master container name to log into
#       arg2 - the worker container name to wait for
_CC_wait_for_cluster() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  cat <<'EnD' >"${setupfile}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
found=0
for i in $(seq 1 20); do
  if kubectl get pods &>/dev/null; then
    found=1
    break
  fi
  sleep 1
done
[[ $found == 0 ]] && {
  printf '# kubectl get pods\n'
  kubectl get pods
  printf '\nWaited for 20 seconds for kubectl to work.\n'
  printf 'Kubectl cannot contact master. Aborting.\n'
  exit 1
}
counter=0
while ! kubectl get nodes | grep -qs "$1"; do
  ((counter++))
  [[ ${counter} -gt 60 ]] && {
    printf '# kubectl get nodes\n'
    kubectl get nodes
    printf '\nWaited for 2 minutes for node to appear in master. Aborting.\n'
    exit 1
  }
  sleep 2
done
counter=0
while kubectl get pods -A | tail -n +2 | awk '{ print $3; }' | grep -qs 0; do
  ((counter++))
  [[ ${counter} -gt 120 ]] && {
    printf '# kubectl get pods -A\n'
    kubectl get pods -A
    printf '\nWaited for 3 minutes for pods to be ready. Aborting.\n'
    exit 1
  }
  sleep 2
done
exit 0
EnD

  docker cp "${setupfile}" "$1":/root/wait.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/wait.sh "$2" || err
}

# _CC_set_up_worker_node calls the correct set up function based on the version.
# Args: arg1 - the container ID to set up
#       arg2 - the CA hash
#       arg3 - the token
#       arg4 - the master IP
_CC_set_up_worker_node() {

  case "${_CC[k8sver]}" in
  "1.30.0" | "1.30.1" | "1.31.1")
    _CC_set_up_worker_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# Initialise _CC
_CC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster - versions file

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR TRUE

# _CC_set_up_master_node_v1_30_0 uses kubeadm to set up the master node.
# Args: arg1 - the container to set up.
_CC_set_up_master_node_v1_30_0() {

  local setupfile lbaddr certSANs="{}" certkey masternum t lbip
  # Set by _CC_get_master_join_details:
  local cahash token masterip

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masternum="${1##*-}" # <- eg. for xxx-master-1, masternum=1

  if [[ ${_CC[skipmastersetup]} != "${TRUE}" ]]; then

    if [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -eq 1 ]]; then

      # This is the first master node

      # Sets cahash, token, and masterip:
      lbip=$(CU_get_container_ip "${_CC[clustername]}-lb")
      lbaddr=", '${lbip}'"
      uploadcerts="--upload-certs"
      certkey="CertificateKey: f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07"

    elif [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -ne 1 ]]; then

      # This is not the first master node, so join with the master
      # https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/

      # Keep trying to get join details until apiserver is ready or we run out of tries
      for try in $(seq 1 9); do
        # Runs a script on master node to get join details
        t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1")
        retval=$?
        [[ ${retval} -eq 0 ]] && break
        [[ ${try} -eq 9 ]] && {
          printf '\nERROR: Problem with "_CC_get_master_join_details". Tried %d times\n\n' "${try}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        sleep 5
      done
      eval "${t}"
    fi
  fi

  # Always set certSANs for the host whether we need it or not
  hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
  certSANs="
  certSANs: [ '${hostaddr}'${lbaddr}, '127.0.0.1', 'localhost' ]"

  # Apply the dns hack if there are no workers (single node cluster)
  if [[ ${_CC[numworkers]} -eq 0 ]]; then
    # I don't know why DNS resolution on single node clusters doesn't work but
    # I hope someone will finally figure it out. I've spent too long trying!
    dns_hack='sed -i "s/^ *- 10.96.0.10.*/- 10.244.0.2\n- 10.244.0.3/" /var/lib/kubelet/config.yaml'
  fi

  # Write the file regardless, so the user can use it if required

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

# Use a custom configuration. Default config created from kubeadm with:
#   kubeadm config print init-defaults
# then edited.

ipaddr=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")
podsubnet="10.244.0.0/16"
servicesubnet="10.96.0.0/16"

cat <<EOF >kubeadm-init-defaults.yaml
apiVersion: kubeadm.k8s.io/v1beta4
bootstrapTokens:
- groups:
  - system:bootstrappers:kubeadm:default-node-token
  token: abcdef.0123456789abcdef
  ttl: 24h0m0s
  usages:
  - signing
  - authentication
kind: InitConfiguration
${certkey}
localAPIEndpoint:
  advertiseAddress: \$ipaddr
  bindPort: 6443
nodeRegistration:
  criSocket: unix:///var/run/crio/crio.sock
  imagePullPolicy: IfNotPresent
  imagePullSerial: true
  name: $1
  taints:
  - effect: NoSchedule
    key: node-role.kubernetes.io/control-plane
timeouts:
  controlPlaneComponentHealthCheck: 4m0s
  discovery: 5m0s
  etcdAPICall: 2m0s
  kubeletHealthCheck: 4m0s
  kubernetesAPICall: 1m0s
  tlsBootstrap: 5m0s
  upgradeManifests: 5m0s
---
apiServer: ${certSANs}
apiVersion: kubeadm.k8s.io/v1beta4
caCertificateValidityPeriod: 87600h0m0s
certificateValidityPeriod: 8760h0m0s
certificatesDir: /etc/kubernetes/pki
clusterName: ${_CC[clustername]}-cluster
controlPlaneEndpoint: ${lbaddr:-\$ipaddr}:6443
controllerManager: {}
dns: {}
encryptionAlgorithm: RSA-2048
etcd:
  local:
    dataDir: /var/lib/etcd
imageRepository: registry.k8s.io
kind: ClusterConfiguration
networking:
  dnsDomain: cluster.local
  podSubnet: \${podsubnet}
  serviceSubnet: \${servicesubnet}
proxy: {}
scheduler: {}
EOF

mkdir -p /mok
cp kubeadm-init-defaults.yaml /mok/kubeadm.yaml

if [[ -z "${masterip}" ]]; then
  # Run the preflight phase
  kubeadm init \\
    --ignore-preflight-errors Swap \\
    --config=kubeadm-init-defaults.yaml \\
    phase preflight

  # Set up the kubelet
  kubeadm init phase kubelet-start

  # Edit the kubelet configuration file
  echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
  sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml
  ${dns_hack}

  # Tell kubeadm to carry on from here
  kubeadm init \\
    --config=kubeadm-init-defaults.yaml \\
    --ignore-preflight-errors Swap \\
    ${uploadcerts} \\
    --skip-phases=preflight,kubelet-start

  export KUBECONFIG=/etc/kubernetes/super-admin.conf

  # Flannel - 10.244.0.0./16
  kubectl apply -f /root/kube-flannel.yml
else
  kubeadm join ${masterip}:6443 \\
    --ignore-preflight-errors Swap \\
    --control-plane \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --certificate-key f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07
fi

systemctl enable kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  # Run the file
  [[ -z ${_CC[skipmastersetup]} ]] && {
    docker exec "$1" bash /root/setup.sh || err || return

    # Remove the taint if we're setting up a single node cluster

    [[ ${_CC[numworkers]} -eq 0 ]] && {

      removetaint=$(mktemp -p /var/tmp) || {
        printf 'ERROR: mktmp failed.\n' >"${STDERR}"
        return "${ERROR}"
      }

      # Write the file
      cat <<'EnD' >"${removetaint}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
kubectl taint nodes --all node-role.kubernetes.io/control-plane:NoSchedule-
EnD

      docker cp "${removetaint}" "$1":/root/removetaint.sh || err || {
        rm -f "${removetaint}"
        return "${ERROR}"
      }

      # Run the file
      docker exec "$1" bash /root/removetaint.sh || err
    }
  }

  return "${OK}"
}

# _CC_set_up_worker_node_v1_30_0 uses kubeadm to set up the worker node.
# Args: arg1 - the container to set up.
_CC_set_up_worker_node_v1_30_0() {

  local setupfile cahash="$2" token="$3" masterip="$4"

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  if [[ ${_CC[withlb]} == "${TRUE}" ]]; then
    masterip=$(CU_get_container_ip "${_CC[clustername]}-lb") || return
  fi

  cat <<EnD >"${setupfile}"
# Wait for the master API to become ready
while true; do
  curl -k https://${masterip}:6443/
  [[ \$? -eq 0 ]] && break
  sleep 1
done

# Do the preflight tests (ignoring swap error)
kubeadm join \\
  phase preflight \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --ignore-preflight-errors Swap \\
    ${masterip}:6443

# Set up the kubelet
kubeadm join \\
  phase kubelet-start \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    ${masterip}:6443 &

while true; do
  [[ -e /var/lib/kubelet/config.yaml ]] && break
    sleep 1
  done

# Edit the kubelet configuration file
echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

systemctl enable --now kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh 2>"${STDERR}" || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CU - Container Utilities

# _CU is an associative array that holds data specific to container utils.
declare -A _CU

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# CU_containerrt getter outputs the container runtime (podman or docker)
# that has been chosen.
CU_containerrt() {
  printf '%s' "${_CU[containerrt]}"
}

# CU_imgprefix getter outputs the prefix to be used with docker build. For
# podman it is 'localhost/'. For docker it is empty.
CU_imgprefix() {
  printf '%s' "${_CU[imgprefix]}"
}

# CU_labelkey getter outputs the key value of the label that is applied to all
# cluster member's container labels for podman or docker.
CU_labelkey() {
  printf '%s' "${_CU[labelkey]}"
}

# CU_podmantype getter outputs the container runtime type (native or machine).
CU_podmantype() {
  printf '%s' "${_CU[podmantype]}"
}

# Public Functions ------------------------------------------------------------

# CU_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted.
CU_cleanup() { :; }

# CU_get_cluster_container_ids outputs just the container IDs, one per line
# for any MOK cluster, unless arg1 is set, in which case just the IDs
# for the requested cluster name are output.
# Args: arg1 - The cluster name, optional.
CU_get_cluster_container_ids() {

  local value output

  [[ -n $1 ]] && value="=$1"

  output=$(docker ps -a -f label="${_CU[labelkey]}${value}" -q) || {
    printf 'ERROR: %s command failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  output=$(printf '%s' "${output}" | sed 's/$//')

  printf '%s' "${output}"

  return "${OK}"
}

# CU_get_cluster_size searches for an existing cluster using labels and outputs
# the number of containers in that cluster. All cluster nodes are labelled with
# "${_CU[labelkey]}=${CC[clustername]}"
# Args: arg1 - The cluster name to search for.
CU_get_cluster_size() {

  local output
  declare -a nodes

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Cluster name cannot be empty.\n' >"${STDERR}"
    err || return
  }

  output=$(CU_get_cluster_container_ids "$1") || err || return

  # readarray will read null as an array item so don't run
  # through readarray if it's null
  [[ -z ${output} ]] && {
    printf '0'
    return "${OK}"
  }

  # read the nodes array and delete blank lines
  readarray -t nodes <<<"${output}"

  printf '%d' "${#nodes[*]}"
}

# CU_get_container_ip outputs the IP address of the container.
# Args: arg1 - docker container id or container name to query.
CU_get_container_ip() {

  local info

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  info=$(CU_get_container_info "$1") || return
  JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}" ||
    err || return
}

# CU_get_container_info uses 'docker/podman inspect $id' to output
# container details.
# Args: arg1 - docker container id
CU_get_container_info() {

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  docker inspect "$1" || {
    printf 'ERROR: %s inspect failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_create_container creates and runs a container with settings suitable for
# running privileged containers that can manipulate cgroups.
# Args: arg1 - The string used to set the name and hostname.
#       arg2 - The label to assign to the container.
#       arg3 - The k8s base image version to use.
CU_create_container() {

  local imagename img allimgs systemd_always clustername parg pval

  [[ -z $1 || -z $2 || -z $3 ]] && {
    printf 'INTERNAL ERROR: Neither arg1, arg2 nor arg3 can be empty.\n' \
      >"${STDERR}"
    err || return
  }

  img=$(BI_baseimagename) || err || return

  local imglocal="${_CU[imgprefix]}local/${img}-v${3}"
  local imgremote="myownkind/${img}-v${3}"

  # Prefer a locally built container over one downloaded from a registry
  allimgs=$(docker images | tail -n +2) || {
    printf 'ERROR: %s returned an error\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  if echo "${allimgs}" | grep -qs "${imglocal}"; then
    imagename="${imglocal}"
  elif echo "${allimgs}" | grep -qs "${imgremote}"; then
    imagename="${imgremote}"
  else
    cat <<EnD
ERROR: No container base image found. Use either:

  $ mok build image
OR
  $ mok build image --get-prebuilt-image

Then try running 'mok create ...' again.
EnD
    return "${ERROR}"
  fi

  clustername=$(CC_clustername) || err || return

  if [[ ${_CU[containerrt]} == "podman" ]];
  then 
    docker network exists "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  else
    docker network inspect "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  fi

  [[ ${create_network} -ne 0 ]] && {
    docker network create "${clustername}_network" || {
      printf 'ERROR: docker network create failed\n' >"${STDERR}"
      err || return
    }
  }

  # Docker does not have the --systemd option
  [[ ${_CU[containerrt]} == "podman" ]] && systemd_always="--systemd=always"

  [[ $(CC_publish) == "${TRUE}" ]] && {
    if [[ $(CC_withlb) == "${TRUE}" ]]; then
      if echo "$1" | grep -qs -- '-lb$'; then
        parg='-p'
        pval='6443:6443'
      fi
    else
      if echo "$1" | grep -qs -- '-master-1$'; then
        parg='-p'
        pval='6443:6443'
      fi
    fi
  }

  docker run --privileged ${systemd_always} \
    --network "${clustername}_network" \
    -v /lib/modules:/lib/modules:ro \
    --detach ${parg} ${pval} \
    --name "$1" \
    --hostname "$1" \
    --label "$2" \
    "${imagename}" \
    /usr/local/bin/entrypoint /lib/systemd/systemd log-level=info unit=sysinit.target || {
    printf 'ERROR: %s run failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_podman_or_docker checks to see if docker and/or podman are installed and
# sets the imgprefix and containerrt array members accordingly. It also defines
# the docker function to run the detected container runtime. Podman is
# preferred if both are installed.
# Args: No args expected.
CU_podman_or_docker() {
  if type podman &>/dev/null; then
    _CU[imgprefix]="localhost/"
    _CU[containerrt]="podman"
    _CU_podman_checks || return

    # Override docker() to run podman
    # shellcheck disable=SC2317
    docker() {
      podman "$@"
    }
  elif type docker &>/dev/null; then
    _CU[imgprefix]=""
    _CU[containerrt]="docker"
    _CU_docker_checks || return
  else
    printf 'ERROR: Neither "podman" nor "docker" were found.\n' \
      >"${STDERR}"
    printf 'Please install one of "podman" or "docker".\nAborting.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi
  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CU_docker_checks checks to see if the current user has permission to write
# to the docker socket. If not, it prints an error message and exits.
# Args: No args expected.
_CU_docker_checks() {
  if docker ps >/dev/stdout 2>&1 | grep -qs 'docker.sock.*permission denied'; then
    cat <<EnD >"${STDERR}"
Not enough permissions to write to 'docker.sock'.

Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  fi

  return "${OK}"
}

# _CU_podman_checks sets the _CU[podmantype] member to "native" or "machine"
# depending on whether this is linux or macos. We assume linux won't be using
# a podman machine, and macos will always be using a podman machine.
# Args: No args expected.
_CU_podman_checks() {
  local info running

  if [[ -e /proc/sys/kernel/hostname ]]; then
    # We're on linux
    _CU[podmantype]="native"
    _CU_podman_native_checks || return
  elif [[ -d /System/Library/CoreServices ]]; then
    # We're on macOS
    [[ $(id -u) -eq 0 ]] && {
      printf 'ERROR: Cannot run mok as root on macOS.\n' >"${STDERR}"
      exit "${ERROR}"
    }

    info=$(podman machine list --format json) || err || return
    running=$(JSONPath -b '..Running' <<<"${info}") || err || return

    if [[ ${running} == "true" ]]; then
      _CU[podmantype]="machine"
    else
      printf 'ERROR: Podman machine is not running. Aborting.\n' >"${STDERR}"
      exit "${ERROR}"
    fi

    # shellcheck disable=SC2317
    ip() {
      podman machine ssh ip "$@"
    }
  else
    printf 'ERROR: Unknown OS. Aborting.\n' >"${STDERR}"
    exit "${ERROR}"
  fi
}

# _CU_podman_native_checks checks to see if the current user is root. If not,
# it prints an error message and exits.
# Args: No args expected.
_CU_podman_native_checks() {
  [[ $(id -u) -ne 0 ]] && {
    cat <<EnD >"${STDERR}"
Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  }
}

# _CU_new sets the initial values for the Container Utils associative array.
# Args: None expected.
_CU_new() {
  _CU[imgprefix]=
  _CU[labelkey]="MokCluster"
  _CU[containerrt]=

  # _CU[podmantype] will only be set only if _CU[containerrt]=podman.
  # podmantype will be "native" or "machine".
  _CU[podmantype]=
}

# Initialise _CU
_CU_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# BI - Build Image

# _BI is an associative array that holds data specific to building an image.
declare -A _BI

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE

# Getters/Setters -------------------------------------------------------------

# BI_setflag_useprebuiltimage setter sets the useprebuiltimage array item.
# This is called by the parser, via a callback in _BI_new.
BI_setflag_useprebuiltimage() {
  _BI[useprebuiltimage]="$1"
}

# BI_baseimagename getter outputs the value of the _BI[baseimagename].
# Args: None expected.
BI_baseimagename() {
  printf '%s' "${_BI[baseimagename]}"
}

# Public Functions ------------------------------------------------------------

# BI_usage outputs help text for the build image component.
# It is called by PA_usage(), via a callback in _BI_new.
# Args: None expected.
BI_usage() {

  # NOTE: This flag to be added back in the future
  # --get-prebuilt-image - Instead of building a 'node' image
  #        locally, download it from a container registry instead.

  cat <<'EnD'
BUILD subcommands are:
 
  image - Creates the docker 'mok-image' container image.
 
build image options:
 
 Format:
  build image

 Flags:
  --tailf - Show the build output whilst building.

EnD
}

# BI_cleanup removes temporary files created during the build.
# This function is called by the 'MA_cleanup' trap only.
# Args: None expected.
BI_cleanup() {
  [[ -e ${_BI[dockerbuildtmpdir]} ]] &&
    [[ ${_BI[dockerbuildtmpdir]} == "/var/tmp/"* ]] && {
    rm -rf "${_BI[dockerbuildtmpdir]}" || {
      printf 'ERROR: "rm -rf %s" failed.\n' "${_BI[dockerbuildtmpdir]}" \
        >"${STDERR}"
      err || return
    }
  }
}

# BI_check_valid_options checks if arg1 is in a list of valid build image
# options. This function is called by the parser, via a callback in _BI_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
BI_process_options() {

  case "$1" in
  -h | --help)
    BI_usage
    return "${STOP}"
    ;;
  --tailf)
    _BI[tailf]="${TRUE}"
    return "${OK}"
    ;;
  # NOTE: This flag to be added back in the future
  # --get-prebuilt-image)
  #   _BI[useprebuiltimage]="${TRUE}"
  #   return "${OK}"
  #   ;;
  *)
    BI_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# BI_run builds the base image used for masters and workers.
# This function is called in main.sh.
# Args: None expected.
BI_run() {

  _BI_sanity_checks || return

  [[ ${_BI[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  local retval=0
  _BI_build_container_image
  retval=$?

  if [[ ${retval} -eq ${OK} ]]; then
    : # We only need the tick - no text
  else
    printf 'Image build failed\n' >"${STDERR}"
    err
  fi

  return "${retval}"
}

# Private Functions -----------------------------------------------------------

# _BI_new resets the initial values for the _BI associative array.
# Args: None expected.
_BI_new() {
  _BI[tailf]="${FALSE}"
  _BI[baseimagename]="mok-image"
  _BI[useprebuiltimage]="${FALSE}"
  _BI[dockerbuildtmpdir]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "build" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "buildimage" "END" ""

  # Set up the parser's option callbacks
  PA_add_option_callback "build" "BI_process_options" || return
  PA_add_option_callback "buildimage" "BI_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "build" "BI_usage" || return
  PA_add_usage_callback "buildimage" "BI_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "buildimage" "BI_run"
}

# BI_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_BI_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    BI_usage
    exit "${OK}"
  fi
}

# _BI_build_container_image creates the docker build directory in
# dockerbuildtmpdir then calls docker build to build the image.
# Args: No args expected.
_BI_build_container_image() {

  local cmd retval tagname buildargs text buildtype

  _BI_create_docker_build_dir || return

  buildargs=$(_BI_get_build_args_for_latest) || return
  tagname="${_BI[baseimagename]}-v${K8SVERSION}"

  local imgprefix
  imgprefix=$(CU_imgprefix) || err || return
  if [[ ${_BI[useprebuiltimage]} == "${FALSE}" ]]; then
    buildtype="create"
    cmd="docker build \
      -t "${imgprefix}local/${tagname}" \
      --force-rm \
      ${buildargs} \
      ${_BI[dockerbuildtmpdir]}/${_BI[baseimagename]}"
    text="Creating"
  else
    buildtype="download"
    cmd="docker pull myownkind/${tagname}"
    text="Downloading"
  fi

  UT_run_with_progress \
    "    ${text} base image, '${tagname}'" "${cmd}"

  retval=$?
  [[ ${retval} -ne ${OK} ]] && {
    local runlogfile
    runlogfile=$(UT_runlogfile) || err || return
    printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\n' >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${buildtype} == "create" ]] && {
    cmd="_BI_modify_container_image"

    UT_run_with_progress \
      "    Modifying base image (pulling kubernetes images)" "${cmd}"

    retval=$?
    [[ ${retval} -ne ${OK} ]] && {
      local runlogfile
      runlogfile=$(UT_runlogfile) || err || return
      printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\n' >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _BI_modify_container_image starts a container suitable for running kubernetes
# components (since the docker/podman build environment isn't suitable), makes
# some modifications and then 'commits' the image. The modifications allow
# `mok create ...` to complete more quickly.
# Args: No args expected.
_BI_modify_container_image() {

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify &>/dev/null
  docker rm mok-build-modify &>/dev/null

  CC_set_clustername "build" || err || return

  # Start container
  CU_create_container "mok-build-modify" "mok-build-modify" "${K8SVERSION}" ||
    return

  # Wait for crio to become ready
  printf '\n\n ** WAITING FOR CRIO TO BECOME READY **\n\n'
  while ! docker exec mok-build-modify systemctl status crio; do
    sleep 1
    [[ ${counter} -gt 10 ]] && {
      printf '\nERROR: CRI-O did not start after %d tries.\n' "${counter}"
      err || return
    }
    ((counter++))
  done

  # Modify container
  docker exec mok-build-modify kubeadm config images pull \
    --kubernetes-version "${K8SVERSION}" || err || return

  # Stop container
  docker stop -t 5 "mok-build-modify"

  # Write image
  local imgprefix tagname
  imgprefix=$(CU_imgprefix) || err || return
  tagname="${_BI[baseimagename]}-v${K8SVERSION}"
  docker commit mok-build-modify "${imgprefix}local/${tagname}" || err || return

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify
  docker rm mok-build-modify || err || return

  return "${OK}"
}

# _BI_get_build_args_for_latest sets the buildargs variable that is added
# to the 'podman build ...' command line.  Only the latest version is built
# from scratch.  Earlier versions are downloaded using '--get-prebuilt-image'.
# Args: None expected
_BI_get_build_args_for_latest() {

  local buildargs

  buildargs="--build-arg GO_VERSION=${GO_VERSION}"

  printf '%s' "${buildargs}"
}

# _BI_create_docker_build_dir creates a docker build directory in
# /var/tmp/tmp.XXXXXXXX
# Args: None expected
_BI_create_docker_build_dir() {

  _BI[dockerbuildtmpdir]="$(mktemp -d -p /var/tmp)" || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }

  # The following comments should not be removed or changed.
  # embed-dockerfile.sh adds a base64 encoded tarball and
  # unpacking code between them.

  #mok-image-tarball-start 
  cat <<EnD | base64 -d | tar xz -C "${_BI[dockerbuildtmpdir]}" 
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
D5+Hz8Pn4fPw+U///H/biIzSALgBAA==
EnD
  #mok-image-tarball-end
}

# Initialise _BI
_BI_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
#!/usr/bin/env bash

declare -A JSONPath

JSONPath_new() {
  JSONPath[DEBUG]=0
  JSONPath[INCLEMPTY]=0
  JSONPath[NOCASE]=0
  JSONPath[WHOLEWORD]=0
  JSONPath[FILE]=
  JSONPath[NO_HEAD]=0
  JSONPath[NORMALIZE_SOLIDUS]=0
  JSONPath[BRIEF]=0
  JSONPath[PASSTHROUGH]=0
  JSONPath[JSON]=0
  JSONPath[MULTIPASS]=0
  JSONPath[FLATTEN]=0
  JSONPath[STDINFILE]=/var/tmp/JSONPath.$$.stdin
  JSONPath[STDINFILE2]=/var/tmp/JSONPath.$$.stdin2
  JSONPath[PASSFILE]=/var/tmp/JSONPath.$$.pass1
  declare -a INDEXMATCH_QUERY
}

# JSONPath reads JSON from stdin and applies a JSON Path query.
# Args: arg1-N - command line arguments to be parsed.
JSONPath() {

  JSONPath_sanity_checks
  JSONPath_parse_options "$@"

  trap JSONPath_cleanup EXIT

  if [[ ${QUERY} == *'?(@'* ]]; then
    # This will be a multipass query

    [[ -n ${JSONPath[FILE]} ]] && JSONPath[STDINFILE]=${JSONPath[FILE]}
    [[ -z ${JSONPath[FILE]} ]] && cat >"${JSONPath[STDINFILE]}"

    while true; do
      JSONPath_tokenize_path
      JSONPath_create_filter

      JSONPath_tokenize | JSONPath_parse | JSONPath_filter |
        JSONPath_indexmatcher >"${JSONPath[PASSFILE]}" <"${JSONPath[STDINFILE]}"

      [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && {
        # replace filter expression with index sequence
        SET=$(sed -rn 's/.*[[,"]+([0-9]+)[],].*/\1/p' "${JSONPath[PASSFILE]}" | tr '\n' ,)
        SET=${SET%,}
        #QUERY=$(sed "s/?(@[^)]\+)/${SET}/" <<<"${QUERY}")
        # Testing:
        QUERY="${QUERY//\?\(@*)/${SET}}"
        [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "QUERY=${QUERY}" >/dev/stderr
        JSONPath_reset
        continue
      }

      JSONPath_flatten | JSONPath_json | JSONPath_brief <<<"${JSONPath[PASSFILE]}"

      break
    done

  else

    JSONPath_tokenize_path
    JSONPath_create_filter

    if [[ ${JSONPath[PASSTHROUGH]} -eq 1 ]]; then
      JSONPath[JSON]=1
      JSONPath_flatten | JSONPath_json
    elif [[ -z ${JSONPath[FILE]} ]]; then
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten | JSONPath_json | JSONPath_brief
    else
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten <"${JSONPath[FILE]}"
      JSONPath_json | JSONPath_brief
    fi

  fi
}

JSONPath_sanity_checks() {

  local binary

  # Reset some vars
  for binary in gawk grep sed; do
    if ! command -v "${binary}" >&/dev/null; then
      echo "ERROR: ${binary} binary not found in path. Aborting."
      exit 1
    fi
  done
}

JSONPath_reset() {

  # Reset some vars
  declare -a INDEXMATCH_QUERY
  PATHTOKENS=
  FILTER=
  OPERATOR=
  RHS=
  JSONPath[MULTIPASS]=0
}

JSONPath_cleanup() {

  [[ -e ${JSONPath[PASSFILE]} ]] && rm -f "${PASSFILE}"
  [[ -e ${JSONPath[STDINFILE2]} ]] && rm -f "${JSONPath[STDINFILE2]}"
  [[ -z ${JSONPath[FILE]} && -e ${JSONPath[STDINFILE]} ]] &&
    rm -f "${JSONPath[STDINFILE]}"
}

JSONPath_usage() {

  echo
  echo "Usage: JSONPath.sh [-b] [j] [-h] [-f FILE] [pattern]"
  echo
  echo "pattern - the JSONPath query. Defaults to '$.*' if not supplied."
  echo "-b      - Brief. Only show values."
  echo "-j      - JSON output."
  echo "-u      - Strip unnecessary leading path elements."
  echo "-i      - Case insensitive."
  echo "-p      - Pass-through to the JSON parser."
  echo "-w      - Match whole words only (for filter script expression)."
  echo "-f FILE - Read a FILE instead of stdin."
  echo "-h      - This help text."
  echo
}

JSONPath_parse_options() {

  set -- "$@"
  local ARGN=$#
  while [[ ${ARGN} -ne 0 ]]; do
    case $1 in
    -h)
      JSONPath_usage
      exit 0
      ;;
    -f)
      shift
      JSONPath[FILE]=$1
      ;;
    -i)
      JSONPath[NOCASE]=1
      ;;
    -j)
      JSONPath[JSON]=1
      ;;
    -n)
      JSONPath[NO_HEAD]=1
      ;;
    -b)
      JSONPath[BRIEF]=1
      ;;
    -u)
      JSONPath[FLATTEN]=1
      ;;
    -p)
      JSONPath[PASSTHROUGH]=1
      ;;
    -w)
      JSONPath[WHOLEWORD]=1
      ;;
    -s)
      JSONPath[NORMALIZE_SOLIDUS]=1
      ;;
    *)
      QUERY=$1
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done
  [[ -z ${QUERY} ]] && QUERY='$.*'
}

JSONPath_awk_egrep() {
  local pattern_string=$1

  gawk '{
    while ($0) {
      start=match($0, pattern);
      token=substr($0, start, RLENGTH);
      print token;
      $0=substr($0, start+RLENGTH);
    }
  }' pattern="${pattern_string}"
}

JSONPath_tokenize() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    ESCAPE='(\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
    ESCAPE='(\\\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\\\]'
  fi

  local STRING="\"${CHAR}*(${ESCAPE}${CHAR}*)*\""
  local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'
  local KEYWORD='null|false|true'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  ${GREP} "${STRING}|${NUMBER}|${KEYWORD}|${SPACE}|." | grep -Ev "^${SPACE}$"
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

JSONPath_tokenize_path() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
  fi

  local WILDCARD='\*'
  local WORD='[ A-Za-z0-9_-]*'
  local INDEX="\\[${WORD}(:${WORD}){0,2}\\]"
  local INDEXALL='\[\*\]'
  local STRING="[\\\"'][^[:cntrl:]\\\"']*[\\\"']"
  local SET="\\[(${WORD}|${STRING})(,(${WORD}|${STRING}))*\\]"
  local FILTER='\?\(@[^)]+'
  local DEEPSCAN='\.\.'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  readarray -t PATHTOKENS < <(echo "${QUERY}" |
    ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
    grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$")
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    echo "grep -Eo '${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|.'" >/dev/stderr
    echo -n "TOKENISED QUERY="
    echo "${QUERY}" |
      ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
      grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$" >/dev/stderr
  }
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

# JSONPath_create_filter creates the filter from the user's query.
# Filter works in a single pass through the data, unless a filter (script)
#  expression is used, in which case two passes are required (MULTIPASS=1).
JSONPath_create_filter() {

  local len=${#PATHTOKENS[*]}

  local -i i=0
  local a query="^\[" comma=
  while [[ i -lt len ]]; do
    case "${PATHTOKENS[i]}" in
    '"')
      :
      ;;
    '..')
      query+="${comma}[^]]*"
      comma=
      ;;
    '[*]')
      query+="${comma}[^,]*"
      comma=","
      ;;
    '*')
      query+="${comma}(\"[^\"]*\"|[0-9]+[^],]*)"
      comma=","
      ;;
    '?(@'*)
      a=${PATHTOKENS[i]#?(@.}
      elem="${a%%[<>=!]*}"
      rhs="${a##*[<>=!]}"
      a="${a#${elem}}"
      elem="${elem//./[\",.]+}" # Allows child node matching
      operator="${a%${rhs}}"
      [[ -z ${operator} ]] && {
        operator="=="
        rhs=
      }
      if [[ ${rhs} == *'"'* || ${rhs} == *"'"* ]]; then
        case ${operator} in
        '==' | '=')
          OPERATOR=
          if [[ ${elem} == '?(@' ]]; then
            # To allow search on @.property such as:
            #   $..book[?(@.title==".*Book 1.*")]
            query+="${comma}[0-9]+[],][[:space:]\"]*${rhs//\"/}"
          else
            # To allow search on @ (this node) such as:
            #   $..reviews[?(@==".*Fant.*")]
            query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs//\"/}"
          fi
          FILTER="${query}"
          ;;
        '>=' | '>')
          OPERATOR=">"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=' | '<')
          OPERATOR="<"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      else
        case ${operator} in
        '==' | '=')
          OPERATOR=
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs}"
          FILTER="${query}"
          ;;
        '>=')
          OPERATOR="-ge"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '>')
          OPERATOR="-gt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=')
          OPERATOR="-le"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<')
          OPERATOR="-lt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      fi
      JSONPath[MULTIPASS]=1
      ;;
    "["*)
      if [[ ${PATHTOKENS[i]} =~ , ]]; then
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          # converts only one comma: s/("[^"]+),([^"]+")/\1`\2/g;s/"//g
          #a=$(echo $a | sed 's/\([[:alpha:]]*\)/"\1"/g')
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        fi
        query+="${comma}(${a//,/|})"
      elif [[ ${PATHTOKENS[i]} =~ : ]]; then
        if ! [[ ${PATHTOKENS[i]} =~ [0-9][0-9] || ${PATHTOKENS[i]} =~ :] ]]; then
          if [[ ${PATHTOKENS[i]#*:} =~ : ]]; then
            INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
            query+="${comma}[^,]*"
          else
            # Index in the range of 0-9 can be handled by regex
            query+="${comma}$(echo "${PATHTOKENS[i]}" |
              gawk '/:/ { a=substr($0,0,index($0,":")-1);
                         b=substr($0,index($0,":")+1,index($0,"]")-index($0,":")-1);
                         if(b>0) { print a ":" b-1 "]" };
                         if(b<=0) { print a ":]" } }' |
              sed 's/\([0-9]\):\([0-9]\)/\1-\2/;
                       s/\[:\([0-9]\)/[0-\1/;
                       s/\([0-9]\):\]/\1-9999999]/')"
          fi
        else
          INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
          query+="${comma}[^,]*"
        fi
      else
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        else
          [[ ${i} -gt 0 ]] && comma=","
        fi
        query+="${comma}${a}"
      fi
      comma=","
      ;;
    *)
      PATHTOKENS[i]=${PATHTOKENS[i]//\'/\"}
      query+="${comma}\"${PATHTOKENS[i]//\"/}\""
      comma=","
      ;;
    esac
    i=$((i + 1))
  done

  [[ -z ${FILTER} ]] && FILTER="${query}[],]"
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
}

JSONPath_parse_array() {

  local index=0
  local ary=''
  read -r token
  case "${token}" in
  ']') ;;

  *)
    while :; do
      JSONPath_parse_value "$1" "${index}"
      index=$((index + 1))
      ary="${ary}""${value}"
      read -r token
      case "${token}" in
      ']') break ;;
      ',') ary="${ary}," ;;
      *) JSONPath_throw "EXPECTED , or ] GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_object() {

  local key
  local obj=''
  read -r token
  case "${token}" in
  '}') ;;

  *)
    while :; do
      case "${token}" in
      '"'*'"') key=${token} ;;
      *) JSONPath_throw "EXPECTED string GOT ${token:-EOF}" ;;
      esac
      read -r token
      case "${token}" in
      ':') ;;
      *) JSONPath_throw "EXPECTED : GOT ${token:-EOF}" ;;
      esac
      read -r token
      JSONPath_parse_value "$1" "${key}"
      obj="${obj}${key}:${value}"
      read -r token
      case "${token}" in
      '}') break ;;
      ',') obj="${obj}," ;;
      *) JSONPath_throw "EXPECTED , or } GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_value() {

  local jpath="${1:+$1,}$2" isleaf=0 isempty=0 print=0
  case "${token}" in
  '{') JSONPath_parse_object "${jpath}" ;;
  '[') JSONPath_parse_array "${jpath}" ;;
    # At this point, the only valid single-character tokens are digits.
  '' | [!0-9]) JSONPath_throw "EXPECTED value GOT ${token:-EOF}" ;;
  *)
    value=${token}
    # if asked, replace solidus ("\/") in json strings with normalized value: "/"
    # Testing:
    #[ "${JSONPath[NORMALIZE_SOLIDUS]}" -eq 1 ] && value=$(echo "${value}" | sed 's#\\/#/#g')
    [[ ${JSONPath[NORMALIZE_SOLIDUS]} -eq 1 ]] && value=$(${value//\\\///})
    isleaf=1
    [[ ${value} == '""' ]] && isempty=1
    ;;
  esac
  [[ -z ${JSONPath[INCLEMPTY]} ]] && [[ ${value} == '' ]] && return
  [[ ${JSONPath[NO_HEAD]} -eq 1 ]] && [[ -z ${jpath} ]] && return

  [[ ${isleaf} -eq 1 ]] && [[ ${isempty} -eq 0 ]] && print=1
  [[ ${print} -eq 1 ]] && printf "[%s]\t%s\n" "${jpath}" "${value}"
  :
}

JSONPath_flatten() {

  local path a prevpath pathlen

  if [[ ${JSONPath[FLATTEN]} -eq 1 ]]; then
    cat >"${JSONPath[STDINFILE2]}"

    highest=9999

    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      [[ -z ${prevpath} ]] && {
        prevpath=("${path[@]}")
        highest=$((${#path[*]} - 1))
        continue
      }

      pathlen=$((${#path[*]} - 1))

      for i in $(seq 0 "${pathlen}"); do
        [[ ${path[i]} != "${prevpath[i]}" ]] && {
          high=${i}
          break
        }
      done

      [[ ${high} -lt ${highest} ]] && highest=${high}

      prevpath=("${path[@]}")
    done <"${JSONPath[STDINFILE2]}"

    if [[ ${highest} -gt 0 ]]; then
      sed -r 's/\[(([0-9]+|"[^"]+")[],]){'$((highest))'}(.*)/[\3/' \
        "${JSONPath[STDINFILE2]}"
    else
      cat "${JSONPath[STDINFILE2]}"
    fi
  else
    cat
  fi
}

# JSONPath_indexmatcher is for double digit or greater indexes match each line
# individually Single digit indexes are handled more efficiently by regex
JSONPath_indexmatcher() {

  local a b

  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
      echo "INDEXMATCH_QUERY[${i}]=${INDEXMATCH_QUERY[i]}" >/dev/stderr
    done
  }

  matched=1

  step=
  if [[ ${#INDEXMATCH_QUERY[*]} -gt 0 ]]; then
    while read -r line; do
      for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
        [[ ${INDEXMATCH_QUERY[i]#*:} =~ : ]] && {
          step=${INDEXMATCH_QUERY[i]##*:}
          step=${step%]}
          INDEXMATCH_QUERY[i]="${INDEXMATCH_QUERY[i]%:*}]"
        }
        q=${INDEXMATCH_QUERY[i]:1:-1} # <- strip '[' and ']'
        a=${q%:*}                     # <- number before ':'
        b=${q#*:}                     # <- number after ':'
        [[ -z ${b} ]] && b=99999999999
        readarray -t num < <((grep -Eo '[0-9]+[],]' | tr -d ,]) <<<"${line}")
        if [[ ${num[i]} -ge ${a} && ${num[i]} -lt ${b} && matched -eq 1 ]]; then
          matched=1
          [[ ${i} -eq $((${#INDEXMATCH_QUERY[*]} - 1)) ]] && {
            if [[ ${step} -gt 1 ]]; then
              [[ $(((num[i] - a) % step)) -eq 0 ]] && {
                [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
                echo "${line}"
              }
            else
              [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
              echo "${line}"
            fi
          }
        else
          matched=0
          continue
        fi
      done
      matched=1
    done
  else
    cat -
  fi
}

JSONPath_brief() {
  # Only show the value

  if [[ ${JSONPath[BRIEF]} -eq 1 ]]; then
    sed 's/^[^\t]*\t//;s/^"//;s/"$//;'
  else
    cat
  fi
}

JSONPath_json() {
  # Turn output into JSON

  local a tab="$'\t'"
  local UP=1 DOWN=2 SAME=3
  local prevpathlen=-1 prevpath=() path a
  declare -a closers

  if [[ ${JSONPath[JSON]} -eq 0 ]]; then
    cat -
  else
    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      value=${line#*${tab}}

      # Not including the object itself (last item)
      pathlen=$((${#path[*]} - 1))

      # General direction

      direction=${SAME}
      [[ ${pathlen} -gt ${prevpathlen} ]] && direction=${DOWN}
      [[ ${pathlen} -lt ${prevpathlen} ]] && direction=${UP}

      # Handle jumps UP the tree (close previous paths)

      [[ ${prevpathlen} != -1 ]] && {
        for i in $(seq 0 $((pathlen - 1))); do
          [[ ${prevpath[i]} == "${path[i]}" ]] && continue
          [[ ${path[i]} != '"'* ]] && {
            # Testing double quotes:
            a="(${!arrays[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                arrays[k]=
              done
            }
            a="(${!comma[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                comma[k]=
              done
            }
            for j in $(seq $((prevpathlen)) -1 $((i + 2))); do
              arrays[j]=
              [[ -n ${closers[j]} ]] && {
                indent=$((j * 4))
                printf "\n%${indent}s${closers[j]}" ""
                unset "closers[j]"
                comma[j]=
              }
            done
            direction=${DOWN}
            break
          }
          direction=${DOWN}
          for j in $(seq $((prevpathlen)) -1 $((i + 1))); do
            arrays[j]=
            [[ -n ${closers[j]} ]] && {
              indent=$((j * 4))
              printf "\n%${indent}s${closers[j]}" ""
              unset "closers[j]"
              comma[j]=
            }
          done
          a="(${!arrays[*]})"
          [[ -n ${a} ]] && {
            for k in $(seq "${i}" "${a[-1]}"); do
              arrays[k]=
            done
          }
          break
        done
      }

      [[ ${direction} -eq ${UP} ]] && {
        [[ ${prevpathlen} != -1 ]] && comma[prevpathlen]=
        for i in $(seq $((prevpathlen + 1)) -1 $((pathlen + 1))); do
          arrays[i]=
          [[ -n ${closers[i]} ]] && {
            indent=$((i * 4))
            printf "\n%${indent}s${closers[i]}" ""
            unset "closers[i]"
            comma[i]=
          }
        done
        a="(${!arrays[*]})"
        [[ -n ${a} ]] && {
          for k in $(seq "${i}" "${a[-1]}"); do
            arrays[k]=
          done
        }
      }

      # Opening braces (the path leading up to the key)

      broken=
      for i in $(seq 0 $((pathlen - 1))); do
        [[ -z ${broken} && ${prevpath[i]} == "${path[i]}" ]] && continue
        [[ -z ${broken} ]] && {
          broken=${i}
          [[ ${prevpathlen} -ne -1 ]] && broken=$((i + 1))
        }
        if [[ ${path[i]} == '"'* ]]; then
          # Object
          [[ ${i} -ge ${broken} ]] && {
            indent=$((i * 4))
            printf "${comma[i]}%${indent}s{\n" ""
            closers[i]='}'
            comma[i]=
          }
          indent=$(((i + 1) * 4))
          printf "${comma[i]}%${indent}s${path[i]}:\n" ""
          comma[i]=",\n"
        else
          # Array
          if [[ ${arrays[i]} != 1 ]]; then
            indent=$((i * 4))
            printf "%${indent}s" ""
            echo "["
            closers[i]=']'
            arrays[i]=1
            comma[i]=
          else
            indent=$(((i + 1) * 4))
            printf "\n%${indent}s${closers[i - 1]}" ""
            direction=${DOWN}
            comma[i + 1]=",\n"
          fi
        fi
      done

      # keys & values

      if [[ ${path[-1]} == '"'* ]]; then
        # Object
        [[ ${direction} -eq ${DOWN} ]] && {
          indent=$((pathlen * 4))
          printf "${comma[pathlen]}%${indent}s{\n" ""
          closers[pathlen]='}'
          comma[pathlen]=
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${path[-1]}:${value}"
        comma[pathlen]=",\n"
      else
        # Array
        [[ ${arrays[i]} != 1 ]] && {
          indent=$(((pathlen - 0) * 4))
          printf "%${indent}s[\n" ""
          closers[pathlen]=']'
          comma[pathlen]=
          arrays[i]=1
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${value}"
        comma[pathlen]=",\n"
      fi

      prevpath=("${path[@]}")
      prevpathlen=${pathlen}
    done

    # closing braces

    for i in $(seq $((pathlen)) -1 0); do
      indent=$((i * 4))
      printf "\n%${indent}s${closers[i]}" ""
    done
    echo
  fi
}

JSONPath_filter() {
  # Apply the query filter

  local a tab=$'\t' v

  [[ ${JSONPath[NOCASE]} -eq 1 ]] && opts+="i"
  [[ ${JSONPath[WHOLEWORD]} -eq 1 ]] && opts+="w"
  if [[ -z ${OPERATOR} ]]; then
    [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && FILTER="${FILTER}[\"]?$"
    grep "-E${opts}" "${FILTER}"
    [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
  else
    grep "-E${opts}" "${FILTER}" |
      while read -r line; do
        v=${line#*${tab}}
        case ${OPERATOR} in
        '-ge')
          if gawk '{exit !($1>=$2)}' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-gt')
          if gawk '{exit !($1>$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-le')
          if gawk '{exit !($1<=$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-lt')
          if gawk '{exit !($1<$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '>')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} > ${RHS,,} ]] && echo "${line}"
          ;;
        '<')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} < ${RHS,,} ]] && echo "${line}"
          ;;
        *) return 1 ;;
        esac
      done
  fi
}

JSONPath_parse() {
  # Parses json

  read -r token
  JSONPath_parse_value
  read -r token
  case "${token}" in
  '') ;;
  *)
    JSONPath_throw "EXPECTED EOF GOT ${token}"
    exit 1
    ;;
  esac
}

JSONPath_throw() {
  echo "$*" >&2
  exit 1
}

JSONPath_new || exit 1

# vi: expandtab sw=2 ts=2
# shellcheck shell=bash disable=SC2148
# MA - execution starts here

# MA is an associative array that holds data specific to this file
declare -A _MA

# Defined in GL (globals.sh)
declare OK ERROR STOP STDERR TRUE

# Getters/Setters -------------------------------------------------------------

# MA_program_args getter outputs the program arguments sent by the user.
MA_program_args() {
  printf '%s' "${_MA[program_args]}"
}

# Public Functions ------------------------------------------------------------

# main is the start point for this application.
# Args: arg1-N - the command line arguments entered by the user.
MA_main() {
  local retval="${OK}"

  CU_podman_or_docker

  trap MA_cleanup EXIT
  MA_sanity_checks || return
  PA_run "$@" || retval=$?

  exit "${retval}"
}

# MA_version outputs the version information the exits.
MA_version() {
  printf 'Version: %s\n' "${MOKVERSION}"
  exit "${OK}"
}

# MA_process_global_options is called by the parser when a global option is
# encountered for processing.
# Args: arg1 - the global option that was found.
MA_process_global_options() {
  case "$1" in
  -h | --help)
    PA_usage
    return "${STOP}"
    ;;
  -p | --plain)
    UT_set_plain "${TRUE}"
    ;;
  *)
    printf 'INTERNAL ERROR: Invalid global option, "%s".' "$1"
    return "${ERROR}"
    ;;
  esac
}

# MA_cleanup is called from an EXIT trap only, when the program exits, and
# calls every other function matching the pattern '^.._cleanup'.
# Args: No args expected.
MA_cleanup() {
  local retval="${OK}" funcs func
  funcs=$(declare -F | awk '{print $NF;}' | grep '^.._cleanup')
  for func in ${funcs}; do
    [[ ${func} == "${FUNCNAME[0]}" ]] && continue
    eval "${func}" || retval=$?
  done
  return "${retval}"
}

# MA_sanity_checks is expected to run some quick and simple checks to
# see if key components are available before MA_main is called.
# Args: No args expected.
MA_sanity_checks() {

  local binary

  if [[ ${_CU[podmantype]} == "native" ]]; then
    binaries="gawk tac column tput grep sed ip cut"
  else
    binaries="gawk tac column tput grep sed cut"
  fi

  for binary in ${binaries}; do
    if ! command -v "${binary}" >&/dev/null; then
      printf 'ERROR: "%s" binary not found in path. Aborting.' "${binary}" \
        >"${STDERR}"
      return "${ERROR}"
    fi
  done

  # Disable terminal escapes (colours) if stdout is not a terminal
  [ -t 1 ] || UT_disable_colours
}

# MA_usage outputs help text for all components then quits with no error.  This
# is registered as a callback in the Parser, see _MA_new
# Args: None expected.
MA_usage() {

  cat <<'EnD'
Usage: mok [-h] <command> [subcommand] [ARGS...]
 
Global options:
  --help
  -h     - This help text
  --plain
  -p     - Plain output. No colours or animations.
 
Where command can be one of:
  create  - Add item(s) to the system.
  delete  - Delete item(s) from the system.
  build   - Build item(s) used by the system.
  get     - Get details about items in the system.
  exec    - 'Log in' to the container.
  version - Display version information.

For help on a specific command, run:
  mok <command> --help
EnD
}

# MA_new sets the initial values for the _MA associative array
_MA_new() {
  _MA[program_args]="$*"

  # Program the parser's state machine
  PA_add_state "COMMAND" "version" "END" "MA_version"

  # Set up the parser's option callbacks
  PA_add_option_callback "" "MA_process_global_options"

  # Set up the parser's usage callbacks
  PA_add_usage_callback "" "MA_usage"
}

# Initialise _MA
_MA_new "$@" || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
if [ "$0" = "${BASH_SOURCE[0]}" ] || [ -z "${BASH_SOURCE[0]}" ]; then
  MA_main "$@"
fi
