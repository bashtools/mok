#!/usr/bin/env bash
# shellcheck shell=bash disable=SC2148
# PA - PArser

# _PA holds data specific to parsing the command line arguments.
declare -A _PA

# Declare externally defined variables ----------------------------------------

# Defined in ER (globals.sh)
declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# PA_command getter outputs the _PA[command] array member. This contains the
# command the user requested.
PA_command() {
  printf '%s' "${_PA[command]}"
}

# PA_subcommand getter outputs the _PA[subcommand] array member. This contains
# the subcommand the user requested.
PA_subcommand() {
  printf '%s' "${_PA[subcommand]}"
}

# PA_shift outputs the _PA[shift] array member, returned by the caller
# when an extra shift is required whilst consuming option values.
#
# Example code:
# ```
#XX_process_options_callback() {
#
#  case "$1" in
#  -h | --help)
#    CC_usage
#    return "${STOP}"
#    ;;
#    ... omitted ...
#  --k8sver)
#    _CC[k8sver]="$2"
#    return "$(PA_shift)"
#    ;;
#  --with-lb)
#    ... omitted ..
# ```
PA_shift() {
  printf '%s' "${_PA[shift]}"
}

# PA_set_state setter sets the initial state of the parser, which should be one
# of COMMAND, SUBCOMMAND, or ARG1.
# Args: arg1 - the initial state to set.
PA_set_state() {
  _PA[state]="$1"
}

# Public Functions ------------------------------------------------------------

# PA_add_option_callback adds a callback to the list of callbacks used for
# processing options.
# Args: arg1 - Null string (for global options), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_option_callback() {
  _PA[optscallbacks]+="$1,$2 "
}

# PA_add_usage_callback adds a callback to the list of callbacks used for
# output of help text.
# Args: arg1 - Null string (for global help), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_usage_callback() {
  _PA[usagecallbacks]+="$1,$2 "
}

# PA_add_state adds a callback to the list of callbacks used for
# programming the state machine.
# Args: arg1 - Current state to match.
#       arg2 - The value of the state to match.
#       arg3 - The new state if arg1 and arg2 match.
#       arg4 - The function to call, optional.
PA_add_state() {
  _PA[statecallbacks]+="$1,$2,$3,$4 "
}

# PA_add_run_callback adds a callback to the list of callbacks used for
# running the user defined entrypoint function.
# Args: arg1 - The value of the state to match. Probably like:
#              "commandsubcommand" "function"
#       arg2 - The function to call.
PA_add_run_callback() {
  _PA[runcallbacks]+="$1,$2 "
}

# PA_run implements an interleaved state machine to process the
# user request. It allows for strict checking of arguments and args. All
# command line arguments are processed in order from left to right.
#
# Each COMMAND can have a different set of requirements which are controlled
# by setting the next state at each transition.
#
# --global-options COMMAND --command-options SUBCOMMAND --subcommand-options \
#  ARG1 --subcommand-options ARG2 --subcommand-options ...
#
# --global-options are those before COMMAND.
# --command-options can be after the COMMAND but before SUBCOMMAND.
# --subcommand-options can be anywhere after the SUBCOMMAND.
#
# Args: arg1-N - The arguments given to mok by the user on the command line
PA_run() {

  local retval=${OK}

  set -- "$@"
  local ARGN=$# ARGNUM=0 retval=0
  while [ "${ARGN}" -ne 0 ]; do
    case "$1" in
    --* | -*)
      _PA_process_option "$1" "$2" || {
        retval=$?
        if [[ ${retval} == "${_PA[shift]}" ]]; then
          ARGN=$((ARGN - 1))
          shift
        else
          return "${retval}"
        fi
      }
      ;;
    *)
      case "${_PA[state]}" in
      COMMAND)
        _PA_check_token "${1}" "COMMAND" "command"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid COMMAND, "%s".\n\n' "$1" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      SUBCOMMAND)
        _PA_check_token "$1" "SUBCOMMAND" "subcommand"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid SUBCOMMAND for %s, "%s".\n\n' "${_PA[command]}" "${1}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      ARG*)
        ((ARGNUM++))
        _PA_check_token "${1}" "ARG${ARGNUM}"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid ARG1 for %s %s, "%s".\n\n' "${_PA[command]}" \
            "${_PA[subcommand]}" "${1}" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      END)
        PA_usage
        printf 'ERROR No more args expected, "%s" is unexpected for "%s %s"\n' \
          "${1}" "${_PA[command]}" "${_PA[subcommand]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      *)
        printf 'Internal ERROR. Invalid state "%s"\n' "${_PA[state]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      esac
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done

  # Run the user defined entrypoint function:
  for item in ${_PA[runcallbacks]}; do
    IFS=, read -r stateval func <<<"${item}"
    [[ ${stateval} == "${_PA[command]}${_PA[subcommand]}" ]] && {
      eval "${func}" || retval=$?
      return "${retval}"
    }
  done

  PA_usage

  return "${OK}"
}

# PA_usage outputs help text for a single component if help was asked for when
# a command was specified, or for all components otherwise.
# Args: None expected.
PA_usage() {

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[usagecallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func}"
      return
    }
  done

  eval "${_PA[usage]}"
}

# Private Functions -----------------------------------------------------------

# PA_new sets the initial values for the PArser's associative array.
# Args: None expected.
_PA_new() {
  _PA[command]=
  _PA[subcommand]=
  _PA[state]="COMMAND"
  _PA[optscallbacks]=
  _PA[usagecallbacks]=
  _PA[statecallbacks]=
  _PA[runcallbacks]=
  # The return value if the caller asked for an extra shift:
  _PA[shift]=126
}

# _PA_check_token checks for a valid token in arg2 state. The logic is
# most easily understood by reading the full original version at:
# https://github.com/mclarkson/my-own-kind/blob/master/docs/package.md#scripted-cluster-creation-and-deletion
# This function is a reduction of all the check_xxx_token functions.
# Args: arg1 - the token to check.
#       arg2 - the current state.
#       arg3 - the state value to set, optional. This should only be sent
#              for command and subcommand states.
_PA_check_token() {

  local item

  if [[ -n ${_PA[subcommand]} ]]; then
    cmdsubcommand="${_PA[command]}${_PA[subcommand]}"
  elif [[ -n ${_PA[command]} && ${_PA[state]} != "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}$1"
  elif [[ -n ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}"
  elif [[ -z ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand=
  else
    cmdsubcommand="$1"
  fi

  for item in ${_PA[statecallbacks]}; do
    IFS=, read -r state component newstate func <<<"${item}"
    [[ ${state} == "$2" ]] && {
      [[ ${component} == "${cmdsubcommand}" ]] && {
        [[ -n $3 ]] && _PA["$3"]="$1"
        _PA[state]="${newstate}"
        [[ -n ${func} ]] && {
          eval "${func} $1" || return
        }
        return "${OK}"
      }
    }
  done
}

# _PA_process_option checks that the user-provided option is valid for the
# command-subcommand or global states.
# Args: arg1 - The option to check.
#       arg2 - TODO The value of the option if present, optional.
_PA_process_option() {

  local item curcmdsubcmd

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[optscallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func} \"$1\" \"$2\""
      return $?
    }
  done

  return "${ERROR}"
}

# Initialise _PA
_PA_new

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GL - Globals

# Private Functions -----------------------------------------------------------

# GL_new sets the only global variables that should be in use anywhere.  The
# only other globals are the associative arrays. All the globals are constant
# (readonly) variables. Declare these globals, where needed, in other files
# so that shellcheck passes.
# Args: None expected.
_GL_new() {

  declare -rg MOKVERSION="0.8.19"
  declare -rg K8SVERSION="1.31.2"
  declare -rg GO_VERSION="1.23.2"

  # Returns, exit codes
  declare -rg OK=0
  declare -rg SUCCESS=0
  declare -rg ERROR=1
  declare -rg FAILURE=1

  # For setting flags
  declare -rg TRUE=1
  declare -rg FALSE=0

  # To signal main() to exit with SUCCESS in the PArser
  declare -rg STOP=2

  declare -rg STDOUT="/dev/stdout"
  declare -rg STDERR="/dev/stderr"

  # The following just keep shellcheck happy
  local dummy dumb
  dummy="${OK}"
  dummy="${ERROR}"
  dummy="${STOP}"
  dummy="${STDOUT}"
  dummy="${STDERR}"
  dummy="${TRUE}"
  dummy="${FALSE}"
  dummy="${SUCCESS}"
  dummy="${FAILURE}"
  dummy="${MOKVERSION}"
  dummy="${GO_VERSION}"
  dummy="${K8SVERSION}"
  dumb="${dummy}${dumb}"
}

# Initialise GL
_GL_new || exit 1

# vim helpers -----------------------------------------------------------------

# The following lines allow the use of '[C-i' and '[I' (do ':help [I') in vim.
#include buildimage.sh
#include containerutils.sh
#include createcluster.sh
#include deletecluster.sh
#include embed-dockerfile.sh
#include error.sh
#include exec.sh
#include getcluster.sh
#include main.sh
#include lib/parser.sh
#include util.sh
#include versions.sh

# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# ER - Error handling

# ER is an associative array that holds data specific to error handling.
declare -A ER

# Declare externally defined associative arrays -------------------------------

# Defined in GL (globals.sh)
declare ERROR TRUE STDERR

# Public Functions ------------------------------------------------------------

# ER_err outputs a stacktrace and returns ERROR status.
# Args: None expected.
ER_err() {

  # In case of error print the function call stack
  # No args expected

  [[ ${ER[errcalled]} == "${TRUE}" ]] && return "${ERROR}"
  ER[errcalled]="${TRUE}"
  local frame=0
  printf '\n' >"${STDERR}"
  while caller "${frame}"; do
    ((frame++))
  done | tac >"${STDERR}"
  printf '\n' >"${STDERR}"
  return "${ERROR}"
}

# err is a synonym for ER_err to aid with code readability.
err() {
  ER_err
  return
}

# Private Functions -----------------------------------------------------------

# ER_new sets the initial values for the ER associative array.
# Args: None expected.
_ER_new() {
  ER[errcalled]=
}

# Initialise ER
_ER_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# UT - Utilities

# _UT is an associative array that holds data specific to general utilities.
declare -A _UT

# Declare externally defined global variables ---------------------------------

declare OK STDERR FALSE TRUE

# Getters/Setters -------------------------------------------------------------

# UT_runlogfile getter outputs the value of _UT[runlogfile], which contains the
# name of the file written to when running UT_run_with_progress.
UT_runlogfile() {
  printf '%s' "${_UT[runlogfile]}"
}

# UT_tailf getter indicates whether a log will be shown in real-time during the
# 'run', TRUE, or not, FALSE.
# Args
UT_tailf() {
  printf '%s' "${_UT[tailf]}"
}

# UT_tailf setter indicates whether a log should be shown during the 'run',
# TRUE, or not, FALSE.
# Args: arg1 - Whether to tail, TRUE or FALSE.
UT_set_tailf() {
  _UT[tailf]="$1"
}

# UT_set_plain setter sets plain output, with no colour, animations, or UTF
# high byte characters.
# Args: arg1 - Whether to show plain output, TRUE or FALSE.
UT_set_plain() {
  _UT[plain]="$1"
  UT_disable_colours
}

# Public Functions ------------------------------------------------------------

# UT_disable_colours resets variables used for colourised output so that they
# contain no colour terminal escapes. Useful if stdin is not a terminal.
UT_disable_colours() {
  _UT[yellow]=
  _UT[green]=
  _UT[red]=
  _UT[normal]=
  _UT[probablysuccess]="PROBABLY SUCCESS (!)"
  _UT[success]="SUCCESS"
  _UT[failure]="FAIL"
}

# UT_run_with_progress displays a progress spinner, item text, and a tick or
# cross based on the exit code.
# Args: arg1   - the text to display.
#       arg2-N - remaining args are the program to run and its arguments.
UT_run_with_progress() {

  local displaytext=$1 retval int spinner=()

  _UT[runlogfile]=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }
  shift

  if [[ ${_UT[tailf]} == "${FALSE}" && ${_UT[plain]} == "${TRUE}" ]]; then

    # Output with no colours or spinny

    printf '%s' "${displaytext}"

    eval "$*" &>"${_UT[runlogfile]}"
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 0 ]]; then
      printf ' .. %s\n' "${_UT[success]}"
    else
      printf ' .. %s\n' "${_UT[failure]}"
    fi

  elif [[ ${_UT[tailf]} == "${FALSE}" ]]; then

    # Output with colours and spinny

    while read -r char; do
      spinner+=("${char}")
    done <<<"$(grep -o . <<<"${_UT[spinnerchars]}")"

    (
      eval "$*" &>"${_UT[runlogfile]}"
    ) &

    # Turn the cursor off
    tput civis

    # Start the spin animation
    printf ' %s' "${displaytext}"
    (while true; do
      for int in {0..3}; do
        printf '\r  %s ' "${spinner[int]}"
        sleep .1
      done
    done) &
    _UT[spinnerpid]=$!
    disown

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Kill the spinner
    kill "${_UT[spinnerpid]}" 2>/dev/null
    _UT[spinnerpid]=

    sleep .5

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\r  %s\n' "${_UT[probablysuccess]}"
    elif [[ ${retval} -eq 0 ]]; then
      printf '\r  %s\n' "${_UT[success]}"
    else
      printf '\r  %s\n' "${_UT[failure]}"
    fi

    # Restore the cursor
    tput cnorm
    sleep .5

  else

    # Tailf output

    printf 'COMMAND: %s\n\n' "$*"

    (
      eval "$*" &>/dev/stdout
    ) &
    sleep 1

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\n\nSTATUS: OK - (Probably)\n\n'
    elif [[ ${retval} -eq 0 ]]; then
      printf '\n\nSTATUS: OK\n\n'
    else
      printf '\n\nSTATUS: FAIL\n\n'
    fi
  fi

  return "${retval}"
}

# UT_cleanup removes any artifacts that were created during execution.
# This is called by 'MA_cleanup' trap only.
UT_cleanup() {

  # Called when the script exits.

  local int

  # Kill the spinny, and anything else, if they're running
  if [[ ${_UT[tailf]} == "${FALSE}" ]]; then
    [[ -n ${_UT[spinnerpid]} ]] && {
      printf '%s\r  ✕%s\n' "${_UT[red]}" "${_UT[normal]}"
      kill "${_UT[spinnerpid]}"
    }
    # If progress spinner crashed make sure the cursor is shown
    [ -t 1 ] && tput cnorm
  else
    kill "${_UT[spinnerpid]}" &>/dev/null
  fi

  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _UT_new sets the initial values for the _UT associative array.
# Args: None expected.
_UT_new() {
  _UT[tailf]="${FALSE}"
  _UT[yellow]=$(tput setaf 3)
  _UT[green]=$(tput setaf 2)
  _UT[red]=$(tput setaf 1)
  _UT[normal]=$(tput sgr0)
  _UT[probablysuccess]="${_UT[yellow]}✓${_UT[normal]}"
  _UT[success]="${_UT[green]}✓${_UT[normal]}"
  _UT[failure]="${_UT[red]}✕${_UT[normal]}"
  _UT[runlogfile]=
  _UT[spinnerchars]="|/-\\"
  _UT[spinnerpid]=
}

# Initialise _UT
_UT_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GC - Get Cluster

# _GC is an associative array that holds data specific to the get cluster command.
declare -A _GC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# GC_showheader getter outputs the value of the showheader array member.
GC_showheader() {
  printf '%s' "${_GC[showheader]}"
}

# GC_set_showheader setter sets the value of the showheader array member.
# If $TRUE the header will be shown, or $FALSE, then it won't be shown.
GC_set_showheader() {
  _GC[showheader]="$1"
}

# GC_set_clustername setter sets the cluster name to show information about.
GC_set_clustername() {
  _GC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# GC_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted. It is called by
# MA_cleanup.
GC_cleanup() {
  :
}

# GC_process_options checks if arg1 is in a list of valid get cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
GC_process_options() {

  case "$1" in
  -h | --help)
    GC_usage
    return "${STOP}"
    ;;
  *)
    GC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# GC_usage outputs help text for the create cluster component.
# It is called by PA_usage().
# Args: None expected.
GC_usage() {

  cat <<'EnD'
GET subcommands are:
 
  cluster(s) - list all mok managed clusters.
 
get cluster(s) options:
 
 Format:
  get cluster(s) [NAME]
  NAME        - (optional) The name of the cluster to get
                details about.

EnD
}

# GC_run gets information about cluster(s).
# This function is called in main.sh.
# Args: None expected.
GC_run() {

  _GC_sanity_checks || return

  local ids id info output labelkey
  local containerhostname containerip

  declare -a nodes

  ids=$(CU_get_cluster_container_ids "${_GC[clustername]}") || return

  if [[ -z ${ids} ]]; then
    printf 'No clusters found\n'
    return "${OK}"
  fi

  readarray -t nodes <<<"${ids}"

  # Use 'docker inspect' to get the value of the label $LABELKEY

  output=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  # Output the header
  [[ ${_GC[showheader]} -eq ${TRUE} ]] && {
    printf 'MOK_Cluster Docker_ID Container_Name IP_Address\n' >"${output}"
  }

  labelkey=$(CU_labelkey) || err || return

  for id in "${nodes[@]}"; do

    info=$(CU_get_container_info "${id}") || return

    clustname=$(JSONPath ".[0].Config.Labels.${labelkey}" -b <<<"${info}") ||
      err || return

    containerhostname=$(JSONPath '.[0].Config.Hostname' -b <<<"${info}") ||
      err || return

    containerip=$(JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}") ||
      err || return

    printf '%s %s %s %s\n' "${clustname}" "${id}" "${containerhostname}" "${containerip}"

  done | sort -k 3 >>"${output}"

  column -t "${output}" || err
}

# Private Functions -----------------------------------------------------------

# _GC_new sets the initial values for the _GC associative array.
# Args: None expected.
_GC_new() {
  _GC[showheader]="${TRUE}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "get" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "getcluster" "ARG1" ""
  PA_add_state "SUBCOMMAND" "getclusters" "ARG1" ""
  PA_add_state "ARG1" "getcluster" "END" "GC_set_clustername"
  PA_add_state "ARG1" "getclusters" "END" "GC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "get" "GC_process_options" || return
  PA_add_option_callback "getcluster" "GC_process_options" || return
  PA_add_option_callback "getclusters" "GC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "get" "GC_usage" || return
  PA_add_usage_callback "getcluster" "GC_usage" || return
  PA_add_usage_callback "getclusters" "GC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "getcluster" "GC_run"
  PA_add_run_callback "getclusters" "GC_run"
}

# GC_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_GC_sanity_checks() {

  # Only show the usage if we are in 'get' mode and have not specified a
  # subcommand. This allows internal code to call GC_run()
  if [[ $(PA_command) == "get" && -z $(PA_subcommand) ]]; then
    GC_usage
    exit "${OK}"
  fi
}

# Initialise _GC
_GC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# EX - EXec

# EX is an associative array that holds data specific to the exec cluster command.
declare -A _EX

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# EX_set_containername setter sets the containername to be used to 'log in' to.
EX_set_containername() {
  _EX[containername]="$1"
}

# Public Functions ------------------------------------------------------------

# EX_process_options checks if arg1 is in a list of valid exec options. This
# function is called by the parser, via a callback in _EX_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
EX_process_options() {

  case "$1" in
  -h | --help)
    EX_usage
    return "${STOP}"
    ;;
  *)
    EX_usage
    printf 'ERROR: "%s" is not a valid "exec" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# EX_usage outputs help text for the create exec component.  It is called in
# this file and by PA_usage(), via a callback in _EX_new.
# Args: None expected.
EX_usage() {

  cat <<'EnD'
'Log in' to a container. EXEC has no subcommands.
 
exec options:
 
 Format:
  exec [NAME]
  NAME        - (optional) The name of the container to 'log in' to.
                If NAME is not given then the user will be offered
                a choice of containers to log in to. If there is only
                one cluster and one node then it will 'log in' to the
                only available container.

EnD
}

# Execs 'bash' in the container referenced by _EX[containername]. If just
# 'mok exec' is called without options then the user is offered a selection
# of existing clusters to exec into.
# Args: None expected.
# ---------------------------------------------------------------------------
EX_run() {

  _EX_sanity_checks || return

  local names int ans lines containernames gcoutput

  GC_set_showheader "${TRUE}" || err || return
  gcoutput=$(GC_run) || return
  names=$(printf '%s' "${gcoutput}" | awk '{ print $3; }')
  readarray -t containernames <<<"${names}"

  if [[ -n ${_EX[containername]} ]]; then

    # The caller gave a specific name for exec.
    # Check if the container name exists

    if grep -qs "^${_EX[containername]}$" <<<"${names}"; then
      _EX_exec "${_EX[containername]}" || return
      return "${OK}"
    else
      printf 'ERROR: Cannot exec into non-existent container: "%s".\n' \
        "${_EX[containername]}"
      return "${ERROR}"
    fi

  elif [[ ${#containernames[*]} == 2 ]]; then

    # If there's only one container just log into it without asking
    _EX_exec "${containernames[1]}"

  elif [[ ${#containernames[*]} == 1 ]]; then

    printf 'No containers found.\n'
    return "${OK}"

  else

    # The caller supplied no container name.
    # Present some choices

    printf 'Choose the container to log in to:\n\n'

    readarray -t lines <<<"${gcoutput}" || return

    # Print the header then print the items in the loop
    printf '   %s\n' "${lines[0]}"
    for int in $(seq 1 $((${#lines[*]} - 1))); do
      printf '%00d) %s\n' "${int}" "${lines[int]}"
    done | sort -k 4

    printf "\nChoose a number (Enter to cancel)> "
    read -r ans

    [[ -z ${ans} || ${ans} -lt 0 || ${ans} -gt $((${#lines[*]} - 1)) ]] && {
      printf '\nInvalid choice. Aborting.\n'
      return "${OK}"
    }

    _EX_exec "${containernames[ans]}"
  fi
}

# Private Functions -----------------------------------------------------------

# _EX_new sets the initial values for the _EX associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
_EX_new() {
  _EX[containername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "exec" "ARG1" ""
  PA_add_state "ARG1" "exec" "END" "EX_set_containername"

  # Set up the parser's option callbacks
  PA_add_option_callback "exec" "EX_process_options" || return
  PA_add_usage_callback "exec" "EX_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "exec" "EX_run"
}

# EX_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For exec this does nothing.
# Args: None expected.
_EX_sanity_checks() { :; }

# _EX_exec runs a command in a docker container using bash as the command by
# default.
# Args: arg1 - docker container name
#       arg2 - command to run
_EX_exec() {

  local cmd=${2:-bash}

  containerrt=$(CU_containerrt) || err || return

  read -rt 0.1
  if [[ ${containerrt} == "podman" ]]; then
    exec podman exec -ti "$1" "${cmd}"
  elif [[ ${containerrt} == "docker" ]]; then
    exec docker exec -ti "$1" "${cmd}"
  fi
}

# Initialise EX
_EX_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# DC - Delete Cluster

# _DC is an associative array that holds data specific to deleting a cluster.
declare -A _DC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR STOP TRUE

# Getters/Setters -------------------------------------------------------------

# DC_set_clustername setter sets the cluster name to be deleted. This is
# called by the parser, via a callback in _DC_new.
DC_set_clustername() {
  _DC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# DC_process_options checks if arg1 is in a list of valid delete cluster
# options. This function is called by the parser, via a callback in _DC_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
DC_process_options() {

  case "$1" in
  -h | --help)
    DC_usage
    return "${STOP}"
    ;;
  *)
    DC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# DC_usage outputs help text for the create cluster component.
# It is called by PA_usage(), via a callback in _DC_new.
# Args: None expected.
DC_usage() {

  cat <<'EnD'
DELETE subcommands are:
 
  cluster - Delete a local kubernetes cluster.
 
delete cluster options:
 
 Format:
  delete cluster NAME
  NAME        - The name of the cluster to delete

EnD
}

# DC_run starts the delete cluster process.
# Args: None expected.
DC_run() {

  _DC_sanity_checks || return

  # Mutate functions make system changes.

  declare -i numnodes=0
  local id ids r

  numnodes=$(CU_get_cluster_size "${_DC[clustername]}") || return

  [[ ${numnodes} -eq 0 ]] && {
    printf '\nERROR: No cluster exists with name, "%s". Aborting.\n\n' \
      "${_DC[clustername]}" >"${STDERR}"
    return "${ERROR}"
  }

  ids=$(CU_get_cluster_container_ids "${_DC[clustername]}") || return

  printf 'The following containers will be deleted:\n\n'

  GC_set_showheader "${TRUE}"
  GC_set_clustername "${_DC[clustername]}"
  GC_run "${_DC[clustername]}" || return

  printf "\nAre you sure you want to delete the cluster? (y/N) >"

  read -r ans

  [[ ${ans} != "y" ]] && {
    printf '\nCancelling by user request.\n'
    return "${OK}"
  }

  printf '\n'

  for id in ${ids}; do
    UT_run_with_progress \
      "    Deleting id, '${id}' from cluster '${_DC[clustername]}'." \
      _DC_delete "${id}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n\n' >"${STDERR}"
      err
      return "${r}"
    }
  done

  printf '\n'
}

# Private Functions -----------------------------------------------------------

# _DC_new sets the initial values for the _DC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_DC_new() {
  _DC[clustername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "delete" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "deletecluster" "ARG1" ""
  PA_add_state "ARG1" "deletecluster" "END" "DC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "delete" "DC_process_options" || return
  PA_add_option_callback "deletecluster" "DC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "delete" "DC_usage" || return
  PA_add_usage_callback "deletecluster" "DC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "deletecluster" "DC_run"
}

# DC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before DC_run is called.
# Args: None expected.
_DC_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    DC_usage
    exit "${OK}"
  fi

  if [[ -z ${_DC[clustername]} ]]; then
    DC_usage
    printf 'Please provide the Cluster NAME to delete.\n' >"${STDERR}"
    return "${ERROR}"
  fi
}

# _DC_delete stops and removes a docker container.
# Args: arg1 - docker id to delete.
_DC_delete() {

  docker stop -t 5 "${id}"
  docker rm "${id}" || err
}

# Initialise _DC
_DC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE K8SVERSION

# Getters/Setters -------------------------------------------------------------

# CC_set_clustername setter sets the clustername array item.
CC_clustername() {
  printf '%s' "${_CC[clustername]}"
}

# CC_publish getter outputs the publish array item.
CC_publish() {
  printf '%s' "${_CC[publish]}"
}

# CC-withlb getter outputs the withlb array item.
CC_withlb() {
  printf '%s' "${_CC[withlb]}"
}

# CC_set_clustername setter sets the clustername array item.
CC_set_clustername() {
  _CC[clustername]="$1"
}

# CC_set_nummasters setter sets the nummasters array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_nummasters() {
  _CC[nummasters]="$1"
}

# CC_set_numworkers setter sets the numworkers array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_numworkers() {
  _CC[numworkers]="$1"
}

# Public Functions ------------------------------------------------------------

# CC_process_options checks if arg1 is in a list of valid create cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option. For example, '--masters' should be sent
#              with a value but boolean options, like 'skiplbsetup' should not.
CC_process_options() {

  case "$1" in
  -h | --help)
    CC_usage
    return "${STOP}"
    ;;
  --skiplbsetup)
    _CC[skiplbsetup]="${TRUE}"
    return
    ;;
  --k8sver)
    _CC[k8sver]="$2"
    return "$(PA_shift)"
    ;;
  --with-lb)
    _CC[withlb]="${TRUE}"
    return
    ;;
  --skipmastersetup)
    _CC[skipmastersetup]="${TRUE}"
    return
    ;;
  --skipworkersetup)
    _CC[skipworkersetup]="${TRUE}"
    return
    ;;
  --masters)
    _CC[nummasters]="$2"
    return "$(PA_shift)"
    ;;
  --workers)
    _CC[numworkers]="$2"
    return "$(PA_shift)"
    ;;
  --tailf)
    _CC[tailf]="${TRUE}"
    return "${OK}"
    ;;
  --publish)
    _CC[publish]="${TRUE}"
    return
    ;;
  *)
    CC_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# CC_usage outputs help text for the create cluster component.  It is called in
# this file and by PA_usage(), via a callback set in _CC_new.
# Args: None expected.
CC_usage() {

  cat <<'EnD'
CREATE subcommands are:
 
  cluster - Create a local kubernetes cluster.
 
create cluster [flags] options:
 
 Format:
  create cluster NAME [ [NUM_MASTERS] [NUM_WORKERS] ]
  NAME        - The name of the cluster. This will be used as
                the prefix in the name for newly created
                docker containers.
  NUM_MASTERS - The number of master containers.
  NUM_WORKERS - The number of worker containers. If NUM_WORKERS is
                zero then the 'node-role.kubernetes.io/master' taint
                will be removed from master nodes so that pods are
                schedulable.
 
 Flags:
  --skipmastersetup - Create the master container but don't set it
         up. Useful for manually installing kubernetes. Kubeadm, 
         kubelet and kubectl will be installed at the requested 
         version. With this option the worker will also be skipped.
         See also '--k8sver' flag.
  --skipworkersetup - The same as '--skipmastersetup', but skips
         setting up the worker only.
  --with-lb - Add a haproxy load balancer. The software will be installed
         and set up to reverse proxy to the master node(s), unless
         --skiplbsetup is used.
  --k8sver VERSION - Unimplemented.
  --masters NUM - The number of master containers to create.
  --workers NUM - The number of worker containers to create. When workers
                  is zero then the master node taint will be removed from
                  master nodes so that pods are schedulable on those nodes.
  --tailf - Show the log output whilst creating the cluster.
  --publish - Publish port 6443 for the master node, or the load balancer if
              it's enabled, for external kubectl access to the cluster. The IP
              address of the default route interface is added to the cert.


EnD
}

# CC_run creates the kubernetes cluster.
# Args: None expected.
CC_run() {

  _CC_sanity_checks || return

  [[ ${_CC[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  declare -i numnodes=0

  numnodes=$(CU_get_cluster_size "${_CC[clustername]}") || return

  [[ ${numnodes} -gt 0 ]] && {
    printf '\nERROR: Cluster, "%s", exists! Aborting.\n\n' "${_CC[clustername]}" \
      >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_create_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_create_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_setup_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_setup_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[numworkers]} -gt 0 ]] && {
    _CC_create_worker_nodes "${_CC[numworkers]}" || return
  }

  printf '\n'

  [[ -z ${_CC[skipmastersetup]} ]] && {
    printf 'Cluster, "%s", can be accessed using:\n\n' "${_CC[clustername]}"
    printf 'export KUBECONFIG=/var/tmp/admin-%s.conf\n\n' "${_CC[clustername]}"
  }

  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CC_new sets the initial values for the _CC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_CC_new() {
  _CC[tailf]="${FALSE}"
  _CC[skipmastersetup]=
  _CC[skipworkersetup]=
  _CC[skiplbsetup]=
  _CC[withlb]=
  _CC[clustername]=
  _CC[nummasters]=0
  _CC[numworkers]=0
  _CC[publish]=0
  _CC[k8sver]="${K8SVERSION}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "create" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "createcluster" "ARG2" ""

  # Support for the legacy style of create (less to type):
  PA_add_state "ARG1" "createcluster" "ARG2" "CC_set_clustername"
  PA_add_state "ARG2" "createcluster" "ARG3" "CC_set_nummasters"
  PA_add_state "ARG3" "createcluster" "END" "CC_set_numworkers"

  # Set up the parser's option callbacks
  PA_add_option_callback "create" "CC_process_options" || return
  PA_add_option_callback "createcluster" "CC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "create" "CC_usage" || return
  PA_add_usage_callback "createcluster" "CC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "createcluster" "CC_run"
  PA_add_run_callback "createclusters" "CC_run"
}

# CC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before CC_run is called.
# Args: None expected.
_CC_sanity_checks() {

  declare -i host_max=0 cpus=0 should_be=0

  if [[ -z $(PA_subcommand) ]]; then
    CC_usage
    exit "${OK}"
  fi

  if [[ -z ${_CC[clustername]} ]]; then
    CC_usage
    printf 'Please provide the Cluster NAME to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[nummasters]} || ${_CC[nummasters]} -le 0 ]]; then
    CC_usage
    printf 'Please provide the number of Masters to create. Must be 1 or more.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[numworkers]} ]]; then
    CC_usage
    printf 'Please provide the number of Workers to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/sys/net/nf_conntrack_max ]]; then
    host_max=$(cat /proc/sys/net/nf_conntrack_max)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    host_max=$(podman machine ssh cat /proc/sys/net/nf_conntrack_max)
  else
    printf '\nWARNING: /proc/sys/net/nf_conntrack_max not found.\n' >"${STDERR}"
    printf '         kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/cpuinfo ]]; then
    cpus=$(grep -cw ^processor /proc/cpuinfo)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    cpus=$(podman machine ssh cat /proc/cpuinfo | grep -cw ^processor)
  else
    printf '\nWARNING: /proc/cpuinfo not found.\n' >"${STDERR}"
    printf '         I have no idea how many CPUs I have\n' >"${STDERR}"
    printf '         and kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  # These are the default values that kube-proxy expects:
  # conntrack:
  #   max: null
  #   maxPerCore: 32768
  #   min: 131072
  if [[ $((32768*cpus)) -lt 131072 ]]; then
    should_be=131072
  else
    should_be=$((32768*cpus))
  fi
  if [[ ${should_be} -ne $host_max ]]; then
    printf '\nERROR: /proc/sys/net/nf_conntrack_max should be set to %d.\n' \
      "${should_be}" >"${STDERR}"
    printf '     kube-proxy will not start with an incorrect nf_conntrack_max.\n' >"${STDERR}"
    printf '     To fix this, run the following command:\n\n' >"${STDERR}"
    if [[ ${_CU[podmantype]} == "native" ]]; then
      printf '       sudo sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
    elif [[ ${_CU[podmantype]} == "machine" ]]; then
      printf '       podman machine ssh sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
      printf '     If the above command fails, you may have to recreate the podman machine, for example:\n\n' >"${STDERR}"
      tput setaf 1 # red
      printf '     WARNING: The following commands will destroy your podman machine and all its data.\n' >"${STDERR}"
      printf '              All existing pods and containers will be gone.\n\n' >"${STDERR}"
      tput sgr0 # reset
      printf '       podman machine stop\n' >"${STDERR}"
      printf '       podman machine rm\n' >"${STDERR}"
      printf '       podman machine init --now --rootful --user-mode-networing\n' >"${STDERR}"
      printf '       podman machine ssh modprobe nf_conntrack\n' >"${STDERR}"
      printf '       podman machine ssh sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
    else
      printf 'Internal ERROR. Invalid podman type.\n' >"${STDERR}"
      return "${ERROR}"
    fi
    
    printf 'Press ENTER to continue or CTRL-C to abort.\n' >"${STDERR}"
    read -r
    printf '\n' >"${STDERR}"
  fi
}

# _CC_create_master_nodes creates the master node containers.
# Args: arg1 - number of master nodes to create
_CC_create_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating master container, '${_CC[clustername]}-master-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-master-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }
  done

  return "${OK}"
}

# _CC_setup_master_nodes sets up the master node containers.
# Args: arg1 - number of master nodes to create
_CC_setup_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile lbaddr hostaddr
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-master-${int}'" \
      _CC_set_up_master_node "${_CC[clustername]}-master-${int}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  done

  # For now, copy admin.conf from master to /var/tmp/admin-CLUSTERNAME.conf

  if [[ -z ${_CC[skipmastersetup]} ]]; then
    if [[ ${_CC[publish]} -eq ${TRUE} ]]; then
      # On MacOS we need to use localhost, on linux use the host IP
      if [[ $(CU_podmantype) == "native" ]]; then
        hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
      else
        hostaddr="localhost"
      fi
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${hostaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    elif [[ ${_CC[withlb]} -eq ${TRUE} ]]; then
      lbaddr=$(CU_get_container_ip "${_CC[clustername]}-lb") || err || return
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${lbaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    else
      [[ -n ${_CC[skipmastersetup]} ]] || {
        docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
          "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      }
    fi

    chmod 666 "/var/tmp/admin-${_CC[clustername]}.conf" || {
      printf 'ERROR: Could not "chown 666 /var/tmp/admin-%s.conf"' "${_CC[clustername]}"
      err || return
    }
  fi

  return "${OK}"
}

# _CC_set_up_master_node calls the correct set up function based on the version
# Args: arg1 - the container ID to set up
_CC_set_up_master_node() {

  case "${_CC[k8sver]}" in
  "1.30.1" | "1.31.1" | "1.31.2")
    _CC_set_up_master_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# _CC_get_master_join_details uses 'docker exec' or 'podman exec' to run a
# script on the master to get CA hash, a token, and the master IP.  The caller
# can eval the output of this function to set the variables: cahash, token, and
# masterip. See also:
# https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/#token-based-discovery-with-ca-pinning
# Args: arg1 - id/name of master container
_CC_get_master_join_details() {

  local joinvarsfile master1ip

  joinvarsfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  master1ip=$(CU_get_container_ip "${_CC[clustername]}-master-1") || err || return

  cat <<EnD >"${joinvarsfile}"
#!/bin/bash
set -e

sed 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${master1ip}"'\2#' \
  /etc/kubernetes/super-admin.conf >/etc/kubernetes/admin2.conf

cahash=\$(openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | \
        openssl rsa -pubin -outform der 2>/dev/null | \
        openssl dgst -sha256 -hex | sed 's/^.* //')
token=\$(kubeadm token create --kubeconfig=/etc/kubernetes/admin2.conf 2>/dev/null)
ip=\$(ip ro get 8.8.8.8 | cut -d" " -f 7)

printf 'cahash=%s\ntoken=%s\nmasterip=%s' "\$cahash" "\$token" "\$ip"

exit 0
EnD

  docker cp "${joinvarsfile}" "$1":/root/joinvars.sh 2>"${STDERR}" ||
    err || return
  rm -f "${joinvarsfile}" 2>"${STDERR}" || err || return

  [[ -z ${_CC[skipworkersetup]} ]] && {
    docker exec "$1" bash /root/joinvars.sh 2>"${STDERR}" || err || return
  }

  return "${OK}"
}

# _CC_create_lb_node creates the load balancer node container.
# Args: None expected.
_CC_create_lb_node() {

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  # Create container
  UT_run_with_progress \
    "    Creating load balancer container, '${_CC[clustername]}-lb'" \
    CU_create_container \
    "${_CC[clustername]}-lb" \
    "${labelkey}=${_CC[clustername]}" \
    "${_CC[k8sver]}"

  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    printf '\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
    printf '%s\n' "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  return "${OK}"
}

# _CC_setup_lb_node sets up the load balancer node container.
# Args: None expected.
_CC_setup_lb_node() {

  local runlogfile

  # Set up
  [[ -z ${_CC[skiplbsetup]} ]] && {
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-lb'" \
      _CC_set_up_lb_node_real "${_CC[clustername]}-lb"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _CC_set_up_lb_node_real sets up the lb node.
# Args: arg1 - the container ID to set up
_CC_set_up_lb_node_real() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masteriplist=
  nl=
  gotamaster="${FALSE}"
  for idx in $(seq 1 "${_CC[nummasters]}"); do
    ip=$(CU_get_container_ip "${_CC[clustername]}-master-${idx}") || continue
    gotamaster="${TRUE}"
    masteriplist="${masteriplist}${nl}    server master-${idx} ${ip}:6443 check fall 3 rise 2"
    nl='\n'
  done

  [[ ${gotamaster} == "${FALSE}" ]] && {
    printf 'ERROR: Did not manage to get an IP address for any master nodes\n'
    err || return
  }

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

systemctl stop kubelet crio
systemctl disable kubelet crio

apt -y install haproxy

INTERNAL_IP=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")

cat <<EOF | tee /etc/haproxy/haproxy.cfg 
frontend kubernetes
    bind \$INTERNAL_IP:6443
    option tcplog
    mode tcp
    default_backend kubernetes-master-nodes
backend kubernetes-master-nodes
    mode tcp
    balance roundrobin
    option tcp-check
\$(echo -e "${masteriplist}")
EOF

systemctl restart haproxy
systemctl enable haproxy

EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# _CC_create_worker_nodes creates the worker nodes.
# Args: arg1 - number of worker nodes to create
_CC_create_worker_nodes() {

  local cahash token t masterip
  declare -i int=0

  [[ -n ${_CC[skipmastersetup]} ]] || {
    # Runs a script on master node to get details
    t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1") || {
      printf '\nERROR: Problem with "_CC_get_master_join_details".\n\n' >"${STDERR}"
      return "${ERROR}"
    }

    # Sets cahash, token, and masterip:
    eval "${t}"
  }

  local labelkey
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating worker container, '${_CC[clustername]}-worker-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-worker-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }

    [[ -n ${_CC[skipworkersetup]} || -n ${_CC[skipmastersetup]} ]] || {
      UT_run_with_progress \
        "    Setting up '${_CC[clustername]}-worker-${int}'" \
        _CC_set_up_worker_node "${_CC[clustername]}-worker-${int}" \
        "${cahash}" "${token}" "${masterip}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n' >"${STDERR}"
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
        printf '%s\n' "${runlogfile}" >"${STDERR}"
        return "${ERROR}"
      }

      UT_run_with_progress \
        "    Waiting for system to become ready" \
        _CC_wait_for_cluster \
        "${_CC[clustername]}-master-1" \
        "${_CC[clustername]}-worker-${int}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n'
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Wait timed out.\n' >"${STDERR}"
        return "${ERROR}"
      }
    }
  done

  return "${OK}"
}

# _CC_wait_for_cluster runs a `kubectl` command in the master-1 container,
# which doesn't exit until the all pods are fully up and running before it
# returns.
# Args: arg1 - the master container name to log into
#       arg2 - the worker container name to wait for
_CC_wait_for_cluster() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  cat <<'EnD' >"${setupfile}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
found=0
for i in $(seq 1 20); do
  if kubectl get pods &>/dev/null; then
    found=1
    break
  fi
  sleep 1
done
[[ $found == 0 ]] && {
  printf '# kubectl get pods\n'
  kubectl get pods
  printf '\nWaited for 20 seconds for kubectl to work.\n'
  printf 'Kubectl cannot contact master. Aborting.\n'
  exit 1
}
counter=0
while ! kubectl get nodes | grep -qs "$1"; do
  ((counter++))
  [[ ${counter} -gt 60 ]] && {
    printf '# kubectl get nodes\n'
    kubectl get nodes
    printf '\nWaited for 2 minutes for node to appear in master. Aborting.\n'
    exit 1
  }
  sleep 2
done
counter=0
while kubectl get pods -A | tail -n +2 | awk '{ print $3; }' | grep -qs 0; do
  ((counter++))
  [[ ${counter} -gt 120 ]] && {
    printf '# kubectl get pods -A\n'
    kubectl get pods -A
    printf '\nWaited for 3 minutes for pods to be ready. Aborting.\n'
    exit 1
  }
  sleep 2
done
exit 0
EnD

  docker cp "${setupfile}" "$1":/root/wait.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/wait.sh "$2" || err
}

# _CC_set_up_worker_node calls the correct set up function based on the version.
# Args: arg1 - the container ID to set up
#       arg2 - the CA hash
#       arg3 - the token
#       arg4 - the master IP
_CC_set_up_worker_node() {

  case "${_CC[k8sver]}" in
  "1.30.1" | "1.31.1" | "1.31.2")
    _CC_set_up_worker_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# Initialise _CC
_CC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster - versions file

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR TRUE

# _CC_set_up_master_node_v1_30_0 uses kubeadm to set up the master node.
# Args: arg1 - the container to set up.
_CC_set_up_master_node_v1_30_0() {

  local setupfile lbaddr certSANs="{}" certkey masternum t lbip
  # Set by _CC_get_master_join_details:
  local cahash token masterip

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masternum="${1##*-}" # <- eg. for xxx-master-1, masternum=1

  if [[ ${_CC[skipmastersetup]} != "${TRUE}" ]]; then

    if [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -eq 1 ]]; then

      # This is the first master node

      # Sets cahash, token, and masterip:
      lbip=$(CU_get_container_ip "${_CC[clustername]}-lb")
      lbaddr=", '${lbip}'"
      uploadcerts="--upload-certs"
      certkey="CertificateKey: f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07"

    elif [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -ne 1 ]]; then

      # This is not the first master node, so join with the master
      # https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/

      # Keep trying to get join details until apiserver is ready or we run out of tries
      for try in $(seq 1 9); do
        # Runs a script on master node to get join details
        t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1")
        retval=$?
        [[ ${retval} -eq 0 ]] && break
        [[ ${try} -eq 9 ]] && {
          printf '\nERROR: Problem with "_CC_get_master_join_details". Tried %d times\n\n' "${try}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        sleep 5
      done
      eval "${t}"
    fi
  fi

  # Always set certSANs for the host whether we need it or not
  hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
  certSANs="
  certSANs: [ '${hostaddr}'${lbaddr}, '127.0.0.1', 'localhost' ]"

  # Write the file regardless, so the user can use it if required

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

# Use a custom configuration. Default config created from kubeadm with:
#   kubeadm config print init-defaults
# then edited.

ipaddr=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")
podsubnet="10.244.0.0/16"
servicesubnet="10.96.0.0/16"

cat <<EOF >kubeadm-init-defaults.yaml
apiVersion: kubeadm.k8s.io/v1beta4
bootstrapTokens:
- groups:
  - system:bootstrappers:kubeadm:default-node-token
  token: abcdef.0123456789abcdef
  ttl: 24h0m0s
  usages:
  - signing
  - authentication
kind: InitConfiguration
${certkey}
localAPIEndpoint:
  advertiseAddress: \$ipaddr
  bindPort: 6443
nodeRegistration:
  criSocket: unix:///var/run/crio/crio.sock
  imagePullPolicy: IfNotPresent
  imagePullSerial: true
  name: $1
  taints:
  - effect: NoSchedule
    key: node-role.kubernetes.io/control-plane
timeouts:
  controlPlaneComponentHealthCheck: 4m0s
  discovery: 5m0s
  etcdAPICall: 2m0s
  kubeletHealthCheck: 4m0s
  kubernetesAPICall: 1m0s
  tlsBootstrap: 5m0s
  upgradeManifests: 5m0s
---
apiServer: ${certSANs}
apiVersion: kubeadm.k8s.io/v1beta4
caCertificateValidityPeriod: 87600h0m0s
certificateValidityPeriod: 8760h0m0s
certificatesDir: /etc/kubernetes/pki
clusterName: ${_CC[clustername]}-cluster
controlPlaneEndpoint: ${lbaddr:-\$ipaddr}:6443
controllerManager: {}
dns: {}
encryptionAlgorithm: RSA-2048
etcd:
  local:
    dataDir: /var/lib/etcd
imageRepository: registry.k8s.io
kind: ClusterConfiguration
networking:
  dnsDomain: cluster.local
  podSubnet: \${podsubnet}
  serviceSubnet: \${servicesubnet}
proxy: {}
scheduler: {}
EOF

mkdir -p /mok
cp kubeadm-init-defaults.yaml /mok/kubeadm.yaml

if [[ -z "${masterip}" ]]; then
  # Run the preflight phase
  kubeadm init \\
    --ignore-preflight-errors Swap \\
    --config=kubeadm-init-defaults.yaml \\
    phase preflight

  # Set up the kubelet
  kubeadm init phase kubelet-start

  # Edit the kubelet configuration file
  echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
  sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

  # Tell kubeadm to carry on from here
  kubeadm init \\
    --config=kubeadm-init-defaults.yaml \\
    --ignore-preflight-errors Swap \\
    ${uploadcerts} \\
    --skip-phases=preflight,kubelet-start

  export KUBECONFIG=/etc/kubernetes/super-admin.conf

  # Flannel - 10.244.0.0./16
  kubectl apply -f /root/kube-flannel.yml
else
  kubeadm join ${masterip}:6443 \\
    --ignore-preflight-errors Swap \\
    --control-plane \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --certificate-key f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07
fi

systemctl enable kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  # Run the file
  [[ -z ${_CC[skipmastersetup]} ]] && {
    docker exec "$1" bash /root/setup.sh || err || return

    # Remove the taint if we're setting up a single node cluster

    [[ ${_CC[numworkers]} -eq 0 ]] && {

      removetaint=$(mktemp -p /var/tmp) || {
        printf 'ERROR: mktmp failed.\n' >"${STDERR}"
        return "${ERROR}"
      }

      # Write the file
      cat <<'EnD' >"${removetaint}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
kubectl taint nodes --all node-role.kubernetes.io/control-plane:NoSchedule-
EnD

      docker cp "${removetaint}" "$1":/root/removetaint.sh || err || {
        rm -f "${removetaint}"
        return "${ERROR}"
      }

      # Run the file
      docker exec "$1" bash /root/removetaint.sh || err
    }
  }

  return "${OK}"
}

# _CC_set_up_worker_node_v1_30_0 uses kubeadm to set up the worker node.
# Args: arg1 - the container to set up.
_CC_set_up_worker_node_v1_30_0() {

  local setupfile cahash="$2" token="$3" masterip="$4"

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  if [[ ${_CC[withlb]} == "${TRUE}" ]]; then
    masterip=$(CU_get_container_ip "${_CC[clustername]}-lb") || return
  fi

  cat <<EnD >"${setupfile}"
# Wait for the master API to become ready
while true; do
  curl -k https://${masterip}:6443/
  [[ \$? -eq 0 ]] && break
  sleep 1
done

# Do the preflight tests (ignoring swap error)
kubeadm join \\
  phase preflight \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --ignore-preflight-errors Swap \\
    ${masterip}:6443

# Set up the kubelet
kubeadm join \\
  phase kubelet-start \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    ${masterip}:6443 &

while true; do
  [[ -e /var/lib/kubelet/config.yaml ]] && break
    sleep 1
  done

# Edit the kubelet configuration file
echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

systemctl enable --now kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh 2>"${STDERR}" || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CU - Container Utilities

# _CU is an associative array that holds data specific to container utils.
declare -A _CU

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# CU_containerrt getter outputs the container runtime (podman or docker)
# that has been chosen.
CU_containerrt() {
  printf '%s' "${_CU[containerrt]}"
}

# CU_imgprefix getter outputs the prefix to be used with docker build. For
# podman it is 'localhost/'. For docker it is empty.
CU_imgprefix() {
  printf '%s' "${_CU[imgprefix]}"
}

# CU_labelkey getter outputs the key value of the label that is applied to all
# cluster member's container labels for podman or docker.
CU_labelkey() {
  printf '%s' "${_CU[labelkey]}"
}

# CU_podmantype getter outputs the container runtime type (native or machine).
CU_podmantype() {
  printf '%s' "${_CU[podmantype]}"
}

# Public Functions ------------------------------------------------------------

# CU_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted.
CU_cleanup() { :; }

# CU_get_cluster_container_ids outputs just the container IDs, one per line
# for any MOK cluster, unless arg1 is set, in which case just the IDs
# for the requested cluster name are output.
# Args: arg1 - The cluster name, optional.
CU_get_cluster_container_ids() {

  local value output

  [[ -n $1 ]] && value="=$1"

  output=$(docker ps -a -f label="${_CU[labelkey]}${value}" -q) || {
    printf 'ERROR: %s command failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  output=$(printf '%s' "${output}" | sed 's/$//')

  printf '%s' "${output}"

  return "${OK}"
}

# CU_get_cluster_size searches for an existing cluster using labels and outputs
# the number of containers in that cluster. All cluster nodes are labelled with
# "${_CU[labelkey]}=${CC[clustername]}"
# Args: arg1 - The cluster name to search for.
CU_get_cluster_size() {

  local output
  declare -a nodes

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Cluster name cannot be empty.\n' >"${STDERR}"
    err || return
  }

  output=$(CU_get_cluster_container_ids "$1") || err || return

  # readarray will read null as an array item so don't run
  # through readarray if it's null
  [[ -z ${output} ]] && {
    printf '0'
    return "${OK}"
  }

  # read the nodes array and delete blank lines
  readarray -t nodes <<<"${output}"

  printf '%d' "${#nodes[*]}"
}

# CU_get_container_ip outputs the IP address of the container.
# Args: arg1 - docker container id or container name to query.
CU_get_container_ip() {

  local info

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  info=$(CU_get_container_info "$1") || return
  JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}" ||
    err || return
}

# CU_get_container_info uses 'docker/podman inspect $id' to output
# container details.
# Args: arg1 - docker container id
CU_get_container_info() {

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  docker inspect "$1" || {
    printf 'ERROR: %s inspect failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_create_container creates and runs a container with settings suitable for
# running privileged containers that can manipulate cgroups.
# Args: arg1 - The string used to set the name and hostname.
#       arg2 - The label to assign to the container.
#       arg3 - The k8s base image version to use.
CU_create_container() {

  local imagename img allimgs systemd_always clustername parg pval

  [[ -z $1 || -z $2 || -z $3 ]] && {
    printf 'INTERNAL ERROR: Neither arg1, arg2 nor arg3 can be empty.\n' \
      >"${STDERR}"
    err || return
  }

  img=$(BI_baseimagename) || err || return

  local imglocal="${_CU[imgprefix]}local/${img}-v${3}"
  local imgremote="myownkind/${img}-v${3}"

  # Prefer a locally built container over one downloaded from a registry
  allimgs=$(docker images | tail -n +2) || {
    printf 'ERROR: %s returned an error\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  if echo "${allimgs}" | grep -qs "${imglocal}"; then
    imagename="${imglocal}"
  elif echo "${allimgs}" | grep -qs "${imgremote}"; then
    imagename="${imgremote}"
  else
    cat <<EnD
ERROR: No container base image found. Use either:

  $ mok build image
OR
  $ mok build image --get-prebuilt-image

Then try running 'mok create ...' again.
EnD
    return "${ERROR}"
  fi

  clustername=$(CC_clustername) || err || return

  if [[ ${_CU[containerrt]} == "podman" ]];
  then 
    docker network exists "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  else
    docker network inspect "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  fi

  [[ ${create_network} -ne 0 ]] && {
    docker network create "${clustername}_network" || {
      printf 'ERROR: docker network create failed\n' >"${STDERR}"
      err || return
    }
  }

  # Docker does not have the --systemd option
  [[ ${_CU[containerrt]} == "podman" ]] && systemd_always="--systemd=always"

  [[ $(CC_publish) == "${TRUE}" ]] && {
    if [[ $(CC_withlb) == "${TRUE}" ]]; then
      if echo "$1" | grep -qs -- '-lb$'; then
        parg='-p'
        pval='6443:6443'
      fi
    else
      if echo "$1" | grep -qs -- '-master-1$'; then
        parg='-p'
        pval='6443:6443'
      fi
    fi
  }

  docker run --privileged ${systemd_always} \
    --network "${clustername}_network" \
    -v /lib/modules:/lib/modules:ro \
    --detach ${parg} ${pval} \
    --name "$1" \
    --hostname "$1" \
    --label "$2" \
    "${imagename}" \
    /usr/local/bin/entrypoint /lib/systemd/systemd log-level=info unit=sysinit.target || {
    printf 'ERROR: %s run failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_podman_or_docker checks to see if docker and/or podman are installed and
# sets the imgprefix and containerrt array members accordingly. It also defines
# the docker function to run the detected container runtime. Podman is
# preferred if both are installed.
# Args: No args expected.
CU_podman_or_docker() {
  if type podman &>/dev/null; then
    _CU[imgprefix]="localhost/"
    _CU[containerrt]="podman"
    _CU_podman_checks || return
  elif type docker &>/dev/null; then
    _CU[imgprefix]=""
    _CU[containerrt]="docker"
    _CU_docker_checks || return
  else
    printf 'ERROR: Neither "podman" nor "docker" were found.\n' \
      >"${STDERR}"
    printf 'Please install one of "podman" or "docker".\nAborting.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi
  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CU_docker_checks checks to see if the current user has permission to write
# to the docker socket. If not, it prints an error message and exits.
# Args: No args expected.
_CU_docker_checks() {
  if [[ ! -e /proc/sys/kernel/hostname ]]; then
    printf 'ERROR: Docker is currently supported on Linux only'
    exit "${ERROR}"
  fi

  if docker ps >/dev/stdout 2>&1 | grep -qs 'docker.sock.*permission denied'; then
    cat <<EnD >"${STDERR}"
Not enough permissions to write to 'docker.sock'.

Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  fi

  _CU[podmantype]="native"
  return "${OK}"
}

# _CU_podman_checks sets the _CU[podmantype] member to "native" or "machine"
# depending on whether this is linux or macos. We assume linux won't be using
# a podman machine, and macos will always be using a podman machine.
# Args: No args expected.
_CU_podman_checks() {
  local info running

  if [[ -e /proc/sys/kernel/hostname ]]; then
    # We're on linux
    _CU[podmantype]="native"
    _CU_podman_native_checks || return
  elif [[ -d /System/Library/CoreServices ]]; then
    # We're on macOS
    [[ $(id -u) -eq 0 ]] && {
      printf 'ERROR: Cannot run mok as root on macOS.\n' >"${STDERR}"
      exit "${ERROR}"
    }

    info=$(podman machine list --format json) || err || return
    running=$(JSONPath -b '..Running' <<<"${info}") || err || return

    if [[ ${running} == "true" ]]; then
      _CU[podmantype]="machine"
    else
      printf 'ERROR: Podman machine is not running. Aborting.\n' >"${STDERR}"
      exit "${ERROR}"
    fi
  else
    printf 'ERROR: Unknown OS. Aborting.\n' >"${STDERR}"
    exit "${ERROR}"
  fi
}

# _CU_podman_native_checks checks to see if the current user is root. If not,
# it prints an error message and exits.
# Args: No args expected.
_CU_podman_native_checks() {
  [[ $(id -u) -ne 0 ]] && {
    cat <<EnD >"${STDERR}"
Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  }
}

# _CU_new sets the initial values for the Container Utils associative array.
# Args: None expected.
_CU_new() {
  _CU[imgprefix]=
  _CU[labelkey]="MokCluster"
  _CU[containerrt]=

  # _CU[podmantype] will only be set only if _CU[containerrt]=podman.
  # podmantype will be "native" or "machine".
  _CU[podmantype]=
}

# Override `docker` depending on _CU[containerrt]
docker() {
  local cmd
  if [[ "${_CU[containerrt]}" == "podman" ]]; then
    podman "$@"
  else
    cmd=$(which -a docker | tail -n 1)
    $cmd "$@"
  fi
}

# Override `ip` depending on _CU[podmantype]
ip() {
  local cmd
  if [[ "${_CU[podmantype]}" == "machine" ]]; then
    podman machine ssh ip "$@"
  else
    cmd=$(which -a ip | tail -n 1)
    $cmd "$@"
  fi
}

# Initialise _CU
_CU_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# BI - Build Image

# _BI is an associative array that holds data specific to building an image.
declare -A _BI

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE

# Getters/Setters -------------------------------------------------------------

# BI_setflag_useprebuiltimage setter sets the useprebuiltimage array item.
# This is called by the parser, via a callback in _BI_new.
BI_setflag_useprebuiltimage() {
  _BI[useprebuiltimage]="$1"
}

# BI_baseimagename getter outputs the value of the _BI[baseimagename].
# Args: None expected.
BI_baseimagename() {
  printf '%s' "${_BI[baseimagename]}"
}

# Public Functions ------------------------------------------------------------

# BI_usage outputs help text for the build image component.
# It is called by PA_usage(), via a callback in _BI_new.
# Args: None expected.
BI_usage() {

  # NOTE: This flag to be added back in the future
  # --get-prebuilt-image - Instead of building a 'node' image
  #        locally, download it from a container registry instead.

  cat <<'EnD'
BUILD subcommands are:
 
  image - Creates the docker 'mok-image' container image.
 
build image options:
 
 Format:
  build image

 Flags:
  --tailf - Show the build output whilst building.

EnD
}

# BI_cleanup removes temporary files created during the build.
# This function is called by the 'MA_cleanup' trap only.
# Args: None expected.
BI_cleanup() {
  [[ -e ${_BI[dockerbuildtmpdir]} ]] &&
    [[ ${_BI[dockerbuildtmpdir]} == "/var/tmp/"* ]] && {
    rm -rf "${_BI[dockerbuildtmpdir]}" || {
      printf 'ERROR: "rm -rf %s" failed.\n' "${_BI[dockerbuildtmpdir]}" \
        >"${STDERR}"
      err || return
    }
  }
}

# BI_check_valid_options checks if arg1 is in a list of valid build image
# options. This function is called by the parser, via a callback in _BI_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
BI_process_options() {

  case "$1" in
  -h | --help)
    BI_usage
    return "${STOP}"
    ;;
  --tailf)
    _BI[tailf]="${TRUE}"
    return "${OK}"
    ;;
  # NOTE: This flag to be added back in the future
  # --get-prebuilt-image)
  #   _BI[useprebuiltimage]="${TRUE}"
  #   return "${OK}"
  #   ;;
  *)
    BI_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# BI_run builds the base image used for masters and workers.
# This function is called in main.sh.
# Args: None expected.
BI_run() {

  _BI_sanity_checks || return

  [[ ${_BI[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  local retval=0
  _BI_build_container_image
  retval=$?

  if [[ ${retval} -eq ${OK} ]]; then
    : # We only need the tick - no text
  else
    printf 'Image build failed\n' >"${STDERR}"
    err
  fi

  return "${retval}"
}

# Private Functions -----------------------------------------------------------

# _BI_new resets the initial values for the _BI associative array.
# Args: None expected.
_BI_new() {
  _BI[tailf]="${FALSE}"
  _BI[baseimagename]="mok-image"
  _BI[useprebuiltimage]="${FALSE}"
  _BI[dockerbuildtmpdir]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "build" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "buildimage" "END" ""

  # Set up the parser's option callbacks
  PA_add_option_callback "build" "BI_process_options" || return
  PA_add_option_callback "buildimage" "BI_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "build" "BI_usage" || return
  PA_add_usage_callback "buildimage" "BI_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "buildimage" "BI_run"
}

# BI_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_BI_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    BI_usage
    exit "${OK}"
  fi
}

# _BI_build_container_image creates the docker build directory in
# dockerbuildtmpdir then calls docker build to build the image.
# Args: No args expected.
_BI_build_container_image() {

  local cmd retval tagname buildargs text buildtype

  _BI_create_docker_build_dir || return

  buildargs=$(_BI_get_build_args_for_latest) || return
  tagname="${_BI[baseimagename]}-v${K8SVERSION}"

  local imgprefix
  imgprefix=$(CU_imgprefix) || err || return
  if [[ ${_BI[useprebuiltimage]} == "${FALSE}" ]]; then
    buildtype="create"
    cmd="docker build \
      -t "${imgprefix}local/${tagname}" \
      --force-rm \
      ${buildargs} \
      ${_BI[dockerbuildtmpdir]}/${_BI[baseimagename]}"
    text="Creating"
  else
    buildtype="download"
    cmd="docker pull myownkind/${tagname}"
    text="Downloading"
  fi

  UT_run_with_progress \
    "    ${text} base image, '${tagname}'" "${cmd}"

  retval=$?
  [[ ${retval} -ne ${OK} ]] && {
    local runlogfile
    runlogfile=$(UT_runlogfile) || err || return
    printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\n' >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${buildtype} == "create" ]] && {
    cmd="_BI_modify_container_image"

    UT_run_with_progress \
      "    Modifying base image (pulling kubernetes images)" "${cmd}"

    retval=$?
    [[ ${retval} -ne ${OK} ]] && {
      local runlogfile
      runlogfile=$(UT_runlogfile) || err || return
      printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\n' >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _BI_modify_container_image starts a container suitable for running kubernetes
# components (since the docker/podman build environment isn't suitable), makes
# some modifications and then 'commits' the image. The modifications allow
# `mok create ...` to complete more quickly.
# Args: No args expected.
_BI_modify_container_image() {

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify &>/dev/null
  docker rm mok-build-modify &>/dev/null

  CC_set_clustername "build" || err || return

  # Start container
  CU_create_container "mok-build-modify" "mok-build-modify" "${K8SVERSION}" ||
    return

  # Wait for crio to become ready
  printf '\n\n ** WAITING FOR CRIO TO BECOME READY **\n\n'
  while ! docker exec mok-build-modify systemctl status crio; do
    sleep 1
    [[ ${counter} -gt 10 ]] && {
      printf '\nERROR: CRI-O did not start after %d tries.\n' "${counter}"
      err || return
    }
    ((counter++))
  done

  # Modify container
  docker exec mok-build-modify kubeadm config images pull \
    --kubernetes-version "${K8SVERSION}" || err || return

  # Stop container
  docker stop -t 5 "mok-build-modify"

  # Write image
  local imgprefix tagname
  imgprefix=$(CU_imgprefix) || err || return
  tagname="${_BI[baseimagename]}-v${K8SVERSION}"
  docker commit mok-build-modify "${imgprefix}local/${tagname}" || err || return

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify
  docker rm mok-build-modify || err || return

  return "${OK}"
}

# _BI_get_build_args_for_latest sets the buildargs variable that is added
# to the 'podman build ...' command line.  Only the latest version is built
# from scratch.  Earlier versions are downloaded using '--get-prebuilt-image'.
# Args: None expected
_BI_get_build_args_for_latest() {

  local buildargs

  buildargs="--build-arg GO_VERSION=${GO_VERSION}"

  printf '%s' "${buildargs}"
}

# _BI_create_docker_build_dir creates a docker build directory in
# /var/tmp/tmp.XXXXXXXX
# Args: None expected
_BI_create_docker_build_dir() {

  _BI[dockerbuildtmpdir]="$(mktemp -d -p /var/tmp)" || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }

  # The following comments should not be removed or changed.
  # embed-dockerfile.sh adds a base64 encoded tarball and
  # unpacking code between them.

  #mok-image-tarball-start 
  cat <<EnD | base64 -d | tar xz -C "${_BI[dockerbuildtmpdir]}" 
H4sIAAAAAAAAA+w9/XPbtpL9WX8FqmRe7dYk9WFZOXf03lNsJdXEkT22014nl/FAJCQxIgmVICWr
d/e/3+4CpChZ8kfiqtep2GkkkQtgsd8LAutQji0/5EPhfPOHXRW4mo0GflabjUrxM7u+qR42K4e1
o3r9EO5X64fN+jes8cehtLhSlfCYsW9CN+DxWMloA9xDz/+iV5jz/1S6YxEP/EA89xjI4KPDww38
r9UbR0fE/ybebjSB/41GFfhfeW5E1l1/c/6/YCdyMo/94ShhtUr1FbseCfYu7Ys4EolQrJ0mIxkr
u/Si9IKd+a6IlPBYGnkiZgmAtifchQ/z5ID9LGLly4jV7ArbQ4CyeVTe/xF6mMuUhXzOIpmwVAno
wlcMZY6JW1dMEuZHzJXhJPB55Ao285MRDWM6ATTYr6YL2U84QHOAn8CvQRGO8YQQxmuUJJNjx5nN
ZjYnZG0ZD51AAyrnrHvS6V11LECYmnyIAqEUi8VvqR/DVPtzxieAj8v7gGXAZ0zGjA9jAc8SifjO
Yj/xo+EBU3KQzHgsoBfPV0ns99NkiVgZdjDnIgCQi0es3L5i3asye92+6l4dQB+/dK9/Ov9wzX5p
X162e9fdzhU7v2Qn573T7nX3vAe/3rB271f2rts7PWACSAXDiNtJjPgDkj6SUXhIsyshlhAYSI2Q
mgjXH/guzCsapmAF2FBOgfUwHTYRcegrZKYC9DzoJfBDP+EJ3bkzKbsEEGM/8oC3nmB9jvNEw0JU
fQMDqrlKROixH5hHpgYYFw38YRpTlygOQG0RyBlQ0uA7kAH8RmxiMRCxAJlQx9Ad8lQBU02Xti8d
oMt1u9vrXN50e9edyzftk46DKKF6J2wQy5B5og9ixRTM40BLHiGI7IgFB9UGFs+ZCnkQMA6T1m2J
FtKPQKKIbpyNF+pBc6VeDpifwMSEir5LcGYknGHqjtgej+YwWjT81z6bCYBBiAjkBzokLGCYIco6
DOtH8AM+gXzAFVQMIj4DwR0DkCq1L9+ihHRuuu/bbzstPaXjvpTjmYxDC+dWenN5/p69XEAxkCzk
R4lav/vwunPZ61x3rm5+7lxegSS1plW7XqWHJ5fd85XbgCVpGExHIfcNWnAbEVVu7E8SjaQHCuMm
MvYR6VgwdPpsL57dstii//dNo0hGVt4QAcE7IKAFQPT/funk/OJXZlnuKJReizqiUZ1UxU4gXR44
fT9yvmcrN1baYb+6HUqmw/THRiBwhgCD/wKiBCSjwOg/zAnUneAOyHyhfGYzBuokSgQDtAH0YEl5
yCIM/FuQbyDi5YeeFnNt3cB+IRr2xhkXkNoEQrPC6bPF142TNAbvCom3+L4RXCSuA6xyk8Ce8zBg
dOMhaEn/2KjgtocDrb1/by+g2jhm3jr//VArNAjms9C2ePcpPaCuByKxlYinYOiW8LkfbrMoAqg1
AIsbCaApkjSWMrlzGxWva8yBJyYCDG7k+ih9Az9WxqTxSYKmTET6Zww4oOEFu9WHdui2We/8unOM
hgf9rYwECSCIcuhHYM9/R582F5mHR++/MN2grGAYvTkbkTnURgm6iRXYIwGGHIZn4MOw9yh3iBrl
UIJiZ2YL8bgw3zMIAEfd78dyDOh7chbBE+hgT4CTJp8IDicS+2jvrbwnGkePFKdgkTS5Fdsz/Nhf
C412u2C1McIASkSJ2ggNgGBQx+iS4Cl8KFBzbaZBaRd9re0AYgY0AsYLgKcDVBM/FAQMdsFdtCCP
CSRVxoIs95eMeMImsZz64GaUCH3LRbIWpjJIIxfdJw/8ZA6N24MExjMkJteV9QU8ckE6onQC+Gmi
xiKErgEojWY8wlAk89EZXQkMYhXwjAg3DtUQbdhnmcYwpEchHkhLIIcMyEmWfybTAB05ufdUQbN9
Eq2euE20/5tFgeQeuQy4F3MXHCZZGLp10uuySZAOYRiwY5z6JOFOJxAyCR7aS91B7JHGOlogvVzQ
xgl55A+ESlTBTotbCLyUzXrgLYFCSDLt0LmXBwgOiydhRjgzn3wYnminrTvKpN8QHO08hF8jcBr9
1A+SxQw0BnB/hsoKLfC5R2gvYgg9szfQJkBI0D/vM+QnDFgy0bFAxkEQf6BwFZUYQkjGietlCAOS
MuEC08GQuNoISakx1FFAVeDR3ADPxHdTCkYQeQhgOfhykUDXOsZBpA5odn0xQJlDbMiRBf5YAHaA
QRLTB4ScEkIskAGgSuLaJTQwZPUYuqjcJbF//IP9VwlDcuGOJCt3F0Ka2wbbtssGCKBPO6+77d4N
xDMQ0vVOWxA3gIkQKDH+1IizlRkc3YrlIgy2yQLhihRiZ1HEyFxuuQJCOgh5OWrPcDIEjw3f89Yg
tBGK5JhBdIIhPyj1wHzxQROB2jWY5SiRMmBp4gcWTCC9BXMHKg76AZPOugr8vhIu2poam/jD30FX
lbAwvgaLO1A5XDRQoNZhCCZPgpm3wD4oP38KRnd0B283jQP2+Tc0De5ELQg2QGsCuU1/1T3BB3LZ
BscwBC+F2q4cZkU8hAzNwFqJkTKLBCFzZWVmeejaxGKYOGTWYO04YRokvoUuYnmo7+80XuetNwKv
GYliPmugHhpnHTEw/UhWW6aemH5FcyQvKPijeiBHuhFxrR2XoMLv3qshCH2Z/fOfywTL7C9FUouW
QcQsxcov92YjH3xo5hLLzFEYEiKKxagCgn3rHNMTCN01h43XgqwMsxkXrG1CDtsEcJHvgGW1wcmS
iqMQAgeuzvJ8bDIeKnv8SmFChp7q2FGkO8fOy7tphwPm1rnUEYs9FnP2P2YmqJUWCB2PIYhgltSj
gz47ABWDvVAFK2+hnpv7NrZcoSMMwj4qfxgJz+rPW0/p6tNXzIs55Xw+iRCLKShgHThWOwD3AVHi
YnS6s8D+AepyD0w33ATHackCOsUE7msITP1+NW3X9rKerI+e0GMpSx2tEBUxAZ2DUMLjRYOW3c98
iTVn1JyZsD6PEPATA5V11ixXD8im8rg7s62gf4MwTw90sh+LIWBHyyhILR3+asAbihK1GoPnHqOM
BNYwkBDWk/JpBnQiE5g57DQP0vKYGJwpK3hTjQpiLyJazFrJWe6BTCNPWuTirBH4RnVfk5Cr8aZp
bx6B8sKHwTAssUBUcI3L0lzMWpWW6ALRGtFlU0hYoEs4huCMWZPNwLSONOIxpQEYEwKfdLA0lGxq
VjwxbqKgDsfN4j4jBxg9EcsxLI6lIoc/8Yld2G4i4gEGpLjmqZeiVCFu44GSIAsUEerlLD7E1SVa
56FlPHTjhbQNwzYOIeeA1sxw4WoS8ARHoAibFjVoeY1iykLWk+GPq48GY1r7QeCVgJZCcugVxJdo
QssjutMIY0m8t6f29WKUZWUItF6+/tA9O704a1+/Ob+8s0w1lBbh8EzrP9jOLDQ5oGSxdzMB8s2d
oR+GQv/7lB7IYVuue6fNC4bxYE5KnmhKWpj0EblpAQizdpNHYDLGo9ze5EkaMUHislDsjvwEbA1A
K5JsD6wl4AXCbxUfAmR4dIhyvBEg9ABg4ViWoubN4eUQIoCQjyGJHw8tExToTkiC9QRBDUHAIHmw
9CjrHxGGuu0iKAb/Mz3WrVZvIjyqHBheSKURCXpFAAJmg4AYhaP1yre5b9DaPwXRg/hHc7b88r8X
z/+3vF/QeZOzvD2/Pj8/O/mp3e21ykO5DL+Afnv+GgCWmY6qnxERSDVK+xCMhc5QymEAoiWt7A3D
v1FJVGLWoodi2VDEkL9rHclEn1ZriYL0DGd5Df904J+Tn4oTxicw6ZN8vbY8rdrwX728eHRydt7r
3Hy4PGuVM6dbQBbTjXyRQjk4XpnoiLx3A8wNLQtID0regtRbHFeQpssdA52oYUHAvNU71N1IuGNI
n/Ie1tD5D2JfDo0UbL0sUHPx8OSk9XIvV/D94hPotNNrvz7rnLaqBa+BqrE8zTUDFOQArPQU6Ykf
YIaSUcu5ydZfmb1BPPS6yCYBMU/vFxEIoG6QTFcPCEMhDoaQTsduZNXKWTcn12dLslYHYXuEvKxB
AIUm739ZctbcXhWfZVT+0gJEzvAGrMvNRfv6p5btaA6b5bBnkSzHDT2zgr9JyCLf0ituaqOkRf5D
Ytbr3lycfXjb7V0tCUkDZWQV4H5JzE2SWYQFHB2D32PEbd04JHCLaa6I3LoHd4Tu7vy2IHk6NrXJ
4fyx4gjuTPMcsh4azxlJlVjk75iFsdBUQBaAyBhaOf6Eh0Woe/oKpJzgQvqGnkJehLmnn0kyua8L
fHxfa5h/yDf2IBKegzyH6mVLeOxBmi3DLFNj4xRXGhWwRz3XU9fBuM4KAj5HWabAXdJmAR24a52n
9CHT9ywIRtjWIhjRfl0790I0RItLFKygctJTK4/SNvV0s/Y9ZPayGVdJMyuoZ4KJS7bKfrdPA7rw
HtqQOtn99TH+mg4egdbiBYVagxuSoJBSyklCCwMw7LpRI3/J/KzqXbH5WqzXtc8l54tao3x9WUOj
OY9qvIHM6J9+SzElofeBEPCjkcfEABN+yKzoXeUBvYRDWebRHF8SDgUl+zPMeUjEKa+FbF6LNuRv
PHFHd3FhDkPWQsbEUH08nvADFuIbl755NaLflVCOTXjp3FinconA/Q/mbQO9GAKX4dNyqdngsgc3
dBKNjiTfdbN4Lyii6f4TtrN0ej8vGrf0IEgyg4O49ROFb06vum8vr993ez/U9VYF+A19vGdmXTgW
lrgVbkpru0kRgX46/B3w5XYsPJgQeWM1krMbeGC7Q/9fvteq1irVo0azdHV9fgEd99pnhfFwAxW+
8tMrASlMHbwOGEt0pjIMUVGUEKF+gdsX+TYrm7VD/js0pFTZrIeh78fpvBFgqDmrN2EC+PbVHcYy
nahp1awKaQWkV43sQnowyr5+TRtJeis5p+07Jo3/9tvSi07v+vLXi3OgLPvIyivGYdGifAAP85Xz
MvtUOnl/Si3urul7CBzIoRWIqQhafjSQeCeFhq3lly/Yz5+9629xLfZ/6vWVP2KMx+7/PapVjuqN
2jeV6mGj2dzt/93Gtcr/3BY/4xhP3/99VKnUdvzfxrWR/5ed9un7zrOMcf/+b9wCXl3l/1Fjt/97
K9dbyYJsUzBt6/yzEdpdW71W9R9fgT33GE+3/406PN7Z/y1c6/hf2O77LGM8ZP+r1foK/+Fpc2f/
t3GZnamWiDzKeY4pZ7mFXNCZ8hhXdQr7tnHnU7mE8JBlH7NKyROQGB6zAQ+U2HmOv+K1Qf/lnxz/
1yuHO/u/jWsj/4sHNb5yjCfzv1Y5rBzt+L+N61H8r1at/OcXjPGg/6/XVvhfO6wd7vz/Nq6PxFgT
BXwChz7gaZDcmBusxcoufC+XgPWhjG700ivenkgP7tLPm5BHIEExQdOdgSrvwoG/xLVO/40QPFsI
8AX+v9nc+f+tXPfx3+wP/uoxHl7/O1z1//XDo53938aFxxfOOtc3nf+8vmzftC/fXrV2lvtvdK3T
//yo9TON8XT738QloZ3938J1L/+rFctswbMAxHe/MAF4wP5X69XqavzfPNy9/9nK9YKdStojAqxV
PtZ0ybcPmWM2WMxDsRAroWDxFDpkheVlPKESP9K1W2Yj3J+Pp2P1BhmL6WpSehuGCzSWYXakXunj
7tCXCPvCw/MSp70rOrWUNTAjs2qzZlfgv2qV+iyUJYLsQ5kzt/kRamgigynJaFaHY46nLL7TpYY4
zawwMdpowmnLDp2IibHwAJ0yoi1yWb/6UDYW2QEIrPVD5/LxCEcQWOMI9ymZ7T44jRz1WtOgThWE
qOTJKmVtU3AB2yUxH2AhHleGdCiIijvgNPUGohFuM8SaB3gAGb/gbFwe4F6xfEy9pabXvhYe1g8a
CSqhJPLG5gwV9XFDzYGYyEqiJmJBY6E0IKMQvQLJQz/xhzyb/UQq5WNvSrgpEGUOZFQpnmrRdXzm
ejS9FQgpPEFBwS5jMTjONxxFU8+O8LzeUE6daRpEEHwm3A+ck587Vg0CQetVo/GqhMfq/Mn0UC9I
8CCwlyfRqu6Cli+7Hmv/MzZ/iQt4KP6v1Vfj/3qj3tjZ/21cYIHSOKJNg9qyt40x+VnE+jwY2nes
s0bVqRIRD7hLh/3wVGEspgJ31skQa4lJOUB950lCZ0RXtNZklXY8uTF79qvr9Lrw9M+mzd/h2qD/
tLPxucb4gvi/crh7/7+V6z7+m2oVXz3GY/mP9T9rjSNa/2nu9v9t5XoE/1fKBDx9jIfyv0bjaNX/
H1YrO/+/jesFlsMcjrAyVSg98PhYCQCSj2KVzbWHRItf+4HsO33+auDyAR+8chuVGj9sHHLXe3XU
b9Zeua8azf+o1xqNRr3aMCdzPNFXq6JV+vgh8pNPpVOh9+pD6NEyIMerhWl7mPK1h1jeAHLNNIQv
FKu0TL3XQmEVXzqQoSknL8pBRdc8MfUpnVkqLgZZU6wTrKn08SAmVyPM23ReSxUZsMgn+x6ypO+Z
Sid0po5jxJIde8hqhpgz83gqjOFxleHI1nUVMIyK6AREPirlSJB9RqZ6gz5hktXUw7xWF+fJGuT1
9KjEWywhEwvZHsZohdpw5giWMpV2TZ0IfTgGj8lgzdxYiH27dCIjz0fqXQCyHaps1qL9P3jQwczH
0fOhbWGl0scrzbJPpc6tcK+wKoU+II/HJUyL0qWgchUtHsz4XJUI6gyLyHYxkJzyoFV5PE9MtcxA
ziDVNj1fCbe0+NqqYk7fjnTRXs/LGJLjSgUFla6+WTq5+NB2XVxCALhWEqei9F6EMp6v3r3CDbKt
XFTxV+kdJMrvQQJbWIEL1xJKH01VpU+lX6iU3ut5604xrP+HEe3T7f/T14Wfvv+j3qzs4r+tXF/E
/2rFMgWRHrUc8JD/bx6t+v+jw93+z+1c2/DyK+KCJl8m4th40xidq16B1cvDeYVVLLiFJ/syh4rl
Tao/FF1PNPVjGaHvb5WzN5n4eXLee9N9q19nWhaWxQRPwieEhnZjrdViT8tAKO9UW8+6r00Rsrwe
m2VMsn7uca3lYuEnXRqfVqnLGUX0WUSkS37rs/SjMoNYSMTkPQHcbOA5YBM5SQOeZL6wSKX26XtC
jAE6Pi0Ne/OIh75LhVEL03kDWLSsO1ib4bFo8VDZIppuQJ0CF4UHujmVeaeDsHiUOvY9DEUGS2ET
eEqly68HHGIgXNWPE5tdUAV4rNB+sOhQjag4K3ynxXzBbAwLL6mumi4rb7/T3Xaw0Gwbu5b9z8Kl
PzSwqHaY1aDXsZEpoGqzuy/HsxH7wrwJ8bKXBebvGNhr6LZmT0UharongGIvNwj14sHam0vMfXl3
FoU45Mvsf9XCcO2xa8EP2f/DWnPF/jea1Z3938pl/mZD/ocgMGzWf+GB6lstBLtgdl+w88gcwgab
rNUxF1lzH9MZKh/qZZp25yR2VlkYTBX9wYns9Pty/7UH+8fswGZ72d+4wHPmWNp787jZOXxdac/e
X2ggGJkWKaAaMUukLiv7A/aRKjwCds5AOXp484EKkMQyCCDRYp9+1IXYFyX4NYKZP7F0G2tas9Xo
R6ApWnqwOb9cndV0EdYJeEWqmAauUBfooL8SIlVe7yCr6LqKTlYBoECVReWCBQEOmGfKIuan2u3M
ZtNKfkpjB2D86G1iRvMB16UKMRVFMtEf6Di+P3LQRaSIFvRmUDm1eq3+IKm/fSSxsTQLQXsbaJEL
TMaXRU2Oe+E1Z/5stdza9RT7H3zR6t//sfetbY0bycKf17+iYzjHeMayLV/BGyaHgCfDszPAArPZ
fWcmHlmSQRlbciwbhk04v/3UpbvVkmVuYdkn76InGSz1vbu6uqq6Lne4/6tn9T+a9ab9jP+f4smR
uNE6czgeGWXBELvVhCSoCt8T9ubcyhk2yoXGdEbki1JyZC7/7gn4D3/usP9XOf+9cxu37v9u1v6j
bT/rfz3Nk7P/38N6s74TK1jRohcosEhmt0sUkJXiG6Ti6dXU345CH9gmk+dJaKRl4Dr/w8pS/4jP
Hfb/DT6379bGbfu/1bL1/a/c/+3us/7Pkzw5+39XOys7ONzr7+ztHfdPTnbf7Bz80N8juROSBNKD
PpeSyEHqihm0wG1oADEAeaC2XFFiVisUxfXldosJe5X21sX9GFDwrOks+nolmavSkhyGQNtPPj6j
GXyy+58Q8yO3cX/9n3a78az/8SRP7vqz76fq/Ovvt/3C53b6b8n/RwPX/xn//+sfvoNJwlhiKFRS
xeeAEEQGfvjJ/sS6n+hMdrqYTaMYY/oV3qHGyBVKhsgeAGMU0osWrc9JEEcC/mwzB4enSn0CY9QW
3uAdP7rdnDlnUYi1Y7OJkIkEzihTUgFj/n/HzE/z5O5/PFgfsY374/9O41n/72melet/g/D6vm3c
sv5NvOzJyP+a7ef7nyd51r7RRDh6XzaDwTfs52Dwz8HgHxoMHoP3WJHwZzN0S61ew2gByfp1Gkx9
vFwqIO8nL3+Kt97+ADMoucHCnyjeV6l/fHx43JPR1PmST17UI2xh0C0OOBwZ95YCbefiknj13w2o
Bvoo7MIoSCK3cYgmaTz4GUP4CCv+DJWRiZusp4r6f6TwgA05GNJtAXhCqgLAqAA2psL65UKUfqqv
l1bcbHEltw4J1UHjG6tgC0B/Mp1fiQ1cVwmOtDbzaMreqVXf48UQ9T8HcmrLci4AQqJKTsNcuZxJ
vl4cO4vQPU9d3v5J3ifKojCF6SUgdYmVLrerqaXgYFmDTD83yuLXwp/YQT4NZHvdxmZ/RPFAzl0h
dAZj1oqiO10I+B9hb0LXEyJAEPTiYgXL588KFsdZnGPYXsRAxZdYz0tZ0UtZ00uo6iXVJWAMiBYt
X5TimqiJl7Wzknz7qfayVhLfZkF8fTWkv7o5b6azxcI1ArC6+pR4KybjLUWSq2nZCEJ3vCCC/Xxx
5s/HwzJF+rz17pXhwLmAfUtoMAihyUwxrdiU200+QH5MgoZLadJdoJS64MRkflvRu1GOQG1ERHto
mCZVAOhMAdytTNBWAJaoFVZdEiu1nVUFVfqaDM2nAo7re1P6oq7pJQ7yZgHg19valBrHt7Qsc937
/F9J/7FMHtCKt3DnFiU+gPSj5xb6r9VZ0v9ptDvP/P+TPM/03zP99y+h/9JkAGmEMku5q6OfnEfR
F/HB/sRaokAojWX8SQ4eErpYuzNG5wJENSxrcsGc8x2lxFMDCmhOulTyw2IReGxRIz0q3JgRoCcg
jTUZyxSxLAAf9HUWRfMRnX3K6Nk8UzmAIrcxRH26idRxSJvdVMXJuTNLfU5yw1k2v/T9MK9iOKpR
WU1ODQaUDF0ARRdNT1R1OntFdRFTAjVynTcI2V7bdUiIh2COa3Cn8JDkKhjhhJXBJw6GL1bayxNv
jVdYl7FwheP78gLQob4MGjO+oiCgGBsPPXo4fLozARKEAOLBPNHANaaAqQvyexFGUs9PFuMwMRg4
iELZXuWUrhBgwCcK+6SglTqBuGaMLjxCDNc7FkVkIopig5QoyQtJUkBpT+JEl3WYHrIHk/N+8hAt
unbbpsI7ACYS0emgvMtEO2AgouqkZjGGdsWQwKhFjbtizuraUnuaAvbIkdFwGTVgFoogRhgYgGsO
OxKOzdBzZh7aVC2+qlHJGHMUzLCUCRHWS1P9/Jok0A9+hX9KBekcZQjIBZ2W+JKm4y2AFBMb1kXG
jBOVQrNcMb4qX5bQY6AxEdZpwFMnlipOWCFCagnmbu4hOfv794RMwE1B7UKdPJLt9Y2ffxHWTFT5
vVwouFOpNKpw0QsMIMjJve+ua4x7akXJJSsFSSBI4rjmTYJakBQlvKbZYyFRi4WeYyqEa8yai6rq
VOncHDc2SMzaHTpHOPbBnaPS9+scFsnpHJoZAjqsXQQzVHl9ym7eoWns8JPRfyvp/xzFnIe2cQv9
b7eX/f/WG8/+H5/kuYn+bz7T/8/0/9PIf3GWIhS2om6RltLG4qKRoO57CYZxsUmSWJdCXbNSG4W7
l05IpCQiugzRTmE+CRoh/TwAqg4G71JEetOcorDgkwGxt1tTtf/2m/gDKTYv4X9UpBoBBIT+uHr1
OAFgbtb/sG27LuU/zWa92cT4f93O8/3f0zySTZ84YTDCKw4ZxjaWBlIS7wXhaOYQopCgke8dRCZa
QaR+1mb+mBjXGjKt8byGcV3HkeMtAZok90ewk6NLulHwPRUzlNkYwrwJxe4MYZvqjtPm9FDGPp0F
FwDKZ74nA9OkvuDWrJWS3BdfoQsccvfsEhKcaSBPrR7giQKSQz1xADRuDMeFX1BhYnuAYMbO0B/H
PUI1XzZjC/rX0/ODH6eRl/jNS/sj8UOYTBe4v6RvUARp6Z4wZ6ZgWVZ+n6RupTSnuE/HuJX0O43u
lqZnQ8etOkQCBP9k41qpiqM7tTteIPdzHI3vNVXpHs0WgIh6BQsWPPiBcCoWtESxCH/QHBjtbuU3
9FwJPwBfD+UX1Nm8U1Hk1nPK4t8xnMf045LiBt+9uhryeotMrVOu5HfN5vcBqVb9jkmFSo79EeZW
g7mhD5BreUGzVcYLsqSmpcqFyYeDGkyBGiWGmSbvgD/HmPIbDfdXGQC9iBUWe6IIuerFivoKb7Iq
TKtXm1U7SZQxqyHlgw6j/qv+BRnmV1OqU3ZOl6RED/AZekGFDGYhSDl3gtk0CNErTJHxTCWdIYj3
+P7pByh/6VzJXEama/37unJz32Sw7XTfXCBph8EYCFA/Xu4fFnkHMIKhlW9sWv76VFBvIer/rFyC
A9b6xl7Z9Wqj1UK/tzW7k8x4n/zOHrw+xT/YNqFlnfw9sJd+6KV6XDyVA5WYuVgwO3etNggJHmFQ
K/fFEk7ORdQwYbMe7eBcJGy5o7N7AC9UHyebeM/xJ1F44q9G0Y/TR8KDq7qIpD02FgP0ogYmNzxB
xPTW6ElOX3J7M/eBmwAgltUY48JnnKoxt84VY1wapxCq51TRaIQmy1dJ1ZhtZ+mr0ITLHpk7nwCf
5y3Qgnn/LIz05z7FQMclS20UrPNEztMpsD1xOtniaesza4XsTzodc3zxr3oifeBHcSaXENEU3XXA
Yoj9cCnxwhkv/KWq+XAKF1/l90QSqXJa5D8jKWcJywqm1sSJf0l9I/AADI57e3I202mS4jIrqEXT
OQkJ5FJ5Os0PL8yMDJVHh3uDg513faPrNJjX5FXOHMsogMrkobT0HT2R9TRsVUnMuKqpk6Od3X9B
e0zyZRvt/61/cDr46/v++/5gr390+ibbMGCtNvA1Rf2d+Kue9BJeNYhj+bd3AXizXe0mYL1MB6qk
FNWRfPwFgGWeARd3uugJu16fpL6yvkpPtOvvAp2gqFS8m/O/zs16zEMlXb/jedmtcdA/Hezsvds/
yPl+vPOj8TVLk+uki2i8mPjvkIBIgTGx2rxIFJUyOzFq1iBtRSnlvEfNaW2pbBrfr2r565zOseoY
1nOpCploGYl4hMlDMjVWxFq7d9nAI3MzZsct9yeQPOYevWk/u9M7Q6aF1BcTTL0Lu9qu2mryGhlg
lXyjUeBeK2oMYWlKl6q8bYqWFjpFQ2ZzYrPoh5rcmimGFHNLLuAx5nHFDjcm7V6zlep23nw94g6A
jRoRasD7lQPKxFdsFtmFuijvdB0FcHGKAzjIkP/4zIGVYG9LBsj7oxGct8BoR/KsTvBBckqyX8qC
OU1GFbjLaJgmklmNLrLI4sYK8qBzJWzeUE/+umVXzZJOqYCu7S0tUA5devP63TozK9AZcho9gZaT
h7NdutbPNJXCdP9uMdbz88AnK//Fm/jHbuMB9p/P8V+f6Mlbf1bReLw2HmD/1X72//o0z+r1fzwj
wLuufxcWvtXtkv1v59n+70mem9ffHftOaEky9cFt3LL+jYad9f+LcSCe7/+e4pH6H8vaH3b3Wfvj
Wfvj4drfO0oP1Q9dZxorH8QOcdIwTA4QyHqlwI2gcwHqi0Q21CxFOPBRWVMq5AJEIEbCxMWU3QAD
u4OazajJK4sKDFU4ctw5Bdjzq2dVkcJjAnpFrIvwh/IHMFzhfAbNLemtkPqJWF8T26IuEuUSstF7
9d8NUTyIdD/VHPoeyv4MOzZnOrfOoF42czJez2aO5wvrSn9SXbSuhAUMtuqyNfPZrakXi+L6/xR1
fhoYVjCbCGs2Eh+RSSNHzS7CN/rfRmay9sJIQRfOUL6G8o04nRKd6ff5ZJpKM99JcfccwBvjauR/
tYZO7OckTZww5yufOC+e2cgnf24+/xNdp9/Txs3nf8fu2m1J/8HBT/Gf7Naz/8+neW7Q/7S3nimA
ZwrgyfQ/4fChaEbn/hhaiwvwPgjCUUTm3vLELe4fvD7siXW7SKbq15QJZjlMZYI5Oshmgn5Es1Qu
aWCfZIM+7I+kMmfsj0e1ReANJs5UtBpbra1Ot7HVBlhjBYoKapBK2xocN97lBM6YoxLou8OKCKp+
VdqXxORr+xAX5jKIfaMCjg6cX0U1X9Nu2QxFmp9c2Kh+Yc3crQYe9DqPcuZIt8fVs2jtrV3fst7a
9mYBGwzj7WIx8VfQ/+VCFOsfPvRYmeDTp5epl2RCijnzpYkkVbGN5JBaTlFS/t5p5OnRig0AWaQK
MZrXuFwi6gm7NHBQLXAQRnT5LtdxjXuL8BUDdQY7h1IrwsbfYaReG/hKAACFqAjSUKio+wFIu+/E
9jaU+PSJQWDmn/lfB34MRKs/CKZIGsImgAb2j3SgZdytMIB1myMxUxGLi6A9FNCyzriQqWij/Csp
YEjHAGsfq2sf4X/lGmDt4wd4/2C8f4L3T/j+7bffFgFKsXsXzjggf4c8tXIepIb0P9HqhBOuM5rQ
M3++mOFPnE/BoaNhghDXDoAAI93D5G27uL6xoP0trDdhuZhXYoAL5QLC2i52WvK2m/sBnTDyQU+s
8TzzURfO9lNtZ1F8D+M4OOkJlVMcv91/t386ODh8vf+2r3wQzNFXfTwXK2qvAAbLJF4X9Sw8XLGc
FGHpdJoulCsJ9P3wZ+FF6nJ3JL5Rzj8uxfodfNob9aupIJhN5gJqSfKnnHIorTQvUTqQ7Ae/jPhu
yYtCn4cPsIS4fexcjeLBlEKrYGwVfxmiGKAyE0CYUiKwaDHHwPFyt1ek3xTBMd+EE8eLiS90Y3jc
Ge0Z0CnqemXWxJ4/xGjzdp04P9tWruJis6ZQtqlCwxXplJoP6MoTkM1A9f0LEjBjVsSsUP1o+8ix
26VVKPJZ0B8KHI8Do+h/bCsK85iDgSfR8Ir/kYaZrUaz3kjmzpdgNYnwOrMmu12bOjNAdnNE2mZv
Y7O7S1uC8KYGAzma2PcnsZoXZbXAM8N2mvnVs90njQ8LeQufKRccP6p5XFWL5qLYxqKwY9ikGekC
hEpViDaao2bYXIaKYOMIDDEBhamCQ2PtDJhBmDAXI3EtokiTRCvccOBKl79rwhJ/4Ql5tS3aVQCV
DRwg/ULYgR8NtgTmdaJQ1/23ZLRKHoCq4nXwlcOUQN5mtSxrfT+E7i/kbMtvEizlCmzomYTiyxNJ
UTI4eEkOIFSrVeHShJIiu2r15CoeRqjeBfz29vrG5AvOqLA8TNeOQgCbQvJ1bVzUPxfJz8vk50Si
5W+UDeNcLR9SXxRKEarc1vVVAJr4k6q2gmorxgeoXNWQNHIXcKWomUjpI9xSJBEZO1PDkwI8lmTI
2vOAESgLHk5qmNlyEo/MMdjT5blPBLFaeAC4PmngI0htAJAd0WYBBFpGOEa8PaU4KQlxA7A9q0nr
aUEgTVHM2HcB4zzFx3w+g1ZZwf+zUhzhGJbKXY06DKBm1Z/51ZQDb9Ek0fikD86EzqvyaspjRRQH
8x6s9YpOFlP4mpwjUZgtXo4gVuF3LhDqaasYsyO771XECPprJXt+Qswhhr9yRmgpz+hyOkOnDI7A
s5umFHcGecSShFe5KvuRg0nnEYYC9WKmTWs4YcG81h05Db+75XSGw61Ga+S0hg3Pb3c7Hc8ZNu1R
fdTqDtvOsLOCblBj0f3V613FswtZT9ydqn8AYWMKmwOAqQdbEfMZOSAgjPbxM/JWg/7fj/rH++/6
B6c7bzH61unO/kH/eG9wcrBzdPLm8PS0f7ydnrOPn0W1qCBXn3VwAqvYY+zNh5bYkwcw01tx6EzR
ZTY6117/9a7N96xrBv6AzmjpBQEdVsx8x7tSkdc8CRBGIxWFwYmuXeAmJUXYNEVgFFgiCy4Tn04x
nEIuGeiXQuATL/wS8qGl9NyUEB3/c8RaPXoWBokhP9KiaFSBdJrliv86ZVP5MuMFRXHmlSwiXV/6
J7aR6qTsphcZcgdf/L/XJ+ZM6J0ajUT8xb9Uh8dFrLk5pfFkrFGRB1qUk4FDVX7okP++ymwmopVk
ejJbmQ2H2ImrLVO1gDFuHTRWMRx/WRp4qq/pdlSfE/6UAvWl+wItpwg56WorRczdElAyx6FFo9tO
jYxcwCe0EEZ6+kbkUqv3GxztP0XLnDvkVkISIBtooY+innIC6uFq4tcngwbUxQVG0J0PomgyiF1A
pgPH+5nyEJ8XoIFZfiaxLW3TViazoZrUGdPoQflamUeTsTEa2umlC9/c2yiZgi1s8Rb2vexmV7As
naJVlBO2pLH0XKze9smZTxGsyXjPaIccrHwsJviwiGD+MVXjx2LRnLciHI1GDdvp4ktp6Zpqxdtn
LYV9KW6AlimwozXywiODO/soAXT9QMbgpuzqWIgNv3IFE/pRxDhCwaAff5lHU5IzKpmgjrCBtyHy
t8V/SfO0ej6njiae4ZbDcnBGD1U4XUCP337bP3wtXt2Qkbptya5aBh3NQVk/vHNC58yfYSwIypIK
Z/rm9PRocHR8+Pd/wEGUvMBRAwQIvp+kUk/M5INDnaZ+YkIBOozrMAq+MpOijz4lKKKVQGiSLKVP
Bhs+E0c1SQOipyNmeHizWjN/4kxLtBbJ1SCHl0UayMzFlA7uZU85LUfMzizSuTObIEqgmk6Vl50r
kXjHM4KBAvPC4mFEJERM0bFLWw5OfPRBFSB8uOfI5mCmHuWE0+3yPADETxWWi8mHhfxChYB3EFZ8
l9yytyoIK1LvzgzS6EiGOdx5DwfdcHHGdCtTR3zSfT71v8451CNzyPHVZ5yVz1R1QshS9PQqSZEn
SD96PuyyMbJ0hRXYf4lV3mq3uoa8KHPAZ0dZ5kPNWSwd5QmoeETno1/SBZ6rrrxBjq9Ct8SIBX4Z
8i8ti/S10T9uF3QV5VkILAxAam8GoeVYiUchue60xFiCwQsrSE2B8okaRDVNqQ32D4BEe72z269x
XuDBLpDyUpQTB36cnxNuIdT5mdXKyTWCZSWGE0BWVpkR4dtxvDwZO2eAuYAoP3eAkwtJPjRxvvhy
dJdA4U0iqHmeakcz6Oyybe7TzgjYWIq3TSK0JcadyezE/2bAQSKl6KG/s7vbP6lmeE90xEU/K7OI
+mOs5G1nrrlmisSn/mGfuH5svyQJiVgpKxtSMOP4T+qCudE1wMjxMtrjpUfOS/uWmzpndNVR0M6A
LJxVa8YlRI1lx3x1waHzABewHEo66BywxG+A276wMgX9ezLYpBgBIwc6u9X8gcq8va4kT1IMbBS4
LoplUbAStqWFCrq+61qmClV7KhPtyyXhKfnFTbeZYCQEcd+rJmRmBSWEsJJ0ycTHrTLw5wplBUgG
o9O2EOglX3lQLQN+w40IRBQcWCjB6R8cnhztMrOJx2J6UNy3Kv4pilc3jjiV9+bqJv7kztVRXjX1
KRe4ADgAcuiiEDl50y9gSnIQ6YkzEZRE5CgGlm50pYvZRRhQEA5ypAg4SvL86NsOiytHwRTVlcQL
CryVn6vVIHELwORtCDzq5aqu3AF5cK+biRn6+QJPt5gkQ6/QOhmODyDP91+fbDN6tmbJVtEy+jvs
wSTqcBru711e+gBeqkUK5NfMcxoRDwkmib3KBEcuSO6VDhwvklh/ydlwgpZLshpIvECHN4TMmfFF
fwJYHREpuZ6JFV7+ZtVkb4sX+dF0X6TR9wPmKr9eTb1r2CIJmXbsU8Gt5OPdVagcSqPrHoVL1h4U
uLjZaDSh6NCJWUInvbInkahxPmG+rhDQR4sx9WkRsxtJpC7GxD+g10Vx6cRhibyVqNg3RDUuQjfj
oQiQHdAG1ZTnoouGIoXHPkm0JakKOaCEHCxdepKXTylgJSLCdI2JOBRhimAEr2MioIAncQGP5wt/
gBNmeNtObchM2nYps0yYXjLgxvLEeqZM3s1kchwlvCT1hg5nWkBdvpjIf5eq/u03QxSIBAFqXOTn
ZZExnn13qiU/azGFhC8D4Bk9yEH+ozLdJnpcX2wQTqdYer6l7knU3qZq0MumD+kB+s5Fx1hJWXnb
lZwQchejGx+qiioY+oLXkwBsVQzXgrwQty6AFsK1yzizesUbYYTEjvyWPSSWc6TrUDwev6YvGB9w
95pD8+tQ8SVJLHwPp6RUMKVJPoq8CfKPLLbZpewHJ2Y0iIZEuaaTeKpL1niC11kxbWAtOlQn9wRp
Fom8tY6SrJh8lMbzxWhUUdIxg+CHbYgOV2U97DyXShcVMiyqitRVt5KjbySCOjNKuyTAP8twPcRj
fiiqyj7RLQxCk4+2lJ9Z9s33VGv2VmernBr0aW5PjBjzSHAZ8dyV3hWWcLyJMgZNz+SH1zt/7Ykf
z/meQ455uRXcIN99UpcXKhSHMUUyHw3XDA2ABStLFy1p6MoJ8UAxM9Tk7sBKXvnzJAQIanWloyfM
ozvWDRAVLWZA012gwjHpZenuyeZuiughTxcO6eHM1TYnuU1qXikEpxQjI9aUbo1JwpHjNlvirIpG
XkAeuAvtfTuRfEkFJ2JbuCWeeKijWEOdpSrgu6lf5M/qQgjPKJ40VVhkJwY35qrlrxpnw9LJsLzx
7ZKkpoGfh3wR8XTq7lhuBdqJ+htGAklQs/xMlagrPjkDVekH0EefaAvYXig2MatMeY4mtjmsJvQr
V6aIXpH5sL2+IfWtROmnDz/1Pr3obdCfSvk76OJG5cNPFXgrf9erviiZl5Fy4L9BfYCHvR5g0qYS
XePNQKoVJNNQKHonLBrGCokSokPgZ7HETDpM1BSVnj7GH6yfPo9ZkIZUqXTgLpcyj7SQLSkERucW
XrmR0AKlkZogqpGnLxZaodIJ7gktcwuYrJW1FSV5A7DEzquAEFuwHuelT/fzs4WL5y05f0T1UDiz
RyOfVl1OLAJsNUE+ktBmgo4oaC8iopxgfQKtIGtDFgl4yo8pUiJe2ZjbRnveVk63UcLouZHH2B/O
ax1FhAuwVmUuZV7Rc0ZiHpgZGf+D1zaXdWImdpmh2hjB+T3B83yMAiZADeRgpMLxb1FlQEMbA+tr
4gZSIIZ8l3Auv4jSr3wVvN64LpUT0l/LS1B6hTs+jfJu5hFWMB9LKIK2L8ZuooMLL1Z05EkFi3C4
O+qMZOsR2PrzBfEKcTBfkJAHSjEm0JGiKH8Y6S2ihMZVcRiiZ3/4x3OuUBTNPMCMQRnlg0ZNSTmS
ZsgbP82+IBHCcs9zJ0bwVJkTmqTM4r5D1IamrSClfJXMKBH7GvQf6VDDNh/DAVcwLstLul90xHBz
34gj8tgokiBX0LOK2U85IUuzUeIlSHm19xrBL8RgDdG4RHKzFpKMFosSLccyeC+5ZS1YFpK3BuEi
WsQWCjHOZkoEtyZ2nel8MUvUbtm1uxRuTFRUUkOsiXcEiKPGeBfGHK8GpQSrOC5tWgSBxWzpJFAS
G6nSlnOOBEopjbS4yZe+GREgrmhpLUtfTYJCXURTVAjoHJ0uiepUalIBOXal4jpqTMAr5D4DThUT
FN1d7aprpATZA5Yixo8XUko98fTDziYzUlotgCk8PQ5BNXzGIgbdl7d8CMVaj0x5/V+wk3+qByXo
6fNaK2FXAUiiOAUWqkqU//ozDEWBhA6LYDa0YjdhqIQ0xgAIMerNALSygN3heBskaedAZCzPr32F
R+7o/ZCiRKAusey2vALB4+TSYdKabluM/lkWvEEewBYz4G8YuPCEpc26CMkSrYxV0BxIyX0m0gXg
GbSfkISYOm5HpCpNoqHUnPAJ6BCNeKUniOelwh8J8wEG+ZJEVojnxi0F0lDMn7oYhQQ13wlPIQpJ
gfvNUhrzpxTT2PUte7OhQXcRahHLIGFdc77eG3zTyujIO98LnpM49zmdyZJpJHQJmSSQYs/cUuyU
MUfwCYUNteREvLII9c0XyyGktGUdCigtYq1mh99yxSLkP1sJWJKCLC25uZySqKhSiXIyAQurD/MR
xhQnSbluJzZXkJpU62vYGL7jni9hkYoSF5CaoilcMeLD8PKatIEEccIBkvnN1lylRkktFI5tVlkV
WZaPdchrEjF86wbeK2G9ys9lnGqB3Et4gY/nx18UUYisleNdBHHEAhCWTC0m06w2rTSKWCMhBtmw
wgGmaEtYNdXfz3DkTZzZ1QB6lGirxdWzqNfqfhKv9arifpECXeO+FI5nPmeK1Wo1EfSyfKD4OT0k
Uk2Ud9LM83w7hQmRs/BZB9skn1FMH83PzUhKVXXoGyPNuQ2f+YY4IZoFZ0GoT7wCa4JoDQgiwiLe
LHx2mxCioCpZ9OwBykct1fp15o9uEUHXJkDY4GttuhiPa1vt+iYV7X91kJKDNZoupPozfWfY7Yn0
o8Cp3Wk47c7WZsfZbA2brtfc9DpOs+G4rebIG7nupuO1vEar23TcUWOzueUOR+3WVqPbHDXbbqPe
yYKhDGGCt8lhFC8Cr4JkzgX8iwoaFdKkpHg7dDfas1tNwUFxeo0mOreSjExSi/xJQ5mSqG5pKONg
CCmDqYM7UL5Z0OPWaLjV7QDe33T8tue2bXfY9Rut4dao0W03nJYz6g436w1nc6u1Nap3nO6wMWo0
O01nWPe39P357jhaeOLkHJh8o2VaEGQ7a0O8dBwhq1CD96bXGfqO06zXW1t20x8NO5uuX+82vW6z
tdUa1muO63qjrdZmF5p04NOoaXf9LafetrvQuOt59uaw2R5BluaWP/LQGHZkd4dDt93Z7HbdVv6+
v3W+5STbW8kkK3b2spLgDvFDMH+zGBKxi8Z7a1vNeqsnavJ98HM0rNVR5RY6BLNnb3oNp1537a7d
2mwMW516vdvqOiO32ek6W94IpsLdghmxAbbaruds1ptbWw8cgYSYRieBmNaNg0ntLkOaAkd4qfbh
Q88Zh4tJ79On6otMj6ovqi/4V0quIo9EOB9lFIeMPuCvqQaXrZfotCY+VjP+ySv075wO5VDYbNS1
VJ0S6JRESVgjmzlorYkwYCEeYOj1jcwV6IoaRKNsHP5rJtIihGVWqyw25OvL7EDolEgJ/pcu/nM+
KSQ0GtYBwjsebMhus+40XQCYkdsdjZp+s9X2bL/VbTWa3XbH9dutVn3L73T8ur1l20Nn2LA7dU2/
4BQzXYZmC0aPr9Wb1ljAhxRQFHmHtgFU9LqYsbZKmVbILEli5k7cbLSYU2LJ2upxhVyPK+J6HAHX
PcVbDxVu3VGY9NQc6r1FV0rt0UFZvT8IPK19ukcqHCyEl8lW4Al/MvQ9j69cMIkEC+w8BZfszA/R
SyaRrqF/CWSxr4ggpXejNCEVaTXEO7IvBsGoRBKTKZRG2pp41Uu6aA7VqsWpXqFYZsaKJbDEaMUO
QLMI4nOOhlBNyR7QVcksYTdkl0nzDpVWk2pLBTbmGWUTCkIr5CUfLdSvnKoZNaPS6Tmda3XIeIKC
DsioA/uwFNBD/p6MzwFmid/GTmI+4i3FWqvRKTxAt52LPSBsX0powzpqtxTmPVbE1oulhF0s4YeS
eJWJMKjdaS/FtlvOd0vLBaWSYc4/xrHT83+qFUzE+/f7eyyRWBDYEJdKHNbeu31xETiYkSxv+BIK
FRPIOgpwItUl4Z/ibZLIhC/EfCdUiBMWeEOzHmWGRKYstHytkNzaq6EI7HFFizbS+bFziclXjwak
RpIagRTEziO+VEQ9AOkQQmnZjNjDBRO7LOOR2qQElRjXZj5HxxQeg54RptPgXrQxnbRIV8IaCa4A
cI7uBHaQLD0DYHgQP6vOVh8C0Xa9gaq7rNwxykCLDJyIFhuoLScJKwAeNjqrzWBXQf2ULQuRFPnw
TnslG57xXnuFCvNe4d6U7rINqNQtYSblSf+7Ik2uGspdqnHw8B+P7zmeu8SjVBucLUkGyn2W3t/o
6gl1oO+kWKVKW5czPN5nMfut2OoO6/ao1XQ2/U0PaMXNVn3kAh/X9jebTafZdeteE5iMxlJ55SLL
n1Xj80JChANuB9p/gHbx7tVgDMggpg/haM5vkDebAcgEsaEb4BQrxgNQsgN/FsG0szq5LBqvcEZr
IQbSVZSEK0o/WSWTo0j1gxpF9idCs2XABliiqHsB+agNs2n1rXjfhpUOb3bg6KXhzFcpumsZ1WGc
1G0uVjC0rOkzlCksqXAp00ntcA2pBHXfjMV6AqlpzyfSme2PLIO6RBk3eorR5Ys6ZnACB6oGxChq
Cm6prZNXXeem+pQOk4+u5ShKeUotzpkGKMzyZwN3NidzvO2i9rYuZTrTL0FN56tCvmJO8S/+1Z2K
Qz5p63HyJZjiutIRcYBgr3R88LaD3IXrYgVDMW8EU7/c7WtE3+wYZSmP6tv1jb5F0iSsMWFaTTXp
z0NpVxLYjRHlJKNlWbwhpxX7R3clQPN6SsJJmWa6wDraT+jT/BnMnTMoo9Si8NJSTM+ReHHJs0wy
H5bFVmmiNom+1GSB6pUzIQjke9ZByLEkgHs4C1x2K7NGqN/iyy9pLqJZhr2DE6J+58JudNE7UNW2
e+2mhj7OP1D5B14YA47fLiW55cXuKJjFc9PEl/cymhXtHylWc0TG1A4rIZF9IXdHXgOlmsRv0FRB
ZD6g0a9QwhJbfGugRzKthyZJXe+iJUrkWEkFXpD8SKm8JEnRWJBVNgMW1sPWSWnEkacsBMRxFE2H
GOddufxRYCdv4sUZx/AqpL3vpIdB8iHlZiidJLb/V/wEE/yx+qFubX16mf27nt5jmelZh0NKWC04
3NEcDujHS92v9LhJKUjtS3J/IqsqxQlSpXh7hsV2tOCbVoSb/SMcoUK1dNaR70ZoB8/8j1Li8XlN
FZarjWX3DnZOk8rpRh2vWBFYPuuS6CclrqGa8K/5cHidSlQzWzsrmo0bMEnWT+ik7UreXuoe4FWj
lB/NMJSUKzaIFEahSznVoxL0aEccvj89en8qPm5UX3wsC+tnsXe4+5f+8YC/1z7WP4aQ6+i4fwxf
9g9+EB/t5Vylm+foJJmjO86UhSa9JLsQsIlT70uzhBnOikYH4JTmNQ9CZPQB+7GrEsCs80sfGrSr
m9VN9rkDv7oiQidQCAyW5bEyOVqYoftW3fHP5gil8azKTRlPOF9FuUi5r/Z9vd3KzsKUJhq7QOP3
SBzGyjur4Wiqu9VuPqS8Brnfkh2BWkbRzOcNBthXm6ryPBBHKvGvtjf2FKrEhaYN5koLXwzuNL4g
e9ylD1V1Q0VXnNOx4/rkqEt6FINJWd3z3O2zsoFyypcXeZ2AIQxO+jvHu29efpVmX0tG8QcRjTSG
QxaZWn9eET+j4HDqoEnXOeCqM9JVCOJEOlFcV0MpSttlo0MFwyUAYtdMT5Y60CcdWdm+pa6OUR6g
KAKZBjwcGj7kd+M3rRBf/Inzr+qa1t890UO+S7NSh8LzlCqGggrORnWqQIjcO1l+aQL+nMp18xg4
73XuUEyncCScGMyjAdPP2xtULkuMqqi7MSZ4TKDcnC9N+N25RHKBb7Gw/O5FYxlJ6IYSObXLKVnO
m1S3MgvQakF4Qw0LZFdvyaTuxpMMS5QgfVWOnGV+lQNDA53FVT+8gGxlvaosYhpkWJhtckEhSTuU
7u8f0f2/nkh5QYpwDFjjonUPugxy4k8UEJaLt5BjCcOomcP9I6hD0l7IJOouJKaoKGLBuQFGwMKU
FKsKH7nH6xskiTIzltOClqRRZCmyDauKrpWDlNjBYJPSdZdy/kSW4I7e8IlUziAP1/UY8kybpas/
rihc6opgh0oGb2OkbXxTVldPWXtnA5EnIxHfbKvLDfUl6ygmH16M4HVw7FDZgXQLsF2M1z4O1zey
7jNTDZc/DtfMdtfO9JWZ8qgI+TMo6MP/fMLrOn2LqS7TJEOWACupyaFdJDq9xUlCTVje4RZgxtDX
IZ/5SWyQ1kdLMyDHSM5I1n/Njpau/UbJDeFIxe6Sd36JtblxfbwKAAh9y+tlY0lepYDWoOO9CJe/
Y2zMzp03ZucRNmYnb2N2Vm7MTt7G7ORszM5tG7OTszE7j7gxO3ffmJ0bNmZneWOu2Iudpb3Y+R17
sXP3vdjJ7sXOH24vdh5nL3Zu3Yud7F7s6L0I1a3nL4/pLDadogsz1XZwuNff2ds77p+c7L7ZOfih
v0crq2hOQwVNySDpRCfSHoP6aiE8ahmiSfdYXg6XlGpAicVli/mQro6QRtdsL/Il73ZO/mqhjgGz
/VQZkpLqooi5lzACeh7qd6VRuXSXQ7djUiClgnRQPAyUs8bil0Xgz8esduTNoukUbSbek1fVuTsl
hUTJMLGrTFagZ00kVj20270mSquq9Xqz3WiIC39+Xvdb9VG76YgjmN79I6HDjneqzWZzsy5e4aet
Dsqu6lUvmjhB2BPthm03Xoqd78RZFME0IeNZFRuNzbL41z05Y2hhqMe6QJ3vx+g8taAU2ZKW7E57
06bZ2tqq+44/6izNVkPWzi2mOiEbFHatXquLHWG3GtVGGzLV69VWR2y0W+Wc9lrp1TlczB+7vVMp
lmIIwwsvVlxKZozA+BKtq1ku7cvL2aQXFb52rSijAIJY3Aus9xSNxEVADv/g3JCQzNsBKCsv8MgW
O/6CWJLnfMfzOLANbiQSdSAe5Ott2K8kCA9IWVNL3Kw5uvQTKD06PDlV4iMrTnpZr6Hmm5f9MBUL
LyvGwGbf94939vqP1ATszNVNkOsF5Yac7W6yXsnJi/oiRNRPTu2ZucAoPmic1WP8EUywfrYo5KMa
yBrNDL+QsuZAqndHMwowEEm/zDPHpahAeQ40s37dEv9ihhV6RvtmSXVkSZche/eZg4lzxfM4F2jS
r0wnlROtDe3XnO+ipV5LWb4e7e/ZZEqL+pHkVnheSC4yyFsLO2OCuSxQHooK9ID4HzfHf+FTnzSb
LJrNanx+/zZuif9mN+stGf+l2ejYGP+t2Wg/x395kmftG1pyDvZzITgODBoxweb/y/vv+7uHB6/3
f9i+VZaxJn50AlaFd6aBkPdZBM1k50OuZ9HtCSpZM43uBTFumO2T3Ua92SpQ8C/c8b/a1Wqnfi3J
TKCxsF13PibbAsLUlrzYlEpF1lh82YwtZzrdTiCV42chSwQ0ENFUWiz2SyyO2RDRINOG0MMvik6M
xz5ktAtEQvJLo7BanmB2kNEPOhc0+5LpcCRQkoM3zBhWy9heJOBRzkNrP4kXZKIA1NApMHQAqZNp
r+b9GRNQhIdSfxljR30GXAU/SzdWjOzBBuTlReqJj+Xqi7WPtpLLr+Ogep1Wq7lWzK9HjZevWZDf
y8mVGbQuJJ1UTdGlYf7Cpcup6edXrAGF7oABlfbic9Sw3/Fk8T8C9mO3cdf4r51GvdPs2hj/udl5
jv/8JE/e+h8DR/qu/3htUJS3Vuv29cewv90mxn8GivT5/H+KJ1l/9g0TP/ruf1D8d/s5/vPTPMvr
zxYRlus+Whu30f/t5fjvmP15/z/Bk0v/p+NANprPcSCf40A+PBI0Laf0PAZ8EV6ZBGPvqzjdOf6h
f4qaDDhn67u72aCRRsDIdLBIMvxYN8qT73FnNunIy10lxi85qPzQaVnkKMU6CxfWmeuWxJ9RHcKZ
eEv5v252Biuyv5BZ6YYVP/mx4/7heY8c/H8ezMjSen71SLTA/c//bttuPp//T/HcvP5nwWTi/24o
uPf6Ax9o28/r/xTPXdZfnoYPbuMW/q9h1xuZ9bdp/Z/pv3/9g5Tdu/1TTQRswEu5UEjovw23jLHA
2xb8sykIIPgmH+kUIAILhSNNE5DVtz/zKYSegwHsKgJj4CAh5p4jX1HhMCRXSEjE6GeN6DW+P0OS
raA89imySTqciiM3IJezXuQuKDowKeuSzEKSlCeyRLFcYdsEZ1yQ1qIqiUhHVItRUZegjgrqQo8X
dIenkhOaht374ETEBdbarVA/K9LLHPz1aVjTxXAcxOcVg4aroD+YsaKBYRw1MisZjwtQQ4CRKEep
3rFiKIcCQLVrniJSCb88lz6I9EiCuDBaAE0Wn0tTDLRopxZ/Jg93UcbTDyyZFxCV1isUcNEp6iSN
hdcZiG90u65DiSSUnkqKzx32K80TxsbojjEc9rKPl3rok4/CkmL/M8MEmvD0TV+cHL4+BSK2D+St
ODo+/Nv+Xn9PkbuVLJn7jzRZ2//7ESpMAOVb2H939Ha/D9/2D3bfvt/DS87vodzBIYA0BgyGSk8P
BTZoUsyvxbv+MepbnO58v/92//QflcLr/dMDrPM1kNM74mjn+HR/9/3bnWNx9P746PCkD83vQbUH
+wevj6GVPobgq0Kr8E30/wYv4uTNztu32FRh5z30/lhS5kf/ON7/4c2peHP4dq8PH7/vQ892vn/b
56ZgULtvd/bfVcTezrudH5ieP4RajguYjXsnfnzTx0/Y3g78t4u0Pg4D48ocw2sFRnl8qov+uH/S
r4id4/0TnJDXx4fvKgWcTihxSJVAuYM+14JTLVIrAlnw/f1JX1co9vo7b6GuEyyMQ1SZq394Cvg/
+7nL+c/y4OrEe2Abt8l/G3Y3c/436t368/n/FM8aH+l4JkgnGSF59PPIe6QWo3ygXJ+Ue292DM0h
zvDsuQzHkYPBCgraWx7b4vlzQPeycK55+HzmXASx5QYMa//u6fiPe+6y/3/vytzM/3XosidL/z/r
fzzNkyf/XRMXwaSHztmmQA7OnWFvHm83evEl/IPi0JdCvEdnkT2xvoG+H8hJzHq9LD6Q9cknwBaR
dcEyX3iRvywM3Bp8/UTlLfpX6S6I9V9/2H/3rj/4GxBIQJNcU6rmQZJ0TU1xDsW0vD9+m+SR3OoA
Pl4bbe2zmwhxFn0jUJ49Y8+/k8V4HqBPxfnVlEly6U9CijR12JUKy51LGFO1BFSwNm9W4UKokZES
ucp8GPGY40aWELlK0apP3jq4u6f/OAJSjfkq8g3Gmm+sIkPqNCHbJqNDa2zjLEp1sSrYUH7oAzoO
0FWcg+acSruGZNXTWXQREIdTskY1y6LY3jX6t4Q94SanURxwoDBqB9i1BYeZSCbxcMpsFy5zj76o
xzoXloUhmSguk7DYKpk4Cfowx+CSyFyg/FSWtP4GZSR0CPVXl/T1J1Ikz5Sl8v/X3tV2N3El6c/S
r+hpTFpy3C3LCQyx4yQGDOEs4Cwmk93FoMhWW2giqT3qlm1iNL9966mq+9KtliGZOWf3g/ocsN19
b933uvVe54GOJZD/rfcdaptJq04YLIqMVfrFDDNW2ALlIY0J/Bhe4fxfLD9MuJEB4GoP89re/UbV
xSNf/lcA8sctlXVMUjfWrLyxzV6qSWYU9pamadRwC6x34bRTXC03IBFaQJz+ODI+/4ztb3071WaD
irGleb1l1qRfWUNztM7H81S4PiCRy/5Md0fszYds96dH5pBT+6ZVtwBBa/PV4X/+/OzV4ePNLbOV
hyPkeK3Zp9ijbW2ihEB6xB8+efZf1IQgHT5IbuXszLeM23xUwUAKYBFtlbbE0lPtYZ6C0V7RRfdI
W6y6iAN27vSnYKlTKIhIc9XJfPjs5cGr/+4dHWOkg/6MOP3Yam80XW0+P8cELAN1letAH778W+0k
Yn1V6rIE0dXxINplf/rsde/V4QvkZ4hpwgo+qxpsg/6MJYrQ6kkogSh3udz1o2NqIMtvn9Kj41oQ
ipNf/EQginRyoVGzELx0GQYVqwPi8DoBMT3A9eKneWzJBbFlrwf6TQz6Ig7fHtGU1I7Re2p6RI36
XZK3z14evz54/rz36uCR3yVYUXvj63MCIehZoXklJIl4CZoW6dZuPNNYGv5ICe27gYkJt1wdLq/s
ElTp7OPDhz8/pV5qsi7iD87Y1NnrT2V4L4945x08f3aAldeLLzCWk7jTsWuj/njUzyNRLDMyzQT1
8vmT8DEcpKR6FI6fPT98+RptYF+ZgAiRw+BRgGhJ4mdgzoeDopTLU/QSYp/HbnCsCGXhKAHToO7l
c/PoUe/J0aueqDoRCneW5blZJJP8cEXdx0e/vHx+dPC49/DgGOuuueFTjtcFmgmLzyAsA7e8o0pA
6hDF82fHr3v/8ZKK1TbBQX+WbrzldhwY24h84He9RwePfjzsvTgANhIc6194aMTctbTB2B+BXy63
UwFnGqOLSpTPaZOuuosCnhII/DQcZ6fuzSAryi+IqJEXVQ01Ir7ceBt6oWHxuOB1swlzaCZrSrfO
fnjZTe4lX4fV75bu3Q9rJfM72zWS+SUoHmW8HxpefNa/SoQfh/cG6ktK+CXWvFMl0o1eKDT24qXP
5Zd2AOXXXo+aTaJSh7P+hB0w4NBqWYtwYztsh6uMx7vd7l+bSC4AV7iAA7OeB999sROEd/Pd4G5+
MuUYvT50idq7CVfGRXMwklheDUlQAD+KhrpRs7PLL0bcIU4cGTayhmF8P5L4Zk/ZJyvK1exdEwzB
WoSdIZFN447emmh+EPx4ePD4hxtQaIsE7KdIVXipEBpYMGdHw7qY00mYE3b2o4JTnGl81n5wgbAS
I6ATEwd0Dssc128TGcfkA91OOB1sPxd+52lWKm1K3aMpHnJ2kL9ns9ieXK4QtFhDEiBCUgwM/Zt4
owSvDtu1wDgx0jijQgYQ2+G0OAitdevpT6cZR2G1+EjdCJB/pY8trbkvESHzN2OAQo+JC8YOrxfc
LdsrzYWEbDrZOBsigyv38SeC2+vn1ELR0071hIwTXyTN8gOTJdgl7TTpBj365fBx7+efjl+/Ojx4
YUnFV4f70bs33fibtxy76WZ766tFSwM54b9+/PtB/D+9GF++WbS/3IjYpug1R/ilSeM0chIKlBOL
pAONXEQTw4lU5hd5QUd5YhIcIT/UKaL1nI2RawapaecFqHXGe0JaXWRBgUg9s+B01p+evY95czCD
KVknOUaXOr+J3xvgMFvbIxSSDnq2Xbbi6Q2y3tl8Ng5C+o/OD7Zz2DRv5QR5UbRb9Jse3pudBY5v
s0F3uPF/ii8DBuaiFqorRqPB7+P8+DmcgW+6CE2YKRQ/yiGV1MhzDfjTVoBfwRWjBji/j/9hIR/9
YcjnKQiFGtDywYP9Ob1mwyMgq4j9zHfVlXy8xSNgSlDgngPhRGXM1Mvf93fu3ad9apfDvpEFKXfd
Ff+ipv8eMMGB43Lt4e3Vh8v181TA4l3cD+irfjIpnHPFDYwRtmhfTwdjbMAuHDmFHu0m32zxAdS9
3012qOKTWZo+PH4sAHAcrBwhxivUmNp0pBzYGpc3jBUd5oxjiQA4jqd00GejM64qwYbh2AxH9j2R
wyBaZf+M+IrudtLdSe5v2Q7Qi6+2gp9P59NiHryezXOiTmnaGFK5T8G3LkBnzfxZHISyfJPVwMB1
JdO6VJxm+g4o8StY6wFz0IaZxYrCR0RwYytJBDg34WgaNExqHbfFlxXSMQbYAmLhVNJATohAPB5s
gYd5Dzu+ygBtzjvj8wVVMHGlJkPL9Ps29gN8kA4RYu0kaTGOJFz5caPd7iTb2yfdznAvcJ8q3/E5
Cj4SlIbOTu0SSgFqhxvZ3t7sJFSv2Vg0ceYcKsv12ChKe8M/kiR5a9GaxLhtnO/LmW7Sbh6dF3yu
vMOHeK0bN+eLRF6FtefDJrrG7m9whnDCcxJl4QcNqtBgwBbRbtzQD6FVzm3GgkZtIdt0qSOuSkNj
RLH3WqlMOwgYfPCd/zopJhchV5xcBksfyhC4GOdZ+KNzQo8QXa6e5ofC/ESoH4VeuUhTArLsNSPC
5rrA/T4QZ2QiIiMprMVS/gvTbf43uJf/ZOe+hkTylClumlUyCFZlKKHuc732QLIlw9/pLw6t1dRi
slck4JJW2Me2Me84rituBPMCtenFV/QCe22/RR0L6xmvzjDbuFGgi8QTYsQbNwCzMH1qNtq8PSXO
iC3GMdsiERFFYETCGjGQF3ij4Xr0p7sU1zThuslw0QjHFKG/23IyTIhiBoHUtVF/NokC17E7oP8g
B8D0Ty7v08m9zCXUHF6EKiVsSbAKyCwjSduLqBUI+zhi13w12EkH7X/LYKkfdlvcIRTcTe6fpkV/
J/hC/piddf8V8PfrgHc/PYv+BggiWnwirXN/Nv/1kSe/jy68lj3kKuFjBIG5PirpIrxN9WTlszO7
RbSMHKvPOiDdRQkAFa7ROA8z2LXTjw66TxS/qeqfoNIoduqHIIRZSIQu9ZX/uJUK7joqGDFoBvKu
A+a7dPB4Mc70Mx8UT1iap0UMtC+xGt0Kl4WjtpalSeMYojk695W3xCPksnZluhTFiLsgIkoI2tpW
TBdlOphSgvWct6Y8N3eClw93iQiBzCIF29gPwlkqjLAtCt1DMaDqTQvIx6eQavMlvPs9tTvMCDD+
3MGfzYakZZ1BHMTy/eJqdJYS8QwEMJhzzGeNUSEmff3CU3lcEfmo8nviJwnWuA/CU+uxiC4JlqUA
MonakvDv6AG/hqqOACkIVmW55sHlb5k8FmcSub7p4WwMFcf1n8E74R7P397c31ps+HtEBiwpEsGi
aYaIfs5mlBNMMl2piHSSsjYSslkEByOKmBP7MAhhDIOCZRTUbRrls4pswcGywX2eZsy1agJAwce0
mjQzA6LYg3TKcT41wukFgqC+T0V10C9zpElT9mj8iEbNKxpCISX8WRwjE4s3HR8/BvZurhBTTaF8
UdDvPWQs725s6tUFWuZ3794J4VvMPuhCyWnqbDCIK87GQRTvWapRka7SaKDZ7P8+n9rEpizQkeyR
AII0sf1hXzNqqiQDVq/9M4RhQgSmxGxn6v8lTCRn2Wnak5MAgRa4f/p2SUPyPu3TiM3X/ejND+/+
uXuzeBvVbpkNC8bbLT4smrJGqRLij/1gAlXLMcMshTq1BXI+0ltmSexy3fB6LeoWjGDFsc/ygmlh
wopGjKFQr1str0vttk8joxD6aNoNQrM4bicAuy19BxIvlbipTA6Ns6CbSgWxtr5Wl3xz1Ncl+LP0
HE6Rw3x1F1yRpV64cRtZQqsl7+rHjZMdzdg8d15IlsqcEzR9oMO+BTXIVWo2p8E7mkBGSkKaxnBE
HF7KjH3Rn3HsLVBDipA5TfhYcnmh47k/96W5oVmTAV1COFu3FS5jNJAKXzg6/6B3B8/Hu5uMLZNx
CSokN38bN1R5Yd5/Lug4poHPiv3ujoNQnfTGHUH3DgILiCXcOd83ZhIhJ5SUoiXbgzxNzZ2ojmjn
du9YdmFDGtSLkLgSnPkqryB0gn5cohRAZPi3QFe27KbW948zBMbxtZOOPTI0Ck1IMRtdxF4Or66V
w8ynvyNovBNPDUyrhsej30EVbbr3Jo2vfnKCmx4n3eqdZllBTfYvmtUXNbwQkW9hN+k+oKmgH3+V
H/flxz358bX8+Ep+7MiPrvzY5h/f8P8CQ0AIBAHwddjm2wAydGszw7z2pXLapi8ukGGDvzsu0qeq
PIW2kMGLcDNEcF1TVejsmKlEC8LLmgL+s6S2EJJ235cHNhpPj14dHb3uPaT/jl+/OviJw3orfVyG
62d5ATGXsb5R6reFUzb6lQpM/uauTWWIhQXm/828CS/76VlzWaxbPRwIwyrzLLkp/PHomF00+dx7
07Kim/vhCkMMnX+fAUmW22iWB2m5fE/QGv6siuUs4D2LSbTbVnW4xnIom+l0LEsGjJ5cj7X+Kdu+
JdOjwYaWxqiEP3EqHeQxTGBzt0I+Uj1WFTKI19BnFSxvAa7CxxlK0KeE5OLB+TV1y6tOPWl6K3J0
7FaBOcenR5hd99LOtVbxdNuukPeyVNZXaHul/deMCRV5YIZ642woEjiZMKp0pOvPPVskVMANPyxr
XjW10U6JyWokbu4h3N757otu8JFoYT5yplGq28WeKc+6ItQSiC++K1dbXqc2Ng6fFDWU6MH+worp
OeGO7blvsVEWy5TFiDIpp0z+hNYCI2bLDrreuEnCH+XtCRHgd7YpGLF0wAMkAPHtt9Hh0ZOoicCH
8PwGqd+UWH1EaeVhE4nW+a3AyvLk8HpUtLYxPKpZ7RLiANY3ZS5Lwl/mapxeClCfPSZAoAvowgvK
kIVgtZMM9CXEkeZWRcv94DFLvIwtFN3nz+HZveUnDIHEETSAWmyCDjinWeTsL/SZLS5imUDgBMYQ
gp3RJipNiHwCI0dYU866iovp4Dx5fvCUjlNY6byhLr7ws3ZVRmNEF8RiFgWHnZ90Bv1LQmTpNP3Q
AWE3zztff9W996C78wA5sL/56ut7Ow9Q10Q+pv5LjwLmgxBDzCpLqQwnoVCRmNEJy1yNJBP8fGo/
4ziKSewu4bc7zHRxssEHf4WWEvYY2S7eBsHLbMsjS3vCp/bY9kF7o7aMjGNXtS/ucHkfuW4xEJbw
Kc/LabzATqE5KFJD0SDbhGNFCEVOD7x2j5nPizSDlW99mzzW5ZEa+Fk2Vp7yV7aE+DUwySGJ9c6N
REGGFo+mMfY03yF5ojePI+xa5R1S3hZymeM6OzpuC8tSQsQeHpDknkKSAhvuRZbSk08ldB6V4EQh
Shsx4R/oFZBtpV9yF6zuGb6v7pvcK1EFmu2fXtthiVjYj9C7aC/kU7IinmD3frPc1k8Hr7UlRSrR
7sYNXi64MT+JU9Xqq254zpgJRIWZTl5qi9d6bHAm2I3GML2MVUlrv/nY3zbsm7PVNO2I84qO+l/f
XqwW+HduhTvLRr+W6+yrGEjD8TLe1SiuQdSJLAGA3DyOTqhS5FX4nc5Jp9PrLZhIB3VjeCvOzkWg
eOrGRAXl5+5VPcUPOSDdVQrJTL4B4m9osybCHvElb2hIc+XmRgaMWCUNuY/adpCmNNS6t5PA1QHX
U8SWQquAp7F8/lzeAtpMyt5esyF34b9nLESJ/uu9hgrA698mulZaE0MO0I1bfm+udcvXf68wONSL
xRJMivjDdAcElEpe+kw9qR6KaXqVsiV1Lre0az+djIjUGCP2D0SpLLCFbemWvbWlrvjsAdbFvGCD
BXa6m6V7ApZtXyG9FLkP309n7/vTIYIVcXqELE+95lSOi/tWLu1hXwTUky3JU/8bwr4HdNuN1Oq0
dJ+mEGaq8zxDGmRzwsTxP+aZy6+oliTsIs7G8YmxBuCEayetN+/23p60Nzon3b1OFHy7NIkMWcwc
1UjjLJtN01nMp+uKXXqUvuhpVH4gGmOTOrXx69ksREd8NhoTJmaSMQN9ByM+lunGJplg8FhsSJ9m
nNFdLnYhTrS1kUwfX3lqVDFSc4jTVFw2jPT8apaxRwpUULbExYhNTOYXCcN5TsweFh6pJpSkR/Jn
63Epre4FkznWE/ockKQbuMxKjGceRO/MNYwaEQSzS7PqWCJei6kux7vSvSk58E6wzXeTzY1O5UKm
ezU66fKPvc7FirVTQki4zjvBoYCwSQQuieiT0OVGacGqF2wfzgo6M3vNynUqxIHBDqAPSo2DVKhc
lxVm3pdfOOWVKvfdx08p+FWf7xT8VK1XDH93yIs5oFUK1WRJle+gqL7rFtHILQBLkG5Fprd2i3Fq
U7UHpqRoHW5uMY5cLLNqn62dNhO4caO/3dXJYa2zLqYverK9Cm0V+UPNCUp8uZPUVgrrjC+Xn15W
PhuJgc5stcaKHXoCoZlHIfogfWDtkzC0FIWvDVel6OxsxfaqvxQr+wrVP7mvVt3RDsSfvZ3NTloq
8qe2VM8JTGsAQgshk3XbHnBF9I+6PWAFf6uLVIU8t5XVLeV9NltK5/ZPbykH0gdmtpQaaQe9aVb0
jMwEBAaC8xjW5kzT+LLVdYWs3QrENpAVy2yCDF+W/vkszd8HYls8mqR1mnNE5hGQEErAxmCS2VTL
sFxGzMBMzDaNheGW6K3hDKszqxctK72U5w9UZoOohP28sNaJV2mc96/0Dp6D2S84tYPGxTkfj84K
DWb57JyjUZquztKY54RHV8T9gt3rnFskd0FED8tjYGpHdiXemjzXgwD73+YIgS36S5h2MJHGjqv0
lUkDlnjM0nPxxlSno8i5bLHqirNpwEAWFqsyc7NUF/KqT+B53YajkjkF/fmpox/6ZW8545A0f5JR
MFpvdjcdwEyQmfcD2mtQmxqqU41HZVm5qEiKYFvBlvpsGi/pQq7YRvWOMd3wXFURNNJK99imWCcX
FGKCI2wtVVYhC50fzvxUK6Ar4QFX+tN4YFVZxQPeZ4MHdP7/NB5wIH1g9mq5Gl2kxprY3yKAIZno
V+H27icZRMsxCUukECsC7UkQz8CLt/pXvwXxk5OQ2H8hLDvGnyfY2AkWURlGO9TK5+X3lguHs7UZ
mCdpQV77QbBq4/s6qoqRiUyL5nkzgJuNygvWjftqOV9nhz4vl7+pvLpzZ5Pmd/FZZe/eLa3B5kKk
Yt2kK0b03WQHzNJpf7AX/E6IGbbyvxLGhP+a2kz34MHGduS/MkrnEBDMw0li9P7FRdqfyVniHHgf
2J5GBKI4V4koCwcl1WkNQtkMS30NN1WTqBML5RSnNL4ZuBloeK/115ohOzGMlsE7KP7oFJUs5env
q/c4tTNOlTgzrWpPJAxsOq1AchI6+1IFX5XVKO9sB444on2zcyIIDA0bJCwRqyixZTXdjtj69diA
Q7bx6LwHhJYOZB/f5glnhScX++Ewa715s9sf00rvvj1J3m62T5j+2oQZqb6nS74gQNALFH3noUns
sAGFHqy+KSRKgamXFNeFxfeDcRmBMHkq5QdjDzswmkMrC7XOoZn5S9BqcRgEnQaZmnbbfOXT3iMW
OZ31aBPS8qZnuQfHNlp1+AyXxKlSY/nAWzVU3cDZDlGoUGvFIex1PV5pOptSV8hzehUB5VhxWLNR
3qaQAXl69zfS7WlqaGVa7cXy1qNCDw+Of4S95sHrRz++6YqJsNGKM5tumqw5KfPp6B+sKOQJSogL
Dz1zeZ3nL3zfJrEjccW92fVq2lEurYBdAIu/efH9a4lfsIN1w/4KnPsZZ4etb6GbL18NFfcsaEdl
IS18dK1tsgclK2ZKiOonGkM7HE0vs98kjLdKvrBeYQBZ1ZZLCZYZjRZnSZ9PuU14RhUwHbV505mq
MZSPejT2udk5UZU5R0sv0pnQ5OxbYiHBxi73G2QPMvGjhFnqXB2kAJ4ICxfhS+JscqucxCwaj6Xu
DhH1T1gek8KzR2pDL1yIVxHfODCqzTKOc9MlGlTpuTKhUZWK55xbjcW1w7TocQJOeVc6nCyRpZNf
KY7UpqtKF6OLtj3xhdirV4psJtdttn1jtxErODZbtOuJ06s0I+2/rvt6cHx8+Op17+Dh0avX+5G0
EsnBrfc33amz/KhYsaifzHKYFlGGmfX2xrXji67FYFiT4SbXGhTEioVoHVjfcze5dsIiON6CjdqP
Ijl1euI++7TRHWMknL6fWDooGTygcc/cOXn7ZcnSWcZtAtVcwPUDjkBaL7mOaOc4f38a2vloCqFh
eSYwheJx+2ty/Wtgw1H0acbVuGyi1yD/mVw7EUfKYr3wnTTZ6SSdk5Nk0ToRD1/qb/v7kw02Qtfk
hOKErE7KVUx+CSNTRuRWjqZIXBrSO8XzYOI1MCUd5jbrbVPaAo/29Q5dvuP6dXdceXfLVMue1G2l
yY2Nal69snjqI3FJdVh7h7E2jXMMh+ZbCZWd7e17dL/K9dqlDkNvYj3U9CW9urjCNqLpKH3znCq6
Yk3KBTuliAH4wh2qYJKS/IzfrCZt5LsSKisJDilF0/7g/tfb23bmzRGRz35BJS/UE8++NZ11eMzv
q8V3q7tri3yqx7bgyk7bEpXi5a77Hzzy9baJ7jr8QpSQi0IhGhFOwqHD+n6yj5hhVcLJekS6LklW
uwTqEtVdDDNRWHROup2oXNhSIfoK1Uq9t4NaOfveGOz73rV3JfWu9wlFVjYekQnC4CZBBG/djZ04
JvTcUAa3G4RJCD4XP0KgH4QmaVQvztK0967VbbO6EDjtvUk26BUma6A/GGwLjbEhYzH3sLOmZJE8
rmTxGKS+b57m7CkHsyPM4F24ed8YUAujbOXEGa7cWXD3v2vL8a2Ertbt0WpnK5PeH6ZcbN+o3eV1
kasNmPHNYA6WRWMstWSqS3EVbvkt0CYuhgxurVzCprF2qcj5olueSjOesjlu2xfPEHZttVqEqGBQ
/OXdvI1oUvT/d7bvbTEHrKMHDOZ8yE7TLEUF9WW9m6jfEO3Q0MQrm460HvtgAoHhshAN0MSPhe4V
yNmYemTBYsoK0SmEfIladf3N0MVnLGzlUN9CMJx5bYLX7yYP2McxZKIxm88kaIYN9MSkI1vgpzON
PaHULndA3NI1FN+eLhsHeOOw6fbWgYMWtUV3dJ6pcZsG5wh38BYrHO6EzonKN+MpSfaqF2Ml8MKS
sQrClyBbTuRXCJEDZneZCOwmXydd4sW2FwHHlqmpwx9NOSmycePTi7sxKOxFYNxFRDS8GyyhgTNW
ChsbxXketGr3kkjp2cUJsWXE0j0XHauasBmI7rBMNcJgcq1sx8gIaHkjSWyERAgq+4k13dOijwT0
8Jf76RXxAGfI3oQdy6wAJ+1MseIZPEGSJcunsg4Izg/X/pLVkN2tOvy4DEwO5+1T/Ym+fAlJCodT
2H37tp2U/9xcaaGLWfqRd7+Lu5h/mJxmssH1BOZJoLEbWFOiegWEckgLVpIAzIx4yGzCPljwo2M6
R+K1mHnGuRRaWM0Nps4eFhD4Dh32Z6ew7GWjARfhpTp+jiQnYi6YuPIE1n2seq/+Ef1CnVqAaBD1
q/Uk18I9+eV47f+AHL9dDp9gKWYfZkV6BxSMnMCM2AhTTUDI4B6Dw6eEtJsyXQ9vcrk9NJc3cK/4
sxJuUVCC+PaC/nwwImw9Go8KiWkKOt76ZNmIpxxlCZqoYQZmnW1RGxVuaFCKjWjGHaEXUWVkGkWh
5gRVZqBZCZVgGdD6aDVLGBMIZJaeZcPp6HdvQ0bNEi6kQbl4vf6aNVfiQ9yW6TVfRj1s3R5wH21f
c1v+JHeFCSSlMmoxLdS0bXlAF8ola+CI6LqkpRxK1gos5ek0ux5lc6YhnA9rdn5uYqOIQGf2GdRS
m+1bxPJ8N0Di5uCFpJpHS6GJihJuWbezwUCD1CRizaxR6xjOJIXh1iifcPzgYnT22wemXFCv0Ewj
gSYqoa2+5UY7zcRCzI51i6MvDtLJRYYgb0EL+8+I+U2orjhmIRF94Si/bWy8YjIvRmP0k5dAEe0P
S8Qcb9+pahqfPTnep0NoOd+4j1ioefDtt5A7djudN+8Q3aUTYNk1bFvUvbv91cD/F4nxxtB53veK
rDfMwCvXS5E05VtbmUbOChcGItAJPIY38Lu+65uj7BL5Pmf8GufQwxHT+2aXpied7b6N8DuCdOH3
NvVot7oX/mxt6M1Q140PvK5CmrTDmsb+YBWnwKNKNz8evTjk8AOI7QerwXLhiri7WsFIT8uVXr/4
CSXpx+Nnr3ZjpAVfSPTAcrlSIIHd/duiNEC/XGmEbp/dfdxKC8iYPieQql/dRSPZ3c/y6+528qAM
vxRYwnVuME6GHOdP+1eu5ET53nAcUzsYl4tXtBK7+93tB9vbkJOLmMpcBBp5lwl7EM106E8JX+PM
Q8rSLCOjJWUmnYcO7XqwO9jukGh6ePjJ6JqjF9bUFfLAeAYTsq4rROe27jXuZhHIrNKF+J0ostXQ
TZLFyjAV34KBGF5t0hmb5B/y3rTA8O4EL0bTEd3VCLX99OXPTPP+IpZlprtHx/vW2GzJGk2t2PeD
aHT/wX3fGM193w+/enDf2YD7HzippMhJXPdFkaWmAPvbzWXFFr1siqAQkUPvBPGwCLaZHIGssIri
4vc0aA23/jHQH1f9gmXhkB+NzsG9EgYGigYijuCi0IAAIuq8u3PyZRB0OGYYMerz05Z5tRWEdCsh
kv+e+xZvLL1XmQX7kbJefjtc0qx6KqsG2weHvOgn4Qa+wPrAuJ/KTbFhOi7OgkTlGsl8/DcerTkS
H83h8MXzpQ20WAYxYxCGAv9oaEm5qnHglMATXR6RX1Y7xKH1CWXvubwnRpPCoeaplfkFg+E8XUrr
iwG2xvxkOx7aZf2cNULzmYG+x/ZIXHmJkYGmHm1whzxGLeeovaMiT8fnidUH8pZJg50SBVvHHInv
CMf2s0RwlQ7bjSuk8OdxWU3nGjkYpU5ob5BXxVJHgxugiNFKyqJZq/t4zKvGR/kjq6HbS9q7pZX+
jetI8IOPorhwtVSPUalyzlUkhcBHSSWAKuVT2zWl66Lza63SSweidNAtnBHVUuBG8US3mQTHplka
zCeTDzYJg6+SOgVXUtLuSFQ68XT2F7ZbWsc66h9iNZp5v9JOTaUlBM/7CDxBGTMr8iQcJYl0216k
+31GjbiG6FvpAyFTvNb8vbdy4n/ZD2w0CtA6huRcyfd/WyrVTe6168VAoXI0pZHg8LNpndDGqUYy
HOVeMOuynAfMNuJz3QPpwb4aFhd1yy53Vf4BzDRLT8NSeDbn286RWlb7WnnERcmZepfupLokyOHC
3VI085vlpZpNghWXr9ehpWU232qX2n4sLXdQad6BWN2F0o6gTqgieFkktyyF5/ac7nhlFaeEabte
1KtvmRFqGmsVc6JhqBKUjOtWIM2m7ylp/yAitemcO+2v7OPh+3ToH56zvXnj7wEiKp8edbvdF0eP
f35+GDACyV30+aeZ3icWtC3bbPoxSlZQmXUWgqESsuyOBAg0LXDcncBBHXyn5KRJc5ZEn2Uz7gkL
Qd73ByK/tgk7YH+Am1UF9qWbcDgjMg7n8v18OphBCkNwXjxEkFJ706A9OcqIn40I54NySGyNNcBZ
z4ybc6svEmx4LBEgcbOywZLFEakN7xGC3mOTB9EkqAUFBPbz6YiDibGIaJAig5TYCKulr0ZbzyX4
8tLQnGRVJR8D9T5nB6VAJSBJvWDkNlOkVVS71d6urtwOm9W1XlHT3wwwveEIoeWDrHJEzyMyuNVR
zzl61Iv7SrjR802sdfOzUCt/QsCKuvSzXX4DRrMK60917RMtO8MTvlOeKdkJMiLgPDxZNeNHUtU2
vKa+fA5jnPjXk6UozKWy3AdjAgoxUl+OqySfleRYdfLIpMzvBS3x47Ix3jlfSDWDiYvBT1fU/3WO
tPWzftbP+lk/62f9rJ/1s37Wz/pZP+tn/ayf9bN+1s/6WT/rZ/2sn/WzftbP+lk/62f9rJ/1s37W
z/pZP+tn/ayf/0/P/wIkCqXRAOABAA==
EnD
  #mok-image-tarball-end
}

# Initialise _BI
_BI_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
#!/usr/bin/env bash

declare -A JSONPath

JSONPath_new() {
  JSONPath[DEBUG]=0
  JSONPath[INCLEMPTY]=0
  JSONPath[NOCASE]=0
  JSONPath[WHOLEWORD]=0
  JSONPath[FILE]=
  JSONPath[NO_HEAD]=0
  JSONPath[NORMALIZE_SOLIDUS]=0
  JSONPath[BRIEF]=0
  JSONPath[PASSTHROUGH]=0
  JSONPath[JSON]=0
  JSONPath[MULTIPASS]=0
  JSONPath[FLATTEN]=0
  JSONPath[STDINFILE]=/var/tmp/JSONPath.$$.stdin
  JSONPath[STDINFILE2]=/var/tmp/JSONPath.$$.stdin2
  JSONPath[PASSFILE]=/var/tmp/JSONPath.$$.pass1
  declare -a INDEXMATCH_QUERY
}

# JSONPath reads JSON from stdin and applies a JSON Path query.
# Args: arg1-N - command line arguments to be parsed.
JSONPath() {

  JSONPath_sanity_checks
  JSONPath_parse_options "$@"

  trap JSONPath_cleanup EXIT

  if [[ ${QUERY} == *'?(@'* ]]; then
    # This will be a multipass query

    [[ -n ${JSONPath[FILE]} ]] && JSONPath[STDINFILE]=${JSONPath[FILE]}
    [[ -z ${JSONPath[FILE]} ]] && cat >"${JSONPath[STDINFILE]}"

    while true; do
      JSONPath_tokenize_path
      JSONPath_create_filter

      JSONPath_tokenize | JSONPath_parse | JSONPath_filter |
        JSONPath_indexmatcher >"${JSONPath[PASSFILE]}" <"${JSONPath[STDINFILE]}"

      [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && {
        # replace filter expression with index sequence
        SET=$(sed -rn 's/.*[[,"]+([0-9]+)[],].*/\1/p' "${JSONPath[PASSFILE]}" | tr '\n' ,)
        SET=${SET%,}
        #QUERY=$(sed "s/?(@[^)]\+)/${SET}/" <<<"${QUERY}")
        # Testing:
        QUERY="${QUERY//\?\(@*)/${SET}}"
        [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "QUERY=${QUERY}" >/dev/stderr
        JSONPath_reset
        continue
      }

      JSONPath_flatten | JSONPath_json | JSONPath_brief <<<"${JSONPath[PASSFILE]}"

      break
    done

  else

    JSONPath_tokenize_path
    JSONPath_create_filter

    if [[ ${JSONPath[PASSTHROUGH]} -eq 1 ]]; then
      JSONPath[JSON]=1
      JSONPath_flatten | JSONPath_json
    elif [[ -z ${JSONPath[FILE]} ]]; then
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten | JSONPath_json | JSONPath_brief
    else
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten <"${JSONPath[FILE]}"
      JSONPath_json | JSONPath_brief
    fi

  fi
}

JSONPath_sanity_checks() {

  local binary

  # Reset some vars
  for binary in gawk grep sed; do
    if ! command -v "${binary}" >&/dev/null; then
      echo "ERROR: ${binary} binary not found in path. Aborting."
      exit 1
    fi
  done
}

JSONPath_reset() {

  # Reset some vars
  declare -a INDEXMATCH_QUERY
  PATHTOKENS=
  FILTER=
  OPERATOR=
  RHS=
  JSONPath[MULTIPASS]=0
}

JSONPath_cleanup() {

  [[ -e ${JSONPath[PASSFILE]} ]] && rm -f "${PASSFILE}"
  [[ -e ${JSONPath[STDINFILE2]} ]] && rm -f "${JSONPath[STDINFILE2]}"
  [[ -z ${JSONPath[FILE]} && -e ${JSONPath[STDINFILE]} ]] &&
    rm -f "${JSONPath[STDINFILE]}"
}

JSONPath_usage() {

  echo
  echo "Usage: JSONPath.sh [-b] [j] [-h] [-f FILE] [pattern]"
  echo
  echo "pattern - the JSONPath query. Defaults to '$.*' if not supplied."
  echo "-b      - Brief. Only show values."
  echo "-j      - JSON output."
  echo "-u      - Strip unnecessary leading path elements."
  echo "-i      - Case insensitive."
  echo "-p      - Pass-through to the JSON parser."
  echo "-w      - Match whole words only (for filter script expression)."
  echo "-f FILE - Read a FILE instead of stdin."
  echo "-h      - This help text."
  echo
}

JSONPath_parse_options() {

  set -- "$@"
  local ARGN=$#
  while [[ ${ARGN} -ne 0 ]]; do
    case $1 in
    -h)
      JSONPath_usage
      exit 0
      ;;
    -f)
      shift
      JSONPath[FILE]=$1
      ;;
    -i)
      JSONPath[NOCASE]=1
      ;;
    -j)
      JSONPath[JSON]=1
      ;;
    -n)
      JSONPath[NO_HEAD]=1
      ;;
    -b)
      JSONPath[BRIEF]=1
      ;;
    -u)
      JSONPath[FLATTEN]=1
      ;;
    -p)
      JSONPath[PASSTHROUGH]=1
      ;;
    -w)
      JSONPath[WHOLEWORD]=1
      ;;
    -s)
      JSONPath[NORMALIZE_SOLIDUS]=1
      ;;
    *)
      QUERY=$1
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done
  [[ -z ${QUERY} ]] && QUERY='$.*'
}

JSONPath_awk_egrep() {
  local pattern_string=$1

  gawk '{
    while ($0) {
      start=match($0, pattern);
      token=substr($0, start, RLENGTH);
      print token;
      $0=substr($0, start+RLENGTH);
    }
  }' pattern="${pattern_string}"
}

JSONPath_tokenize() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    ESCAPE='(\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
    ESCAPE='(\\\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\\\]'
  fi

  local STRING="\"${CHAR}*(${ESCAPE}${CHAR}*)*\""
  local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'
  local KEYWORD='null|false|true'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  ${GREP} "${STRING}|${NUMBER}|${KEYWORD}|${SPACE}|." | grep -Ev "^${SPACE}$"
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

JSONPath_tokenize_path() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
  fi

  local WILDCARD='\*'
  local WORD='[ A-Za-z0-9_-]*'
  local INDEX="\\[${WORD}(:${WORD}){0,2}\\]"
  local INDEXALL='\[\*\]'
  local STRING="[\\\"'][^[:cntrl:]\\\"']*[\\\"']"
  local SET="\\[(${WORD}|${STRING})(,(${WORD}|${STRING}))*\\]"
  local FILTER='\?\(@[^)]+'
  local DEEPSCAN='\.\.'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  readarray -t PATHTOKENS < <(echo "${QUERY}" |
    ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
    grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$")
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    echo "grep -Eo '${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|.'" >/dev/stderr
    echo -n "TOKENISED QUERY="
    echo "${QUERY}" |
      ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
      grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$" >/dev/stderr
  }
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

# JSONPath_create_filter creates the filter from the user's query.
# Filter works in a single pass through the data, unless a filter (script)
#  expression is used, in which case two passes are required (MULTIPASS=1).
JSONPath_create_filter() {

  local len=${#PATHTOKENS[*]}

  local -i i=0
  local a query="^\[" comma=
  while [[ i -lt len ]]; do
    case "${PATHTOKENS[i]}" in
    '"')
      :
      ;;
    '..')
      query+="${comma}[^]]*"
      comma=
      ;;
    '[*]')
      query+="${comma}[^,]*"
      comma=","
      ;;
    '*')
      query+="${comma}(\"[^\"]*\"|[0-9]+[^],]*)"
      comma=","
      ;;
    '?(@'*)
      a=${PATHTOKENS[i]#?(@.}
      elem="${a%%[<>=!]*}"
      rhs="${a##*[<>=!]}"
      a="${a#${elem}}"
      elem="${elem//./[\",.]+}" # Allows child node matching
      operator="${a%${rhs}}"
      [[ -z ${operator} ]] && {
        operator="=="
        rhs=
      }
      if [[ ${rhs} == *'"'* || ${rhs} == *"'"* ]]; then
        case ${operator} in
        '==' | '=')
          OPERATOR=
          if [[ ${elem} == '?(@' ]]; then
            # To allow search on @.property such as:
            #   $..book[?(@.title==".*Book 1.*")]
            query+="${comma}[0-9]+[],][[:space:]\"]*${rhs//\"/}"
          else
            # To allow search on @ (this node) such as:
            #   $..reviews[?(@==".*Fant.*")]
            query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs//\"/}"
          fi
          FILTER="${query}"
          ;;
        '>=' | '>')
          OPERATOR=">"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=' | '<')
          OPERATOR="<"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      else
        case ${operator} in
        '==' | '=')
          OPERATOR=
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs}"
          FILTER="${query}"
          ;;
        '>=')
          OPERATOR="-ge"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '>')
          OPERATOR="-gt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=')
          OPERATOR="-le"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<')
          OPERATOR="-lt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      fi
      JSONPath[MULTIPASS]=1
      ;;
    "["*)
      if [[ ${PATHTOKENS[i]} =~ , ]]; then
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          # converts only one comma: s/("[^"]+),([^"]+")/\1`\2/g;s/"//g
          #a=$(echo $a | sed 's/\([[:alpha:]]*\)/"\1"/g')
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        fi
        query+="${comma}(${a//,/|})"
      elif [[ ${PATHTOKENS[i]} =~ : ]]; then
        if ! [[ ${PATHTOKENS[i]} =~ [0-9][0-9] || ${PATHTOKENS[i]} =~ :] ]]; then
          if [[ ${PATHTOKENS[i]#*:} =~ : ]]; then
            INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
            query+="${comma}[^,]*"
          else
            # Index in the range of 0-9 can be handled by regex
            query+="${comma}$(echo "${PATHTOKENS[i]}" |
              gawk '/:/ { a=substr($0,0,index($0,":")-1);
                         b=substr($0,index($0,":")+1,index($0,"]")-index($0,":")-1);
                         if(b>0) { print a ":" b-1 "]" };
                         if(b<=0) { print a ":]" } }' |
              sed 's/\([0-9]\):\([0-9]\)/\1-\2/;
                       s/\[:\([0-9]\)/[0-\1/;
                       s/\([0-9]\):\]/\1-9999999]/')"
          fi
        else
          INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
          query+="${comma}[^,]*"
        fi
      else
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        else
          [[ ${i} -gt 0 ]] && comma=","
        fi
        query+="${comma}${a}"
      fi
      comma=","
      ;;
    *)
      PATHTOKENS[i]=${PATHTOKENS[i]//\'/\"}
      query+="${comma}\"${PATHTOKENS[i]//\"/}\""
      comma=","
      ;;
    esac
    i=$((i + 1))
  done

  [[ -z ${FILTER} ]] && FILTER="${query}[],]"
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
}

JSONPath_parse_array() {

  local index=0
  local ary=''
  read -r token
  case "${token}" in
  ']') ;;

  *)
    while :; do
      JSONPath_parse_value "$1" "${index}"
      index=$((index + 1))
      ary="${ary}""${value}"
      read -r token
      case "${token}" in
      ']') break ;;
      ',') ary="${ary}," ;;
      *) JSONPath_throw "EXPECTED , or ] GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_object() {

  local key
  local obj=''
  read -r token
  case "${token}" in
  '}') ;;

  *)
    while :; do
      case "${token}" in
      '"'*'"') key=${token} ;;
      *) JSONPath_throw "EXPECTED string GOT ${token:-EOF}" ;;
      esac
      read -r token
      case "${token}" in
      ':') ;;
      *) JSONPath_throw "EXPECTED : GOT ${token:-EOF}" ;;
      esac
      read -r token
      JSONPath_parse_value "$1" "${key}"
      obj="${obj}${key}:${value}"
      read -r token
      case "${token}" in
      '}') break ;;
      ',') obj="${obj}," ;;
      *) JSONPath_throw "EXPECTED , or } GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_value() {

  local jpath="${1:+$1,}$2" isleaf=0 isempty=0 print=0
  case "${token}" in
  '{') JSONPath_parse_object "${jpath}" ;;
  '[') JSONPath_parse_array "${jpath}" ;;
    # At this point, the only valid single-character tokens are digits.
  '' | [!0-9]) JSONPath_throw "EXPECTED value GOT ${token:-EOF}" ;;
  *)
    value=${token}
    # if asked, replace solidus ("\/") in json strings with normalized value: "/"
    # Testing:
    #[ "${JSONPath[NORMALIZE_SOLIDUS]}" -eq 1 ] && value=$(echo "${value}" | sed 's#\\/#/#g')
    [[ ${JSONPath[NORMALIZE_SOLIDUS]} -eq 1 ]] && value=$(${value//\\\///})
    isleaf=1
    [[ ${value} == '""' ]] && isempty=1
    ;;
  esac
  [[ -z ${JSONPath[INCLEMPTY]} ]] && [[ ${value} == '' ]] && return
  [[ ${JSONPath[NO_HEAD]} -eq 1 ]] && [[ -z ${jpath} ]] && return

  [[ ${isleaf} -eq 1 ]] && [[ ${isempty} -eq 0 ]] && print=1
  [[ ${print} -eq 1 ]] && printf "[%s]\t%s\n" "${jpath}" "${value}"
  :
}

JSONPath_flatten() {

  local path a prevpath pathlen

  if [[ ${JSONPath[FLATTEN]} -eq 1 ]]; then
    cat >"${JSONPath[STDINFILE2]}"

    highest=9999

    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      [[ -z ${prevpath} ]] && {
        prevpath=("${path[@]}")
        highest=$((${#path[*]} - 1))
        continue
      }

      pathlen=$((${#path[*]} - 1))

      for i in $(seq 0 "${pathlen}"); do
        [[ ${path[i]} != "${prevpath[i]}" ]] && {
          high=${i}
          break
        }
      done

      [[ ${high} -lt ${highest} ]] && highest=${high}

      prevpath=("${path[@]}")
    done <"${JSONPath[STDINFILE2]}"

    if [[ ${highest} -gt 0 ]]; then
      sed -r 's/\[(([0-9]+|"[^"]+")[],]){'$((highest))'}(.*)/[\3/' \
        "${JSONPath[STDINFILE2]}"
    else
      cat "${JSONPath[STDINFILE2]}"
    fi
  else
    cat
  fi
}

# JSONPath_indexmatcher is for double digit or greater indexes match each line
# individually Single digit indexes are handled more efficiently by regex
JSONPath_indexmatcher() {

  local a b

  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
      echo "INDEXMATCH_QUERY[${i}]=${INDEXMATCH_QUERY[i]}" >/dev/stderr
    done
  }

  matched=1

  step=
  if [[ ${#INDEXMATCH_QUERY[*]} -gt 0 ]]; then
    while read -r line; do
      for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
        [[ ${INDEXMATCH_QUERY[i]#*:} =~ : ]] && {
          step=${INDEXMATCH_QUERY[i]##*:}
          step=${step%]}
          INDEXMATCH_QUERY[i]="${INDEXMATCH_QUERY[i]%:*}]"
        }
        q=${INDEXMATCH_QUERY[i]:1:-1} # <- strip '[' and ']'
        a=${q%:*}                     # <- number before ':'
        b=${q#*:}                     # <- number after ':'
        [[ -z ${b} ]] && b=99999999999
        readarray -t num < <((grep -Eo '[0-9]+[],]' | tr -d ,]) <<<"${line}")
        if [[ ${num[i]} -ge ${a} && ${num[i]} -lt ${b} && matched -eq 1 ]]; then
          matched=1
          [[ ${i} -eq $((${#INDEXMATCH_QUERY[*]} - 1)) ]] && {
            if [[ ${step} -gt 1 ]]; then
              [[ $(((num[i] - a) % step)) -eq 0 ]] && {
                [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
                echo "${line}"
              }
            else
              [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
              echo "${line}"
            fi
          }
        else
          matched=0
          continue
        fi
      done
      matched=1
    done
  else
    cat -
  fi
}

JSONPath_brief() {
  # Only show the value

  if [[ ${JSONPath[BRIEF]} -eq 1 ]]; then
    sed 's/^[^\t]*\t//;s/^"//;s/"$//;'
  else
    cat
  fi
}

JSONPath_json() {
  # Turn output into JSON

  local a tab="$'\t'"
  local UP=1 DOWN=2 SAME=3
  local prevpathlen=-1 prevpath=() path a
  declare -a closers

  if [[ ${JSONPath[JSON]} -eq 0 ]]; then
    cat -
  else
    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      value=${line#*${tab}}

      # Not including the object itself (last item)
      pathlen=$((${#path[*]} - 1))

      # General direction

      direction=${SAME}
      [[ ${pathlen} -gt ${prevpathlen} ]] && direction=${DOWN}
      [[ ${pathlen} -lt ${prevpathlen} ]] && direction=${UP}

      # Handle jumps UP the tree (close previous paths)

      [[ ${prevpathlen} != -1 ]] && {
        for i in $(seq 0 $((pathlen - 1))); do
          [[ ${prevpath[i]} == "${path[i]}" ]] && continue
          [[ ${path[i]} != '"'* ]] && {
            # Testing double quotes:
            a="(${!arrays[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                arrays[k]=
              done
            }
            a="(${!comma[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                comma[k]=
              done
            }
            for j in $(seq $((prevpathlen)) -1 $((i + 2))); do
              arrays[j]=
              [[ -n ${closers[j]} ]] && {
                indent=$((j * 4))
                printf "\n%${indent}s${closers[j]}" ""
                unset "closers[j]"
                comma[j]=
              }
            done
            direction=${DOWN}
            break
          }
          direction=${DOWN}
          for j in $(seq $((prevpathlen)) -1 $((i + 1))); do
            arrays[j]=
            [[ -n ${closers[j]} ]] && {
              indent=$((j * 4))
              printf "\n%${indent}s${closers[j]}" ""
              unset "closers[j]"
              comma[j]=
            }
          done
          a="(${!arrays[*]})"
          [[ -n ${a} ]] && {
            for k in $(seq "${i}" "${a[-1]}"); do
              arrays[k]=
            done
          }
          break
        done
      }

      [[ ${direction} -eq ${UP} ]] && {
        [[ ${prevpathlen} != -1 ]] && comma[prevpathlen]=
        for i in $(seq $((prevpathlen + 1)) -1 $((pathlen + 1))); do
          arrays[i]=
          [[ -n ${closers[i]} ]] && {
            indent=$((i * 4))
            printf "\n%${indent}s${closers[i]}" ""
            unset "closers[i]"
            comma[i]=
          }
        done
        a="(${!arrays[*]})"
        [[ -n ${a} ]] && {
          for k in $(seq "${i}" "${a[-1]}"); do
            arrays[k]=
          done
        }
      }

      # Opening braces (the path leading up to the key)

      broken=
      for i in $(seq 0 $((pathlen - 1))); do
        [[ -z ${broken} && ${prevpath[i]} == "${path[i]}" ]] && continue
        [[ -z ${broken} ]] && {
          broken=${i}
          [[ ${prevpathlen} -ne -1 ]] && broken=$((i + 1))
        }
        if [[ ${path[i]} == '"'* ]]; then
          # Object
          [[ ${i} -ge ${broken} ]] && {
            indent=$((i * 4))
            printf "${comma[i]}%${indent}s{\n" ""
            closers[i]='}'
            comma[i]=
          }
          indent=$(((i + 1) * 4))
          printf "${comma[i]}%${indent}s${path[i]}:\n" ""
          comma[i]=",\n"
        else
          # Array
          if [[ ${arrays[i]} != 1 ]]; then
            indent=$((i * 4))
            printf "%${indent}s" ""
            echo "["
            closers[i]=']'
            arrays[i]=1
            comma[i]=
          else
            indent=$(((i + 1) * 4))
            printf "\n%${indent}s${closers[i - 1]}" ""
            direction=${DOWN}
            comma[i + 1]=",\n"
          fi
        fi
      done

      # keys & values

      if [[ ${path[-1]} == '"'* ]]; then
        # Object
        [[ ${direction} -eq ${DOWN} ]] && {
          indent=$((pathlen * 4))
          printf "${comma[pathlen]}%${indent}s{\n" ""
          closers[pathlen]='}'
          comma[pathlen]=
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${path[-1]}:${value}"
        comma[pathlen]=",\n"
      else
        # Array
        [[ ${arrays[i]} != 1 ]] && {
          indent=$(((pathlen - 0) * 4))
          printf "%${indent}s[\n" ""
          closers[pathlen]=']'
          comma[pathlen]=
          arrays[i]=1
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${value}"
        comma[pathlen]=",\n"
      fi

      prevpath=("${path[@]}")
      prevpathlen=${pathlen}
    done

    # closing braces

    for i in $(seq $((pathlen)) -1 0); do
      indent=$((i * 4))
      printf "\n%${indent}s${closers[i]}" ""
    done
    echo
  fi
}

JSONPath_filter() {
  # Apply the query filter

  local a tab=$'\t' v

  [[ ${JSONPath[NOCASE]} -eq 1 ]] && opts+="i"
  [[ ${JSONPath[WHOLEWORD]} -eq 1 ]] && opts+="w"
  if [[ -z ${OPERATOR} ]]; then
    [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && FILTER="${FILTER}[\"]?$"
    grep "-E${opts}" "${FILTER}"
    [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
  else
    grep "-E${opts}" "${FILTER}" |
      while read -r line; do
        v=${line#*${tab}}
        case ${OPERATOR} in
        '-ge')
          if gawk '{exit !($1>=$2)}' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-gt')
          if gawk '{exit !($1>$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-le')
          if gawk '{exit !($1<=$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-lt')
          if gawk '{exit !($1<$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '>')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} > ${RHS,,} ]] && echo "${line}"
          ;;
        '<')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} < ${RHS,,} ]] && echo "${line}"
          ;;
        *) return 1 ;;
        esac
      done
  fi
}

JSONPath_parse() {
  # Parses json

  read -r token
  JSONPath_parse_value
  read -r token
  case "${token}" in
  '') ;;
  *)
    JSONPath_throw "EXPECTED EOF GOT ${token}"
    exit 1
    ;;
  esac
}

JSONPath_throw() {
  echo "$*" >&2
  exit 1
}

JSONPath_new || exit 1

# vi: expandtab sw=2 ts=2
# shellcheck shell=bash disable=SC2148
# MA - execution starts here

# MA is an associative array that holds data specific to this file
declare -A _MA

# Defined in GL (globals.sh)
declare OK ERROR STOP STDERR TRUE

# Getters/Setters -------------------------------------------------------------

# MA_program_args getter outputs the program arguments sent by the user.
MA_program_args() {
  printf '%s' "${_MA[program_args]}"
}

# Public Functions ------------------------------------------------------------

# main is the start point for this application.
# Args: arg1-N - the command line arguments entered by the user.
MA_main() {
  local retval="${OK}"

  CU_podman_or_docker

  trap MA_cleanup EXIT
  MA_sanity_checks || return
  PA_run "$@" || retval=$?

  exit "${retval}"
}

# MA_version outputs the version information the exits.
MA_version() {
  printf 'Version: %s\n' "${MOKVERSION}"
  exit "${OK}"
}

# MA_process_global_options is called by the parser when a global option is
# encountered for processing.
# Args: arg1 - the global option that was found.
MA_process_global_options() {
  case "$1" in
  -h | --help)
    PA_usage
    return "${STOP}"
    ;;
  -p | --plain)
    UT_set_plain "${TRUE}"
    ;;
  *)
    printf 'INTERNAL ERROR: Invalid global option, "%s".' "$1"
    return "${ERROR}"
    ;;
  esac
}

# MA_cleanup is called from an EXIT trap only, when the program exits, and
# calls every other function matching the pattern '^.._cleanup'.
# Args: No args expected.
MA_cleanup() {
  local retval="${OK}" funcs func
  funcs=$(declare -F | awk '{print $NF;}' | grep '^.._cleanup')
  for func in ${funcs}; do
    [[ ${func} == "${FUNCNAME[0]}" ]] && continue
    eval "${func}" || retval=$?
  done
  return "${retval}"
}

# MA_sanity_checks is expected to run some quick and simple checks to
# see if key components are available before MA_main is called.
# Args: No args expected.
MA_sanity_checks() {

  local binary

  if [[ ${_CU[podmantype]} == "native" ]]; then
    binaries="gawk tac column tput grep sed ip cut"
  else
    binaries="gawk tac column tput grep sed cut"
  fi

  for binary in ${binaries}; do
    if ! command -v "${binary}" >&/dev/null; then
      printf 'ERROR: "%s" binary not found in path. Aborting.' "${binary}" \
        >"${STDERR}"
      return "${ERROR}"
    fi
  done

  # Disable terminal escapes (colours) if stdout is not a terminal
  [ -t 1 ] || UT_disable_colours
}

# MA_usage outputs help text for all components then quits with no error.  This
# is registered as a callback in the Parser, see _MA_new
# Args: None expected.
MA_usage() {

  cat <<'EnD'
Usage: mok [-h] <command> [subcommand] [ARGS...]
 
Global options:
  --help
  -h     - This help text
  --plain
  -p     - Plain output. No colours or animations.
 
Where command can be one of:
  create  - Add item(s) to the system.
  delete  - Delete item(s) from the system.
  build   - Build item(s) used by the system.
  get     - Get details about items in the system.
  exec    - 'Log in' to the container.
  version - Display version information.

For help on a specific command, run:
  mok <command> --help
EnD
}

# MA_new sets the initial values for the _MA associative array
_MA_new() {
  _MA[program_args]="$*"

  # Program the parser's state machine
  PA_add_state "COMMAND" "version" "END" "MA_version"

  # Set up the parser's option callbacks
  PA_add_option_callback "" "MA_process_global_options"

  # Set up the parser's usage callbacks
  PA_add_usage_callback "" "MA_usage"
}

# Initialise _MA
_MA_new "$@" || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
if [ "$0" = "${BASH_SOURCE[0]}" ] || [ -z "${BASH_SOURCE[0]}" ]; then
  MA_main "$@"
fi
