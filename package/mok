#!/usr/bin/env bash
# shellcheck shell=bash disable=SC2148

__check_os() {
  local majorversion system_ok=1 install_bash=0 install_coreutils=0 install_gawk=0
  local install_podman=0 install_sed=0 __mokostype=linux

  if [[ -d /System/Library/CoreServices ]]; then
    [[ -e /opt/homebrew/bin/bash ]] && eval "$(/opt/homebrew/bin/brew shellenv)"
    # We're on macOS, check for a recent Bash
    if command -v bash &>/dev/null; then
      majorversion=$(bash --version | head -n 1 | sed 's/^.*version \([0-9]*\).*/\1/')
    else
      echo "No version of Bash was found which is strange. Aborting."
      exit 1
    fi
    if [[ ${majorversion} -lt 5 ]]; then
      install_bash=1
      system_ok=0
    fi
    if ! command -v tac &>/dev/null; then
      install_coreutils=1
      system_ok=0
    fi
    if ! command -v gawk &>/dev/null; then
      install_gawk=1
      system_ok=0
    fi
    if ! command -v gsed &>/dev/null; then
      install_sed=1
      system_ok=0
    fi
    if ! command -v podman &>/dev/null; then
      install_podman=1
      system_ok=0
    fi

    if [[ ${system_ok} -eq 0 ]]; then
      echo "Your system requires some extra packages to be installed."
      echo "This script can install them for you."
      echo
      read -r -p 'Install extra packages? (y/N) ' ans
      if [[ ${ans} == "y" ]]; then
        if ! command -v brew &>/dev/null; then
          echo 'Homebrew is required to install extra packages.'
          echo 'You can install this yourself by following the instructions at https://brew.sh'
          echo
          read -r -p 'Should I install Homebrew now? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            # Install Homebrew
            echo -n "Installing Homebrew, with:"
            echo " /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
            echo
            /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            retval=$?
            if [[ retval -ne 0 ]]; then
              echo "Homebrew install failed."
              echo "Please try to install Homebrew manually using the above commmand."
              exit 1
            fi
            if [[ ! -e /opt/homebrew/bin/brew ]]; then
              echo "Homebrew did not seem install to /opt/homebrew."
              echo "Mok expects 'brew' to be in /opt/homebrew/bin/brew but it's not there."
              echo "Cannot continue. Please report this issue on GitHub."
              exit 1
            fi
            eval "$(/opt/homebrew/bin/brew shellenv)"
          else
            echo "Aborting due to missing 'Homebrew'."
            exit 1
          fi
        fi
        if [[ ! -e /opt/homebrew/bin/brew ]]; then
          echo "Mok expects 'brew' to be in /opt/homebrew/bin/brew but it's not there."
          echo "Cannot continue. Please report this issue on GitHub."
          exit 1
        fi
        eval "$(/opt/homebrew/bin/brew shellenv)"
        if [[ ${install_bash} -eq 1 ]]; then
          read -r -p 'Bash 5 is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install bash
          else
            echo "Aborting due to missing 'Bash 5'."
            exit 1
          fi
        fi
        if [[ ${install_coreutils} -eq 1 ]]; then
          read -r -p 'Coreutils is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install coreutils
          else
            echo "Aborting due to missing 'coreutils'."
            exit 1
          fi
        fi
        if [[ ${install_gawk} -eq 1 ]]; then
          read -r -p 'Gawk is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install gawk
          else
            echo "Aborting due to missing 'gawk'."
            exit 1
          fi
        fi
        if [[ ${install_sed} -eq 1 ]]; then
          read -r -p 'GNU-Sed is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install gnu-sed
          else
            echo "Aborting due to missing 'sed'."
            exit 1
          fi
        fi
        if [[ ${install_podman} -eq 1 ]]; then
          read -r -p 'Podman is not installed. Install? (y/N) ' ans
          if [[ ${ans} == "y" ]]; then
            brew install podman
          else
            echo "Aborting due to missing 'podman'."
            exit 1
          fi
        fi
      else
        echo "Aborting due to missing packages."
        exit 1
      fi
    fi
  fi
}

[[ __homebrew -ne 1 ]] && __check_os

[[ -d /System/Library/CoreServices && -e /opt/homebrew/bin/bash && __homebrew -ne 1 ]] && {
  eval "$(/opt/homebrew/bin/brew shellenv)"
  export __mokostype=macos
  export __homebrew=1
  sed() {
    gsed "$@"
  }
  export -f sed
  exec bash "$0" "$@"
}

__mokostype="${__mokostype:-linux}"
# shellcheck shell=bash disable=SC2148

declare __mokostype

set_arch() {
  if [[ ${__mokostype} == "linux" ]]; then
    # Is this machine x86 or arm?
    if [[ $(uname -m) == "x86_64" ]]; then
      export __mokarch=x86_64
    elif [[ $(uname -m) == "aarch64" ]]; then
      export __mokarch=arm64
    fi
  elif [[ ${__mokostype} == "macos" ]]; then
    # Is this machine x86 or arm?
    if [[ $(uname -m) == "x86_64" ]]; then
      export __mokarch=x86_64
    elif [[ $(uname -m) == "arm64" ]]; then
      export __mokarch=arm64
    fi
  else
    printf 'ERROR: Unknown OS type: %s\n' "${__mokostype}" >"${STDERR}"
    exit "${ERROR}"
  fi
}

set_arch
# shellcheck shell=bash disable=SC2148
# PA - PArser

# _PA holds data specific to parsing the command line arguments.
declare -A _PA

# Declare externally defined variables ----------------------------------------

# Defined in ER (globals.sh)
declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# PA_command getter outputs the _PA[command] array member. This contains the
# command the user requested.
PA_command() {
  printf '%s' "${_PA[command]}"
}

# PA_subcommand getter outputs the _PA[subcommand] array member. This contains
# the subcommand the user requested.
PA_subcommand() {
  printf '%s' "${_PA[subcommand]}"
}

# PA_shift outputs the _PA[shift] array member, returned by the caller
# when an extra shift is required whilst consuming option values.
#
# Example code:
# ```
#XX_process_options_callback() {
#
#  case "$1" in
#  -h | --help)
#    CC_usage
#    return "${STOP}"
#    ;;
#    ... omitted ...
#  --k8sver)
#    _CC[k8sver]="$2"
#    return "$(PA_shift)"
#    ;;
#  --with-lb)
#    ... omitted ..
# ```
PA_shift() {
  printf '%s' "${_PA[shift]}"
}

# PA_set_state setter sets the initial state of the parser, which should be one
# of COMMAND, SUBCOMMAND, or ARG1.
# Args: arg1 - the initial state to set.
PA_set_state() {
  _PA[state]="$1"
}

# Public Functions ------------------------------------------------------------

# PA_add_option_callback adds a callback to the list of callbacks used for
# processing options.
# Args: arg1 - Null string (for global options), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_option_callback() {
  _PA[optscallbacks]+="$1,$2 "
}

# PA_add_usage_callback adds a callback to the list of callbacks used for
# output of help text.
# Args: arg1 - Null string (for global help), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_usage_callback() {
  _PA[usagecallbacks]+="$1,$2 "
}

# PA_add_state adds a callback to the list of callbacks used for
# programming the state machine.
# Args: arg1 - Current state to match.
#       arg2 - The value of the state to match.
#       arg3 - The new state if arg1 and arg2 match.
#       arg4 - The function to call, optional.
PA_add_state() {
  _PA[statecallbacks]+="$1,$2,$3,$4 "
}

# PA_add_run_callback adds a callback to the list of callbacks used for
# running the user defined entrypoint function.
# Args: arg1 - The value of the state to match. Probably like:
#              "commandsubcommand" "function"
#       arg2 - The function to call.
PA_add_run_callback() {
  _PA[runcallbacks]+="$1,$2 "
}

# PA_run implements an interleaved state machine to process the
# user request. It allows for strict checking of arguments and args. All
# command line arguments are processed in order from left to right.
#
# Each COMMAND can have a different set of requirements which are controlled
# by setting the next state at each transition.
#
# --global-options COMMAND --command-options SUBCOMMAND --subcommand-options \
#  ARG1 --subcommand-options ARG2 --subcommand-options ...
#
# --global-options are those before COMMAND.
# --command-options can be after the COMMAND but before SUBCOMMAND.
# --subcommand-options can be anywhere after the SUBCOMMAND.
#
# Args: arg1-N - The arguments given to mok by the user on the command line
PA_run() {

  local retval=${OK}

  set -- "$@"
  local ARGN=$# ARGNUM=0 retval=0
  while [ "${ARGN}" -ne 0 ]; do
    case "$1" in
    --* | -*)
      _PA_process_option "$1" "$2" || {
        retval=$?
        if [[ ${retval} == "${_PA[shift]}" ]]; then
          ARGN=$((ARGN - 1))
          shift
        else
          return "${retval}"
        fi
      }
      ;;
    *)
      case "${_PA[state]}" in
      COMMAND)
        _PA_check_token "${1}" "COMMAND" "command"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid COMMAND, "%s".\n\n' "$1" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      SUBCOMMAND)
        _PA_check_token "$1" "SUBCOMMAND" "subcommand"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid SUBCOMMAND for %s, "%s".\n\n' "${_PA[command]}" "${1}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      ARG*)
        ((ARGNUM++))
        _PA_check_token "${1}" "ARG${ARGNUM}"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid ARG1 for %s %s, "%s".\n\n' "${_PA[command]}" \
            "${_PA[subcommand]}" "${1}" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      END)
        PA_usage
        printf 'ERROR No more args expected, "%s" is unexpected for "%s %s"\n' \
          "${1}" "${_PA[command]}" "${_PA[subcommand]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      *)
        printf 'Internal ERROR. Invalid state "%s"\n' "${_PA[state]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      esac
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done

  # Run the user defined entrypoint function:
  for item in ${_PA[runcallbacks]}; do
    IFS=, read -r stateval func <<<"${item}"
    [[ ${stateval} == "${_PA[command]}${_PA[subcommand]}" ]] && {
      eval "${func}" || retval=$?
      return "${retval}"
    }
  done

  PA_usage

  return "${OK}"
}

# PA_usage outputs help text for a single component if help was asked for when
# a command was specified, or for all components otherwise.
# Args: None expected.
PA_usage() {

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[usagecallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func}"
      return
    }
  done

  eval "${_PA[usage]}"
}

# Private Functions -----------------------------------------------------------

# PA_new sets the initial values for the PArser's associative array.
# Args: None expected.
_PA_new() {
  _PA[command]=
  _PA[subcommand]=
  _PA[state]="COMMAND"
  _PA[optscallbacks]=
  _PA[usagecallbacks]=
  _PA[statecallbacks]=
  _PA[runcallbacks]=
  # The return value if the caller asked for an extra shift:
  _PA[shift]=126
}

# _PA_check_token checks for a valid token in arg2 state. The logic is
# most easily understood by reading the full original version at:
# https://github.com/mclarkson/my-own-kind/blob/master/docs/package.md#scripted-cluster-creation-and-deletion
# This function is a reduction of all the check_xxx_token functions.
# Args: arg1 - the token to check.
#       arg2 - the current state.
#       arg3 - the state value to set, optional. This should only be sent
#              for command and subcommand states.
_PA_check_token() {

  local item

  if [[ -n ${_PA[subcommand]} ]]; then
    cmdsubcommand="${_PA[command]}${_PA[subcommand]}"
  elif [[ -n ${_PA[command]} && ${_PA[state]} != "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}$1"
  elif [[ -n ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}"
  elif [[ -z ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand=
  else
    cmdsubcommand="$1"
  fi

  for item in ${_PA[statecallbacks]}; do
    IFS=, read -r state component newstate func <<<"${item}"
    [[ ${state} == "$2" ]] && {
      [[ ${component} == "${cmdsubcommand}" ]] && {
        [[ -n $3 ]] && _PA["$3"]="$1"
        _PA[state]="${newstate}"
        [[ -n ${func} ]] && {
          eval "${func} $1" || return
        }
        return "${OK}"
      }
    }
  done
}

# _PA_process_option checks that the user-provided option is valid for the
# command-subcommand or global states.
# Args: arg1 - The option to check.
#       arg2 - TODO The value of the option if present, optional.
_PA_process_option() {

  local item curcmdsubcmd

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[optscallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func} \"$1\" \"$2\""
      return $?
    }
  done

  return "${ERROR}"
}

# Initialise _PA
_PA_new

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GL - Globals

# Private Functions -----------------------------------------------------------

# GL_new sets the only global variables that should be in use anywhere.  The
# only other globals are the associative arrays. All the globals are constant
# (readonly) variables. Declare these globals, where needed, in other files
# so that shellcheck passes.
# Args: None expected.
_GL_new() {

  declare -rg MOKVERSION="0.8.30"
  declare -rg K8SVERSION="1.33.1"
  declare -rg GO_VERSION="1.23.4"

  # Returns, exit codes
  declare -rg OK=0
  declare -rg SUCCESS=0
  declare -rg ERROR=1
  declare -rg FAILURE=1

  # For setting flags
  declare -rg TRUE=1
  declare -rg FALSE=0

  # To signal main() to exit with SUCCESS in the PArser
  declare -rg STOP=2

  declare -rg STDOUT="/dev/stdout"
  declare -rg STDERR="/dev/stderr"

  # The following just keep shellcheck happy
  local dummy dumb
  dummy="${OK}"
  dummy="${ERROR}"
  dummy="${STOP}"
  dummy="${STDOUT}"
  dummy="${STDERR}"
  dummy="${TRUE}"
  dummy="${FALSE}"
  dummy="${SUCCESS}"
  dummy="${FAILURE}"
  dummy="${MOKVERSION}"
  dummy="${GO_VERSION}"
  dummy="${K8SVERSION}"
  dumb="${dummy}${dumb}"
}

# Initialise GL
_GL_new || exit 1

# vim helpers -----------------------------------------------------------------

# The following lines allow the use of '[C-i' and '[I' (do ':help [I') in vim.
#include buildimage.sh
#include containerutils.sh
#include createcluster.sh
#include deletecluster.sh
#include embed-dockerfile.sh
#include error.sh
#include exec.sh
#include getcluster.sh
#include main.sh
#include lib/parser.sh
#include util.sh
#include versions.sh

# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# ER - Error handling

# ER is an associative array that holds data specific to error handling.
declare -A ER

# Declare externally defined associative arrays -------------------------------

# Defined in GL (globals.sh)
declare ERROR TRUE STDERR

# Public Functions ------------------------------------------------------------

# ER_err outputs a stacktrace and returns ERROR status.
# Args: None expected.
ER_err() {

  # In case of error print the function call stack
  # No args expected

  [[ ${ER[errcalled]} == "${TRUE}" ]] && return "${ERROR}"
  ER[errcalled]="${TRUE}"
  local frame=0
  printf '\n' >"${STDERR}"
  while caller "${frame}"; do
    ((frame++))
  done | tac >"${STDERR}"
  printf '\n' >"${STDERR}"
  return "${ERROR}"
}

# err is a synonym for ER_err to aid with code readability.
err() {
  ER_err
  return
}

# Private Functions -----------------------------------------------------------

# ER_new sets the initial values for the ER associative array.
# Args: None expected.
_ER_new() {
  ER[errcalled]=
}

# Initialise ER
_ER_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# UT - Utilities

# _UT is an associative array that holds data specific to general utilities.
declare -A _UT

# Declare externally defined global variables ---------------------------------

declare OK STDERR FALSE TRUE

# Getters/Setters -------------------------------------------------------------

# UT_runlogfile getter outputs the value of _UT[runlogfile], which contains the
# name of the file written to when running UT_run_with_progress.
UT_runlogfile() {
  printf '%s' "${_UT[runlogfile]}"
}

# UT_tailf getter indicates whether a log will be shown in real-time during the
# 'run', TRUE, or not, FALSE.
# Args
UT_tailf() {
  printf '%s' "${_UT[tailf]}"
}

# UT_tailf setter indicates whether a log should be shown during the 'run',
# TRUE, or not, FALSE.
# Args: arg1 - Whether to tail, TRUE or FALSE.
UT_set_tailf() {
  _UT[tailf]="$1"
}

# UT_set_plain setter sets plain output, with no colour, animations, or UTF
# high byte characters.
# Args: arg1 - Whether to show plain output, TRUE or FALSE.
UT_set_plain() {
  _UT[plain]="$1"
  UT_disable_colours
}

# Public Functions ------------------------------------------------------------

# UT_disable_colours resets variables used for colourised output so that they
# contain no colour terminal escapes. Useful if stdin is not a terminal.
UT_disable_colours() {
  _UT[yellow]=
  _UT[green]=
  _UT[red]=
  _UT[normal]=
  _UT[probablysuccess]="!"
  _UT[success]="✓"
  _UT[failure]="✕"
}

# UT_run_with_progress displays a progress spinner, item text, and a tick or
# cross based on the exit code.
# Args: arg1   - the text to display.
#       arg2-N - remaining args are the program to run and its arguments.
UT_run_with_progress() {

  local displaytext=$1 retval int spinner=()

  _UT[runlogfile]=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }
  shift

  if [[ ${_UT[tailf]} == "${FALSE}" && ${_UT[plain]} == "${TRUE}" ]]; then

    # Output with no colours or spinny

    printf '%s' "${displaytext}"

    eval "$*" &>"${_UT[runlogfile]}"
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 0 ]]; then
      printf ' .. %s\n' "${_UT[success]}"
    else
      printf ' .. %s\n' "${_UT[failure]}"
    fi

  elif [[ ${_UT[tailf]} == "${FALSE}" ]]; then

    # Output with colours and spinny

    while read -r char; do
      spinner+=("${char}")
    done <<<"$(grep -o . <<<"${_UT[spinnerchars]}")"

    (
      eval "$*" &>"${_UT[runlogfile]}"
    ) &

    # Turn the cursor off
    tput civis

    # Start the spin animation
    printf ' %s' "${displaytext}"
    (while true; do
      for int in {0..3}; do
        printf '\r  %s ' "${spinner[int]}"
        sleep .1
      done
    done) &
    _UT[spinnerpid]=$!
    disown

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Kill the spinner
    kill "${_UT[spinnerpid]}" 2>/dev/null
    _UT[spinnerpid]=

    sleep .5

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\r  %s\n' "${_UT[probablysuccess]}"
    elif [[ ${retval} -eq 0 ]]; then
      printf '\r  %s\n' "${_UT[success]}"
    else
      printf '\r  %s\n' "${_UT[failure]}"
    fi

    # Restore the cursor
    tput cnorm
    sleep .5

  else

    # Tailf output

    printf 'COMMAND: %s\n\n' "$*"

    (
      eval "$*" &>/dev/stdout
    ) &
    sleep 1

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\n\nSTATUS: OK - (Probably)\n\n'
    elif [[ ${retval} -eq 0 ]]; then
      printf '\n\nSTATUS: OK\n\n'
    else
      printf '\n\nSTATUS: FAIL\n\n'
    fi
  fi

  return "${retval}"
}

# UT_cleanup removes any artifacts that were created during execution.
# This is called by 'MA_cleanup' trap only.
UT_cleanup() {

  # Called when the script exits.

  local int

  # Kill the spinny, and anything else, if they're running
  if [[ ${_UT[tailf]} == "${FALSE}" ]]; then
    [[ -n ${_UT[spinnerpid]} ]] && {
      printf '%s\r  ✕%s\n' "${_UT[red]}" "${_UT[normal]}"
      kill "${_UT[spinnerpid]}"
    }
    # If progress spinner crashed make sure the cursor is shown
    [ -t 1 ] && tput cnorm
  else
    kill "${_UT[spinnerpid]}" &>/dev/null
  fi

  return "${OK}"
}

# UT_sed_json_block returns the value of the query_key between
# block_start_key:block_start_val and block_end_key.
# Args:
#  Arg 1: data
#  Arg 2: block_start_key
#  Arg 3: block_start_val
#  Arg 4: block_end_key
#  Arg 5: query_key
UT_sed_json_block() {
  local data block_start_key block_start_val block_end_key query_key
  data="$1"
  block_start_key="$2"
  block_start_val="$3"
  block_end_key="$4"
  query_key="$5"
  echo "$data" | sed -rn \
    '/'"${block_start_key}"'.*'"${block_start_val}"'/,/'"${block_end_key}"'/ { s/^ *"'"${query_key}"'": *//p }' \
    | tr -d ',"'
}

# Private Functions -----------------------------------------------------------

# _UT_new sets the initial values for the _UT associative array.
# Args: None expected.
_UT_new() {
  _UT[tailf]="${FALSE}"
  _UT[yellow]=$(tput setaf 3)
  _UT[green]=$(tput setaf 2)
  _UT[red]=$(tput setaf 1)
  _UT[normal]=$(tput sgr0)
  _UT[probablysuccess]="${_UT[yellow]}✓${_UT[normal]}"
  _UT[success]="${_UT[green]}✓${_UT[normal]}"
  _UT[failure]="${_UT[red]}✕${_UT[normal]}"
  _UT[runlogfile]=
  _UT[spinnerchars]="|/-\\"
  _UT[spinnerpid]=
}

# Initialise _UT
_UT_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GC - Get Cluster

# _GC is an associative array that holds data specific to the get cluster command.
declare -A _GC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# GC_showheader getter outputs the value of the showheader array member.
GC_showheader() {
  printf '%s' "${_GC[showheader]}"
}

# GC_set_showheader setter sets the value of the showheader array member.
# If $TRUE the header will be shown, or $FALSE, then it won't be shown.
GC_set_showheader() {
  _GC[showheader]="$1"
}

# GC_set_clustername setter sets the cluster name to show information about.
GC_set_clustername() {
  _GC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# GC_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted. It is called by
# MA_cleanup.
GC_cleanup() {
  :
}

# GC_process_options checks if arg1 is in a list of valid get cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
GC_process_options() {

  case "$1" in
  -h | --help)
    GC_usage
    return "${STOP}"
    ;;
  *)
    GC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# GC_usage outputs help text for the create cluster component.
# It is called by PA_usage().
# Args: None expected.
GC_usage() {

  cat <<'EnD'
GET subcommands are:
 
  cluster[s] - list all mok managed clusters.
 
get cluster[s] options:
 
 Format:
  get cluster(s) [NAME]
  NAME        - (optional) The name of the cluster to get
                details about.

EnD
}

# GC_run gets information about cluster(s).
# This function is called in main.sh.
# Args: None expected.
GC_run() {

  _GC_sanity_checks || return

  local ids id info output labelkey
  local containerhostname containerip

  declare -a nodes

  ids=$(CU_get_cluster_container_ids "${_GC[clustername]}") || return

  if [[ -z ${ids} ]]; then
    printf 'No clusters found\n'
    return "${OK}"
  fi

  readarray -t nodes <<<"${ids}"

  # Use 'docker inspect' to get the value of the label $LABELKEY

  output=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  # Output the header
  [[ ${_GC[showheader]} -eq ${TRUE} ]] && {
    printf 'MOK_Cluster Docker_ID Container_Name IP_Address\n' >"${output}"
  }

  labelkey=$(CU_labelkey) || err || return

  for id in "${nodes[@]}"; do

    info=$(CU_get_container_info "${id}") || return

    clustname=$(JSONPath ".[0].Config.Labels.${labelkey}" -b <<<"${info}") ||
      err || return

    containerhostname=$(JSONPath '.[0].Config.Hostname' -b <<<"${info}") ||
      err || return

    containerip=$(JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}") ||
      err || return

    printf '%s %s %s %s\n' "${clustname}" "${id}" "${containerhostname}" "${containerip}"

  done | sort -k 3 >>"${output}"

  column -t "${output}" || err
}

# Private Functions -----------------------------------------------------------

# _GC_new sets the initial values for the _GC associative array.
# Args: None expected.
_GC_new() {
  _GC[showheader]="${TRUE}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "get" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "getcluster" "ARG1" ""
  PA_add_state "SUBCOMMAND" "getclusters" "ARG1" ""
  PA_add_state "ARG1" "getcluster" "END" "GC_set_clustername"
  PA_add_state "ARG1" "getclusters" "END" "GC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "get" "GC_process_options" || return
  PA_add_option_callback "getcluster" "GC_process_options" || return
  PA_add_option_callback "getclusters" "GC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "get" "GC_usage" || return
  PA_add_usage_callback "getcluster" "GC_usage" || return
  PA_add_usage_callback "getclusters" "GC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "getcluster" "GC_run"
  PA_add_run_callback "getclusters" "GC_run"
}

# GC_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_GC_sanity_checks() {

  # Only show the usage if we are in 'get' mode and have not specified a
  # subcommand. This allows internal code to call GC_run()
  if [[ $(PA_command) == "get" && -z $(PA_subcommand) ]]; then
    GC_usage
    exit "${OK}"
  fi
}

# Initialise _GC
_GC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# MU - Machine Utilities for Podman

# _MU is an associative array that holds data specific to machine utils.
declare -A _MU

# Declare externally defined variables ----------------------------------------

declare ERROR STDERR STOP

# Getters/Setters -------------------------------------------------------------

# Public Functions ------------------------------------------------------------

# MU_cleanup removes artifacts that were created during execution. This function
# is run automatically by the Parser library. Currently this does nothing and
# this function could be deleted.
MU_cleanup() { :; }

# MU_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_process_options() {
  case "$1" in
  -h | --help)
    MU_usage
    return "${STOP}"
    ;;
  *)
    MU_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_usage() {

  cat <<'EnD'
MACHINE subcommands are:
 
  list    - List the currently created Podman machines. Only one machine
            is currently supported and it will be named 'mok-machine'.
  create  - Create a Podman machine named 'mok-machine'. This will also
            setup the Podman machine to run Kubernetes so there is no
            need to run 'machine setup'.
  destroy - Completely removes the Podman machine named 'mok-machine'.
  start   - Start the Podman machine named 'mok-machine'.
  stop    - Stop the Podman machine named 'mok-machine'.
  setup   - Apply the correct settings to the Podman machine to run
            Kubernetes.
 
For more information:

  machine list -h
  machine create -h
  machine destroy -h
  machine start -h
  machine stop -h
  machine setup -h
 
EnD
}

# Private Functions -----------------------------------------------------------

# _MU_new sets the initial values for the Machine Utils associative array and
# sets up the Parser to call functions in machine*.sh files.
# Args: None expected.
_MU_new() {
  # Program the parser's state machine
  PA_add_state "COMMAND" "machine" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "machinelist" "END" ""
  PA_add_state "SUBCOMMAND" "machinecreate" "END" ""
  PA_add_state "SUBCOMMAND" "machinedestroy" "END" ""
  PA_add_state "SUBCOMMAND" "machinesetup" "END" ""
  PA_add_state "SUBCOMMAND" "machinestart" "END" ""
  PA_add_state "SUBCOMMAND" "machinestop" "END" ""

  # Set up the parser's option callbacks
  PA_add_option_callback "machine" "MU_process_options" || return
  PA_add_option_callback "machinelist" "MU_list_process_options" || return
  PA_add_option_callback "machinecreate" "MU_create_process_options" || return
  PA_add_option_callback "machinedestroy" "MU_destroy_process_options" || return
  PA_add_option_callback "machinesetup" "MU_setup_process_options" || return
  PA_add_option_callback "machinestart" "MU_start_process_options" || return
  PA_add_option_callback "machinestop" "MU_stop_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "machine" "MU_usage" || return
  PA_add_usage_callback "machinelist" "MU_list_usage" || return
  PA_add_usage_callback "machinecreate" "MU_create_usage" || return
  PA_add_usage_callback "machinedestroy" "MU_destroy_usage" || return
  PA_add_usage_callback "machinesetup" "MU_setup_usage" || return
  PA_add_usage_callback "machinestart" "MU_start_usage" || return
  PA_add_usage_callback "machinestop" "MU_stop_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "machinelist" "MU_list_run"
  PA_add_run_callback "machinecreate" "MU_create_run"
  PA_add_run_callback "machinedestroy" "MU_destroy_run"
  PA_add_run_callback "machinesetup" "MU_setup_run"
  PA_add_run_callback "machinestart" "MU_start_run"
  PA_add_run_callback "machinestop" "MU_stop_run"
}

# Initialise _MU
_MU_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148

# MACHINE STOP ================================================================

# MU_stop_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_stop_process_options() {
  case "$1" in
  -h | --help)
    MU_stop_usage
    return "${STOP}"
    ;;
  *)
    MU_stop_usage
    printf 'ERROR: "%s" is not a valid "stop" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_stop_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_stop_usage() {

  cat <<EnD
machine stop options:
 
 Format:
  machine stop [flags]
 
 Flags:
  -h - This help text.

 Description:
  This will stop a Podman machine named 'mok-machine'.
  Stop the podman machine with: $(MA_program_name) machine stop
EnD
}

# MU_stop_run lists Podman machines.
# Args: None expected.
MU_stop_run() {
  UT_run_with_progress \
    "    Stopping Podman machine: mok-machine" \
    podman machine stop mok-machine
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}


# shellcheck shell=bash disable=SC2148

# MACHINE START ===============================================================

# MU_start_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_start_process_options() {
  case "$1" in
  -h | --help)
    MU_start_usage
    return "${STOP}"
    ;;
  -v | --verbose)
    UT_set_tailf "${TRUE}" || err || return
    ;;
  *)
    MU_start_usage
    printf 'ERROR: "%s" is not a valid "start" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_start_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_start_usage() {

  cat <<EnD
machine start options:
 
 Format:
  machine start [flags]
 
 Flags:
  -h, --help - This help text.
  -v, --verbose - Verbose output. Useful if there was a problem.

 Description:
  This will start a Podman machine named 'mok-machine'.
  Start the podman machine with: $(MA_program_name) machine start
EnD
}

# MU_start_run lists Podman machines.
# Args: None expected.
MU_start_run() {
  UT_run_with_progress \
    "    Starting Podman machine: mok-machine" \
    podman machine start mok-machine
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}

# shellcheck shell=bash disable=SC2148

# MACHINE CREATE ==============================================================

# MU_create_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_create_process_options() {
  case "$1" in
  -h | --help)
    MU_create_usage
    return "${STOP}"
    ;;
  -v | --verbose)
    UT_set_tailf "${TRUE}" || err || return
    ;;
  *)
    MU_create_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_create_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_create_usage() {

  cat <<EnD
machine create options:
 
 Format:
  machine create [flags]
 
 Flags:
  -h, --help - This help text.
  -v, --verbose - Verbose output. Useful if there was a problem.

 Description:
  This will create a Podman machine named 'mok-machine' and setup the
  machine to run Kubernetes.
EnD
}

# MU_create_run lists Podman machines.
# Args: None expected.
MU_create_run() {
  UT_run_with_progress \
    "    Creating the Podman machine: mok-machine" \
    podman machine init --now --rootful --user-mode-networking mok-machine
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Loading module in mok-machine" \
    podman machine ssh --username root mok-machine modprobe nf_conntrack
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Persisting nf_conntrack module in mok-machine" \
    podman machine ssh --username root mok-machine \
      bash -c \
      "\"\\\"echo nf_conntrack \
      >/etc/modules-load.d/nf_conntrack.conf\\\"\""
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Setting nf_conntrack_max in mok-machine" \
    podman machine ssh --username root mok-machine sysctl -q \
      -w net.netfilter.nf_conntrack_max=163840
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Persisting nf_conntrack_max in mok-machine" \
    podman machine ssh --username root mok-machine \
      bash -c \
      "\"\\\"echo net.netfilter.nf_conntrack_max=163840 \
      >/etc/sysctl.d/99-nf_conntrack_max.conf\\\"\""
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}

# shellcheck shell=bash disable=SC2148

# MACHINE LIST ================================================================

# MU_list_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_list_process_options() {
  case "$1" in
  -h | --help)
    MU_list_usage
    return "${STOP}"
    ;;
  *)
    MU_list_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_list_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_list_usage() {

  cat <<'EnD'
machine list options:
 
 Format:
  machine list [flags]
 
 Flags:
  -h - This help text.

EnD
}

# MU_list_run lists Podman machines.
# Args: None expected.
MU_list_run() {
  info=$(podman machine list --format json) || err || return

  running=$(UT_sed_json_block "${info}" \
    'Name' 'mok-machine' '}' \
    'Running' \
    ) || err || return

  exists=$(UT_sed_json_block "${info}" \
    'Name' 'mok-machine' '}' \
    'Name' \
    ) || err || return

  if [[ ${exists} != "mok-machine" ]]; then
    printf 'mok-machine: does not exist.\n'
  else
    if [[ ${running} == "true" ]]; then
      printf 'mok-machine: running.\n'
    else
      printf 'mok-machine: stopped.\n'
    fi
  fi
}

# shellcheck shell=bash disable=SC2148

# MACHINE DESTROY ==============================================================

# MU_destroy_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_destroy_process_options() {
  case "$1" in
  -h | --help)
    MU_destroy_usage
    return "${STOP}"
    ;;
  -v | --verbose)
    UT_set_tailf "${TRUE}" || err || return
    ;;
  *)
    MU_destroy_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# MU_destroy_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_destroy_usage() {

  cat <<'EnD'
machine destroy options:
 
 Format:
  machine destroy [flags]
 
 Flags:
  -h, --help - This help text.
  -v, --verbose - Verbose output. Useful if there was a problem.

 Description:
  This will completely remove a Podman machine named 'mok-machine'.
  A machine must be stopped before it can be destroyed.

EnD
}

# MU_destroy_run deletes a Podman machine.
# Args: None expected.
MU_destroy_run() {
  printf 'This will completely remove the podman machine named "mok-machine"\n'
  printf "Are you sure you want to destroy the machine? (y/N) >"
  read -r ans
  [[ ${ans} != "y" ]] && {
    printf 'Cancelling by user request.\n'
    return "${OK}"
  }
  UT_run_with_progress \
    "    Deleting the Podman machine: mok-machine" \
    podman machine rm -f mok-machine
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}

# shellcheck shell=bash disable=SC2148

# MACHINE SETUP ===============================================================

# MU_setup_process_options checks if arg1 is in a list of valid machine utility
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option.
MU_setup_process_options() {
  case "$1" in
  -h | --help)
    MU_setup_usage
    return "${STOP}"
    ;;
  -v | --verbose)
    UT_set_tailf "${TRUE}" || err || return
    ;;
  *)
    MU_setup_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}


# MU_setup_usage outputs help text for the machine utilities component.
# Args: None expected.
MU_setup_usage() {

  cat <<'EnD'
machine setup options:
 
 Format:
  machine setup [flags]
 
 Flags:
  -h, --help - This help text.
  -v, --verbose - Verbose output. Useful if there was a problem.

EnD
}

# MU_setup_run sets up a Podman machine.
# Args: None expected.
MU_setup_run() {
  UT_run_with_progress \
    "    Loading module in mok-machine" \
    podman machine ssh --username root mok-machine modprobe nf_conntrack
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Persisting nf_conntrack module in mok-machine" \
    podman machine ssh --username root mok-machine \
      bash -c \
      "\"\\\"echo nf_conntrack \
      >/etc/modules-load.d/nf_conntrack.conf\\\"\""
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Setting nf_conntrack_max in mok-machine" \
    podman machine ssh --username root mok-machine sysctl -q \
      -w net.netfilter.nf_conntrack_max=163840
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  UT_run_with_progress \
    "    Persisting nf_conntrack_max in mok-machine" \
    podman machine ssh --username root mok-machine \
      bash -c \
      "\"\\\"echo net.netfilter.nf_conntrack_max=163840 \
      >/etc/sysctl.d/99-nf_conntrack_max.conf\\\"\""
  r=$?
  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    cat "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }
}

# shellcheck shell=bash disable=SC2148
# EX - EXec

# EX is an associative array that holds data specific to the exec cluster command.
declare -A _EX

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# EX_set_containername setter sets the containername to be used to 'log in' to.
EX_set_containername() {
  _EX[containername]="$1"
}

# Public Functions ------------------------------------------------------------

# EX_process_options checks if arg1 is in a list of valid exec options. This
# function is called by the parser, via a callback in _EX_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
EX_process_options() {

  case "$1" in
  -h | --help)
    EX_usage
    return "${STOP}"
    ;;
  *)
    EX_usage
    printf 'ERROR: "%s" is not a valid "exec" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# EX_usage outputs help text for the create exec component.  It is called in
# this file and by PA_usage(), via a callback in _EX_new.
# Args: None expected.
EX_usage() {

  cat <<'EnD'
'Log in' to a container. EXEC has no subcommands.
 
exec options:
 
 Format:
  exec [NAME]
  NAME        - (optional) The name of the container to 'log in' to.
                If NAME is not given then the user will be offered
                a choice of containers to log in to. If there is only
                one cluster and one node then it will 'log in' to the
                only available container.

EnD
}

# Execs 'bash' in the container referenced by _EX[containername]. If just
# 'mok exec' is called without options then the user is offered a selection
# of existing clusters to exec into.
# Args: None expected.
# ---------------------------------------------------------------------------
EX_run() {

  _EX_sanity_checks || return

  local names int ans lines containernames gcoutput

  GC_set_showheader "${TRUE}" || err || return
  gcoutput=$(GC_run) || return
  names=$(printf '%s' "${gcoutput}" | awk '{ print $3; }')
  readarray -t containernames <<<"${names}"

  if [[ -n ${_EX[containername]} ]]; then

    # The caller gave a specific name for exec.
    # Check if the container name exists

    if grep -qs "^${_EX[containername]}$" <<<"${names}"; then
      _EX_exec "${_EX[containername]}" || return
      return "${OK}"
    else
      printf 'ERROR: Cannot exec into non-existent container: "%s".\n' \
        "${_EX[containername]}"
      return "${ERROR}"
    fi

  elif [[ ${#containernames[*]} == 2 ]]; then

    # If there's only one container just log into it without asking
    _EX_exec "${containernames[1]}"

  elif [[ ${#containernames[*]} == 1 ]]; then

    printf 'No containers found.\n'
    return "${OK}"

  else

    # The caller supplied no container name.
    # Present some choices

    printf 'Choose the container to log in to:\n\n'

    readarray -t lines <<<"${gcoutput}" || return

    # Print the header then print the items in the loop
    printf '   %s\n' "${lines[0]}"
    for int in $(seq 1 $((${#lines[*]} - 1))); do
      printf '%00d) %s\n' "${int}" "${lines[int]}"
    done | sort -k 4

    printf "\nChoose a number (Enter to cancel)> "
    read -r ans

    [[ -z ${ans} || ${ans} -lt 0 || ${ans} -gt $((${#lines[*]} - 1)) ]] && {
      printf '\nInvalid choice. Aborting.\n'
      return "${OK}"
    }

    _EX_exec "${containernames[ans]}"
  fi
}

# Private Functions -----------------------------------------------------------

# _EX_new sets the initial values for the _EX associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
_EX_new() {
  _EX[containername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "exec" "ARG1" ""
  PA_add_state "ARG1" "exec" "END" "EX_set_containername"

  # Set up the parser's option callbacks
  PA_add_option_callback "exec" "EX_process_options" || return
  PA_add_usage_callback "exec" "EX_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "exec" "EX_run"
}

# EX_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For exec this does nothing.
# Args: None expected.
_EX_sanity_checks() { :; }

# _EX_exec runs a command in a docker container using bash as the command by
# default.
# Args: arg1 - docker container name
#       arg2 - command to run
_EX_exec() {

  local cmd=${2:-bash} url port

  containerrt=$(CU_containerrt) || err || return
  podmantype=$(CU_podmantype) || err || return

  if [[ $containerrt == "podman" && $podmantype == "machine" ]]; then
    # TODO: A named podman machine does not work the same way
    #       as the default podman machine. Rootful doesn't work
    #       for a named machine so need to use '--url'. Ask
    #       Podman developers about this.
    port=$(podman machine inspect mok-machine | grep Port | grep -o '[0-9]\+')
    url="ssh://root@127.0.0.1:$port/run/podman/podman.sock"
    # TODO: This would be preferred to using '--url'
    # podman -c mok-machine exec -ti "$1" "${cmd}" 
    read -rt 0.1
    podman --url "${url}" exec -ti "$1" "${cmd}" 
  elif [[ $containerrt == "podman" ]]; then
    read -rt 0.1
    exec podman exec -ti "$1" "${cmd}"
  elif [[ $containerrt == "docker" ]]; then
    read -rt 0.1
    exec docker exec -ti "$1" "${cmd}"
  fi
}

# Initialise EX
_EX_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# DC - Delete Cluster

# _DC is an associative array that holds data specific to deleting a cluster.
declare -A _DC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR STOP TRUE

# Getters/Setters -------------------------------------------------------------

# DC_set_clustername setter sets the cluster name to be deleted. This is
# called by the parser, via a callback in _DC_new.
DC_set_clustername() {
  _DC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# DC_process_options checks if arg1 is in a list of valid delete cluster
# options. This function is called by the parser, via a callback in _DC_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
DC_process_options() {

  case "$1" in
  -h | --help)
    DC_usage
    return "${STOP}"
    ;;
  *)
    DC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# DC_usage outputs help text for the create cluster component.
# It is called by PA_usage(), via a callback in _DC_new.
# Args: None expected.
DC_usage() {

  cat <<'EnD'
DELETE subcommands are:
 
  cluster - Delete a local kubernetes cluster.
 
delete cluster options:
 
 Format:
  delete cluster NAME
  NAME        - The name of the cluster to delete

EnD
}

# DC_run starts the delete cluster process.
# Args: None expected.
DC_run() {

  _DC_sanity_checks || return

  # Mutate functions make system changes.

  declare -i numnodes=0
  local id ids r

  numnodes=$(CU_get_cluster_size "${_DC[clustername]}") || return

  [[ ${numnodes} -eq 0 ]] && {
    printf '\nERROR: No cluster exists with name, "%s". Aborting.\n\n' \
      "${_DC[clustername]}" >"${STDERR}"
    return "${ERROR}"
  }

  ids=$(CU_get_cluster_container_ids "${_DC[clustername]}") || return

  printf 'The following containers will be deleted:\n\n'

  GC_set_showheader "${TRUE}"
  GC_set_clustername "${_DC[clustername]}"
  GC_run "${_DC[clustername]}" || return

  printf "\nAre you sure you want to delete the cluster? (y/N) >"

  read -r ans

  [[ ${ans} != "y" ]] && {
    printf '\nCancelling by user request.\n'
    return "${OK}"
  }

  printf '\n'

  for id in ${ids}; do
    UT_run_with_progress \
      "    Deleting id, '${id}' from cluster '${_DC[clustername]}'." \
      _DC_delete "${id}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n\n' >"${STDERR}"
      err
      return "${r}"
    }
  done

  printf '\n'
}

# Private Functions -----------------------------------------------------------

# _DC_new sets the initial values for the _DC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_DC_new() {
  _DC[clustername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "delete" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "deletecluster" "ARG1" ""
  PA_add_state "ARG1" "deletecluster" "END" "DC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "delete" "DC_process_options" || return
  PA_add_option_callback "deletecluster" "DC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "delete" "DC_usage" || return
  PA_add_usage_callback "deletecluster" "DC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "deletecluster" "DC_run"
}

# DC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before DC_run is called.
# Args: None expected.
_DC_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    DC_usage
    exit "${OK}"
  fi

  if [[ -z ${_DC[clustername]} ]]; then
    DC_usage
    printf 'Please provide the Cluster NAME to delete.\n' >"${STDERR}"
    return "${ERROR}"
  fi
}

# _DC_delete stops and removes a docker container.
# Args: arg1 - docker id to delete.
_DC_delete() {

  docker stop -t 5 "${id}"
  docker rm "${id}" || err
}

# Initialise _DC
_DC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE K8SVERSION

# Getters/Setters -------------------------------------------------------------

# CC_set_clustername setter sets the clustername array item.
CC_clustername() {
  printf '%s' "${_CC[clustername]}"
}

# CC_publish getter outputs the publish array item.
CC_publish() {
  printf '%s' "${_CC[publish]}"
}

# CC-withlb getter outputs the withlb array item.
CC_withlb() {
  printf '%s' "${_CC[withlb]}"
}

# CC_set_clustername setter sets the clustername array item.
CC_set_clustername() {
  _CC[clustername]="$1"
}

# CC_set_nummasters setter sets the nummasters array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_nummasters() {
  _CC[nummasters]="$1"
}

# CC_set_numworkers setter sets the numworkers array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_numworkers() {
  _CC[numworkers]="$1"
}

# Public Functions ------------------------------------------------------------

# CC_process_options checks if arg1 is in a list of valid create cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option. For example, '--masters' should be sent
#              with a value but boolean options, like 'skiplbsetup' should not.
CC_process_options() {

  case "$1" in
  -h | --help)
    CC_usage
    return "${STOP}"
    ;;
  --skiplbsetup)
    _CC[skiplbsetup]="${TRUE}"
    return
    ;;
  --k8sver)
    _CC[k8sver]="$2"
    return "$(PA_shift)"
    ;;
  --with-lb)
    _CC[withlb]="${TRUE}"
    return
    ;;
  --skipmastersetup)
    _CC[skipmastersetup]="${TRUE}"
    return
    ;;
  --skipworkersetup)
    _CC[skipworkersetup]="${TRUE}"
    return
    ;;
  --masters)
    _CC[nummasters]="$2"
    return "$(PA_shift)"
    ;;
  --workers)
    _CC[numworkers]="$2"
    return "$(PA_shift)"
    ;;
  --tailf)
    _CC[tailf]="${TRUE}"
    return "${OK}"
    ;;
  --publish)
    _CC[publish]="${TRUE}"
    return
    ;;
  *)
    CC_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# CC_usage outputs help text for the create cluster component.  It is called in
# this file and by PA_usage(), via a callback set in _CC_new.
# Args: None expected.
CC_usage() {

  cat <<'EnD'
CREATE subcommands are:
 
  cluster - Create a local kubernetes cluster.
 
create cluster [flags] options:
 
 Format:
  create cluster NAME [ [NUM_MASTERS] [NUM_WORKERS] ]
  NAME        - The name of the cluster. This will be used as
                the prefix in the name for newly created
                docker containers.
  NUM_MASTERS - The number of master containers.
  NUM_WORKERS - The number of worker containers. If NUM_WORKERS is
                zero then the 'node-role.kubernetes.io/master' taint
                will be removed from master nodes so that pods are
                schedulable.
 
 Flags:
  --skipmastersetup - Create the master container but don't set it
         up. Useful for manually installing kubernetes. Kubeadm, 
         kubelet and kubectl will be installed at the requested 
         version. With this option the worker will also be skipped.
         See also '--k8sver' flag.
  --skipworkersetup - The same as '--skipmastersetup', but skips
         setting up the worker only.
  --with-lb - Add a haproxy load balancer. The software will be installed
         and set up to reverse proxy to the master node(s), unless
         --skiplbsetup is used.
  --k8sver VERSION - The Kubernetes version, e.g. "1.32.0".
         A previous version will need to be downloaded first with:
           mok build image --get-prebuilt-image --k8sver VERSION
  --masters NUM - The number of master containers to create.
  --workers NUM - The number of worker containers to create. When workers
                  is zero then the master node taint will be removed from
                  master nodes so that pods are schedulable on those nodes.
  --tailf - Show the log output whilst creating the cluster.
  --publish - Publish port 6443 for the master node, or the load balancer if
              it's enabled, for external kubectl access to the cluster. The IP
              address of the default route interface is added to the cert.

EnD
}

# CC_run creates the kubernetes cluster.
# Args: None expected.
CC_run() {

  _CC_sanity_checks || return

  [[ ${_CC[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  declare -i numnodes=0

  numnodes=$(CU_get_cluster_size "${_CC[clustername]}") || return

  [[ ${numnodes} -gt 0 ]] && {
    printf '\nERROR: Cluster, "%s", exists! Aborting.\n\n' "${_CC[clustername]}" \
      >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_create_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_create_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_setup_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_setup_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[numworkers]} -gt 0 ]] && {
    _CC_create_worker_nodes "${_CC[numworkers]}" || return
  }

  printf '\n'

  [[ -z ${_CC[skipmastersetup]} ]] && {
    printf 'Cluster, "%s", can be accessed using:\n\n' "${_CC[clustername]}"
    printf 'export KUBECONFIG=/var/tmp/admin-%s.conf\n\n' "${_CC[clustername]}"
  }

  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CC_new sets the initial values for the _CC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_CC_new() {
  _CC[tailf]="${FALSE}"
  _CC[skipmastersetup]=
  _CC[skipworkersetup]=
  _CC[skiplbsetup]=
  _CC[withlb]=
  _CC[clustername]=
  _CC[nummasters]=0
  _CC[numworkers]=0
  _CC[publish]=0
  _CC[k8sver]="${K8SVERSION}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "create" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "createcluster" "ARG2" ""

  # Support for the legacy style of create (less to type):
  PA_add_state "ARG1" "createcluster" "ARG2" "CC_set_clustername"
  PA_add_state "ARG2" "createcluster" "ARG3" "CC_set_nummasters"
  PA_add_state "ARG3" "createcluster" "END" "CC_set_numworkers"

  # Set up the parser's option callbacks
  PA_add_option_callback "create" "CC_process_options" || return
  PA_add_option_callback "createcluster" "CC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "create" "CC_usage" || return
  PA_add_usage_callback "createcluster" "CC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "createcluster" "CC_run"
  PA_add_run_callback "createclusters" "CC_run"
}

# CC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before CC_run is called.
# Args: None expected.
_CC_sanity_checks() {

  declare -i host_max=0 cpus=0 should_be=0

  if [[ -z $(PA_subcommand) ]]; then
    CC_usage
    exit "${OK}"
  fi

  if [[ -z ${_CC[clustername]} ]]; then
    CC_usage
    printf 'Please provide the Cluster NAME to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[nummasters]} || ${_CC[nummasters]} -le 0 ]]; then
    CC_usage
    printf 'Please provide the number of Masters to create. Must be 1 or more.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[numworkers]} ]]; then
    CC_usage
    printf 'Please provide the number of Workers to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/sys/net/nf_conntrack_max ]]; then
    host_max=$(cat /proc/sys/net/nf_conntrack_max)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    host_max=$(podman machine ssh mok-machine cat /proc/sys/net/nf_conntrack_max)
  else
    printf '\nWARNING: /proc/sys/net/nf_conntrack_max not found.\n' >"${STDERR}"
    printf '         kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/cpuinfo ]]; then
    cpus=$(grep -cw ^processor /proc/cpuinfo)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    cpus=$(podman machine ssh mok-machine cat /proc/cpuinfo | grep -cw ^processor)
  else
    printf '\nWARNING: /proc/cpuinfo not found.\n' >"${STDERR}"
    printf '         I have no idea how many CPUs I have\n' >"${STDERR}"
    printf '         and kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  # These are the default values that kube-proxy expects:
  # conntrack:
  #   max: null
  #   maxPerCore: 32768
  #   min: 131072
  if [[ $((32768*cpus)) -lt 131072 ]]; then
    should_be=131072
  else
    should_be=$((32768*cpus))
  fi
  if [[ ${should_be} -ne $host_max ]]; then
    printf '\nERROR: /proc/sys/net/nf_conntrack_max should be set to %d.\n' \
      "${should_be}" >"${STDERR}"
    printf '     kube-proxy will not start with an incorrect nf_conntrack_max.\n' >"${STDERR}"
    printf '     To fix this, run the following command:\n\n' >"${STDERR}"
    if [[ $(CU_podmantype) == "native" ]]; then
      printf '       sudo sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
    elif [[ $(CU_podmantype) == "machine" ]]; then
      printf '       %s machine setup\n\n' "$(MA_program_name)" >"${STDERR}"
    else
      printf 'Internal ERROR. Invalid podman type.\n' >"${STDERR}"
      return "${ERROR}"
    fi
    
    printf 'Press ENTER to continue or CTRL-C to abort.\n' >"${STDERR}"
    read -r
    printf '\n' >"${STDERR}"
  fi
}

# _CC_create_master_nodes creates the master node containers.
# Args: arg1 - number of master nodes to create
_CC_create_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating master container, '${_CC[clustername]}-master-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-master-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }
  done

  return "${OK}"
}

# _CC_setup_master_nodes sets up the master node containers.
# Args: arg1 - number of master nodes to create
_CC_setup_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile lbaddr hostaddr
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-master-${int}'" \
      _CC_set_up_master_node "${_CC[clustername]}-master-${int}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  done

  # For now, copy admin.conf from master to /var/tmp/admin-CLUSTERNAME.conf

  if [[ -z ${_CC[skipmastersetup]} ]]; then
    if [[ ${_CC[publish]} -eq ${TRUE} ]]; then
      # On MacOS we need to use localhost, on linux use the host IP
      if [[ $(CU_podmantype) == "native" ]]; then
        hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
      else
        hostaddr="localhost"
      fi
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${hostaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    elif [[ ${_CC[withlb]} -eq ${TRUE} ]]; then
      lbaddr=$(CU_get_container_ip "${_CC[clustername]}-lb") || err || return
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${lbaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    else
      [[ -n ${_CC[skipmastersetup]} ]] || {
        docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
          "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      }
    fi

    chmod 666 "/var/tmp/admin-${_CC[clustername]}.conf" || {
      printf 'ERROR: Could not "chown 666 /var/tmp/admin-%s.conf"' "${_CC[clustername]}"
      err || return
    }
  fi

  return "${OK}"
}

# _CC_set_up_master_node calls the correct set up function based on the version
# Args: arg1 - the container ID to set up
_CC_set_up_master_node() {

  case "${_CC[k8sver]}" in
  "1.31."* | "1.32."* | "1.33."*)
    _CC_set_up_master_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# _CC_get_master_join_details uses 'docker exec' or 'podman exec' to run a
# script on the master to get CA hash, a token, and the master IP.  The caller
# can eval the output of this function to set the variables: cahash, token, and
# masterip. See also:
# https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/#token-based-discovery-with-ca-pinning
# Args: arg1 - id/name of master container
_CC_get_master_join_details() {

  local joinvarsfile master1ip

  joinvarsfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  master1ip=$(CU_get_container_ip "${_CC[clustername]}-master-1") || err || return

  cat <<EnD >"${joinvarsfile}"
#!/bin/bash
set -e

sed 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${master1ip}"'\2#' \
  /etc/kubernetes/super-admin.conf >/etc/kubernetes/admin2.conf

cahash=\$(openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | \
        openssl rsa -pubin -outform der 2>/dev/null | \
        openssl dgst -sha256 -hex | sed 's/^.* //')
token=\$(kubeadm token create --kubeconfig=/etc/kubernetes/admin2.conf 2>/dev/null)
ip=\$(ip ro get 8.8.8.8 | cut -d" " -f 7)

printf 'cahash=%s\ntoken=%s\nmasterip=%s' "\$cahash" "\$token" "\$ip"

exit 0
EnD

  docker cp "${joinvarsfile}" "$1":/root/joinvars.sh 2>"${STDERR}" ||
    err || return
  rm -f "${joinvarsfile}" 2>"${STDERR}" || err || return

  [[ -z ${_CC[skipworkersetup]} ]] && {
    docker exec "$1" bash /root/joinvars.sh 2>"${STDERR}" || err || return
  }

  return "${OK}"
}

# _CC_create_lb_node creates the load balancer node container.
# Args: None expected.
_CC_create_lb_node() {

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  # Create container
  UT_run_with_progress \
    "    Creating load balancer container, '${_CC[clustername]}-lb'" \
    CU_create_container \
    "${_CC[clustername]}-lb" \
    "${labelkey}=${_CC[clustername]}" \
    "${_CC[k8sver]}"

  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    printf '\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
    printf '%s\n' "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  return "${OK}"
}

# _CC_setup_lb_node sets up the load balancer node container.
# Args: None expected.
_CC_setup_lb_node() {

  local runlogfile

  # Set up
  [[ -z ${_CC[skiplbsetup]} ]] && {
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-lb'" \
      _CC_set_up_lb_node_real "${_CC[clustername]}-lb"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _CC_set_up_lb_node_real sets up the lb node.
# Args: arg1 - the container ID to set up
_CC_set_up_lb_node_real() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masteriplist=
  nl=
  gotamaster="${FALSE}"
  for idx in $(seq 1 "${_CC[nummasters]}"); do
    ip=$(CU_get_container_ip "${_CC[clustername]}-master-${idx}") || continue
    gotamaster="${TRUE}"
    masteriplist="${masteriplist}${nl}    server master-${idx} ${ip}:6443 check fall 3 rise 2"
    nl='\n'
  done

  [[ ${gotamaster} == "${FALSE}" ]] && {
    printf 'ERROR: Did not manage to get an IP address for any master nodes\n'
    err || return
  }

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

systemctl stop kubelet crio
systemctl disable kubelet crio

apt -y install haproxy

INTERNAL_IP=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")

cat <<EOF | tee /etc/haproxy/haproxy.cfg 
frontend kubernetes
    bind \$INTERNAL_IP:6443
    option tcplog
    mode tcp
    default_backend kubernetes-master-nodes
backend kubernetes-master-nodes
    mode tcp
    balance roundrobin
    option tcp-check
\$(echo -e "${masteriplist}")
EOF

systemctl restart haproxy
systemctl enable haproxy

EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# _CC_create_worker_nodes creates the worker nodes.
# Args: arg1 - number of worker nodes to create
_CC_create_worker_nodes() {

  local cahash token t masterip
  declare -i int=0

  [[ -n ${_CC[skipmastersetup]} ]] || {
    # Runs a script on master node to get details
    t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1") || {
      printf '\nERROR: Problem with "_CC_get_master_join_details".\n\n' >"${STDERR}"
      return "${ERROR}"
    }

    # Sets cahash, token, and masterip:
    eval "${t}"
  }

  local labelkey
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating worker container, '${_CC[clustername]}-worker-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-worker-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }

    [[ -n ${_CC[skipworkersetup]} || -n ${_CC[skipmastersetup]} ]] || {
      UT_run_with_progress \
        "    Setting up '${_CC[clustername]}-worker-${int}'" \
        _CC_set_up_worker_node "${_CC[clustername]}-worker-${int}" \
        "${cahash}" "${token}" "${masterip}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n' >"${STDERR}"
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
        printf '%s\n' "${runlogfile}" >"${STDERR}"
        return "${ERROR}"
      }

      UT_run_with_progress \
        "    Waiting for system to become ready" \
        _CC_wait_for_cluster \
        "${_CC[clustername]}-master-1" \
        "${_CC[clustername]}-worker-${int}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n'
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Wait timed out.\n' >"${STDERR}"
        return "${ERROR}"
      }
    }
  done

  return "${OK}"
}

# _CC_wait_for_cluster runs a `kubectl` command in the master-1 container,
# which doesn't exit until the all pods are fully up and running before it
# returns.
# Args: arg1 - the master container name to log into
#       arg2 - the worker container name to wait for
_CC_wait_for_cluster() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  cat <<'EnD' >"${setupfile}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
found=0
for i in $(seq 1 20); do
  if kubectl get pods &>/dev/null; then
    found=1
    break
  fi
  sleep 1
done
[[ $found == 0 ]] && {
  printf '# kubectl get pods\n'
  kubectl get pods
  printf '\nWaited for 20 seconds for kubectl to work.\n'
  printf 'Kubectl cannot contact master. Aborting.\n'
  exit 1
}
counter=0
while ! kubectl get nodes | grep -qs "$1"; do
  ((counter++))
  [[ ${counter} -gt 60 ]] && {
    printf '# kubectl get nodes\n'
    kubectl get nodes
    printf '\nWaited for 2 minutes for node to appear in master. Aborting.\n'
    exit 1
  }
  sleep 2
done
counter=0
while kubectl get pods -A | tail -n +2 | awk '{ print $3; }' | grep -qs 0; do
  ((counter++))
  [[ ${counter} -gt 120 ]] && {
    printf '# kubectl get pods -A\n'
    kubectl get pods -A
    printf '\nWaited for 3 minutes for pods to be ready. Aborting.\n'
    exit 1
  }
  sleep 2
done
exit 0
EnD

  docker cp "${setupfile}" "$1":/root/wait.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/wait.sh "$2" || err
}

# _CC_set_up_worker_node calls the correct set up function based on the version.
# Args: arg1 - the container ID to set up
#       arg2 - the CA hash
#       arg3 - the token
#       arg4 - the master IP
_CC_set_up_worker_node() {

  case "${_CC[k8sver]}" in
  "1.31."* | "1.32."* | "1.33."*)
    _CC_set_up_worker_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# Initialise _CC
_CC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster - versions file

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR TRUE

# _CC_set_up_master_node_v1_30_0 uses kubeadm to set up the master node.
# Args: arg1 - the container to set up.
_CC_set_up_master_node_v1_30_0() {

  local setupfile lbaddr certSANs="{}" certkey masternum t lbip
  # Set by _CC_get_master_join_details:
  local cahash token masterip

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masternum="${1##*-}" # <- eg. for xxx-master-1, masternum=1

  if [[ ${_CC[skipmastersetup]} != "${TRUE}" ]]; then

    if [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -eq 1 ]]; then

      # This is the first master node

      # Sets cahash, token, and masterip:
      lbip=$(CU_get_container_ip "${_CC[clustername]}-lb")
      lbaddr=", '${lbip}'"
      uploadcerts="--upload-certs"
      certkey="CertificateKey: f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07"

    elif [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -ne 1 ]]; then

      # This is not the first master node, so join with the master
      # https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/

      # Keep trying to get join details until apiserver is ready or we run out of tries
      for try in $(seq 1 9); do
        # Runs a script on master node to get join details
        t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1")
        retval=$?
        [[ ${retval} -eq 0 ]] && break
        [[ ${try} -eq 9 ]] && {
          printf '\nERROR: Problem with "_CC_get_master_join_details". Tried %d times\n\n' "${try}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        sleep 5
      done
      eval "${t}"
    fi
  fi

  # Always set certSANs for the host whether we need it or not
  hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
  certSANs="
  certSANs: [ '${hostaddr}'${lbaddr}, '127.0.0.1', 'localhost' ]"

  # Write the file regardless, so the user can use it if required

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

# Use a custom configuration. Default config created from kubeadm with:
#   kubeadm config print init-defaults
# then edited.

ipaddr=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")
podsubnet="10.244.0.0/16"
servicesubnet="10.96.0.0/16"

cat <<EOF >kubeadm-init-defaults.yaml
apiVersion: kubeadm.k8s.io/v1beta4
bootstrapTokens:
- groups:
  - system:bootstrappers:kubeadm:default-node-token
  token: abcdef.0123456789abcdef
  ttl: 24h0m0s
  usages:
  - signing
  - authentication
kind: InitConfiguration
${certkey}
localAPIEndpoint:
  advertiseAddress: \$ipaddr
  bindPort: 6443
nodeRegistration:
  criSocket: unix:///var/run/crio/crio.sock
  imagePullPolicy: IfNotPresent
  imagePullSerial: true
  name: $1
  taints:
  - effect: NoSchedule
    key: node-role.kubernetes.io/control-plane
timeouts:
  controlPlaneComponentHealthCheck: 4m0s
  discovery: 5m0s
  etcdAPICall: 2m0s
  kubeletHealthCheck: 4m0s
  kubernetesAPICall: 1m0s
  tlsBootstrap: 5m0s
  upgradeManifests: 5m0s
---
apiServer: ${certSANs}
apiVersion: kubeadm.k8s.io/v1beta4
caCertificateValidityPeriod: 87600h0m0s
certificateValidityPeriod: 8760h0m0s
certificatesDir: /etc/kubernetes/pki
clusterName: ${_CC[clustername]}-cluster
controlPlaneEndpoint: ${lbaddr:-\$ipaddr}:6443
controllerManager: {}
dns: {}
encryptionAlgorithm: RSA-2048
etcd:
  local:
    dataDir: /var/lib/etcd
imageRepository: registry.k8s.io
kind: ClusterConfiguration
kubernetesVersion: v${_CC[k8sver]}
networking:
  dnsDomain: cluster.local
  podSubnet: \${podsubnet}
  serviceSubnet: \${servicesubnet}
proxy: {}
scheduler: {}
EOF

mkdir -p /mok
cp kubeadm-init-defaults.yaml /mok/kubeadm.yaml

if [[ -z "${masterip}" ]]; then
  # Run the preflight phase
  kubeadm init \\
    --ignore-preflight-errors Swap \\
    --config=kubeadm-init-defaults.yaml \\
    phase preflight

  # Set up the kubelet
  kubeadm init phase kubelet-start

  # Edit the kubelet configuration file
  echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
  sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

  # Tell kubeadm to carry on from here
  kubeadm init \\
    --config=kubeadm-init-defaults.yaml \\
    --ignore-preflight-errors Swap \\
    ${uploadcerts} \\
    --skip-phases=preflight,kubelet-start

  export KUBECONFIG=/etc/kubernetes/super-admin.conf

  # Flannel - 10.244.0.0./16
  kubectl apply -f /root/kube-flannel.yml
else
  kubeadm join ${masterip}:6443 \\
    --ignore-preflight-errors Swap \\
    --control-plane \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --certificate-key f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07
fi

systemctl enable kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  # Run the file
  [[ -z ${_CC[skipmastersetup]} ]] && {
    docker exec "$1" bash /root/setup.sh || err || return

    # Remove the taint if we're setting up a single node cluster

    [[ ${_CC[numworkers]} -eq 0 ]] && {

      removetaint=$(mktemp -p /var/tmp) || {
        printf 'ERROR: mktmp failed.\n' >"${STDERR}"
        return "${ERROR}"
      }

      # Write the file
      cat <<'EnD' >"${removetaint}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
kubectl taint nodes --all node-role.kubernetes.io/control-plane:NoSchedule-
EnD

      docker cp "${removetaint}" "$1":/root/removetaint.sh || err || {
        rm -f "${removetaint}"
        return "${ERROR}"
      }

      # Run the file
      docker exec "$1" bash /root/removetaint.sh || err
    }
  }

  return "${OK}"
}

# _CC_set_up_worker_node_v1_30_0 uses kubeadm to set up the worker node.
# Args: arg1 - the container to set up.
_CC_set_up_worker_node_v1_30_0() {

  local setupfile cahash="$2" token="$3" masterip="$4"

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  if [[ ${_CC[withlb]} == "${TRUE}" ]]; then
    masterip=$(CU_get_container_ip "${_CC[clustername]}-lb") || return
  fi

  cat <<EnD >"${setupfile}"
# Wait for the master API to become ready
while true; do
  curl -k https://${masterip}:6443/
  [[ \$? -eq 0 ]] && break
  sleep 1
done

# Do the preflight tests (ignoring swap error)
kubeadm join \\
  phase preflight \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --ignore-preflight-errors Swap \\
    ${masterip}:6443

# Set up the kubelet
kubeadm join \\
  phase kubelet-start \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    ${masterip}:6443 &

while true; do
  [[ -e /var/lib/kubelet/config.yaml ]] && break
    sleep 1
  done

# Edit the kubelet configuration file
echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

systemctl enable --now kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh 2>"${STDERR}" || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CU - Container Utilities

# _CU is an associative array that holds data specific to container utils.
declare -A _CU

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# CU_containerrt getter outputs the container runtime (podman or docker)
# that has been chosen.
CU_containerrt() {
  printf '%s' "${_CU[containerrt]}"
}

# CU_imgprefix getter outputs the prefix to be used with docker build. For
# podman it is 'localhost/'. For docker it is empty.
CU_imgprefix() {
  printf '%s' "${_CU[imgprefix]}"
}

# CU_labelkey getter outputs the key value of the label that is applied to all
# cluster member's container labels for podman or docker.
CU_labelkey() {
  printf '%s' "${_CU[labelkey]}"
}

# CU_podmantype getter outputs the container runtime type (native or machine).
CU_podmantype() {
  printf '%s' "${_CU[podmantype]}"
}

# Public Functions ------------------------------------------------------------

# CU_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted.
CU_cleanup() { :; }

# CU_get_cluster_container_ids outputs just the container IDs, one per line
# for any MOK cluster, unless arg1 is set, in which case just the IDs
# for the requested cluster name are output.
# Args: arg1 - The cluster name, optional.
CU_get_cluster_container_ids() {

  local value output

  [[ -n $1 ]] && value="=$1"

  output=$(docker ps -a -f label="${_CU[labelkey]}${value}" -q) || {
    printf 'ERROR: %s command failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  output=$(printf '%s' "${output}" | sed 's/$//')

  printf '%s' "${output}"

  return "${OK}"
}

# CU_get_cluster_size searches for an existing cluster using labels and outputs
# the number of containers in that cluster. All cluster nodes are labelled with
# "${_CU[labelkey]}=${CC[clustername]}"
# Args: arg1 - The cluster name to search for.
CU_get_cluster_size() {

  local output
  declare -a nodes

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Cluster name cannot be empty.\n' >"${STDERR}"
    err || return
  }

  output=$(CU_get_cluster_container_ids "$1") || err || return

  # readarray will read null as an array item so don't run
  # through readarray if it's null
  [[ -z ${output} ]] && {
    printf '0'
    return "${OK}"
  }

  # read the nodes array and delete blank lines
  readarray -t nodes <<<"${output}"

  printf '%d' "${#nodes[*]}"
}

# CU_get_container_ip outputs the IP address of the container.
# Args: arg1 - docker container id or container name to query.
CU_get_container_ip() {

  local info

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  info=$(CU_get_container_info "$1") || return
  JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}" ||
    err || return
}

# CU_get_container_info uses 'docker/podman inspect $id' to output
# container details.
# Args: arg1 - docker container id
CU_get_container_info() {

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  docker inspect "$1" || {
    printf 'ERROR: %s inspect failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_create_container creates and runs a container with settings suitable for
# running privileged containers that can manipulate cgroups.
# Args: arg1 - The string used to set the name and hostname.
#       arg2 - The label to assign to the container.
#       arg3 - The k8s base image version to use.
CU_create_container() {

  local imagename img allimgs systemd_always clustername parg pval root_user url port

  [[ -z $1 || -z $2 || -z $3 ]] && {
    printf 'INTERNAL ERROR: Neither arg1, arg2 nor arg3 can be empty.\n' \
      >"${STDERR}"
    err || return
  }

  img="$(BI_baseimagename)_$(MA_arch)"

  local imglocal="${_CU[imgprefix]}local/${img}"
  local imgremote="myownkind/${img}"
  local imgtag="${3}"

  # Prefer a locally built container over one downloaded from a registry
  allimgs=$(docker images | tail -n +2) || {
    printf 'ERROR: %s returned an error\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  if echo "${allimgs}" | grep -qs "${imglocal} *${imgtag}"; then
    imagename="${imglocal}:${imgtag}"
  elif echo "${allimgs}" | grep -qs "${imgremote} *${imgtag}"; then
    imagename="${imgremote}:${imgtag}"
  else
    cat <<EnD
ERROR: No container base image found. Use either:

  $ mok build image
OR
  $ mok build image --get-prebuilt-image

Then try running 'mok create ...' again.
EnD
    return "${ERROR}"
  fi

  clustername=$(CC_clustername) || err || return

  if [[ ${_CU[containerrt]} == "podman" ]];
  then 
    docker network exists "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  else
    docker network inspect "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  fi

  [[ ${create_network} -ne 0 ]] && {
    docker network create "${clustername}_network" || {
      printf 'ERROR: docker network create failed\n' >"${STDERR}"
      err || return
    }
  }

  # Docker does not have the --systemd option
  [[ ${_CU[containerrt]} == "podman" ]] && systemd_always="--systemd=always"
  [[ ${_CU[podmantype]} == "machine" ]] && {
    root_user="--user=root"
    # TODO: A named podman machine does not work the same way
    #       as the default podman machine. Rootful doesn't work
    #       for a named machine so need to use '--url'. Ask
    #       Podman developers about this.
    port=$(podman machine inspect mok-machine | grep Port | grep -o '[0-9]\+')
    url="--url ssh://root@127.0.0.1:$port/run/podman/podman.sock"
  }

  [[ $(CC_publish) == "${TRUE}" ]] && {
    if [[ $(CC_withlb) == "${TRUE}" ]]; then
      if echo "$1" | grep -qs -- '-lb$'; then
        parg='-p'
        pval='6443:6443'
      fi
    else
      if echo "$1" | grep -qs -- '-master-1$'; then
        parg='-p'
        pval='6443:6443'
      fi
    fi
  }

  # shellcheck disable=SC2086
  docker ${url} run --privileged ${systemd_always} ${root_user} \
    --network "${clustername}_network" \
    -v /lib/modules:/lib/modules:ro \
    --detach ${parg} ${pval} \
    --name "$1" \
    --hostname "$1" \
    --label "$2" \
    "${imagename}" \
    /usr/local/bin/entrypoint /lib/systemd/systemd log-level=info unit=sysinit.target || {
    printf 'ERROR: %s run failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_podman_or_docker checks to see if docker and/or podman are installed and
# sets the imgprefix and containerrt array members accordingly. It also defines
# the docker function to run the detected container runtime. Podman is
# preferred if both are installed.
# Args: No args expected.
CU_podman_or_docker() {
  if type podman &>/dev/null; then
    _CU[imgprefix]="localhost/"
    _CU[containerrt]="podman"
    _CU_podman_checks || return
  elif type docker &>/dev/null; then
    _CU[imgprefix]=""
    _CU[containerrt]="docker"
    _CU_docker_checks || return
  else
    printf 'ERROR: Neither "podman" nor "docker" were found.\n' \
      >"${STDERR}"
    printf 'Please install one of "podman" or "docker".\nAborting.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi
  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CU_docker_checks checks to see if the current user has permission to write
# to the docker socket. If not, it prints an error message and exits.
# Args: No args expected.
_CU_docker_checks() {
  if [[ ! -e /proc/sys/kernel/hostname ]]; then
    printf 'ERROR: Docker is currently supported on Linux only'
    exit "${ERROR}"
  fi

  if docker ps >/dev/stdout 2>&1 | grep -qs 'docker.sock.*permission denied'; then
    cat <<EnD >"${STDERR}"
Not enough permissions to write to 'docker.sock'.

Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  fi

  _CU[podmantype]="native"
  return "${OK}"
}

# _CU_podman_checks sets the _CU[podmantype] member to "native" or "machine"
# depending on whether this is linux or macos. We assume linux won't be using
# a podman machine, and macos will always be using a podman machine.
# Args: No args expected.
_CU_podman_checks() {
  local info running exists

  if [[ -e /proc/sys/kernel/hostname ]]; then
    # We're on linux
    _CU[podmantype]="native"
    _CU_podman_native_checks || return
  elif [[ -d /System/Library/CoreServices ]]; then
    # We're on macOS
    [[ $(id -u) -eq 0 ]] && {
      printf 'ERROR: Cannot run mok as root on macOS.\n' >"${STDERR}"
      exit "${ERROR}"
    }

    info=$(podman machine list --format json) || err || return
    running=$(UT_sed_json_block "${info}" \
      'Name' 'mok-machine' '}' \
      'Running' \
      ) || err || return
    exists=$(UT_sed_json_block "${info}" \
      'Name' 'mok-machine' '}' \
      'Name' \
      ) || err || return

    if [[ $(MA_arg_1) != "machine" && ${exists} != "mok-machine" ]]; then
      printf 'ERROR: Podman machine does not exist.\n' >"${STDERR}"
      printf '       Create a Podman machine with: %s machine create\n' \
        "$(MA_program_name)" >"${STDERR}"
      exit "${ERROR}"
    elif [[ ${running} == "true" ]]; then
      _CU[podmantype]="machine"
    elif [[ $(MA_arg_1) != "machine" ]]; then
      # Don't check for a podman machine if we're running 'machine' commands
      printf 'ERROR: Podman machine is not running.\n' >"${STDERR}"
      printf '       Try starting the machine with: %s machine start\n' \
        "$(MA_program_name)" >"${STDERR}"
      exit "${ERROR}"
    fi
  else
    printf 'ERROR: Unknown OS. Aborting.\n' >"${STDERR}"
    exit "${ERROR}"
  fi
}

# _CU_podman_native_checks checks to see if the current user is root. If not,
# it prints an error message and exits.
# Args: No args expected.
_CU_podman_native_checks() {
  [[ $(id -u) -ne 0 ]] && {
    cat <<EnD >"${STDERR}"
Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  }
}

# _CU_new sets the initial values for the Container Utils associative array.
# Args: None expected.
_CU_new() {
  _CU[imgprefix]=
  _CU[labelkey]="MokCluster"
  _CU[containerrt]=

  # _CU[podmantype] will only be set only if _CU[containerrt]=podman.
  # podmantype will be "native" or "machine".
  _CU[podmantype]=
}

# Override `docker` depending on _CU[containerrt]
# [[ -n ${_CU[containerrt]} ]] && {
  docker() {
    local cmd port url

    if [[ "${_CU[containerrt]}" == "podman" && "${_CU[podmantype]}" == "machine" ]]; then
      # TODO: A named podman machine does not work the same way
      #       as the default podman machine. Rootful doesn't work
      #       for a named machine so need to use '--url'. Ask
      #       Podman developers about this.
      port=$(podman machine inspect mok-machine | grep Port | grep -o '[0-9]\+')
      url="ssh://root@127.0.0.1:$port/run/podman/podman.sock"

      # TODO: This would be preferred to '--url'
      # podman -c mok-machine "$@"
      podman --url "${url}" "$@"
    elif [[ "${_CU[containerrt]}" == "podman" ]]; then
      podman "$@"
    else
      cmd=$(which -a docker | tail -n 1)
      $cmd "$@"
    fi
  }
# }

# Override `ip` depending on _CU[podmantype]
ip() {
  local cmd
  if [[ "${_CU[podmantype]}" == "machine" ]]; then
    podman machine ssh mok-machine ip "$@"
  else
    cmd=$(which -a ip | tail -n 1)
    $cmd "$@"
  fi
}

# Initialise _CU
_CU_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# BI - Build Image

# _BI is an associative array that holds data specific to building an image.
declare -A _BI

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE

# Getters/Setters -------------------------------------------------------------

# BI_setflag_useprebuiltimage setter sets the useprebuiltimage array item.
# This is called by the parser, via a callback in _BI_new.
BI_setflag_useprebuiltimage() {
  _BI[useprebuiltimage]="$1"
}

# BI_baseimagename getter outputs the value of the _BI[baseimagename].
# Args: None expected.
BI_baseimagename() {
  printf '%s' "${_BI[baseimagename]}"
}

# Public Functions ------------------------------------------------------------

# BI_usage outputs help text for the build image component.
# It is called by PA_usage(), via a callback in _BI_new.
# Args: None expected.
BI_usage() {

  cat <<'EnD'
BUILD subcommands are:
 
  image - Creates the docker 'mok-image' container image.
 
build image options:
 
 Format:
  build image [flags]

 Flags:
  --get-prebuilt-image - Instead of building a 'node' image
         locally, download it from a container registry instead.
  --k8sver VERSION - The Kubernetes version, e.g. "1.32.0"
         A previous version cannot be built from scratch hence this option
         must be used with '--get-prebuilt-image'. To build a previous
         version of kubernetes it must be built with a previous version
         of mok.
  --tailf - Show the build output whilst building.

EnD
}

# BI_cleanup removes temporary files created during the build.
# This function is called by the 'MA_cleanup' trap only.
# Args: None expected.
BI_cleanup() {
  [[ -e ${_BI[dockerbuildtmpdir]} ]] &&
    [[ ${_BI[dockerbuildtmpdir]} == "/var/tmp/"* ]] && {
    rm -rf "${_BI[dockerbuildtmpdir]}" || {
      printf 'ERROR: "rm -rf %s" failed.\n' "${_BI[dockerbuildtmpdir]}" \
        >"${STDERR}"
      err || return
    }
  }
}

# BI_check_valid_options checks if arg1 is in a list of valid build image
# options. This function is called by the parser, via a callback in _BI_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
BI_process_options() {

  case "$1" in
  -h | --help)
    BI_usage
    return "${STOP}"
    ;;
  --tailf)
    _BI[tailf]="${TRUE}"
    return "${OK}"
    ;;
  --k8sver)
    _BI[k8sver]="$2"
    return "$(PA_shift)"
    ;;
  --get-prebuilt-image)
    _BI[useprebuiltimage]="${TRUE}"
    return "${OK}"
    ;;
  *)
    BI_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# BI_run builds the base image used for masters and workers.
# This function is called in main.sh.
# Args: None expected.
BI_run() {

  _BI_sanity_checks || return

  [[ ${_BI[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  local retval=0
  _BI_build_container_image
  retval=$?

  if [[ ${retval} -eq ${OK} ]]; then
    : # We only need the tick - no text
  else
    printf 'Image build failed\n' >"${STDERR}"
    err
  fi

  return "${retval}"
}

# Private Functions -----------------------------------------------------------

# _BI_new resets the initial values for the _BI associative array.
# Args: None expected.
_BI_new() {
  _BI[tailf]="${FALSE}"
  _BI[baseimagename]="mok-image"
  _BI[useprebuiltimage]="${FALSE}"
  _BI[dockerbuildtmpdir]=
  _BI[k8sver]="${K8SVERSION}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "build" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "buildimage" "END" ""

  # Set up the parser's option callbacks
  PA_add_option_callback "build" "BI_process_options" || return
  PA_add_option_callback "buildimage" "BI_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "build" "BI_usage" || return
  PA_add_usage_callback "buildimage" "BI_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "buildimage" "BI_run"
}

# BI_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_BI_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    BI_usage
    exit "${OK}"
  fi
}

# _BI_build_container_image creates the docker build directory in
# dockerbuildtmpdir then calls docker build to build the image.
# Args: No args expected.
_BI_build_container_image() {

  local cmd retval tagname buildargs text buildtype basename

  _BI_create_docker_build_dir || return

  buildargs=$(_BI_get_build_args_for_latest) || return
  basename="${_BI[baseimagename]}_$(MA_arch)"
  tagname="${_BI[k8sver]}"

  local imgprefix
  imgprefix=$(CU_imgprefix) || err || return
  if [[ ${_BI[useprebuiltimage]} == "${FALSE}" ]]; then
    # Each mok release can build the hardcoded version only
    # so reset the tagname to that version
    tagname="${K8SVERSION}"
    buildtype="create"
    cmd="docker build \
      -t "${imgprefix}local/${basename}:${tagname}" \
      --force-rm \
      ${buildargs} \
      ${_BI[dockerbuildtmpdir]}/${_BI[baseimagename]}"
    text="Creating"
  else
    # We can download and run any available version
    buildtype="download"
    cmd="docker pull docker.io/myownkind/${basename}:${tagname}"
    text="Downloading"
  fi

  UT_run_with_progress \
    "    ${text} base image, '${basename}:${tagname}'" "${cmd}"

  retval=$?
  [[ ${retval} -ne ${OK} ]] && {
    local runlogfile
    runlogfile=$(UT_runlogfile) || err || return
    printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\n' >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${buildtype} == "create" ]] && {
    cmd="_BI_modify_container_image"

    UT_run_with_progress \
      "    Modifying base image (pulling kubernetes images)" "${cmd}"

    retval=$?
    [[ ${retval} -ne ${OK} ]] && {
      local runlogfile
      runlogfile=$(UT_runlogfile) || err || return
      printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\n' >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _BI_modify_container_image starts a container suitable for running kubernetes
# components (since the docker/podman build environment isn't suitable), makes
# some modifications and then 'commits' the image. The modifications allow
# `mok create ...` to complete more quickly.
# Args: No args expected.
_BI_modify_container_image() {

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify &>/dev/null
  docker rm mok-build-modify &>/dev/null

  CC_set_clustername "build" || err || return

  # Start container
  CU_create_container "mok-build-modify" "mok-build-modify" "${K8SVERSION}" ||
    return

  # Wait for crio to become ready
  local counter
  printf '\n\n ** WAITING FOR CRIO TO BECOME READY **\n\n'
  while ! docker exec mok-build-modify systemctl status crio; do
    sleep 1
    [[ ${counter} -gt 10 ]] && {
      printf '\nERROR: CRI-O did not start after %d tries.\n' "${counter}"
      err || return
    }
    ((counter++))
  done

  # Modify container
  docker exec mok-build-modify kubeadm config images pull \
    --kubernetes-version "${K8SVERSION}" || err || return

  # Stop container
  docker stop -t 5 "mok-build-modify"

  # Write image
  local imgprefix tagname basename
  imgprefix=$(CU_imgprefix) || err || return
  basename="${_BI[baseimagename]}_$(MA_arch)"
  tagname="${K8SVERSION}"
  docker commit mok-build-modify "${imgprefix}local/${basename}:${tagname}" || err || return

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify
  docker rm mok-build-modify || err || return

  return "${OK}"
}

# _BI_get_build_args_for_latest sets the buildargs variable that is added
# to the 'podman build ...' command line.  Only the latest version is built
# from scratch.  Earlier versions are downloaded using '--get-prebuilt-image'.
# Args: None expected
_BI_get_build_args_for_latest() {

  local buildargs

  buildargs="--build-arg GO_VERSION=${GO_VERSION}"

  printf '%s' "${buildargs}"
}

# _BI_create_docker_build_dir creates a docker build directory in
# /var/tmp/tmp.XXXXXXXX
# Args: None expected
_BI_create_docker_build_dir() {

  _BI[dockerbuildtmpdir]="$(mktemp -d -p /var/tmp)" || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }

  # The following comments should not be removed or changed.
  # embed-dockerfile.sh adds a base64 encoded tarball and
  # unpacking code between them.

  #mok-image-tarball-start 
  cat <<EnD | base64 -d | tar xz -C "${_BI[dockerbuildtmpdir]}" 
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
EnD
  #mok-image-tarball-end
}

# Initialise _BI
_BI_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
#!/usr/bin/env bash

declare -A JSONPath

JSONPath_new() {
  JSONPath[DEBUG]=0
  JSONPath[INCLEMPTY]=0
  JSONPath[NOCASE]=0
  JSONPath[WHOLEWORD]=0
  JSONPath[FILE]=
  JSONPath[NO_HEAD]=0
  JSONPath[NORMALIZE_SOLIDUS]=0
  JSONPath[BRIEF]=0
  JSONPath[PASSTHROUGH]=0
  JSONPath[JSON]=0
  JSONPath[MULTIPASS]=0
  JSONPath[FLATTEN]=0
  JSONPath[STDINFILE]=/var/tmp/JSONPath.$$.stdin
  JSONPath[STDINFILE2]=/var/tmp/JSONPath.$$.stdin2
  JSONPath[PASSFILE]=/var/tmp/JSONPath.$$.pass1
  declare -a INDEXMATCH_QUERY
}

# JSONPath reads JSON from stdin and applies a JSON Path query.
# Args: arg1-N - command line arguments to be parsed.
JSONPath() {

  JSONPath_sanity_checks
  JSONPath_parse_options "$@"

  trap JSONPath_cleanup EXIT

  if [[ ${QUERY} == *'?(@'* ]]; then
    # This will be a multipass query

    [[ -n ${JSONPath[FILE]} ]] && JSONPath[STDINFILE]=${JSONPath[FILE]}
    [[ -z ${JSONPath[FILE]} ]] && cat >"${JSONPath[STDINFILE]}"

    while true; do
      JSONPath_tokenize_path
      JSONPath_create_filter

      JSONPath_tokenize | JSONPath_parse | JSONPath_filter |
        JSONPath_indexmatcher >"${JSONPath[PASSFILE]}" <"${JSONPath[STDINFILE]}"

      [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && {
        # replace filter expression with index sequence
        SET=$(sed -rn 's/.*[[,"]+([0-9]+)[],].*/\1/p' "${JSONPath[PASSFILE]}" | tr '\n' ,)
        SET=${SET%,}
        #QUERY=$(sed "s/?(@[^)]\+)/${SET}/" <<<"${QUERY}")
        # Testing:
        QUERY="${QUERY//\?\(@*)/${SET}}"
        [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "QUERY=${QUERY}" >/dev/stderr
        JSONPath_reset
        continue
      }

      JSONPath_flatten | JSONPath_json | JSONPath_brief <<<"${JSONPath[PASSFILE]}"

      break
    done

  else

    JSONPath_tokenize_path
    JSONPath_create_filter

    if [[ ${JSONPath[PASSTHROUGH]} -eq 1 ]]; then
      JSONPath[JSON]=1
      JSONPath_flatten | JSONPath_json
    elif [[ -z ${JSONPath[FILE]} ]]; then
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten | JSONPath_json | JSONPath_brief
    else
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten <"${JSONPath[FILE]}"
      JSONPath_json | JSONPath_brief
    fi

  fi
}

JSONPath_sanity_checks() {

  local binary

  # Reset some vars
  for binary in gawk grep sed; do
    if ! command -v "${binary}" >&/dev/null; then
      echo "ERROR: ${binary} binary not found in path. Aborting."
      exit 1
    fi
  done
}

JSONPath_reset() {

  # Reset some vars
  declare -a INDEXMATCH_QUERY
  PATHTOKENS=
  FILTER=
  OPERATOR=
  RHS=
  JSONPath[MULTIPASS]=0
}

JSONPath_cleanup() {

  [[ -e ${JSONPath[PASSFILE]} ]] && rm -f "${PASSFILE}"
  [[ -e ${JSONPath[STDINFILE2]} ]] && rm -f "${JSONPath[STDINFILE2]}"
  [[ -z ${JSONPath[FILE]} && -e ${JSONPath[STDINFILE]} ]] &&
    rm -f "${JSONPath[STDINFILE]}"
}

JSONPath_usage() {

  echo
  echo "Usage: JSONPath.sh [-b] [j] [-h] [-f FILE] [pattern]"
  echo
  echo "pattern - the JSONPath query. Defaults to '$.*' if not supplied."
  echo "-b      - Brief. Only show values."
  echo "-j      - JSON output."
  echo "-u      - Strip unnecessary leading path elements."
  echo "-i      - Case insensitive."
  echo "-p      - Pass-through to the JSON parser."
  echo "-w      - Match whole words only (for filter script expression)."
  echo "-f FILE - Read a FILE instead of stdin."
  echo "-h      - This help text."
  echo
}

JSONPath_parse_options() {

  set -- "$@"
  local ARGN=$#
  while [[ ${ARGN} -ne 0 ]]; do
    case $1 in
    -h)
      JSONPath_usage
      exit 0
      ;;
    -f)
      shift
      JSONPath[FILE]=$1
      ;;
    -i)
      JSONPath[NOCASE]=1
      ;;
    -j)
      JSONPath[JSON]=1
      ;;
    -n)
      JSONPath[NO_HEAD]=1
      ;;
    -b)
      JSONPath[BRIEF]=1
      ;;
    -u)
      JSONPath[FLATTEN]=1
      ;;
    -p)
      JSONPath[PASSTHROUGH]=1
      ;;
    -w)
      JSONPath[WHOLEWORD]=1
      ;;
    -s)
      JSONPath[NORMALIZE_SOLIDUS]=1
      ;;
    *)
      QUERY=$1
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done
  [[ -z ${QUERY} ]] && QUERY='$.*'
}

JSONPath_awk_egrep() {
  local pattern_string=$1

  gawk '{
    while ($0) {
      start=match($0, pattern);
      token=substr($0, start, RLENGTH);
      print token;
      $0=substr($0, start+RLENGTH);
    }
  }' pattern="${pattern_string}"
}

JSONPath_tokenize() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    ESCAPE='(\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
    ESCAPE='(\\\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\\\]'
  fi

  local STRING="\"${CHAR}*(${ESCAPE}${CHAR}*)*\""
  local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'
  local KEYWORD='null|false|true'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  ${GREP} "${STRING}|${NUMBER}|${KEYWORD}|${SPACE}|." | grep -Ev "^${SPACE}$"
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

JSONPath_tokenize_path() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
  fi

  local WILDCARD='\*'
  local WORD='[ A-Za-z0-9_-]*'
  local INDEX="\\[${WORD}(:${WORD}){0,2}\\]"
  local INDEXALL='\[\*\]'
  local STRING="[\\\"'][^[:cntrl:]\\\"']*[\\\"']"
  local SET="\\[(${WORD}|${STRING})(,(${WORD}|${STRING}))*\\]"
  local FILTER='\?\(@[^)]+'
  local DEEPSCAN='\.\.'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  readarray -t PATHTOKENS < <(echo "${QUERY}" |
    ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
    grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$")
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    echo "grep -Eo '${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|.'" >/dev/stderr
    echo -n "TOKENISED QUERY="
    echo "${QUERY}" |
      ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
      grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$" >/dev/stderr
  }
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

# JSONPath_create_filter creates the filter from the user's query.
# Filter works in a single pass through the data, unless a filter (script)
#  expression is used, in which case two passes are required (MULTIPASS=1).
JSONPath_create_filter() {

  local len=${#PATHTOKENS[*]}

  local -i i=0
  local a query="^\[" comma=
  while [[ i -lt len ]]; do
    case "${PATHTOKENS[i]}" in
    '"')
      :
      ;;
    '..')
      query+="${comma}[^]]*"
      comma=
      ;;
    '[*]')
      query+="${comma}[^,]*"
      comma=","
      ;;
    '*')
      query+="${comma}(\"[^\"]*\"|[0-9]+[^],]*)"
      comma=","
      ;;
    '?(@'*)
      a=${PATHTOKENS[i]#?(@.}
      elem="${a%%[<>=!]*}"
      rhs="${a##*[<>=!]}"
      a="${a#${elem}}"
      elem="${elem//./[\",.]+}" # Allows child node matching
      operator="${a%${rhs}}"
      [[ -z ${operator} ]] && {
        operator="=="
        rhs=
      }
      if [[ ${rhs} == *'"'* || ${rhs} == *"'"* ]]; then
        case ${operator} in
        '==' | '=')
          OPERATOR=
          if [[ ${elem} == '?(@' ]]; then
            # To allow search on @.property such as:
            #   $..book[?(@.title==".*Book 1.*")]
            query+="${comma}[0-9]+[],][[:space:]\"]*${rhs//\"/}"
          else
            # To allow search on @ (this node) such as:
            #   $..reviews[?(@==".*Fant.*")]
            query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs//\"/}"
          fi
          FILTER="${query}"
          ;;
        '>=' | '>')
          OPERATOR=">"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=' | '<')
          OPERATOR="<"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      else
        case ${operator} in
        '==' | '=')
          OPERATOR=
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs}"
          FILTER="${query}"
          ;;
        '>=')
          OPERATOR="-ge"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '>')
          OPERATOR="-gt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=')
          OPERATOR="-le"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<')
          OPERATOR="-lt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      fi
      JSONPath[MULTIPASS]=1
      ;;
    "["*)
      if [[ ${PATHTOKENS[i]} =~ , ]]; then
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          # converts only one comma: s/("[^"]+),([^"]+")/\1`\2/g;s/"//g
          #a=$(echo $a | sed 's/\([[:alpha:]]*\)/"\1"/g')
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        fi
        query+="${comma}(${a//,/|})"
      elif [[ ${PATHTOKENS[i]} =~ : ]]; then
        if ! [[ ${PATHTOKENS[i]} =~ [0-9][0-9] || ${PATHTOKENS[i]} =~ :] ]]; then
          if [[ ${PATHTOKENS[i]#*:} =~ : ]]; then
            INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
            query+="${comma}[^,]*"
          else
            # Index in the range of 0-9 can be handled by regex
            query+="${comma}$(echo "${PATHTOKENS[i]}" |
              gawk '/:/ { a=substr($0,0,index($0,":")-1);
                         b=substr($0,index($0,":")+1,index($0,"]")-index($0,":")-1);
                         if(b>0) { print a ":" b-1 "]" };
                         if(b<=0) { print a ":]" } }' |
              sed 's/\([0-9]\):\([0-9]\)/\1-\2/;
                       s/\[:\([0-9]\)/[0-\1/;
                       s/\([0-9]\):\]/\1-9999999]/')"
          fi
        else
          INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
          query+="${comma}[^,]*"
        fi
      else
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        else
          [[ ${i} -gt 0 ]] && comma=","
        fi
        query+="${comma}${a}"
      fi
      comma=","
      ;;
    *)
      PATHTOKENS[i]=${PATHTOKENS[i]//\'/\"}
      query+="${comma}\"${PATHTOKENS[i]//\"/}\""
      comma=","
      ;;
    esac
    i=$((i + 1))
  done

  [[ -z ${FILTER} ]] && FILTER="${query}[],]"
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
}

JSONPath_parse_array() {

  local index=0
  local ary=''
  read -r token
  case "${token}" in
  ']') ;;

  *)
    while :; do
      JSONPath_parse_value "$1" "${index}"
      index=$((index + 1))
      ary="${ary}""${value}"
      read -r token
      case "${token}" in
      ']') break ;;
      ',') ary="${ary}," ;;
      *) JSONPath_throw "EXPECTED , or ] GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_object() {

  local key
  local obj=''
  read -r token
  case "${token}" in
  '}') ;;

  *)
    while :; do
      case "${token}" in
      '"'*'"') key=${token} ;;
      *) JSONPath_throw "EXPECTED string GOT ${token:-EOF}" ;;
      esac
      read -r token
      case "${token}" in
      ':') ;;
      *) JSONPath_throw "EXPECTED : GOT ${token:-EOF}" ;;
      esac
      read -r token
      JSONPath_parse_value "$1" "${key}"
      obj="${obj}${key}:${value}"
      read -r token
      case "${token}" in
      '}') break ;;
      ',') obj="${obj}," ;;
      *) JSONPath_throw "EXPECTED , or } GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_value() {

  local jpath="${1:+$1,}$2" isleaf=0 isempty=0 print=0
  case "${token}" in
  '{') JSONPath_parse_object "${jpath}" ;;
  '[') JSONPath_parse_array "${jpath}" ;;
    # At this point, the only valid single-character tokens are digits.
  '' | [!0-9]) JSONPath_throw "EXPECTED value GOT ${token:-EOF}" ;;
  *)
    value=${token}
    # if asked, replace solidus ("\/") in json strings with normalized value: "/"
    # Testing:
    #[ "${JSONPath[NORMALIZE_SOLIDUS]}" -eq 1 ] && value=$(echo "${value}" | sed 's#\\/#/#g')
    [[ ${JSONPath[NORMALIZE_SOLIDUS]} -eq 1 ]] && value=$(${value//\\\///})
    isleaf=1
    [[ ${value} == '""' ]] && isempty=1
    ;;
  esac
  [[ -z ${JSONPath[INCLEMPTY]} ]] && [[ ${value} == '' ]] && return
  [[ ${JSONPath[NO_HEAD]} -eq 1 ]] && [[ -z ${jpath} ]] && return

  [[ ${isleaf} -eq 1 ]] && [[ ${isempty} -eq 0 ]] && print=1
  [[ ${print} -eq 1 ]] && printf "[%s]\t%s\n" "${jpath}" "${value}"
  :
}

JSONPath_flatten() {

  local path a prevpath pathlen

  if [[ ${JSONPath[FLATTEN]} -eq 1 ]]; then
    cat >"${JSONPath[STDINFILE2]}"

    highest=9999

    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      [[ -z ${prevpath} ]] && {
        prevpath=("${path[@]}")
        highest=$((${#path[*]} - 1))
        continue
      }

      pathlen=$((${#path[*]} - 1))

      for i in $(seq 0 "${pathlen}"); do
        [[ ${path[i]} != "${prevpath[i]}" ]] && {
          high=${i}
          break
        }
      done

      [[ ${high} -lt ${highest} ]] && highest=${high}

      prevpath=("${path[@]}")
    done <"${JSONPath[STDINFILE2]}"

    if [[ ${highest} -gt 0 ]]; then
      sed -r 's/\[(([0-9]+|"[^"]+")[],]){'$((highest))'}(.*)/[\3/' \
        "${JSONPath[STDINFILE2]}"
    else
      cat "${JSONPath[STDINFILE2]}"
    fi
  else
    cat
  fi
}

# JSONPath_indexmatcher is for double digit or greater indexes match each line
# individually Single digit indexes are handled more efficiently by regex
JSONPath_indexmatcher() {

  local a b

  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
      echo "INDEXMATCH_QUERY[${i}]=${INDEXMATCH_QUERY[i]}" >/dev/stderr
    done
  }

  matched=1

  step=
  if [[ ${#INDEXMATCH_QUERY[*]} -gt 0 ]]; then
    while read -r line; do
      for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
        [[ ${INDEXMATCH_QUERY[i]#*:} =~ : ]] && {
          step=${INDEXMATCH_QUERY[i]##*:}
          step=${step%]}
          INDEXMATCH_QUERY[i]="${INDEXMATCH_QUERY[i]%:*}]"
        }
        q=${INDEXMATCH_QUERY[i]:1:-1} # <- strip '[' and ']'
        a=${q%:*}                     # <- number before ':'
        b=${q#*:}                     # <- number after ':'
        [[ -z ${b} ]] && b=99999999999
        readarray -t num < <((grep -Eo '[0-9]+[],]' | tr -d ,]) <<<"${line}")
        if [[ ${num[i]} -ge ${a} && ${num[i]} -lt ${b} && matched -eq 1 ]]; then
          matched=1
          [[ ${i} -eq $((${#INDEXMATCH_QUERY[*]} - 1)) ]] && {
            if [[ ${step} -gt 1 ]]; then
              [[ $(((num[i] - a) % step)) -eq 0 ]] && {
                [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
                echo "${line}"
              }
            else
              [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
              echo "${line}"
            fi
          }
        else
          matched=0
          continue
        fi
      done
      matched=1
    done
  else
    cat -
  fi
}

JSONPath_brief() {
  # Only show the value

  if [[ ${JSONPath[BRIEF]} -eq 1 ]]; then
    sed 's/^[^\t]*\t//;s/^"//;s/"$//;'
  else
    cat
  fi
}

JSONPath_json() {
  # Turn output into JSON

  local a tab="$'\t'"
  local UP=1 DOWN=2 SAME=3
  local prevpathlen=-1 prevpath=() path a
  declare -a closers

  if [[ ${JSONPath[JSON]} -eq 0 ]]; then
    cat -
  else
    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      value=${line#*${tab}}

      # Not including the object itself (last item)
      pathlen=$((${#path[*]} - 1))

      # General direction

      direction=${SAME}
      [[ ${pathlen} -gt ${prevpathlen} ]] && direction=${DOWN}
      [[ ${pathlen} -lt ${prevpathlen} ]] && direction=${UP}

      # Handle jumps UP the tree (close previous paths)

      [[ ${prevpathlen} != -1 ]] && {
        for i in $(seq 0 $((pathlen - 1))); do
          [[ ${prevpath[i]} == "${path[i]}" ]] && continue
          [[ ${path[i]} != '"'* ]] && {
            # Testing double quotes:
            a="(${!arrays[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                arrays[k]=
              done
            }
            a="(${!comma[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                comma[k]=
              done
            }
            for j in $(seq $((prevpathlen)) -1 $((i + 2))); do
              arrays[j]=
              [[ -n ${closers[j]} ]] && {
                indent=$((j * 4))
                printf "\n%${indent}s${closers[j]}" ""
                unset "closers[j]"
                comma[j]=
              }
            done
            direction=${DOWN}
            break
          }
          direction=${DOWN}
          for j in $(seq $((prevpathlen)) -1 $((i + 1))); do
            arrays[j]=
            [[ -n ${closers[j]} ]] && {
              indent=$((j * 4))
              printf "\n%${indent}s${closers[j]}" ""
              unset "closers[j]"
              comma[j]=
            }
          done
          a="(${!arrays[*]})"
          [[ -n ${a} ]] && {
            for k in $(seq "${i}" "${a[-1]}"); do
              arrays[k]=
            done
          }
          break
        done
      }

      [[ ${direction} -eq ${UP} ]] && {
        [[ ${prevpathlen} != -1 ]] && comma[prevpathlen]=
        for i in $(seq $((prevpathlen + 1)) -1 $((pathlen + 1))); do
          arrays[i]=
          [[ -n ${closers[i]} ]] && {
            indent=$((i * 4))
            printf "\n%${indent}s${closers[i]}" ""
            unset "closers[i]"
            comma[i]=
          }
        done
        a="(${!arrays[*]})"
        [[ -n ${a} ]] && {
          for k in $(seq "${i}" "${a[-1]}"); do
            arrays[k]=
          done
        }
      }

      # Opening braces (the path leading up to the key)

      broken=
      for i in $(seq 0 $((pathlen - 1))); do
        [[ -z ${broken} && ${prevpath[i]} == "${path[i]}" ]] && continue
        [[ -z ${broken} ]] && {
          broken=${i}
          [[ ${prevpathlen} -ne -1 ]] && broken=$((i + 1))
        }
        if [[ ${path[i]} == '"'* ]]; then
          # Object
          [[ ${i} -ge ${broken} ]] && {
            indent=$((i * 4))
            printf "${comma[i]}%${indent}s{\n" ""
            closers[i]='}'
            comma[i]=
          }
          indent=$(((i + 1) * 4))
          printf "${comma[i]}%${indent}s${path[i]}:\n" ""
          comma[i]=",\n"
        else
          # Array
          if [[ ${arrays[i]} != 1 ]]; then
            indent=$((i * 4))
            printf "%${indent}s" ""
            echo "["
            closers[i]=']'
            arrays[i]=1
            comma[i]=
          else
            indent=$(((i + 1) * 4))
            printf "\n%${indent}s${closers[i - 1]}" ""
            direction=${DOWN}
            comma[i + 1]=",\n"
          fi
        fi
      done

      # keys & values

      if [[ ${path[-1]} == '"'* ]]; then
        # Object
        [[ ${direction} -eq ${DOWN} ]] && {
          indent=$((pathlen * 4))
          printf "${comma[pathlen]}%${indent}s{\n" ""
          closers[pathlen]='}'
          comma[pathlen]=
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${path[-1]}:${value}"
        comma[pathlen]=",\n"
      else
        # Array
        [[ ${arrays[i]} != 1 ]] && {
          indent=$(((pathlen - 0) * 4))
          printf "%${indent}s[\n" ""
          closers[pathlen]=']'
          comma[pathlen]=
          arrays[i]=1
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${value}"
        comma[pathlen]=",\n"
      fi

      prevpath=("${path[@]}")
      prevpathlen=${pathlen}
    done

    # closing braces

    for i in $(seq $((pathlen)) -1 0); do
      indent=$((i * 4))
      printf "\n%${indent}s${closers[i]}" ""
    done
    echo
  fi
}

JSONPath_filter() {
  # Apply the query filter

  local a tab=$'\t' v

  [[ ${JSONPath[NOCASE]} -eq 1 ]] && opts+="i"
  [[ ${JSONPath[WHOLEWORD]} -eq 1 ]] && opts+="w"
  if [[ -z ${OPERATOR} ]]; then
    [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && FILTER="${FILTER}[\"]?$"
    grep "-E${opts}" "${FILTER}"
    [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
  else
    grep "-E${opts}" "${FILTER}" |
      while read -r line; do
        v=${line#*${tab}}
        case ${OPERATOR} in
        '-ge')
          if gawk '{exit !($1>=$2)}' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-gt')
          if gawk '{exit !($1>$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-le')
          if gawk '{exit !($1<=$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-lt')
          if gawk '{exit !($1<$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '>')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} > ${RHS,,} ]] && echo "${line}"
          ;;
        '<')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} < ${RHS,,} ]] && echo "${line}"
          ;;
        *) return 1 ;;
        esac
      done
  fi
}

JSONPath_parse() {
  # Parses json

  read -r token
  JSONPath_parse_value
  read -r token
  case "${token}" in
  '') ;;
  *)
    JSONPath_throw "EXPECTED EOF GOT ${token}"
    exit 1
    ;;
  esac
}

JSONPath_throw() {
  echo "$*" >&2
  exit 1
}

JSONPath_new || exit 1

# vi: expandtab sw=2 ts=2
# shellcheck shell=bash disable=SC2148
# MA - execution starts here

# MA is an associative array that holds data specific to this file
declare -A _MA

# Defined in GL (globals.sh)
declare OK ERROR STOP STDERR TRUE __mokostype __mokarch

# Getters/Setters -------------------------------------------------------------

# MA_program_args getter outputs the program arguments sent by the user.
MA_program_args() {
  printf '%s' "${_MA[program_args]}"
}

# MA_arg_1 getter outputs the first argument sent by the user.
# Used by _CU_podman_checks so it doesn't check for a podman machine
# if we're running 'machine' commands
# FIXME: The command might not be the first argument. It could be '-p'
MA_arg_1() {
  printf '%s' "${_MA[arg_1]}"
}

# MA_program_name getter outputs the name of the program.
MA_program_name() {
  printf '%s' "${_MA[arg_0]##*/}"
}

# MA_ostype getter outputs the OS type.
MA_ostype() {
  printf '%s' "${_MA[ostype]}"
}

# MA_ostype getter outputs the machine architecture.
MA_arch() {
  printf '%s' "${_MA[arch]}"
}

# Public Functions ------------------------------------------------------------

# main is the start point for this application.
# Args: arg1-N - the command line arguments entered by the user.
MA_main() {
  local retval="${OK}"

  CU_podman_or_docker

  trap MA_cleanup EXIT
  MA_sanity_checks || return
  PA_run "$@" || retval=$?

  exit "${retval}"
}

# MA_version outputs the version information the exits.
MA_version() {
  printf 'Version: %s\n' "${MOKVERSION}"
  exit "${OK}"
}

# MA_process_global_options is called by the parser when a global option is
# encountered for processing.
# Args: arg1 - the global option that was found.
MA_process_global_options() {
  case "$1" in
  -h | --help)
    PA_usage
    return "${STOP}"
    ;;
  -p | --plain)
    UT_set_plain "${TRUE}"
    ;;
  *)
    printf 'INTERNAL ERROR: Invalid global option, "%s".' "$1"
    return "${ERROR}"
    ;;
  esac
}

# MA_cleanup is called from an EXIT trap only, when the program exits, and
# calls every other function matching the pattern '^.._cleanup'.
# Args: No args expected.
MA_cleanup() {
  local retval="${OK}" funcs func
  funcs=$(declare -F | awk '{print $NF;}' | grep '^.._cleanup')
  for func in ${funcs}; do
    [[ ${func} == "${FUNCNAME[0]}" ]] && continue
    eval "${func}" || retval=$?
  done
  return "${retval}"
}

# MA_sanity_checks is expected to run some quick and simple checks to
# see if key components are available before MA_main is called.
# Args: No args expected.
MA_sanity_checks() {

  local binary binaries

  if [[ $(CU_podmantype) == "native" ]]; then
    binaries="gawk tac column tput grep sed ip cut"
  else
    binaries="gawk tac column tput grep sed cut"
  fi

  for binary in ${binaries}; do
    if ! command -v "${binary}" >&/dev/null; then
      printf 'ERROR: "%s" binary not found in path. Aborting.' "${binary}" \
        >"${STDERR}"
      return "${ERROR}"
    fi
  done

  # Disable terminal escapes (colours) if stdout is not a terminal
  [ -t 1 ] || UT_disable_colours
}

# MA_usage outputs help text for all components then quits with no error.  This
# is registered as a callback in the Parser, see _MA_new
# Args: None expected.
MA_usage() {

  cat <<'EnD'
Usage: mok [-h] <command> [subcommand] [ARGS...]
 
Global options:
  --help
  -h     - This help text
  --plain
  -p     - Plain output. No colours or animations.
 
Where command can be one of:
  create  - Add item(s) to the system.
  delete  - Delete item(s) from the system.
  build   - Build item(s) used by the system.
  get     - Get details about items in the system.
  exec    - 'Log in' to the container.
  machine - Manage a podman machine (MacOS only).
  version - Display version information.

For help on a specific command, run:
  mok <command> --help
EnD
}

# MA_new sets the initial values for the _MA associative array
_MA_new() {
  _MA[program_args]="$*"
  _MA[arg_0]="$0"
  _MA[arg_1]="$1"
  _MA[ostype]="${__mokostype}" # linux or macos
  _MA[arch]="${__mokarch}" # x86_64 or arm64

  # Program the parser's state machine
  PA_add_state "COMMAND" "version" "END" "MA_version"

  # Set up the parser's option callbacks
  PA_add_option_callback "" "MA_process_global_options"

  # Set up the parser's usage callbacks
  PA_add_usage_callback "" "MA_usage"
}

# Initialise _MA
_MA_new "$@" || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
if [ "$0" = "${BASH_SOURCE[0]}" ] || [ -z "${BASH_SOURCE[0]}" ]; then
  MA_main "$@"
fi
