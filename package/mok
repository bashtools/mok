#!/usr/bin/env bash
# shellcheck shell=bash disable=SC2148
# PA - PArser

# _PA holds data specific to parsing the command line arguments.
declare -A _PA

# Declare externally defined variables ----------------------------------------

# Defined in ER (globals.sh)
declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# PA_command getter outputs the _PA[command] array member. This contains the
# command the user requested.
PA_command() {
  printf '%s' "${_PA[command]}"
}

# PA_subcommand getter outputs the _PA[subcommand] array member. This contains
# the subcommand the user requested.
PA_subcommand() {
  printf '%s' "${_PA[subcommand]}"
}

# PA_shift outputs the _PA[shift] array member, returned by the caller
# when an extra shift is required whilst consuming option values.
#
# Example code:
# ```
#XX_process_options_callback() {
#
#  case "$1" in
#  -h | --help)
#    CC_usage
#    return "${STOP}"
#    ;;
#    ... omitted ...
#  --k8sver)
#    _CC[k8sver]="$2"
#    return "$(PA_shift)"
#    ;;
#  --with-lb)
#    ... omitted ..
# ```
PA_shift() {
  printf '%s' "${_PA[shift]}"
}

# PA_set_state setter sets the initial state of the parser, which should be one
# of COMMAND, SUBCOMMAND, or ARG1.
# Args: arg1 - the initial state to set.
PA_set_state() {
  _PA[state]="$1"
}

# Public Functions ------------------------------------------------------------

# PA_add_option_callback adds a callback to the list of callbacks used for
# processing options.
# Args: arg1 - Null string (for global options), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_option_callback() {
  _PA[optscallbacks]+="$1,$2 "
}

# PA_add_usage_callback adds a callback to the list of callbacks used for
# output of help text.
# Args: arg1 - Null string (for global help), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_usage_callback() {
  _PA[usagecallbacks]+="$1,$2 "
}

# PA_add_state adds a callback to the list of callbacks used for
# programming the state machine.
# Args: arg1 - Current state to match.
#       arg2 - The value of the state to match.
#       arg3 - The new state if arg1 and arg2 match.
#       arg4 - The function to call, optional.
PA_add_state() {
  _PA[statecallbacks]+="$1,$2,$3,$4 "
}

# PA_add_run_callback adds a callback to the list of callbacks used for
# running the user defined entrypoint function.
# Args: arg1 - The value of the state to match. Probably like:
#              "commandsubcommand" "function"
#       arg2 - The function to call.
PA_add_run_callback() {
  _PA[runcallbacks]+="$1,$2 "
}

# PA_run implements an interleaved state machine to process the
# user request. It allows for strict checking of arguments and args. All
# command line arguments are processed in order from left to right.
#
# Each COMMAND can have a different set of requirements which are controlled
# by setting the next state at each transition.
#
# --global-options COMMAND --command-options SUBCOMMAND --subcommand-options \
#  ARG1 --subcommand-options ARG2 --subcommand-options ...
#
# --global-options are those before COMMAND.
# --command-options can be after the COMMAND but before SUBCOMMAND.
# --subcommand-options can be anywhere after the SUBCOMMAND.
#
# Args: arg1-N - The arguments given to mok by the user on the command line
PA_run() {

  local retval=${OK}

  set -- "$@"
  local ARGN=$# ARGNUM=0 retval=0
  while [ "${ARGN}" -ne 0 ]; do
    case "$1" in
    --* | -*)
      _PA_process_option "$1" "$2" || {
        retval=$?
        if [[ ${retval} == "${_PA[shift]}" ]]; then
          ARGN=$((ARGN - 1))
          shift
        else
          return "${retval}"
        fi
      }
      ;;
    *)
      case "${_PA[state]}" in
      COMMAND)
        _PA_check_token "${1}" "COMMAND" "command"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid COMMAND, "%s".\n\n' "$1" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      SUBCOMMAND)
        _PA_check_token "$1" "SUBCOMMAND" "subcommand"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid SUBCOMMAND for %s, "%s".\n\n' "${_PA[command]}" "${1}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      ARG*)
        ((ARGNUM++))
        _PA_check_token "${1}" "ARG${ARGNUM}"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid ARG1 for %s %s, "%s".\n\n' "${_PA[command]}" \
            "${_PA[subcommand]}" "${1}" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      END)
        PA_usage
        printf 'ERROR No more args expected, "%s" is unexpected for "%s %s"\n' \
          "${1}" "${_PA[command]}" "${_PA[subcommand]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      *)
        printf 'Internal ERROR. Invalid state "%s"\n' "${_PA[state]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      esac
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done

  # Run the user defined entrypoint function:
  for item in ${_PA[runcallbacks]}; do
    IFS=, read -r stateval func <<<"${item}"
    [[ ${stateval} == "${_PA[command]}${_PA[subcommand]}" ]] && {
      eval "${func}" || retval=$?
      return "${retval}"
    }
  done

  PA_usage

  return "${OK}"
}

# PA_usage outputs help text for a single component if help was asked for when
# a command was specified, or for all components otherwise.
# Args: None expected.
PA_usage() {

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[usagecallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func}"
      return
    }
  done

  eval "${_PA[usage]}"
}

# Private Functions -----------------------------------------------------------

# PA_new sets the initial values for the PArser's associative array.
# Args: None expected.
_PA_new() {
  _PA[command]=
  _PA[subcommand]=
  _PA[state]="COMMAND"
  _PA[optscallbacks]=
  _PA[usagecallbacks]=
  _PA[statecallbacks]=
  _PA[runcallbacks]=
  # The return value if the caller asked for an extra shift:
  _PA[shift]=126
}

# _PA_check_token checks for a valid token in arg2 state. The logic is
# most easily understood by reading the full original version at:
# https://github.com/mclarkson/my-own-kind/blob/master/docs/package.md#scripted-cluster-creation-and-deletion
# This function is a reduction of all the check_xxx_token functions.
# Args: arg1 - the token to check.
#       arg2 - the current state.
#       arg3 - the state value to set, optional. This should only be sent
#              for command and subcommand states.
_PA_check_token() {

  local item

  if [[ -n ${_PA[subcommand]} ]]; then
    cmdsubcommand="${_PA[command]}${_PA[subcommand]}"
  elif [[ -n ${_PA[command]} && ${_PA[state]} != "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}$1"
  elif [[ -n ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}"
  elif [[ -z ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand=
  else
    cmdsubcommand="$1"
  fi

  for item in ${_PA[statecallbacks]}; do
    IFS=, read -r state component newstate func <<<"${item}"
    [[ ${state} == "$2" ]] && {
      [[ ${component} == "${cmdsubcommand}" ]] && {
        [[ -n $3 ]] && _PA["$3"]="$1"
        _PA[state]="${newstate}"
        [[ -n ${func} ]] && {
          eval "${func} $1" || return
        }
        return "${OK}"
      }
    }
  done
}

# _PA_process_option checks that the user-provided option is valid for the
# command-subcommand or global states.
# Args: arg1 - The option to check.
#       arg2 - TODO The value of the option if present, optional.
_PA_process_option() {

  local item curcmdsubcmd

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[optscallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func} \"$1\" \"$2\""
      return $?
    }
  done

  return "${ERROR}"
}

# Initialise _PA
_PA_new

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GL - Globals

# Private Functions -----------------------------------------------------------

# GL_new sets the only global variables that should be in use anywhere.  The
# only other globals are the associative arrays. All the globals are constant
# (readonly) variables. Declare these globals, where needed, in other files
# so that shellcheck passes.
# Args: None expected.
_GL_new() {

  declare -rg MOKVERSION="0.8.22"
  declare -rg K8SVERSION="1.32.0"
  declare -rg GO_VERSION="1.23.2"

  # Returns, exit codes
  declare -rg OK=0
  declare -rg SUCCESS=0
  declare -rg ERROR=1
  declare -rg FAILURE=1

  # For setting flags
  declare -rg TRUE=1
  declare -rg FALSE=0

  # To signal main() to exit with SUCCESS in the PArser
  declare -rg STOP=2

  declare -rg STDOUT="/dev/stdout"
  declare -rg STDERR="/dev/stderr"

  # The following just keep shellcheck happy
  local dummy dumb
  dummy="${OK}"
  dummy="${ERROR}"
  dummy="${STOP}"
  dummy="${STDOUT}"
  dummy="${STDERR}"
  dummy="${TRUE}"
  dummy="${FALSE}"
  dummy="${SUCCESS}"
  dummy="${FAILURE}"
  dummy="${MOKVERSION}"
  dummy="${GO_VERSION}"
  dummy="${K8SVERSION}"
  dumb="${dummy}${dumb}"
}

# Initialise GL
_GL_new || exit 1

# vim helpers -----------------------------------------------------------------

# The following lines allow the use of '[C-i' and '[I' (do ':help [I') in vim.
#include buildimage.sh
#include containerutils.sh
#include createcluster.sh
#include deletecluster.sh
#include embed-dockerfile.sh
#include error.sh
#include exec.sh
#include getcluster.sh
#include main.sh
#include lib/parser.sh
#include util.sh
#include versions.sh

# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# ER - Error handling

# ER is an associative array that holds data specific to error handling.
declare -A ER

# Declare externally defined associative arrays -------------------------------

# Defined in GL (globals.sh)
declare ERROR TRUE STDERR

# Public Functions ------------------------------------------------------------

# ER_err outputs a stacktrace and returns ERROR status.
# Args: None expected.
ER_err() {

  # In case of error print the function call stack
  # No args expected

  [[ ${ER[errcalled]} == "${TRUE}" ]] && return "${ERROR}"
  ER[errcalled]="${TRUE}"
  local frame=0
  printf '\n' >"${STDERR}"
  while caller "${frame}"; do
    ((frame++))
  done | tac >"${STDERR}"
  printf '\n' >"${STDERR}"
  return "${ERROR}"
}

# err is a synonym for ER_err to aid with code readability.
err() {
  ER_err
  return
}

# Private Functions -----------------------------------------------------------

# ER_new sets the initial values for the ER associative array.
# Args: None expected.
_ER_new() {
  ER[errcalled]=
}

# Initialise ER
_ER_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# UT - Utilities

# _UT is an associative array that holds data specific to general utilities.
declare -A _UT

# Declare externally defined global variables ---------------------------------

declare OK STDERR FALSE TRUE

# Getters/Setters -------------------------------------------------------------

# UT_runlogfile getter outputs the value of _UT[runlogfile], which contains the
# name of the file written to when running UT_run_with_progress.
UT_runlogfile() {
  printf '%s' "${_UT[runlogfile]}"
}

# UT_tailf getter indicates whether a log will be shown in real-time during the
# 'run', TRUE, or not, FALSE.
# Args
UT_tailf() {
  printf '%s' "${_UT[tailf]}"
}

# UT_tailf setter indicates whether a log should be shown during the 'run',
# TRUE, or not, FALSE.
# Args: arg1 - Whether to tail, TRUE or FALSE.
UT_set_tailf() {
  _UT[tailf]="$1"
}

# UT_set_plain setter sets plain output, with no colour, animations, or UTF
# high byte characters.
# Args: arg1 - Whether to show plain output, TRUE or FALSE.
UT_set_plain() {
  _UT[plain]="$1"
  UT_disable_colours
}

# Public Functions ------------------------------------------------------------

# UT_disable_colours resets variables used for colourised output so that they
# contain no colour terminal escapes. Useful if stdin is not a terminal.
UT_disable_colours() {
  _UT[yellow]=
  _UT[green]=
  _UT[red]=
  _UT[normal]=
  _UT[probablysuccess]="PROBABLY SUCCESS (!)"
  _UT[success]="SUCCESS"
  _UT[failure]="FAIL"
}

# UT_run_with_progress displays a progress spinner, item text, and a tick or
# cross based on the exit code.
# Args: arg1   - the text to display.
#       arg2-N - remaining args are the program to run and its arguments.
UT_run_with_progress() {

  local displaytext=$1 retval int spinner=()

  _UT[runlogfile]=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }
  shift

  if [[ ${_UT[tailf]} == "${FALSE}" && ${_UT[plain]} == "${TRUE}" ]]; then

    # Output with no colours or spinny

    printf '%s' "${displaytext}"

    eval "$*" &>"${_UT[runlogfile]}"
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 0 ]]; then
      printf ' .. %s\n' "${_UT[success]}"
    else
      printf ' .. %s\n' "${_UT[failure]}"
    fi

  elif [[ ${_UT[tailf]} == "${FALSE}" ]]; then

    # Output with colours and spinny

    while read -r char; do
      spinner+=("${char}")
    done <<<"$(grep -o . <<<"${_UT[spinnerchars]}")"

    (
      eval "$*" &>"${_UT[runlogfile]}"
    ) &

    # Turn the cursor off
    tput civis

    # Start the spin animation
    printf ' %s' "${displaytext}"
    (while true; do
      for int in {0..3}; do
        printf '\r  %s ' "${spinner[int]}"
        sleep .1
      done
    done) &
    _UT[spinnerpid]=$!
    disown

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Kill the spinner
    kill "${_UT[spinnerpid]}" 2>/dev/null
    _UT[spinnerpid]=

    sleep .5

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\r  %s\n' "${_UT[probablysuccess]}"
    elif [[ ${retval} -eq 0 ]]; then
      printf '\r  %s\n' "${_UT[success]}"
    else
      printf '\r  %s\n' "${_UT[failure]}"
    fi

    # Restore the cursor
    tput cnorm
    sleep .5

  else

    # Tailf output

    printf 'COMMAND: %s\n\n' "$*"

    (
      eval "$*" &>/dev/stdout
    ) &
    sleep 1

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\n\nSTATUS: OK - (Probably)\n\n'
    elif [[ ${retval} -eq 0 ]]; then
      printf '\n\nSTATUS: OK\n\n'
    else
      printf '\n\nSTATUS: FAIL\n\n'
    fi
  fi

  return "${retval}"
}

# UT_cleanup removes any artifacts that were created during execution.
# This is called by 'MA_cleanup' trap only.
UT_cleanup() {

  # Called when the script exits.

  local int

  # Kill the spinny, and anything else, if they're running
  if [[ ${_UT[tailf]} == "${FALSE}" ]]; then
    [[ -n ${_UT[spinnerpid]} ]] && {
      printf '%s\r  ✕%s\n' "${_UT[red]}" "${_UT[normal]}"
      kill "${_UT[spinnerpid]}"
    }
    # If progress spinner crashed make sure the cursor is shown
    [ -t 1 ] && tput cnorm
  else
    kill "${_UT[spinnerpid]}" &>/dev/null
  fi

  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _UT_new sets the initial values for the _UT associative array.
# Args: None expected.
_UT_new() {
  _UT[tailf]="${FALSE}"
  _UT[yellow]=$(tput setaf 3)
  _UT[green]=$(tput setaf 2)
  _UT[red]=$(tput setaf 1)
  _UT[normal]=$(tput sgr0)
  _UT[probablysuccess]="${_UT[yellow]}✓${_UT[normal]}"
  _UT[success]="${_UT[green]}✓${_UT[normal]}"
  _UT[failure]="${_UT[red]}✕${_UT[normal]}"
  _UT[runlogfile]=
  _UT[spinnerchars]="|/-\\"
  _UT[spinnerpid]=
}

# Initialise _UT
_UT_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GC - Get Cluster

# _GC is an associative array that holds data specific to the get cluster command.
declare -A _GC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# GC_showheader getter outputs the value of the showheader array member.
GC_showheader() {
  printf '%s' "${_GC[showheader]}"
}

# GC_set_showheader setter sets the value of the showheader array member.
# If $TRUE the header will be shown, or $FALSE, then it won't be shown.
GC_set_showheader() {
  _GC[showheader]="$1"
}

# GC_set_clustername setter sets the cluster name to show information about.
GC_set_clustername() {
  _GC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# GC_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted. It is called by
# MA_cleanup.
GC_cleanup() {
  :
}

# GC_process_options checks if arg1 is in a list of valid get cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
GC_process_options() {

  case "$1" in
  -h | --help)
    GC_usage
    return "${STOP}"
    ;;
  *)
    GC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# GC_usage outputs help text for the create cluster component.
# It is called by PA_usage().
# Args: None expected.
GC_usage() {

  cat <<'EnD'
GET subcommands are:
 
  cluster[s] - list all mok managed clusters.
 
get cluster[s] options:
 
 Format:
  get cluster(s) [NAME]
  NAME        - (optional) The name of the cluster to get
                details about.

EnD
}

# GC_run gets information about cluster(s).
# This function is called in main.sh.
# Args: None expected.
GC_run() {

  _GC_sanity_checks || return

  local ids id info output labelkey
  local containerhostname containerip

  declare -a nodes

  ids=$(CU_get_cluster_container_ids "${_GC[clustername]}") || return

  if [[ -z ${ids} ]]; then
    printf 'No clusters found\n'
    return "${OK}"
  fi

  readarray -t nodes <<<"${ids}"

  # Use 'docker inspect' to get the value of the label $LABELKEY

  output=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  # Output the header
  [[ ${_GC[showheader]} -eq ${TRUE} ]] && {
    printf 'MOK_Cluster Docker_ID Container_Name IP_Address\n' >"${output}"
  }

  labelkey=$(CU_labelkey) || err || return

  for id in "${nodes[@]}"; do

    info=$(CU_get_container_info "${id}") || return

    clustname=$(JSONPath ".[0].Config.Labels.${labelkey}" -b <<<"${info}") ||
      err || return

    containerhostname=$(JSONPath '.[0].Config.Hostname' -b <<<"${info}") ||
      err || return

    containerip=$(JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}") ||
      err || return

    printf '%s %s %s %s\n' "${clustname}" "${id}" "${containerhostname}" "${containerip}"

  done | sort -k 3 >>"${output}"

  column -t "${output}" || err
}

# Private Functions -----------------------------------------------------------

# _GC_new sets the initial values for the _GC associative array.
# Args: None expected.
_GC_new() {
  _GC[showheader]="${TRUE}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "get" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "getcluster" "ARG1" ""
  PA_add_state "SUBCOMMAND" "getclusters" "ARG1" ""
  PA_add_state "ARG1" "getcluster" "END" "GC_set_clustername"
  PA_add_state "ARG1" "getclusters" "END" "GC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "get" "GC_process_options" || return
  PA_add_option_callback "getcluster" "GC_process_options" || return
  PA_add_option_callback "getclusters" "GC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "get" "GC_usage" || return
  PA_add_usage_callback "getcluster" "GC_usage" || return
  PA_add_usage_callback "getclusters" "GC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "getcluster" "GC_run"
  PA_add_run_callback "getclusters" "GC_run"
}

# GC_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_GC_sanity_checks() {

  # Only show the usage if we are in 'get' mode and have not specified a
  # subcommand. This allows internal code to call GC_run()
  if [[ $(PA_command) == "get" && -z $(PA_subcommand) ]]; then
    GC_usage
    exit "${OK}"
  fi
}

# Initialise _GC
_GC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# EX - EXec

# EX is an associative array that holds data specific to the exec cluster command.
declare -A _EX

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# EX_set_containername setter sets the containername to be used to 'log in' to.
EX_set_containername() {
  _EX[containername]="$1"
}

# Public Functions ------------------------------------------------------------

# EX_process_options checks if arg1 is in a list of valid exec options. This
# function is called by the parser, via a callback in _EX_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
EX_process_options() {

  case "$1" in
  -h | --help)
    EX_usage
    return "${STOP}"
    ;;
  *)
    EX_usage
    printf 'ERROR: "%s" is not a valid "exec" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# EX_usage outputs help text for the create exec component.  It is called in
# this file and by PA_usage(), via a callback in _EX_new.
# Args: None expected.
EX_usage() {

  cat <<'EnD'
'Log in' to a container. EXEC has no subcommands.
 
exec options:
 
 Format:
  exec [NAME]
  NAME        - (optional) The name of the container to 'log in' to.
                If NAME is not given then the user will be offered
                a choice of containers to log in to. If there is only
                one cluster and one node then it will 'log in' to the
                only available container.

EnD
}

# Execs 'bash' in the container referenced by _EX[containername]. If just
# 'mok exec' is called without options then the user is offered a selection
# of existing clusters to exec into.
# Args: None expected.
# ---------------------------------------------------------------------------
EX_run() {

  _EX_sanity_checks || return

  local names int ans lines containernames gcoutput

  GC_set_showheader "${TRUE}" || err || return
  gcoutput=$(GC_run) || return
  names=$(printf '%s' "${gcoutput}" | awk '{ print $3; }')
  readarray -t containernames <<<"${names}"

  if [[ -n ${_EX[containername]} ]]; then

    # The caller gave a specific name for exec.
    # Check if the container name exists

    if grep -qs "^${_EX[containername]}$" <<<"${names}"; then
      _EX_exec "${_EX[containername]}" || return
      return "${OK}"
    else
      printf 'ERROR: Cannot exec into non-existent container: "%s".\n' \
        "${_EX[containername]}"
      return "${ERROR}"
    fi

  elif [[ ${#containernames[*]} == 2 ]]; then

    # If there's only one container just log into it without asking
    _EX_exec "${containernames[1]}"

  elif [[ ${#containernames[*]} == 1 ]]; then

    printf 'No containers found.\n'
    return "${OK}"

  else

    # The caller supplied no container name.
    # Present some choices

    printf 'Choose the container to log in to:\n\n'

    readarray -t lines <<<"${gcoutput}" || return

    # Print the header then print the items in the loop
    printf '   %s\n' "${lines[0]}"
    for int in $(seq 1 $((${#lines[*]} - 1))); do
      printf '%00d) %s\n' "${int}" "${lines[int]}"
    done | sort -k 4

    printf "\nChoose a number (Enter to cancel)> "
    read -r ans

    [[ -z ${ans} || ${ans} -lt 0 || ${ans} -gt $((${#lines[*]} - 1)) ]] && {
      printf '\nInvalid choice. Aborting.\n'
      return "${OK}"
    }

    _EX_exec "${containernames[ans]}"
  fi
}

# Private Functions -----------------------------------------------------------

# _EX_new sets the initial values for the _EX associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
_EX_new() {
  _EX[containername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "exec" "ARG1" ""
  PA_add_state "ARG1" "exec" "END" "EX_set_containername"

  # Set up the parser's option callbacks
  PA_add_option_callback "exec" "EX_process_options" || return
  PA_add_usage_callback "exec" "EX_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "exec" "EX_run"
}

# EX_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For exec this does nothing.
# Args: None expected.
_EX_sanity_checks() { :; }

# _EX_exec runs a command in a docker container using bash as the command by
# default.
# Args: arg1 - docker container name
#       arg2 - command to run
_EX_exec() {

  local cmd=${2:-bash}

  containerrt=$(CU_containerrt) || err || return

  read -rt 0.1
  if [[ ${containerrt} == "podman" ]]; then
    exec podman exec -ti "$1" "${cmd}"
  elif [[ ${containerrt} == "docker" ]]; then
    exec docker exec -ti "$1" "${cmd}"
  fi
}

# Initialise EX
_EX_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# DC - Delete Cluster

# _DC is an associative array that holds data specific to deleting a cluster.
declare -A _DC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR STOP TRUE

# Getters/Setters -------------------------------------------------------------

# DC_set_clustername setter sets the cluster name to be deleted. This is
# called by the parser, via a callback in _DC_new.
DC_set_clustername() {
  _DC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# DC_process_options checks if arg1 is in a list of valid delete cluster
# options. This function is called by the parser, via a callback in _DC_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
DC_process_options() {

  case "$1" in
  -h | --help)
    DC_usage
    return "${STOP}"
    ;;
  *)
    DC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# DC_usage outputs help text for the create cluster component.
# It is called by PA_usage(), via a callback in _DC_new.
# Args: None expected.
DC_usage() {

  cat <<'EnD'
DELETE subcommands are:
 
  cluster - Delete a local kubernetes cluster.
 
delete cluster options:
 
 Format:
  delete cluster NAME
  NAME        - The name of the cluster to delete

EnD
}

# DC_run starts the delete cluster process.
# Args: None expected.
DC_run() {

  _DC_sanity_checks || return

  # Mutate functions make system changes.

  declare -i numnodes=0
  local id ids r

  numnodes=$(CU_get_cluster_size "${_DC[clustername]}") || return

  [[ ${numnodes} -eq 0 ]] && {
    printf '\nERROR: No cluster exists with name, "%s". Aborting.\n\n' \
      "${_DC[clustername]}" >"${STDERR}"
    return "${ERROR}"
  }

  ids=$(CU_get_cluster_container_ids "${_DC[clustername]}") || return

  printf 'The following containers will be deleted:\n\n'

  GC_set_showheader "${TRUE}"
  GC_set_clustername "${_DC[clustername]}"
  GC_run "${_DC[clustername]}" || return

  printf "\nAre you sure you want to delete the cluster? (y/N) >"

  read -r ans

  [[ ${ans} != "y" ]] && {
    printf '\nCancelling by user request.\n'
    return "${OK}"
  }

  printf '\n'

  for id in ${ids}; do
    UT_run_with_progress \
      "    Deleting id, '${id}' from cluster '${_DC[clustername]}'." \
      _DC_delete "${id}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n\n' >"${STDERR}"
      err
      return "${r}"
    }
  done

  printf '\n'
}

# Private Functions -----------------------------------------------------------

# _DC_new sets the initial values for the _DC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_DC_new() {
  _DC[clustername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "delete" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "deletecluster" "ARG1" ""
  PA_add_state "ARG1" "deletecluster" "END" "DC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "delete" "DC_process_options" || return
  PA_add_option_callback "deletecluster" "DC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "delete" "DC_usage" || return
  PA_add_usage_callback "deletecluster" "DC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "deletecluster" "DC_run"
}

# DC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before DC_run is called.
# Args: None expected.
_DC_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    DC_usage
    exit "${OK}"
  fi

  if [[ -z ${_DC[clustername]} ]]; then
    DC_usage
    printf 'Please provide the Cluster NAME to delete.\n' >"${STDERR}"
    return "${ERROR}"
  fi
}

# _DC_delete stops and removes a docker container.
# Args: arg1 - docker id to delete.
_DC_delete() {

  docker stop -t 5 "${id}"
  docker rm "${id}" || err
}

# Initialise _DC
_DC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE K8SVERSION

# Getters/Setters -------------------------------------------------------------

# CC_set_clustername setter sets the clustername array item.
CC_clustername() {
  printf '%s' "${_CC[clustername]}"
}

# CC_publish getter outputs the publish array item.
CC_publish() {
  printf '%s' "${_CC[publish]}"
}

# CC-withlb getter outputs the withlb array item.
CC_withlb() {
  printf '%s' "${_CC[withlb]}"
}

# CC_set_clustername setter sets the clustername array item.
CC_set_clustername() {
  _CC[clustername]="$1"
}

# CC_set_nummasters setter sets the nummasters array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_nummasters() {
  _CC[nummasters]="$1"
}

# CC_set_numworkers setter sets the numworkers array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_numworkers() {
  _CC[numworkers]="$1"
}

# Public Functions ------------------------------------------------------------

# CC_process_options checks if arg1 is in a list of valid create cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option. For example, '--masters' should be sent
#              with a value but boolean options, like 'skiplbsetup' should not.
CC_process_options() {

  case "$1" in
  -h | --help)
    CC_usage
    return "${STOP}"
    ;;
  --skiplbsetup)
    _CC[skiplbsetup]="${TRUE}"
    return
    ;;
  --k8sver)
    _CC[k8sver]="$2"
    return "$(PA_shift)"
    ;;
  --with-lb)
    _CC[withlb]="${TRUE}"
    return
    ;;
  --skipmastersetup)
    _CC[skipmastersetup]="${TRUE}"
    return
    ;;
  --skipworkersetup)
    _CC[skipworkersetup]="${TRUE}"
    return
    ;;
  --masters)
    _CC[nummasters]="$2"
    return "$(PA_shift)"
    ;;
  --workers)
    _CC[numworkers]="$2"
    return "$(PA_shift)"
    ;;
  --tailf)
    _CC[tailf]="${TRUE}"
    return "${OK}"
    ;;
  --publish)
    _CC[publish]="${TRUE}"
    return
    ;;
  *)
    CC_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# CC_usage outputs help text for the create cluster component.  It is called in
# this file and by PA_usage(), via a callback set in _CC_new.
# Args: None expected.
CC_usage() {

  cat <<'EnD'
CREATE subcommands are:
 
  cluster - Create a local kubernetes cluster.
 
create cluster [flags] options:
 
 Format:
  create cluster NAME [ [NUM_MASTERS] [NUM_WORKERS] ]
  NAME        - The name of the cluster. This will be used as
                the prefix in the name for newly created
                docker containers.
  NUM_MASTERS - The number of master containers.
  NUM_WORKERS - The number of worker containers. If NUM_WORKERS is
                zero then the 'node-role.kubernetes.io/master' taint
                will be removed from master nodes so that pods are
                schedulable.
 
 Flags:
  --skipmastersetup - Create the master container but don't set it
         up. Useful for manually installing kubernetes. Kubeadm, 
         kubelet and kubectl will be installed at the requested 
         version. With this option the worker will also be skipped.
         See also '--k8sver' flag.
  --skipworkersetup - The same as '--skipmastersetup', but skips
         setting up the worker only.
  --with-lb - Add a haproxy load balancer. The software will be installed
         and set up to reverse proxy to the master node(s), unless
         --skiplbsetup is used.
  --k8sver VERSION - Unimplemented.
  --masters NUM - The number of master containers to create.
  --workers NUM - The number of worker containers to create. When workers
                  is zero then the master node taint will be removed from
                  master nodes so that pods are schedulable on those nodes.
  --tailf - Show the log output whilst creating the cluster.
  --publish - Publish port 6443 for the master node, or the load balancer if
              it's enabled, for external kubectl access to the cluster. The IP
              address of the default route interface is added to the cert.


EnD
}

# CC_run creates the kubernetes cluster.
# Args: None expected.
CC_run() {

  _CC_sanity_checks || return

  [[ ${_CC[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  declare -i numnodes=0

  numnodes=$(CU_get_cluster_size "${_CC[clustername]}") || return

  [[ ${numnodes} -gt 0 ]] && {
    printf '\nERROR: Cluster, "%s", exists! Aborting.\n\n' "${_CC[clustername]}" \
      >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_create_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_create_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_setup_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_setup_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[numworkers]} -gt 0 ]] && {
    _CC_create_worker_nodes "${_CC[numworkers]}" || return
  }

  printf '\n'

  [[ -z ${_CC[skipmastersetup]} ]] && {
    printf 'Cluster, "%s", can be accessed using:\n\n' "${_CC[clustername]}"
    printf 'export KUBECONFIG=/var/tmp/admin-%s.conf\n\n' "${_CC[clustername]}"
  }

  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CC_new sets the initial values for the _CC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_CC_new() {
  _CC[tailf]="${FALSE}"
  _CC[skipmastersetup]=
  _CC[skipworkersetup]=
  _CC[skiplbsetup]=
  _CC[withlb]=
  _CC[clustername]=
  _CC[nummasters]=0
  _CC[numworkers]=0
  _CC[publish]=0
  _CC[k8sver]="${K8SVERSION}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "create" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "createcluster" "ARG2" ""

  # Support for the legacy style of create (less to type):
  PA_add_state "ARG1" "createcluster" "ARG2" "CC_set_clustername"
  PA_add_state "ARG2" "createcluster" "ARG3" "CC_set_nummasters"
  PA_add_state "ARG3" "createcluster" "END" "CC_set_numworkers"

  # Set up the parser's option callbacks
  PA_add_option_callback "create" "CC_process_options" || return
  PA_add_option_callback "createcluster" "CC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "create" "CC_usage" || return
  PA_add_usage_callback "createcluster" "CC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "createcluster" "CC_run"
  PA_add_run_callback "createclusters" "CC_run"
}

# CC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before CC_run is called.
# Args: None expected.
_CC_sanity_checks() {

  declare -i host_max=0 cpus=0 should_be=0

  if [[ -z $(PA_subcommand) ]]; then
    CC_usage
    exit "${OK}"
  fi

  if [[ -z ${_CC[clustername]} ]]; then
    CC_usage
    printf 'Please provide the Cluster NAME to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[nummasters]} || ${_CC[nummasters]} -le 0 ]]; then
    CC_usage
    printf 'Please provide the number of Masters to create. Must be 1 or more.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[numworkers]} ]]; then
    CC_usage
    printf 'Please provide the number of Workers to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/sys/net/nf_conntrack_max ]]; then
    host_max=$(cat /proc/sys/net/nf_conntrack_max)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    host_max=$(podman machine ssh cat /proc/sys/net/nf_conntrack_max)
  else
    printf '\nWARNING: /proc/sys/net/nf_conntrack_max not found.\n' >"${STDERR}"
    printf '         kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/cpuinfo ]]; then
    cpus=$(grep -cw ^processor /proc/cpuinfo)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    cpus=$(podman machine ssh cat /proc/cpuinfo | grep -cw ^processor)
  else
    printf '\nWARNING: /proc/cpuinfo not found.\n' >"${STDERR}"
    printf '         I have no idea how many CPUs I have\n' >"${STDERR}"
    printf '         and kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  # These are the default values that kube-proxy expects:
  # conntrack:
  #   max: null
  #   maxPerCore: 32768
  #   min: 131072
  if [[ $((32768*cpus)) -lt 131072 ]]; then
    should_be=131072
  else
    should_be=$((32768*cpus))
  fi
  if [[ ${should_be} -ne $host_max ]]; then
    printf '\nERROR: /proc/sys/net/nf_conntrack_max should be set to %d.\n' \
      "${should_be}" >"${STDERR}"
    printf '     kube-proxy will not start with an incorrect nf_conntrack_max.\n' >"${STDERR}"
    printf '     To fix this, run the following command:\n\n' >"${STDERR}"
    if [[ $(CU_podmantype) == "native" ]]; then
      printf '       sudo sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
    elif [[ $(CU_podmantype) == "machine" ]]; then
      printf '       podman machine ssh sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
      printf '     If the above command fails, you may have to recreate the podman machine, for example:\n\n' >"${STDERR}"
      tput setaf 1 # red
      printf '     WARNING: The following commands will destroy your podman machine and all its data.\n' >"${STDERR}"
      printf '              All existing pods and containers will be gone.\n\n' >"${STDERR}"
      tput sgr0 # reset
      printf '       podman machine stop\n' >"${STDERR}"
      printf '       podman machine rm\n' >"${STDERR}"
      printf '       podman machine init --now --rootful --user-mode-networing\n' >"${STDERR}"
      printf '       podman machine ssh modprobe nf_conntrack\n' >"${STDERR}"
      printf '       podman machine ssh sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
    else
      printf 'Internal ERROR. Invalid podman type.\n' >"${STDERR}"
      return "${ERROR}"
    fi
    
    printf 'Press ENTER to continue or CTRL-C to abort.\n' >"${STDERR}"
    read -r
    printf '\n' >"${STDERR}"
  fi
}

# _CC_create_master_nodes creates the master node containers.
# Args: arg1 - number of master nodes to create
_CC_create_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating master container, '${_CC[clustername]}-master-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-master-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }
  done

  return "${OK}"
}

# _CC_setup_master_nodes sets up the master node containers.
# Args: arg1 - number of master nodes to create
_CC_setup_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile lbaddr hostaddr
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-master-${int}'" \
      _CC_set_up_master_node "${_CC[clustername]}-master-${int}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  done

  # For now, copy admin.conf from master to /var/tmp/admin-CLUSTERNAME.conf

  if [[ -z ${_CC[skipmastersetup]} ]]; then
    if [[ ${_CC[publish]} -eq ${TRUE} ]]; then
      # On MacOS we need to use localhost, on linux use the host IP
      if [[ $(CU_podmantype) == "native" ]]; then
        hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
      else
        hostaddr="localhost"
      fi
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${hostaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    elif [[ ${_CC[withlb]} -eq ${TRUE} ]]; then
      lbaddr=$(CU_get_container_ip "${_CC[clustername]}-lb") || err || return
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${lbaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    else
      [[ -n ${_CC[skipmastersetup]} ]] || {
        docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
          "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      }
    fi

    chmod 666 "/var/tmp/admin-${_CC[clustername]}.conf" || {
      printf 'ERROR: Could not "chown 666 /var/tmp/admin-%s.conf"' "${_CC[clustername]}"
      err || return
    }
  fi

  return "${OK}"
}

# _CC_set_up_master_node calls the correct set up function based on the version
# Args: arg1 - the container ID to set up
_CC_set_up_master_node() {

  case "${_CC[k8sver]}" in
  "1.31."* | "1.32."*)
    _CC_set_up_master_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# _CC_get_master_join_details uses 'docker exec' or 'podman exec' to run a
# script on the master to get CA hash, a token, and the master IP.  The caller
# can eval the output of this function to set the variables: cahash, token, and
# masterip. See also:
# https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/#token-based-discovery-with-ca-pinning
# Args: arg1 - id/name of master container
_CC_get_master_join_details() {

  local joinvarsfile master1ip

  joinvarsfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  master1ip=$(CU_get_container_ip "${_CC[clustername]}-master-1") || err || return

  cat <<EnD >"${joinvarsfile}"
#!/bin/bash
set -e

sed 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${master1ip}"'\2#' \
  /etc/kubernetes/super-admin.conf >/etc/kubernetes/admin2.conf

cahash=\$(openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | \
        openssl rsa -pubin -outform der 2>/dev/null | \
        openssl dgst -sha256 -hex | sed 's/^.* //')
token=\$(kubeadm token create --kubeconfig=/etc/kubernetes/admin2.conf 2>/dev/null)
ip=\$(ip ro get 8.8.8.8 | cut -d" " -f 7)

printf 'cahash=%s\ntoken=%s\nmasterip=%s' "\$cahash" "\$token" "\$ip"

exit 0
EnD

  docker cp "${joinvarsfile}" "$1":/root/joinvars.sh 2>"${STDERR}" ||
    err || return
  rm -f "${joinvarsfile}" 2>"${STDERR}" || err || return

  [[ -z ${_CC[skipworkersetup]} ]] && {
    docker exec "$1" bash /root/joinvars.sh 2>"${STDERR}" || err || return
  }

  return "${OK}"
}

# _CC_create_lb_node creates the load balancer node container.
# Args: None expected.
_CC_create_lb_node() {

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  # Create container
  UT_run_with_progress \
    "    Creating load balancer container, '${_CC[clustername]}-lb'" \
    CU_create_container \
    "${_CC[clustername]}-lb" \
    "${labelkey}=${_CC[clustername]}" \
    "${_CC[k8sver]}"

  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    printf '\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
    printf '%s\n' "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  return "${OK}"
}

# _CC_setup_lb_node sets up the load balancer node container.
# Args: None expected.
_CC_setup_lb_node() {

  local runlogfile

  # Set up
  [[ -z ${_CC[skiplbsetup]} ]] && {
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-lb'" \
      _CC_set_up_lb_node_real "${_CC[clustername]}-lb"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _CC_set_up_lb_node_real sets up the lb node.
# Args: arg1 - the container ID to set up
_CC_set_up_lb_node_real() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masteriplist=
  nl=
  gotamaster="${FALSE}"
  for idx in $(seq 1 "${_CC[nummasters]}"); do
    ip=$(CU_get_container_ip "${_CC[clustername]}-master-${idx}") || continue
    gotamaster="${TRUE}"
    masteriplist="${masteriplist}${nl}    server master-${idx} ${ip}:6443 check fall 3 rise 2"
    nl='\n'
  done

  [[ ${gotamaster} == "${FALSE}" ]] && {
    printf 'ERROR: Did not manage to get an IP address for any master nodes\n'
    err || return
  }

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

systemctl stop kubelet crio
systemctl disable kubelet crio

apt -y install haproxy

INTERNAL_IP=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")

cat <<EOF | tee /etc/haproxy/haproxy.cfg 
frontend kubernetes
    bind \$INTERNAL_IP:6443
    option tcplog
    mode tcp
    default_backend kubernetes-master-nodes
backend kubernetes-master-nodes
    mode tcp
    balance roundrobin
    option tcp-check
\$(echo -e "${masteriplist}")
EOF

systemctl restart haproxy
systemctl enable haproxy

EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# _CC_create_worker_nodes creates the worker nodes.
# Args: arg1 - number of worker nodes to create
_CC_create_worker_nodes() {

  local cahash token t masterip
  declare -i int=0

  [[ -n ${_CC[skipmastersetup]} ]] || {
    # Runs a script on master node to get details
    t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1") || {
      printf '\nERROR: Problem with "_CC_get_master_join_details".\n\n' >"${STDERR}"
      return "${ERROR}"
    }

    # Sets cahash, token, and masterip:
    eval "${t}"
  }

  local labelkey
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating worker container, '${_CC[clustername]}-worker-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-worker-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }

    [[ -n ${_CC[skipworkersetup]} || -n ${_CC[skipmastersetup]} ]] || {
      UT_run_with_progress \
        "    Setting up '${_CC[clustername]}-worker-${int}'" \
        _CC_set_up_worker_node "${_CC[clustername]}-worker-${int}" \
        "${cahash}" "${token}" "${masterip}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n' >"${STDERR}"
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
        printf '%s\n' "${runlogfile}" >"${STDERR}"
        return "${ERROR}"
      }

      UT_run_with_progress \
        "    Waiting for system to become ready" \
        _CC_wait_for_cluster \
        "${_CC[clustername]}-master-1" \
        "${_CC[clustername]}-worker-${int}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n'
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Wait timed out.\n' >"${STDERR}"
        return "${ERROR}"
      }
    }
  done

  return "${OK}"
}

# _CC_wait_for_cluster runs a `kubectl` command in the master-1 container,
# which doesn't exit until the all pods are fully up and running before it
# returns.
# Args: arg1 - the master container name to log into
#       arg2 - the worker container name to wait for
_CC_wait_for_cluster() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  cat <<'EnD' >"${setupfile}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
found=0
for i in $(seq 1 20); do
  if kubectl get pods &>/dev/null; then
    found=1
    break
  fi
  sleep 1
done
[[ $found == 0 ]] && {
  printf '# kubectl get pods\n'
  kubectl get pods
  printf '\nWaited for 20 seconds for kubectl to work.\n'
  printf 'Kubectl cannot contact master. Aborting.\n'
  exit 1
}
counter=0
while ! kubectl get nodes | grep -qs "$1"; do
  ((counter++))
  [[ ${counter} -gt 60 ]] && {
    printf '# kubectl get nodes\n'
    kubectl get nodes
    printf '\nWaited for 2 minutes for node to appear in master. Aborting.\n'
    exit 1
  }
  sleep 2
done
counter=0
while kubectl get pods -A | tail -n +2 | awk '{ print $3; }' | grep -qs 0; do
  ((counter++))
  [[ ${counter} -gt 120 ]] && {
    printf '# kubectl get pods -A\n'
    kubectl get pods -A
    printf '\nWaited for 3 minutes for pods to be ready. Aborting.\n'
    exit 1
  }
  sleep 2
done
exit 0
EnD

  docker cp "${setupfile}" "$1":/root/wait.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/wait.sh "$2" || err
}

# _CC_set_up_worker_node calls the correct set up function based on the version.
# Args: arg1 - the container ID to set up
#       arg2 - the CA hash
#       arg3 - the token
#       arg4 - the master IP
_CC_set_up_worker_node() {

  case "${_CC[k8sver]}" in
  "1.31."* | "1.32."*)
    _CC_set_up_worker_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# Initialise _CC
_CC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster - versions file

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR TRUE

# _CC_set_up_master_node_v1_30_0 uses kubeadm to set up the master node.
# Args: arg1 - the container to set up.
_CC_set_up_master_node_v1_30_0() {

  local setupfile lbaddr certSANs="{}" certkey masternum t lbip
  # Set by _CC_get_master_join_details:
  local cahash token masterip

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masternum="${1##*-}" # <- eg. for xxx-master-1, masternum=1

  if [[ ${_CC[skipmastersetup]} != "${TRUE}" ]]; then

    if [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -eq 1 ]]; then

      # This is the first master node

      # Sets cahash, token, and masterip:
      lbip=$(CU_get_container_ip "${_CC[clustername]}-lb")
      lbaddr=", '${lbip}'"
      uploadcerts="--upload-certs"
      certkey="CertificateKey: f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07"

    elif [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -ne 1 ]]; then

      # This is not the first master node, so join with the master
      # https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/

      # Keep trying to get join details until apiserver is ready or we run out of tries
      for try in $(seq 1 9); do
        # Runs a script on master node to get join details
        t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1")
        retval=$?
        [[ ${retval} -eq 0 ]] && break
        [[ ${try} -eq 9 ]] && {
          printf '\nERROR: Problem with "_CC_get_master_join_details". Tried %d times\n\n' "${try}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        sleep 5
      done
      eval "${t}"
    fi
  fi

  # Always set certSANs for the host whether we need it or not
  hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
  certSANs="
  certSANs: [ '${hostaddr}'${lbaddr}, '127.0.0.1', 'localhost' ]"

  # Write the file regardless, so the user can use it if required

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

# Use a custom configuration. Default config created from kubeadm with:
#   kubeadm config print init-defaults
# then edited.

ipaddr=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")
podsubnet="10.244.0.0/16"
servicesubnet="10.96.0.0/16"

cat <<EOF >kubeadm-init-defaults.yaml
apiVersion: kubeadm.k8s.io/v1beta4
bootstrapTokens:
- groups:
  - system:bootstrappers:kubeadm:default-node-token
  token: abcdef.0123456789abcdef
  ttl: 24h0m0s
  usages:
  - signing
  - authentication
kind: InitConfiguration
${certkey}
localAPIEndpoint:
  advertiseAddress: \$ipaddr
  bindPort: 6443
nodeRegistration:
  criSocket: unix:///var/run/crio/crio.sock
  imagePullPolicy: IfNotPresent
  imagePullSerial: true
  name: $1
  taints:
  - effect: NoSchedule
    key: node-role.kubernetes.io/control-plane
timeouts:
  controlPlaneComponentHealthCheck: 4m0s
  discovery: 5m0s
  etcdAPICall: 2m0s
  kubeletHealthCheck: 4m0s
  kubernetesAPICall: 1m0s
  tlsBootstrap: 5m0s
  upgradeManifests: 5m0s
---
apiServer: ${certSANs}
apiVersion: kubeadm.k8s.io/v1beta4
caCertificateValidityPeriod: 87600h0m0s
certificateValidityPeriod: 8760h0m0s
certificatesDir: /etc/kubernetes/pki
clusterName: ${_CC[clustername]}-cluster
controlPlaneEndpoint: ${lbaddr:-\$ipaddr}:6443
controllerManager: {}
dns: {}
encryptionAlgorithm: RSA-2048
etcd:
  local:
    dataDir: /var/lib/etcd
imageRepository: registry.k8s.io
kind: ClusterConfiguration
networking:
  dnsDomain: cluster.local
  podSubnet: \${podsubnet}
  serviceSubnet: \${servicesubnet}
proxy: {}
scheduler: {}
EOF

mkdir -p /mok
cp kubeadm-init-defaults.yaml /mok/kubeadm.yaml

if [[ -z "${masterip}" ]]; then
  # Run the preflight phase
  kubeadm init \\
    --ignore-preflight-errors Swap \\
    --config=kubeadm-init-defaults.yaml \\
    phase preflight

  # Set up the kubelet
  kubeadm init phase kubelet-start

  # Edit the kubelet configuration file
  echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
  sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

  # Tell kubeadm to carry on from here
  kubeadm init \\
    --config=kubeadm-init-defaults.yaml \\
    --ignore-preflight-errors Swap \\
    ${uploadcerts} \\
    --skip-phases=preflight,kubelet-start

  export KUBECONFIG=/etc/kubernetes/super-admin.conf

  # Flannel - 10.244.0.0./16
  kubectl apply -f /root/kube-flannel.yml
else
  kubeadm join ${masterip}:6443 \\
    --ignore-preflight-errors Swap \\
    --control-plane \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --certificate-key f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07
fi

systemctl enable kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  # Run the file
  [[ -z ${_CC[skipmastersetup]} ]] && {
    docker exec "$1" bash /root/setup.sh || err || return

    # Remove the taint if we're setting up a single node cluster

    [[ ${_CC[numworkers]} -eq 0 ]] && {

      removetaint=$(mktemp -p /var/tmp) || {
        printf 'ERROR: mktmp failed.\n' >"${STDERR}"
        return "${ERROR}"
      }

      # Write the file
      cat <<'EnD' >"${removetaint}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
kubectl taint nodes --all node-role.kubernetes.io/control-plane:NoSchedule-
EnD

      docker cp "${removetaint}" "$1":/root/removetaint.sh || err || {
        rm -f "${removetaint}"
        return "${ERROR}"
      }

      # Run the file
      docker exec "$1" bash /root/removetaint.sh || err
    }
  }

  return "${OK}"
}

# _CC_set_up_worker_node_v1_30_0 uses kubeadm to set up the worker node.
# Args: arg1 - the container to set up.
_CC_set_up_worker_node_v1_30_0() {

  local setupfile cahash="$2" token="$3" masterip="$4"

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  if [[ ${_CC[withlb]} == "${TRUE}" ]]; then
    masterip=$(CU_get_container_ip "${_CC[clustername]}-lb") || return
  fi

  cat <<EnD >"${setupfile}"
# Wait for the master API to become ready
while true; do
  curl -k https://${masterip}:6443/
  [[ \$? -eq 0 ]] && break
  sleep 1
done

# Do the preflight tests (ignoring swap error)
kubeadm join \\
  phase preflight \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --ignore-preflight-errors Swap \\
    ${masterip}:6443

# Set up the kubelet
kubeadm join \\
  phase kubelet-start \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    ${masterip}:6443 &

while true; do
  [[ -e /var/lib/kubelet/config.yaml ]] && break
    sleep 1
  done

# Edit the kubelet configuration file
echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

systemctl enable --now kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh 2>"${STDERR}" || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CU - Container Utilities

# _CU is an associative array that holds data specific to container utils.
declare -A _CU

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# CU_containerrt getter outputs the container runtime (podman or docker)
# that has been chosen.
CU_containerrt() {
  printf '%s' "${_CU[containerrt]}"
}

# CU_imgprefix getter outputs the prefix to be used with docker build. For
# podman it is 'localhost/'. For docker it is empty.
CU_imgprefix() {
  printf '%s' "${_CU[imgprefix]}"
}

# CU_labelkey getter outputs the key value of the label that is applied to all
# cluster member's container labels for podman or docker.
CU_labelkey() {
  printf '%s' "${_CU[labelkey]}"
}

# CU_podmantype getter outputs the container runtime type (native or machine).
CU_podmantype() {
  printf '%s' "${_CU[podmantype]}"
}

# Public Functions ------------------------------------------------------------

# CU_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted.
CU_cleanup() { :; }

# CU_get_cluster_container_ids outputs just the container IDs, one per line
# for any MOK cluster, unless arg1 is set, in which case just the IDs
# for the requested cluster name are output.
# Args: arg1 - The cluster name, optional.
CU_get_cluster_container_ids() {

  local value output

  [[ -n $1 ]] && value="=$1"

  output=$(docker ps -a -f label="${_CU[labelkey]}${value}" -q) || {
    printf 'ERROR: %s command failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  output=$(printf '%s' "${output}" | sed 's/$//')

  printf '%s' "${output}"

  return "${OK}"
}

# CU_get_cluster_size searches for an existing cluster using labels and outputs
# the number of containers in that cluster. All cluster nodes are labelled with
# "${_CU[labelkey]}=${CC[clustername]}"
# Args: arg1 - The cluster name to search for.
CU_get_cluster_size() {

  local output
  declare -a nodes

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Cluster name cannot be empty.\n' >"${STDERR}"
    err || return
  }

  output=$(CU_get_cluster_container_ids "$1") || err || return

  # readarray will read null as an array item so don't run
  # through readarray if it's null
  [[ -z ${output} ]] && {
    printf '0'
    return "${OK}"
  }

  # read the nodes array and delete blank lines
  readarray -t nodes <<<"${output}"

  printf '%d' "${#nodes[*]}"
}

# CU_get_container_ip outputs the IP address of the container.
# Args: arg1 - docker container id or container name to query.
CU_get_container_ip() {

  local info

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  info=$(CU_get_container_info "$1") || return
  JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}" ||
    err || return
}

# CU_get_container_info uses 'docker/podman inspect $id' to output
# container details.
# Args: arg1 - docker container id
CU_get_container_info() {

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  docker inspect "$1" || {
    printf 'ERROR: %s inspect failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_create_container creates and runs a container with settings suitable for
# running privileged containers that can manipulate cgroups.
# Args: arg1 - The string used to set the name and hostname.
#       arg2 - The label to assign to the container.
#       arg3 - The k8s base image version to use.
CU_create_container() {

  local imagename img allimgs systemd_always clustername parg pval

  [[ -z $1 || -z $2 || -z $3 ]] && {
    printf 'INTERNAL ERROR: Neither arg1, arg2 nor arg3 can be empty.\n' \
      >"${STDERR}"
    err || return
  }

  img=$(BI_baseimagename) || err || return

  local imglocal="${_CU[imgprefix]}local/${img}"
  local imgremote="myownkind/${img}"
  local imgtag="${3}"

  # Prefer a locally built container over one downloaded from a registry
  allimgs=$(docker images | tail -n +2) || {
    printf 'ERROR: %s returned an error\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  if echo "${allimgs}" | grep -qs "${imglocal} *${imgtag}"; then
    imagename="${imglocal}:${imgtag}"
  elif echo "${allimgs}" | grep -qs "${imgremote} *${imgtag}"; then
    imagename="${imgremote}:${imgtag}"
  else
    cat <<EnD
ERROR: No container base image found. Use either:

  $ mok build image
OR
  $ mok build image --get-prebuilt-image

Then try running 'mok create ...' again.
EnD
    return "${ERROR}"
  fi

  clustername=$(CC_clustername) || err || return

  if [[ ${_CU[containerrt]} == "podman" ]];
  then 
    docker network exists "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  else
    docker network inspect "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  fi

  [[ ${create_network} -ne 0 ]] && {
    docker network create "${clustername}_network" || {
      printf 'ERROR: docker network create failed\n' >"${STDERR}"
      err || return
    }
  }

  # Docker does not have the --systemd option
  [[ ${_CU[containerrt]} == "podman" ]] && systemd_always="--systemd=always"

  [[ $(CC_publish) == "${TRUE}" ]] && {
    if [[ $(CC_withlb) == "${TRUE}" ]]; then
      if echo "$1" | grep -qs -- '-lb$'; then
        parg='-p'
        pval='6443:6443'
      fi
    else
      if echo "$1" | grep -qs -- '-master-1$'; then
        parg='-p'
        pval='6443:6443'
      fi
    fi
  }

  docker run --privileged ${systemd_always} \
    --network "${clustername}_network" \
    -v /lib/modules:/lib/modules:ro \
    --detach ${parg} ${pval} \
    --name "$1" \
    --hostname "$1" \
    --label "$2" \
    "${imagename}" \
    /usr/local/bin/entrypoint /lib/systemd/systemd log-level=info unit=sysinit.target || {
    printf 'ERROR: %s run failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_podman_or_docker checks to see if docker and/or podman are installed and
# sets the imgprefix and containerrt array members accordingly. It also defines
# the docker function to run the detected container runtime. Podman is
# preferred if both are installed.
# Args: No args expected.
CU_podman_or_docker() {
  if type podman &>/dev/null; then
    _CU[imgprefix]="localhost/"
    _CU[containerrt]="podman"
    _CU_podman_checks || return
  elif type docker &>/dev/null; then
    _CU[imgprefix]=""
    _CU[containerrt]="docker"
    _CU_docker_checks || return
  else
    printf 'ERROR: Neither "podman" nor "docker" were found.\n' \
      >"${STDERR}"
    printf 'Please install one of "podman" or "docker".\nAborting.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi
  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CU_docker_checks checks to see if the current user has permission to write
# to the docker socket. If not, it prints an error message and exits.
# Args: No args expected.
_CU_docker_checks() {
  if [[ ! -e /proc/sys/kernel/hostname ]]; then
    printf 'ERROR: Docker is currently supported on Linux only'
    exit "${ERROR}"
  fi

  if docker ps >/dev/stdout 2>&1 | grep -qs 'docker.sock.*permission denied'; then
    cat <<EnD >"${STDERR}"
Not enough permissions to write to 'docker.sock'.

Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  fi

  _CU[podmantype]="native"
  return "${OK}"
}

# _CU_podman_checks sets the _CU[podmantype] member to "native" or "machine"
# depending on whether this is linux or macos. We assume linux won't be using
# a podman machine, and macos will always be using a podman machine.
# Args: No args expected.
_CU_podman_checks() {
  local info running

  if [[ -e /proc/sys/kernel/hostname ]]; then
    # We're on linux
    _CU[podmantype]="native"
    _CU_podman_native_checks || return
  elif [[ -d /System/Library/CoreServices ]]; then
    # We're on macOS
    [[ $(id -u) -eq 0 ]] && {
      printf 'ERROR: Cannot run mok as root on macOS.\n' >"${STDERR}"
      exit "${ERROR}"
    }

    info=$(podman machine list --format json) || err || return
    running=$(JSONPath -b '..Running' <<<"${info}") || err || return

    if [[ ${running} == "true" ]]; then
      _CU[podmantype]="machine"
    else
      printf 'ERROR: Podman machine is not running. Aborting.\n' >"${STDERR}"
      exit "${ERROR}"
    fi
  else
    printf 'ERROR: Unknown OS. Aborting.\n' >"${STDERR}"
    exit "${ERROR}"
  fi
}

# _CU_podman_native_checks checks to see if the current user is root. If not,
# it prints an error message and exits.
# Args: No args expected.
_CU_podman_native_checks() {
  [[ $(id -u) -ne 0 ]] && {
    cat <<EnD >"${STDERR}"
Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  }
}

# _CU_new sets the initial values for the Container Utils associative array.
# Args: None expected.
_CU_new() {
  _CU[imgprefix]=
  _CU[labelkey]="MokCluster"
  _CU[containerrt]=

  # _CU[podmantype] will only be set only if _CU[containerrt]=podman.
  # podmantype will be "native" or "machine".
  _CU[podmantype]=
}

# Override `docker` depending on _CU[containerrt]
docker() {
  local cmd
  if [[ "${_CU[containerrt]}" == "podman" ]]; then
    podman "$@"
  else
    cmd=$(which -a docker | tail -n 1)
    $cmd "$@"
  fi
}

# Override `ip` depending on _CU[podmantype]
ip() {
  local cmd
  if [[ "${_CU[podmantype]}" == "machine" ]]; then
    podman machine ssh ip "$@"
  else
    cmd=$(which -a ip | tail -n 1)
    $cmd "$@"
  fi
}

# Initialise _CU
_CU_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# BI - Build Image

# _BI is an associative array that holds data specific to building an image.
declare -A _BI

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE

# Getters/Setters -------------------------------------------------------------

# BI_setflag_useprebuiltimage setter sets the useprebuiltimage array item.
# This is called by the parser, via a callback in _BI_new.
BI_setflag_useprebuiltimage() {
  _BI[useprebuiltimage]="$1"
}

# BI_baseimagename getter outputs the value of the _BI[baseimagename].
# Args: None expected.
BI_baseimagename() {
  printf '%s' "${_BI[baseimagename]}"
}

# Public Functions ------------------------------------------------------------

# BI_usage outputs help text for the build image component.
# It is called by PA_usage(), via a callback in _BI_new.
# Args: None expected.
BI_usage() {

  cat <<'EnD'
BUILD subcommands are:
 
  image - Creates the docker 'mok-image' container image.
 
build image options:
 
 Format:
  build image [flags]

 Flags:
  --get-prebuilt-image - Instead of building a 'node' image
         locally, download it from a container registry instead.
  --tailf - Show the build output whilst building.

EnD
}

# BI_cleanup removes temporary files created during the build.
# This function is called by the 'MA_cleanup' trap only.
# Args: None expected.
BI_cleanup() {
  [[ -e ${_BI[dockerbuildtmpdir]} ]] &&
    [[ ${_BI[dockerbuildtmpdir]} == "/var/tmp/"* ]] && {
    rm -rf "${_BI[dockerbuildtmpdir]}" || {
      printf 'ERROR: "rm -rf %s" failed.\n' "${_BI[dockerbuildtmpdir]}" \
        >"${STDERR}"
      err || return
    }
  }
}

# BI_check_valid_options checks if arg1 is in a list of valid build image
# options. This function is called by the parser, via a callback in _BI_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
BI_process_options() {

  case "$1" in
  -h | --help)
    BI_usage
    return "${STOP}"
    ;;
  --tailf)
    _BI[tailf]="${TRUE}"
    return "${OK}"
    ;;
  --get-prebuilt-image)
    _BI[useprebuiltimage]="${TRUE}"
    return "${OK}"
    ;;
  *)
    BI_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# BI_run builds the base image used for masters and workers.
# This function is called in main.sh.
# Args: None expected.
BI_run() {

  _BI_sanity_checks || return

  [[ ${_BI[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  local retval=0
  _BI_build_container_image
  retval=$?

  if [[ ${retval} -eq ${OK} ]]; then
    : # We only need the tick - no text
  else
    printf 'Image build failed\n' >"${STDERR}"
    err
  fi

  return "${retval}"
}

# Private Functions -----------------------------------------------------------

# _BI_new resets the initial values for the _BI associative array.
# Args: None expected.
_BI_new() {
  _BI[tailf]="${FALSE}"
  _BI[baseimagename]="mok-image"
  _BI[useprebuiltimage]="${FALSE}"
  _BI[dockerbuildtmpdir]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "build" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "buildimage" "END" ""

  # Set up the parser's option callbacks
  PA_add_option_callback "build" "BI_process_options" || return
  PA_add_option_callback "buildimage" "BI_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "build" "BI_usage" || return
  PA_add_usage_callback "buildimage" "BI_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "buildimage" "BI_run"
}

# BI_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_BI_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    BI_usage
    exit "${OK}"
  fi
}

# _BI_build_container_image creates the docker build directory in
# dockerbuildtmpdir then calls docker build to build the image.
# Args: No args expected.
_BI_build_container_image() {

  local cmd retval tagname buildargs text buildtype basename

  _BI_create_docker_build_dir || return

  buildargs=$(_BI_get_build_args_for_latest) || return
  basename="${_BI[baseimagename]}"
  tagname="${K8SVERSION}"

  local imgprefix
  imgprefix=$(CU_imgprefix) || err || return
  if [[ ${_BI[useprebuiltimage]} == "${FALSE}" ]]; then
    buildtype="create"
    cmd="docker build \
      -t "${imgprefix}local/${basename}:${tagname}" \
      --force-rm \
      ${buildargs} \
      ${_BI[dockerbuildtmpdir]}/${_BI[baseimagename]}"
    text="Creating"
  else
    buildtype="download"
    cmd="docker pull docker.io/myownkind/${basename}:${tagname}"
    text="Downloading"
  fi

  UT_run_with_progress \
    "    ${text} base image, '${basename}:${tagname}'" "${cmd}"

  retval=$?
  [[ ${retval} -ne ${OK} ]] && {
    local runlogfile
    runlogfile=$(UT_runlogfile) || err || return
    printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\n' >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${buildtype} == "create" ]] && {
    cmd="_BI_modify_container_image"

    UT_run_with_progress \
      "    Modifying base image (pulling kubernetes images)" "${cmd}"

    retval=$?
    [[ ${retval} -ne ${OK} ]] && {
      local runlogfile
      runlogfile=$(UT_runlogfile) || err || return
      printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\n' >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _BI_modify_container_image starts a container suitable for running kubernetes
# components (since the docker/podman build environment isn't suitable), makes
# some modifications and then 'commits' the image. The modifications allow
# `mok create ...` to complete more quickly.
# Args: No args expected.
_BI_modify_container_image() {

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify &>/dev/null
  docker rm mok-build-modify &>/dev/null

  CC_set_clustername "build" || err || return

  # Start container
  CU_create_container "mok-build-modify" "mok-build-modify" "${K8SVERSION}" ||
    return

  # Wait for crio to become ready
  local counter
  printf '\n\n ** WAITING FOR CRIO TO BECOME READY **\n\n'
  while ! docker exec mok-build-modify systemctl status crio; do
    sleep 1
    [[ ${counter} -gt 10 ]] && {
      printf '\nERROR: CRI-O did not start after %d tries.\n' "${counter}"
      err || return
    }
    ((counter++))
  done

  # Modify container
  docker exec mok-build-modify kubeadm config images pull \
    --kubernetes-version "${K8SVERSION}" || err || return

  # Stop container
  docker stop -t 5 "mok-build-modify"

  # Write image
  local imgprefix tagname basename
  imgprefix=$(CU_imgprefix) || err || return
  basename="${_BI[baseimagename]}"
  tagname="${K8SVERSION}"
  docker commit mok-build-modify "${imgprefix}local/${basename}:${tagname}" || err || return

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify
  docker rm mok-build-modify || err || return

  return "${OK}"
}

# _BI_get_build_args_for_latest sets the buildargs variable that is added
# to the 'podman build ...' command line.  Only the latest version is built
# from scratch.  Earlier versions are downloaded using '--get-prebuilt-image'.
# Args: None expected
_BI_get_build_args_for_latest() {

  local buildargs

  buildargs="--build-arg GO_VERSION=${GO_VERSION}"

  printf '%s' "${buildargs}"
}

# _BI_create_docker_build_dir creates a docker build directory in
# /var/tmp/tmp.XXXXXXXX
# Args: None expected
_BI_create_docker_build_dir() {

  _BI[dockerbuildtmpdir]="$(mktemp -d -p /var/tmp)" || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }

  # The following comments should not be removed or changed.
  # embed-dockerfile.sh adds a base64 encoded tarball and
  # unpacking code between them.

  #mok-image-tarball-start 
  cat <<EnD | base64 -d | tar xz -C "${_BI[dockerbuildtmpdir]}" 
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
AMBHAOABAA==
EnD
  #mok-image-tarball-end
}

# Initialise _BI
_BI_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
#!/usr/bin/env bash

declare -A JSONPath

JSONPath_new() {
  JSONPath[DEBUG]=0
  JSONPath[INCLEMPTY]=0
  JSONPath[NOCASE]=0
  JSONPath[WHOLEWORD]=0
  JSONPath[FILE]=
  JSONPath[NO_HEAD]=0
  JSONPath[NORMALIZE_SOLIDUS]=0
  JSONPath[BRIEF]=0
  JSONPath[PASSTHROUGH]=0
  JSONPath[JSON]=0
  JSONPath[MULTIPASS]=0
  JSONPath[FLATTEN]=0
  JSONPath[STDINFILE]=/var/tmp/JSONPath.$$.stdin
  JSONPath[STDINFILE2]=/var/tmp/JSONPath.$$.stdin2
  JSONPath[PASSFILE]=/var/tmp/JSONPath.$$.pass1
  declare -a INDEXMATCH_QUERY
}

# JSONPath reads JSON from stdin and applies a JSON Path query.
# Args: arg1-N - command line arguments to be parsed.
JSONPath() {

  JSONPath_sanity_checks
  JSONPath_parse_options "$@"

  trap JSONPath_cleanup EXIT

  if [[ ${QUERY} == *'?(@'* ]]; then
    # This will be a multipass query

    [[ -n ${JSONPath[FILE]} ]] && JSONPath[STDINFILE]=${JSONPath[FILE]}
    [[ -z ${JSONPath[FILE]} ]] && cat >"${JSONPath[STDINFILE]}"

    while true; do
      JSONPath_tokenize_path
      JSONPath_create_filter

      JSONPath_tokenize | JSONPath_parse | JSONPath_filter |
        JSONPath_indexmatcher >"${JSONPath[PASSFILE]}" <"${JSONPath[STDINFILE]}"

      [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && {
        # replace filter expression with index sequence
        SET=$(sed -rn 's/.*[[,"]+([0-9]+)[],].*/\1/p' "${JSONPath[PASSFILE]}" | tr '\n' ,)
        SET=${SET%,}
        #QUERY=$(sed "s/?(@[^)]\+)/${SET}/" <<<"${QUERY}")
        # Testing:
        QUERY="${QUERY//\?\(@*)/${SET}}"
        [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "QUERY=${QUERY}" >/dev/stderr
        JSONPath_reset
        continue
      }

      JSONPath_flatten | JSONPath_json | JSONPath_brief <<<"${JSONPath[PASSFILE]}"

      break
    done

  else

    JSONPath_tokenize_path
    JSONPath_create_filter

    if [[ ${JSONPath[PASSTHROUGH]} -eq 1 ]]; then
      JSONPath[JSON]=1
      JSONPath_flatten | JSONPath_json
    elif [[ -z ${JSONPath[FILE]} ]]; then
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten | JSONPath_json | JSONPath_brief
    else
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten <"${JSONPath[FILE]}"
      JSONPath_json | JSONPath_brief
    fi

  fi
}

JSONPath_sanity_checks() {

  local binary

  # Reset some vars
  for binary in gawk grep sed; do
    if ! command -v "${binary}" >&/dev/null; then
      echo "ERROR: ${binary} binary not found in path. Aborting."
      exit 1
    fi
  done
}

JSONPath_reset() {

  # Reset some vars
  declare -a INDEXMATCH_QUERY
  PATHTOKENS=
  FILTER=
  OPERATOR=
  RHS=
  JSONPath[MULTIPASS]=0
}

JSONPath_cleanup() {

  [[ -e ${JSONPath[PASSFILE]} ]] && rm -f "${PASSFILE}"
  [[ -e ${JSONPath[STDINFILE2]} ]] && rm -f "${JSONPath[STDINFILE2]}"
  [[ -z ${JSONPath[FILE]} && -e ${JSONPath[STDINFILE]} ]] &&
    rm -f "${JSONPath[STDINFILE]}"
}

JSONPath_usage() {

  echo
  echo "Usage: JSONPath.sh [-b] [j] [-h] [-f FILE] [pattern]"
  echo
  echo "pattern - the JSONPath query. Defaults to '$.*' if not supplied."
  echo "-b      - Brief. Only show values."
  echo "-j      - JSON output."
  echo "-u      - Strip unnecessary leading path elements."
  echo "-i      - Case insensitive."
  echo "-p      - Pass-through to the JSON parser."
  echo "-w      - Match whole words only (for filter script expression)."
  echo "-f FILE - Read a FILE instead of stdin."
  echo "-h      - This help text."
  echo
}

JSONPath_parse_options() {

  set -- "$@"
  local ARGN=$#
  while [[ ${ARGN} -ne 0 ]]; do
    case $1 in
    -h)
      JSONPath_usage
      exit 0
      ;;
    -f)
      shift
      JSONPath[FILE]=$1
      ;;
    -i)
      JSONPath[NOCASE]=1
      ;;
    -j)
      JSONPath[JSON]=1
      ;;
    -n)
      JSONPath[NO_HEAD]=1
      ;;
    -b)
      JSONPath[BRIEF]=1
      ;;
    -u)
      JSONPath[FLATTEN]=1
      ;;
    -p)
      JSONPath[PASSTHROUGH]=1
      ;;
    -w)
      JSONPath[WHOLEWORD]=1
      ;;
    -s)
      JSONPath[NORMALIZE_SOLIDUS]=1
      ;;
    *)
      QUERY=$1
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done
  [[ -z ${QUERY} ]] && QUERY='$.*'
}

JSONPath_awk_egrep() {
  local pattern_string=$1

  gawk '{
    while ($0) {
      start=match($0, pattern);
      token=substr($0, start, RLENGTH);
      print token;
      $0=substr($0, start+RLENGTH);
    }
  }' pattern="${pattern_string}"
}

JSONPath_tokenize() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    ESCAPE='(\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
    ESCAPE='(\\\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\\\]'
  fi

  local STRING="\"${CHAR}*(${ESCAPE}${CHAR}*)*\""
  local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'
  local KEYWORD='null|false|true'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  ${GREP} "${STRING}|${NUMBER}|${KEYWORD}|${SPACE}|." | grep -Ev "^${SPACE}$"
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

JSONPath_tokenize_path() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
  fi

  local WILDCARD='\*'
  local WORD='[ A-Za-z0-9_-]*'
  local INDEX="\\[${WORD}(:${WORD}){0,2}\\]"
  local INDEXALL='\[\*\]'
  local STRING="[\\\"'][^[:cntrl:]\\\"']*[\\\"']"
  local SET="\\[(${WORD}|${STRING})(,(${WORD}|${STRING}))*\\]"
  local FILTER='\?\(@[^)]+'
  local DEEPSCAN='\.\.'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  readarray -t PATHTOKENS < <(echo "${QUERY}" |
    ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
    grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$")
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    echo "grep -Eo '${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|.'" >/dev/stderr
    echo -n "TOKENISED QUERY="
    echo "${QUERY}" |
      ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
      grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$" >/dev/stderr
  }
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

# JSONPath_create_filter creates the filter from the user's query.
# Filter works in a single pass through the data, unless a filter (script)
#  expression is used, in which case two passes are required (MULTIPASS=1).
JSONPath_create_filter() {

  local len=${#PATHTOKENS[*]}

  local -i i=0
  local a query="^\[" comma=
  while [[ i -lt len ]]; do
    case "${PATHTOKENS[i]}" in
    '"')
      :
      ;;
    '..')
      query+="${comma}[^]]*"
      comma=
      ;;
    '[*]')
      query+="${comma}[^,]*"
      comma=","
      ;;
    '*')
      query+="${comma}(\"[^\"]*\"|[0-9]+[^],]*)"
      comma=","
      ;;
    '?(@'*)
      a=${PATHTOKENS[i]#?(@.}
      elem="${a%%[<>=!]*}"
      rhs="${a##*[<>=!]}"
      a="${a#${elem}}"
      elem="${elem//./[\",.]+}" # Allows child node matching
      operator="${a%${rhs}}"
      [[ -z ${operator} ]] && {
        operator="=="
        rhs=
      }
      if [[ ${rhs} == *'"'* || ${rhs} == *"'"* ]]; then
        case ${operator} in
        '==' | '=')
          OPERATOR=
          if [[ ${elem} == '?(@' ]]; then
            # To allow search on @.property such as:
            #   $..book[?(@.title==".*Book 1.*")]
            query+="${comma}[0-9]+[],][[:space:]\"]*${rhs//\"/}"
          else
            # To allow search on @ (this node) such as:
            #   $..reviews[?(@==".*Fant.*")]
            query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs//\"/}"
          fi
          FILTER="${query}"
          ;;
        '>=' | '>')
          OPERATOR=">"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=' | '<')
          OPERATOR="<"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      else
        case ${operator} in
        '==' | '=')
          OPERATOR=
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs}"
          FILTER="${query}"
          ;;
        '>=')
          OPERATOR="-ge"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '>')
          OPERATOR="-gt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=')
          OPERATOR="-le"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<')
          OPERATOR="-lt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      fi
      JSONPath[MULTIPASS]=1
      ;;
    "["*)
      if [[ ${PATHTOKENS[i]} =~ , ]]; then
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          # converts only one comma: s/("[^"]+),([^"]+")/\1`\2/g;s/"//g
          #a=$(echo $a | sed 's/\([[:alpha:]]*\)/"\1"/g')
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        fi
        query+="${comma}(${a//,/|})"
      elif [[ ${PATHTOKENS[i]} =~ : ]]; then
        if ! [[ ${PATHTOKENS[i]} =~ [0-9][0-9] || ${PATHTOKENS[i]} =~ :] ]]; then
          if [[ ${PATHTOKENS[i]#*:} =~ : ]]; then
            INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
            query+="${comma}[^,]*"
          else
            # Index in the range of 0-9 can be handled by regex
            query+="${comma}$(echo "${PATHTOKENS[i]}" |
              gawk '/:/ { a=substr($0,0,index($0,":")-1);
                         b=substr($0,index($0,":")+1,index($0,"]")-index($0,":")-1);
                         if(b>0) { print a ":" b-1 "]" };
                         if(b<=0) { print a ":]" } }' |
              sed 's/\([0-9]\):\([0-9]\)/\1-\2/;
                       s/\[:\([0-9]\)/[0-\1/;
                       s/\([0-9]\):\]/\1-9999999]/')"
          fi
        else
          INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
          query+="${comma}[^,]*"
        fi
      else
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        else
          [[ ${i} -gt 0 ]] && comma=","
        fi
        query+="${comma}${a}"
      fi
      comma=","
      ;;
    *)
      PATHTOKENS[i]=${PATHTOKENS[i]//\'/\"}
      query+="${comma}\"${PATHTOKENS[i]//\"/}\""
      comma=","
      ;;
    esac
    i=$((i + 1))
  done

  [[ -z ${FILTER} ]] && FILTER="${query}[],]"
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
}

JSONPath_parse_array() {

  local index=0
  local ary=''
  read -r token
  case "${token}" in
  ']') ;;

  *)
    while :; do
      JSONPath_parse_value "$1" "${index}"
      index=$((index + 1))
      ary="${ary}""${value}"
      read -r token
      case "${token}" in
      ']') break ;;
      ',') ary="${ary}," ;;
      *) JSONPath_throw "EXPECTED , or ] GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_object() {

  local key
  local obj=''
  read -r token
  case "${token}" in
  '}') ;;

  *)
    while :; do
      case "${token}" in
      '"'*'"') key=${token} ;;
      *) JSONPath_throw "EXPECTED string GOT ${token:-EOF}" ;;
      esac
      read -r token
      case "${token}" in
      ':') ;;
      *) JSONPath_throw "EXPECTED : GOT ${token:-EOF}" ;;
      esac
      read -r token
      JSONPath_parse_value "$1" "${key}"
      obj="${obj}${key}:${value}"
      read -r token
      case "${token}" in
      '}') break ;;
      ',') obj="${obj}," ;;
      *) JSONPath_throw "EXPECTED , or } GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_value() {

  local jpath="${1:+$1,}$2" isleaf=0 isempty=0 print=0
  case "${token}" in
  '{') JSONPath_parse_object "${jpath}" ;;
  '[') JSONPath_parse_array "${jpath}" ;;
    # At this point, the only valid single-character tokens are digits.
  '' | [!0-9]) JSONPath_throw "EXPECTED value GOT ${token:-EOF}" ;;
  *)
    value=${token}
    # if asked, replace solidus ("\/") in json strings with normalized value: "/"
    # Testing:
    #[ "${JSONPath[NORMALIZE_SOLIDUS]}" -eq 1 ] && value=$(echo "${value}" | sed 's#\\/#/#g')
    [[ ${JSONPath[NORMALIZE_SOLIDUS]} -eq 1 ]] && value=$(${value//\\\///})
    isleaf=1
    [[ ${value} == '""' ]] && isempty=1
    ;;
  esac
  [[ -z ${JSONPath[INCLEMPTY]} ]] && [[ ${value} == '' ]] && return
  [[ ${JSONPath[NO_HEAD]} -eq 1 ]] && [[ -z ${jpath} ]] && return

  [[ ${isleaf} -eq 1 ]] && [[ ${isempty} -eq 0 ]] && print=1
  [[ ${print} -eq 1 ]] && printf "[%s]\t%s\n" "${jpath}" "${value}"
  :
}

JSONPath_flatten() {

  local path a prevpath pathlen

  if [[ ${JSONPath[FLATTEN]} -eq 1 ]]; then
    cat >"${JSONPath[STDINFILE2]}"

    highest=9999

    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      [[ -z ${prevpath} ]] && {
        prevpath=("${path[@]}")
        highest=$((${#path[*]} - 1))
        continue
      }

      pathlen=$((${#path[*]} - 1))

      for i in $(seq 0 "${pathlen}"); do
        [[ ${path[i]} != "${prevpath[i]}" ]] && {
          high=${i}
          break
        }
      done

      [[ ${high} -lt ${highest} ]] && highest=${high}

      prevpath=("${path[@]}")
    done <"${JSONPath[STDINFILE2]}"

    if [[ ${highest} -gt 0 ]]; then
      sed -r 's/\[(([0-9]+|"[^"]+")[],]){'$((highest))'}(.*)/[\3/' \
        "${JSONPath[STDINFILE2]}"
    else
      cat "${JSONPath[STDINFILE2]}"
    fi
  else
    cat
  fi
}

# JSONPath_indexmatcher is for double digit or greater indexes match each line
# individually Single digit indexes are handled more efficiently by regex
JSONPath_indexmatcher() {

  local a b

  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
      echo "INDEXMATCH_QUERY[${i}]=${INDEXMATCH_QUERY[i]}" >/dev/stderr
    done
  }

  matched=1

  step=
  if [[ ${#INDEXMATCH_QUERY[*]} -gt 0 ]]; then
    while read -r line; do
      for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
        [[ ${INDEXMATCH_QUERY[i]#*:} =~ : ]] && {
          step=${INDEXMATCH_QUERY[i]##*:}
          step=${step%]}
          INDEXMATCH_QUERY[i]="${INDEXMATCH_QUERY[i]%:*}]"
        }
        q=${INDEXMATCH_QUERY[i]:1:-1} # <- strip '[' and ']'
        a=${q%:*}                     # <- number before ':'
        b=${q#*:}                     # <- number after ':'
        [[ -z ${b} ]] && b=99999999999
        readarray -t num < <((grep -Eo '[0-9]+[],]' | tr -d ,]) <<<"${line}")
        if [[ ${num[i]} -ge ${a} && ${num[i]} -lt ${b} && matched -eq 1 ]]; then
          matched=1
          [[ ${i} -eq $((${#INDEXMATCH_QUERY[*]} - 1)) ]] && {
            if [[ ${step} -gt 1 ]]; then
              [[ $(((num[i] - a) % step)) -eq 0 ]] && {
                [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
                echo "${line}"
              }
            else
              [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
              echo "${line}"
            fi
          }
        else
          matched=0
          continue
        fi
      done
      matched=1
    done
  else
    cat -
  fi
}

JSONPath_brief() {
  # Only show the value

  if [[ ${JSONPath[BRIEF]} -eq 1 ]]; then
    sed 's/^[^\t]*\t//;s/^"//;s/"$//;'
  else
    cat
  fi
}

JSONPath_json() {
  # Turn output into JSON

  local a tab="$'\t'"
  local UP=1 DOWN=2 SAME=3
  local prevpathlen=-1 prevpath=() path a
  declare -a closers

  if [[ ${JSONPath[JSON]} -eq 0 ]]; then
    cat -
  else
    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      value=${line#*${tab}}

      # Not including the object itself (last item)
      pathlen=$((${#path[*]} - 1))

      # General direction

      direction=${SAME}
      [[ ${pathlen} -gt ${prevpathlen} ]] && direction=${DOWN}
      [[ ${pathlen} -lt ${prevpathlen} ]] && direction=${UP}

      # Handle jumps UP the tree (close previous paths)

      [[ ${prevpathlen} != -1 ]] && {
        for i in $(seq 0 $((pathlen - 1))); do
          [[ ${prevpath[i]} == "${path[i]}" ]] && continue
          [[ ${path[i]} != '"'* ]] && {
            # Testing double quotes:
            a="(${!arrays[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                arrays[k]=
              done
            }
            a="(${!comma[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                comma[k]=
              done
            }
            for j in $(seq $((prevpathlen)) -1 $((i + 2))); do
              arrays[j]=
              [[ -n ${closers[j]} ]] && {
                indent=$((j * 4))
                printf "\n%${indent}s${closers[j]}" ""
                unset "closers[j]"
                comma[j]=
              }
            done
            direction=${DOWN}
            break
          }
          direction=${DOWN}
          for j in $(seq $((prevpathlen)) -1 $((i + 1))); do
            arrays[j]=
            [[ -n ${closers[j]} ]] && {
              indent=$((j * 4))
              printf "\n%${indent}s${closers[j]}" ""
              unset "closers[j]"
              comma[j]=
            }
          done
          a="(${!arrays[*]})"
          [[ -n ${a} ]] && {
            for k in $(seq "${i}" "${a[-1]}"); do
              arrays[k]=
            done
          }
          break
        done
      }

      [[ ${direction} -eq ${UP} ]] && {
        [[ ${prevpathlen} != -1 ]] && comma[prevpathlen]=
        for i in $(seq $((prevpathlen + 1)) -1 $((pathlen + 1))); do
          arrays[i]=
          [[ -n ${closers[i]} ]] && {
            indent=$((i * 4))
            printf "\n%${indent}s${closers[i]}" ""
            unset "closers[i]"
            comma[i]=
          }
        done
        a="(${!arrays[*]})"
        [[ -n ${a} ]] && {
          for k in $(seq "${i}" "${a[-1]}"); do
            arrays[k]=
          done
        }
      }

      # Opening braces (the path leading up to the key)

      broken=
      for i in $(seq 0 $((pathlen - 1))); do
        [[ -z ${broken} && ${prevpath[i]} == "${path[i]}" ]] && continue
        [[ -z ${broken} ]] && {
          broken=${i}
          [[ ${prevpathlen} -ne -1 ]] && broken=$((i + 1))
        }
        if [[ ${path[i]} == '"'* ]]; then
          # Object
          [[ ${i} -ge ${broken} ]] && {
            indent=$((i * 4))
            printf "${comma[i]}%${indent}s{\n" ""
            closers[i]='}'
            comma[i]=
          }
          indent=$(((i + 1) * 4))
          printf "${comma[i]}%${indent}s${path[i]}:\n" ""
          comma[i]=",\n"
        else
          # Array
          if [[ ${arrays[i]} != 1 ]]; then
            indent=$((i * 4))
            printf "%${indent}s" ""
            echo "["
            closers[i]=']'
            arrays[i]=1
            comma[i]=
          else
            indent=$(((i + 1) * 4))
            printf "\n%${indent}s${closers[i - 1]}" ""
            direction=${DOWN}
            comma[i + 1]=",\n"
          fi
        fi
      done

      # keys & values

      if [[ ${path[-1]} == '"'* ]]; then
        # Object
        [[ ${direction} -eq ${DOWN} ]] && {
          indent=$((pathlen * 4))
          printf "${comma[pathlen]}%${indent}s{\n" ""
          closers[pathlen]='}'
          comma[pathlen]=
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${path[-1]}:${value}"
        comma[pathlen]=",\n"
      else
        # Array
        [[ ${arrays[i]} != 1 ]] && {
          indent=$(((pathlen - 0) * 4))
          printf "%${indent}s[\n" ""
          closers[pathlen]=']'
          comma[pathlen]=
          arrays[i]=1
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${value}"
        comma[pathlen]=",\n"
      fi

      prevpath=("${path[@]}")
      prevpathlen=${pathlen}
    done

    # closing braces

    for i in $(seq $((pathlen)) -1 0); do
      indent=$((i * 4))
      printf "\n%${indent}s${closers[i]}" ""
    done
    echo
  fi
}

JSONPath_filter() {
  # Apply the query filter

  local a tab=$'\t' v

  [[ ${JSONPath[NOCASE]} -eq 1 ]] && opts+="i"
  [[ ${JSONPath[WHOLEWORD]} -eq 1 ]] && opts+="w"
  if [[ -z ${OPERATOR} ]]; then
    [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && FILTER="${FILTER}[\"]?$"
    grep "-E${opts}" "${FILTER}"
    [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
  else
    grep "-E${opts}" "${FILTER}" |
      while read -r line; do
        v=${line#*${tab}}
        case ${OPERATOR} in
        '-ge')
          if gawk '{exit !($1>=$2)}' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-gt')
          if gawk '{exit !($1>$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-le')
          if gawk '{exit !($1<=$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-lt')
          if gawk '{exit !($1<$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '>')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} > ${RHS,,} ]] && echo "${line}"
          ;;
        '<')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} < ${RHS,,} ]] && echo "${line}"
          ;;
        *) return 1 ;;
        esac
      done
  fi
}

JSONPath_parse() {
  # Parses json

  read -r token
  JSONPath_parse_value
  read -r token
  case "${token}" in
  '') ;;
  *)
    JSONPath_throw "EXPECTED EOF GOT ${token}"
    exit 1
    ;;
  esac
}

JSONPath_throw() {
  echo "$*" >&2
  exit 1
}

JSONPath_new || exit 1

# vi: expandtab sw=2 ts=2
# shellcheck shell=bash disable=SC2148
# MA - execution starts here

# MA is an associative array that holds data specific to this file
declare -A _MA

# Defined in GL (globals.sh)
declare OK ERROR STOP STDERR TRUE

# Getters/Setters -------------------------------------------------------------

# MA_program_args getter outputs the program arguments sent by the user.
MA_program_args() {
  printf '%s' "${_MA[program_args]}"
}

# Public Functions ------------------------------------------------------------

# main is the start point for this application.
# Args: arg1-N - the command line arguments entered by the user.
MA_main() {
  local retval="${OK}"

  CU_podman_or_docker

  trap MA_cleanup EXIT
  MA_sanity_checks || return
  PA_run "$@" || retval=$?

  exit "${retval}"
}

# MA_version outputs the version information the exits.
MA_version() {
  printf 'Version: %s\n' "${MOKVERSION}"
  exit "${OK}"
}

# MA_process_global_options is called by the parser when a global option is
# encountered for processing.
# Args: arg1 - the global option that was found.
MA_process_global_options() {
  case "$1" in
  -h | --help)
    PA_usage
    return "${STOP}"
    ;;
  -p | --plain)
    UT_set_plain "${TRUE}"
    ;;
  *)
    printf 'INTERNAL ERROR: Invalid global option, "%s".' "$1"
    return "${ERROR}"
    ;;
  esac
}

# MA_cleanup is called from an EXIT trap only, when the program exits, and
# calls every other function matching the pattern '^.._cleanup'.
# Args: No args expected.
MA_cleanup() {
  local retval="${OK}" funcs func
  funcs=$(declare -F | awk '{print $NF;}' | grep '^.._cleanup')
  for func in ${funcs}; do
    [[ ${func} == "${FUNCNAME[0]}" ]] && continue
    eval "${func}" || retval=$?
  done
  return "${retval}"
}

# MA_sanity_checks is expected to run some quick and simple checks to
# see if key components are available before MA_main is called.
# Args: No args expected.
MA_sanity_checks() {

  local binary

  if [[ $(CU_podmantype) == "native" ]]; then
    binaries="gawk tac column tput grep sed ip cut"
  else
    binaries="gawk tac column tput grep sed cut"
  fi

  for binary in ${binaries}; do
    if ! command -v "${binary}" >&/dev/null; then
      printf 'ERROR: "%s" binary not found in path. Aborting.' "${binary}" \
        >"${STDERR}"
      return "${ERROR}"
    fi
  done

  # Disable terminal escapes (colours) if stdout is not a terminal
  [ -t 1 ] || UT_disable_colours
}

# MA_usage outputs help text for all components then quits with no error.  This
# is registered as a callback in the Parser, see _MA_new
# Args: None expected.
MA_usage() {

  cat <<'EnD'
Usage: mok [-h] <command> [subcommand] [ARGS...]
 
Global options:
  --help
  -h     - This help text
  --plain
  -p     - Plain output. No colours or animations.
 
Where command can be one of:
  create  - Add item(s) to the system.
  delete  - Delete item(s) from the system.
  build   - Build item(s) used by the system.
  get     - Get details about items in the system.
  exec    - 'Log in' to the container.
  version - Display version information.

For help on a specific command, run:
  mok <command> --help
EnD
}

# MA_new sets the initial values for the _MA associative array
_MA_new() {
  _MA[program_args]="$*"

  # Program the parser's state machine
  PA_add_state "COMMAND" "version" "END" "MA_version"

  # Set up the parser's option callbacks
  PA_add_option_callback "" "MA_process_global_options"

  # Set up the parser's usage callbacks
  PA_add_usage_callback "" "MA_usage"
}

# Initialise _MA
_MA_new "$@" || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
if [ "$0" = "${BASH_SOURCE[0]}" ] || [ -z "${BASH_SOURCE[0]}" ]; then
  MA_main "$@"
fi
