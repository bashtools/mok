#!/usr/bin/env bash
# shellcheck shell=bash disable=SC2148
# PA - PArser

# _PA holds data specific to parsing the command line arguments.
declare -A _PA

# Declare externally defined variables ----------------------------------------

# Defined in ER (globals.sh)
declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# PA_command getter outputs the _PA[command] array member. This contains the
# command the user requested.
PA_command() {
  printf '%s' "${_PA[command]}"
}

# PA_subcommand getter outputs the _PA[subcommand] array member. This contains
# the subcommand the user requested.
PA_subcommand() {
  printf '%s' "${_PA[subcommand]}"
}

# PA_shift outputs the _PA[shift] array member, returned by the caller
# when an extra shift is required whilst consuming option values.
#
# Example code:
# ```
#XX_process_options_callback() {
#
#  case "$1" in
#  -h | --help)
#    CC_usage
#    return "${STOP}"
#    ;;
#    ... omitted ...
#  --k8sver)
#    _CC[k8sver]="$2"
#    return "$(PA_shift)"
#    ;;
#  --with-lb)
#    ... omitted ..
# ```
PA_shift() {
  printf '%s' "${_PA[shift]}"
}

# PA_set_state setter sets the initial state of the parser, which should be one
# of COMMAND, SUBCOMMAND, or ARG1.
# Args: arg1 - the initial state to set.
PA_set_state() {
  _PA[state]="$1"
}

# Public Functions ------------------------------------------------------------

# PA_add_option_callback adds a callback to the list of callbacks used for
# processing options.
# Args: arg1 - Null string (for global options), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_option_callback() {
  _PA[optscallbacks]+="$1,$2 "
}

# PA_add_usage_callback adds a callback to the list of callbacks used for
# output of help text.
# Args: arg1 - Null string (for global help), COMMAND or COMMANDSUBCOMMAND.
#       arg2 - The function to call.
PA_add_usage_callback() {
  _PA[usagecallbacks]+="$1,$2 "
}

# PA_add_state adds a callback to the list of callbacks used for
# programming the state machine.
# Args: arg1 - Current state to match.
#       arg2 - The value of the state to match.
#       arg3 - The new state if arg1 and arg2 match.
#       arg4 - The function to call, optional.
PA_add_state() {
  _PA[statecallbacks]+="$1,$2,$3,$4 "
}

# PA_add_run_callback adds a callback to the list of callbacks used for
# running the user defined entrypoint function.
# Args: arg1 - The value of the state to match. Probably like:
#              "commandsubcommand" "function"
#       arg2 - The function to call.
PA_add_run_callback() {
  _PA[runcallbacks]+="$1,$2 "
}

# PA_run implements an interleaved state machine to process the
# user request. It allows for strict checking of arguments and args. All
# command line arguments are processed in order from left to right.
#
# Each COMMAND can have a different set of requirements which are controlled
# by setting the next state at each transition.
#
# --global-options COMMAND --command-options SUBCOMMAND --subcommand-options \
#  ARG1 --subcommand-options ARG2 --subcommand-options ...
#
# --global-options are those before COMMAND.
# --command-options can be after the COMMAND but before SUBCOMMAND.
# --subcommand-options can be anywhere after the SUBCOMMAND.
#
# Args: arg1-N - The arguments given to mok by the user on the command line
PA_run() {

  local retval=${OK}

  set -- "$@"
  local ARGN=$# ARGNUM=0 retval=0
  while [ "${ARGN}" -ne 0 ]; do
    case "$1" in
    --* | -*)
      _PA_process_option "$1" "$2" || {
        retval=$?
        if [[ ${retval} == "${_PA[shift]}" ]]; then
          ARGN=$((ARGN - 1))
          shift
        else
          return "${retval}"
        fi
      }
      ;;
    *)
      case "${_PA[state]}" in
      COMMAND)
        _PA_check_token "${1}" "COMMAND" "command"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid COMMAND, "%s".\n\n' "$1" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      SUBCOMMAND)
        _PA_check_token "$1" "SUBCOMMAND" "subcommand"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid SUBCOMMAND for %s, "%s".\n\n' "${_PA[command]}" "${1}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      ARG*)
        ((ARGNUM++))
        _PA_check_token "${1}" "ARG${ARGNUM}"
        [[ $? -eq ${ERROR} ]] && {
          PA_usage
          printf 'Invalid ARG1 for %s %s, "%s".\n\n' "${_PA[command]}" \
            "${_PA[subcommand]}" "${1}" >"${STDERR}"
          return "${ERROR}"
        }
        ;;
      END)
        PA_usage
        printf 'ERROR No more args expected, "%s" is unexpected for "%s %s"\n' \
          "${1}" "${_PA[command]}" "${_PA[subcommand]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      *)
        printf 'Internal ERROR. Invalid state "%s"\n' "${_PA[state]}" >"${STDERR}"
        return "${ERROR}"
        ;;
      esac
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done

  # Run the user defined entrypoint function:
  for item in ${_PA[runcallbacks]}; do
    IFS=, read -r stateval func <<<"${item}"
    [[ ${stateval} == "${_PA[command]}${_PA[subcommand]}" ]] && {
      eval "${func}" || retval=$?
      return "${retval}"
    }
  done

  PA_usage

  return "${OK}"
}

# PA_usage outputs help text for a single component if help was asked for when
# a command was specified, or for all components otherwise.
# Args: None expected.
PA_usage() {

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[usagecallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func}"
      return
    }
  done

  eval "${_PA[usage]}"
}

# Private Functions -----------------------------------------------------------

# PA_new sets the initial values for the PArser's associative array.
# Args: None expected.
_PA_new() {
  _PA[command]=
  _PA[subcommand]=
  _PA[state]="COMMAND"
  _PA[optscallbacks]=
  _PA[usagecallbacks]=
  _PA[statecallbacks]=
  _PA[runcallbacks]=
  # The return value if the caller asked for an extra shift:
  _PA[shift]=126
}

# _PA_check_token checks for a valid token in arg2 state. The logic is
# most easily understood by reading the full original version at:
# https://github.com/mclarkson/my-own-kind/blob/master/docs/package.md#scripted-cluster-creation-and-deletion
# This function is a reduction of all the check_xxx_token functions.
# Args: arg1 - the token to check.
#       arg2 - the current state.
#       arg3 - the state value to set, optional. This should only be sent
#              for command and subcommand states.
_PA_check_token() {

  local item

  if [[ -n ${_PA[subcommand]} ]]; then
    cmdsubcommand="${_PA[command]}${_PA[subcommand]}"
  elif [[ -n ${_PA[command]} && ${_PA[state]} != "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}$1"
  elif [[ -n ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand="${_PA[command]}"
  elif [[ -z ${_PA[command]} && ${_PA[state]} == "ARG"* ]]; then
    cmdsubcommand=
  else
    cmdsubcommand="$1"
  fi

  for item in ${_PA[statecallbacks]}; do
    IFS=, read -r state component newstate func <<<"${item}"
    [[ ${state} == "$2" ]] && {
      [[ ${component} == "${cmdsubcommand}" ]] && {
        [[ -n $3 ]] && _PA["$3"]="$1"
        _PA[state]="${newstate}"
        [[ -n ${func} ]] && {
          eval "${func} $1" || return
        }
        return "${OK}"
      }
    }
  done
}

# _PA_process_option checks that the user-provided option is valid for the
# command-subcommand or global states.
# Args: arg1 - The option to check.
#       arg2 - TODO The value of the option if present, optional.
_PA_process_option() {

  local item curcmdsubcmd

  curcmdsubcmd="${_PA[command]}${_PA[subcommand]}"

  for item in ${_PA[optscallbacks]}; do
    IFS=, read -r cmdsubcmd func <<<"${item}"
    [[ ${curcmdsubcmd} == "${cmdsubcmd}" ]] && {
      eval "${func} \"$1\" \"$2\""
      return $?
    }
  done

  return "${ERROR}"
}

# Initialise _PA
_PA_new

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GL - Globals

# Private Functions -----------------------------------------------------------

# GL_new sets the only global variables that should be in use anywhere.  The
# only other globals are the associative arrays. All the globals are constant
# (readonly) variables. Declare these globals, where needed, in other files
# so that shellcheck passes.
# Args: None expected.
_GL_new() {

  declare -rg MOKVERSION="0.8.19"
  declare -rg K8SVERSION="1.31.1"
  declare -rg GO_VERSION="1.23.2"

  # Returns, exit codes
  declare -rg OK=0
  declare -rg SUCCESS=0
  declare -rg ERROR=1
  declare -rg FAILURE=1

  # For setting flags
  declare -rg TRUE=1
  declare -rg FALSE=0

  # To signal main() to exit with SUCCESS in the PArser
  declare -rg STOP=2

  declare -rg STDOUT="/dev/stdout"
  declare -rg STDERR="/dev/stderr"

  # The following just keep shellcheck happy
  local dummy dumb
  dummy="${OK}"
  dummy="${ERROR}"
  dummy="${STOP}"
  dummy="${STDOUT}"
  dummy="${STDERR}"
  dummy="${TRUE}"
  dummy="${FALSE}"
  dummy="${SUCCESS}"
  dummy="${FAILURE}"
  dummy="${MOKVERSION}"
  dummy="${GO_VERSION}"
  dummy="${K8SVERSION}"
  dumb="${dummy}${dumb}"
}

# Initialise GL
_GL_new || exit 1

# vim helpers -----------------------------------------------------------------

# The following lines allow the use of '[C-i' and '[I' (do ':help [I') in vim.
#include buildimage.sh
#include containerutils.sh
#include createcluster.sh
#include deletecluster.sh
#include embed-dockerfile.sh
#include error.sh
#include exec.sh
#include getcluster.sh
#include main.sh
#include lib/parser.sh
#include util.sh
#include versions.sh

# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# ER - Error handling

# ER is an associative array that holds data specific to error handling.
declare -A ER

# Declare externally defined associative arrays -------------------------------

# Defined in GL (globals.sh)
declare ERROR TRUE STDERR

# Public Functions ------------------------------------------------------------

# ER_err outputs a stacktrace and returns ERROR status.
# Args: None expected.
ER_err() {

  # In case of error print the function call stack
  # No args expected

  [[ ${ER[errcalled]} == "${TRUE}" ]] && return "${ERROR}"
  ER[errcalled]="${TRUE}"
  local frame=0
  printf '\n' >"${STDERR}"
  while caller "${frame}"; do
    ((frame++))
  done | tac >"${STDERR}"
  printf '\n' >"${STDERR}"
  return "${ERROR}"
}

# err is a synonym for ER_err to aid with code readability.
err() {
  ER_err
  return
}

# Private Functions -----------------------------------------------------------

# ER_new sets the initial values for the ER associative array.
# Args: None expected.
_ER_new() {
  ER[errcalled]=
}

# Initialise ER
_ER_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# UT - Utilities

# _UT is an associative array that holds data specific to general utilities.
declare -A _UT

# Declare externally defined global variables ---------------------------------

declare OK STDERR FALSE TRUE

# Getters/Setters -------------------------------------------------------------

# UT_runlogfile getter outputs the value of _UT[runlogfile], which contains the
# name of the file written to when running UT_run_with_progress.
UT_runlogfile() {
  printf '%s' "${_UT[runlogfile]}"
}

# UT_tailf getter indicates whether a log will be shown in real-time during the
# 'run', TRUE, or not, FALSE.
# Args
UT_tailf() {
  printf '%s' "${_UT[tailf]}"
}

# UT_tailf setter indicates whether a log should be shown during the 'run',
# TRUE, or not, FALSE.
# Args: arg1 - Whether to tail, TRUE or FALSE.
UT_set_tailf() {
  _UT[tailf]="$1"
}

# UT_set_plain setter sets plain output, with no colour, animations, or UTF
# high byte characters.
# Args: arg1 - Whether to show plain output, TRUE or FALSE.
UT_set_plain() {
  _UT[plain]="$1"
  UT_disable_colours
}

# Public Functions ------------------------------------------------------------

# UT_disable_colours resets variables used for colourised output so that they
# contain no colour terminal escapes. Useful if stdin is not a terminal.
UT_disable_colours() {
  _UT[yellow]=
  _UT[green]=
  _UT[red]=
  _UT[normal]=
  _UT[probablysuccess]="PROBABLY SUCCESS (!)"
  _UT[success]="SUCCESS"
  _UT[failure]="FAIL"
}

# UT_run_with_progress displays a progress spinner, item text, and a tick or
# cross based on the exit code.
# Args: arg1   - the text to display.
#       arg2-N - remaining args are the program to run and its arguments.
UT_run_with_progress() {

  local displaytext=$1 retval int spinner=()

  _UT[runlogfile]=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }
  shift

  if [[ ${_UT[tailf]} == "${FALSE}" && ${_UT[plain]} == "${TRUE}" ]]; then

    # Output with no colours or spinny

    printf '%s' "${displaytext}"

    eval "$*" &>"${_UT[runlogfile]}"
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 0 ]]; then
      printf ' .. %s\n' "${_UT[success]}"
    else
      printf ' .. %s\n' "${_UT[failure]}"
    fi

  elif [[ ${_UT[tailf]} == "${FALSE}" ]]; then

    # Output with colours and spinny

    while read -r char; do
      spinner+=("${char}")
    done <<<"$(grep -o . <<<"${_UT[spinnerchars]}")"

    (
      eval "$*" &>"${_UT[runlogfile]}"
    ) &

    # Turn the cursor off
    tput civis

    # Start the spin animation
    printf ' %s' "${displaytext}"
    (while true; do
      for int in {0..3}; do
        printf '\r  %s ' "${spinner[int]}"
        sleep .1
      done
    done) &
    _UT[spinnerpid]=$!
    disown

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Kill the spinner
    kill "${_UT[spinnerpid]}" 2>/dev/null
    _UT[spinnerpid]=

    sleep .5

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\r  %s\n' "${_UT[probablysuccess]}"
    elif [[ ${retval} -eq 0 ]]; then
      printf '\r  %s\n' "${_UT[success]}"
    else
      printf '\r  %s\n' "${_UT[failure]}"
    fi

    # Restore the cursor
    tput cnorm
    sleep .5

  else

    # Tailf output

    printf 'COMMAND: %s\n\n' "$*"

    (
      eval "$*" &>/dev/stdout
    ) &
    sleep 1

    # Wait for the command to finish
    wait %1 2>/dev/null
    retval=$?

    # Mark success/fail
    if [[ ${retval} -eq 127 ]]; then
      # The job finished before we started waiting for it
      printf '\n\nSTATUS: OK - (Probably)\n\n'
    elif [[ ${retval} -eq 0 ]]; then
      printf '\n\nSTATUS: OK\n\n'
    else
      printf '\n\nSTATUS: FAIL\n\n'
    fi
  fi

  return "${retval}"
}

# UT_cleanup removes any artifacts that were created during execution.
# This is called by 'MA_cleanup' trap only.
UT_cleanup() {

  # Called when the script exits.

  local int

  # Kill the spinny, and anything else, if they're running
  if [[ ${_UT[tailf]} == "${FALSE}" ]]; then
    [[ -n ${_UT[spinnerpid]} ]] && {
      printf '%s\r  ✕%s\n' "${_UT[red]}" "${_UT[normal]}"
      kill "${_UT[spinnerpid]}"
    }
    # If progress spinner crashed make sure the cursor is shown
    [ -t 1 ] && tput cnorm
  else
    kill "${_UT[spinnerpid]}" &>/dev/null
  fi

  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _UT_new sets the initial values for the _UT associative array.
# Args: None expected.
_UT_new() {
  _UT[tailf]="${FALSE}"
  _UT[yellow]=$(tput setaf 3)
  _UT[green]=$(tput setaf 2)
  _UT[red]=$(tput setaf 1)
  _UT[normal]=$(tput sgr0)
  _UT[probablysuccess]="${_UT[yellow]}✓${_UT[normal]}"
  _UT[success]="${_UT[green]}✓${_UT[normal]}"
  _UT[failure]="${_UT[red]}✕${_UT[normal]}"
  _UT[runlogfile]=
  _UT[spinnerchars]="|/-\\"
  _UT[spinnerpid]=
}

# Initialise _UT
_UT_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# GC - Get Cluster

# _GC is an associative array that holds data specific to the get cluster command.
declare -A _GC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# GC_showheader getter outputs the value of the showheader array member.
GC_showheader() {
  printf '%s' "${_GC[showheader]}"
}

# GC_set_showheader setter sets the value of the showheader array member.
# If $TRUE the header will be shown, or $FALSE, then it won't be shown.
GC_set_showheader() {
  _GC[showheader]="$1"
}

# GC_set_clustername setter sets the cluster name to show information about.
GC_set_clustername() {
  _GC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# GC_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted. It is called by
# MA_cleanup.
GC_cleanup() {
  :
}

# GC_process_options checks if arg1 is in a list of valid get cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
GC_process_options() {

  case "$1" in
  -h | --help)
    GC_usage
    return "${STOP}"
    ;;
  *)
    GC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# GC_usage outputs help text for the create cluster component.
# It is called by PA_usage().
# Args: None expected.
GC_usage() {

  cat <<'EnD'
GET subcommands are:
 
  cluster(s) - list all mok managed clusters.
 
get cluster(s) options:
 
 Format:
  get cluster(s) [NAME]
  NAME        - (optional) The name of the cluster to get
                details about.

EnD
}

# GC_run gets information about cluster(s).
# This function is called in main.sh.
# Args: None expected.
GC_run() {

  _GC_sanity_checks || return

  local ids id info output labelkey
  local containerhostname containerip

  declare -a nodes

  ids=$(CU_get_cluster_container_ids "${_GC[clustername]}") || return

  if [[ -z ${ids} ]]; then
    printf 'No clusters found\n'
    return "${OK}"
  fi

  readarray -t nodes <<<"${ids}"

  # Use 'docker inspect' to get the value of the label $LABELKEY

  output=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  # Output the header
  [[ ${_GC[showheader]} -eq ${TRUE} ]] && {
    printf 'MOK_Cluster Docker_ID Container_Name IP_Address\n' >"${output}"
  }

  labelkey=$(CU_labelkey) || err || return

  for id in "${nodes[@]}"; do

    info=$(CU_get_container_info "${id}") || return

    clustname=$(JSONPath ".[0].Config.Labels.${labelkey}" -b <<<"${info}") ||
      err || return

    containerhostname=$(JSONPath '.[0].Config.Hostname' -b <<<"${info}") ||
      err || return

    containerip=$(JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}") ||
      err || return

    printf '%s %s %s %s\n' "${clustname}" "${id}" "${containerhostname}" "${containerip}"

  done | sort -k 3 >>"${output}"

  column -t "${output}" || err
}

# Private Functions -----------------------------------------------------------

# _GC_new sets the initial values for the _GC associative array.
# Args: None expected.
_GC_new() {
  _GC[showheader]="${TRUE}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "get" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "getcluster" "ARG1" ""
  PA_add_state "SUBCOMMAND" "getclusters" "ARG1" ""
  PA_add_state "ARG1" "getcluster" "END" "GC_set_clustername"
  PA_add_state "ARG1" "getclusters" "END" "GC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "get" "GC_process_options" || return
  PA_add_option_callback "getcluster" "GC_process_options" || return
  PA_add_option_callback "getclusters" "GC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "get" "GC_usage" || return
  PA_add_usage_callback "getcluster" "GC_usage" || return
  PA_add_usage_callback "getclusters" "GC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "getcluster" "GC_run"
  PA_add_run_callback "getclusters" "GC_run"
}

# GC_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_GC_sanity_checks() {

  # Only show the usage if we are in 'get' mode and have not specified a
  # subcommand. This allows internal code to call GC_run()
  if [[ $(PA_command) == "get" && -z $(PA_subcommand) ]]; then
    GC_usage
    exit "${OK}"
  fi
}

# Initialise _GC
_GC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# EX - EXec

# EX is an associative array that holds data specific to the exec cluster command.
declare -A _EX

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR TRUE STOP

# Getters/Setters -------------------------------------------------------------

# EX_set_containername setter sets the containername to be used to 'log in' to.
EX_set_containername() {
  _EX[containername]="$1"
}

# Public Functions ------------------------------------------------------------

# EX_process_options checks if arg1 is in a list of valid exec options. This
# function is called by the parser, via a callback in _EX_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
EX_process_options() {

  case "$1" in
  -h | --help)
    EX_usage
    return "${STOP}"
    ;;
  *)
    EX_usage
    printf 'ERROR: "%s" is not a valid "exec" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# EX_usage outputs help text for the create exec component.  It is called in
# this file and by PA_usage(), via a callback in _EX_new.
# Args: None expected.
EX_usage() {

  cat <<'EnD'
'Log in' to a container. EXEC has no subcommands.
 
exec options:
 
 Format:
  exec [NAME]
  NAME        - (optional) The name of the container to 'log in' to.
                If NAME is not given then the user will be offered
                a choice of containers to log in to. If there is only
                one cluster and one node then it will 'log in' to the
                only available container.

EnD
}

# Execs 'bash' in the container referenced by _EX[containername]. If just
# 'mok exec' is called without options then the user is offered a selection
# of existing clusters to exec into.
# Args: None expected.
# ---------------------------------------------------------------------------
EX_run() {

  _EX_sanity_checks || return

  local names int ans lines containernames gcoutput

  GC_set_showheader "${TRUE}" || err || return
  gcoutput=$(GC_run) || return
  names=$(printf '%s' "${gcoutput}" | awk '{ print $3; }')
  readarray -t containernames <<<"${names}"

  if [[ -n ${_EX[containername]} ]]; then

    # The caller gave a specific name for exec.
    # Check if the container name exists

    if grep -qs "^${_EX[containername]}$" <<<"${names}"; then
      _EX_exec "${_EX[containername]}" || return
      return "${OK}"
    else
      printf 'ERROR: Cannot exec into non-existent container: "%s".\n' \
        "${_EX[containername]}"
      return "${ERROR}"
    fi

  elif [[ ${#containernames[*]} == 2 ]]; then

    # If there's only one container just log into it without asking
    _EX_exec "${containernames[1]}"

  elif [[ ${#containernames[*]} == 1 ]]; then

    printf 'No containers found.\n'
    return "${OK}"

  else

    # The caller supplied no container name.
    # Present some choices

    printf 'Choose the container to log in to:\n\n'

    readarray -t lines <<<"${gcoutput}" || return

    # Print the header then print the items in the loop
    printf '   %s\n' "${lines[0]}"
    for int in $(seq 1 $((${#lines[*]} - 1))); do
      printf '%00d) %s\n' "${int}" "${lines[int]}"
    done | sort -k 4

    printf "\nChoose a number (Enter to cancel)> "
    read -r ans

    [[ -z ${ans} || ${ans} -lt 0 || ${ans} -gt $((${#lines[*]} - 1)) ]] && {
      printf '\nInvalid choice. Aborting.\n'
      return "${OK}"
    }

    _EX_exec "${containernames[ans]}"
  fi
}

# Private Functions -----------------------------------------------------------

# _EX_new sets the initial values for the _EX associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
_EX_new() {
  _EX[containername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "exec" "ARG1" ""
  PA_add_state "ARG1" "exec" "END" "EX_set_containername"

  # Set up the parser's option callbacks
  PA_add_option_callback "exec" "EX_process_options" || return
  PA_add_usage_callback "exec" "EX_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "exec" "EX_run"
}

# EX_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For exec this does nothing.
# Args: None expected.
_EX_sanity_checks() { :; }

# _EX_exec runs a command in a docker container using bash as the command by
# default.
# Args: arg1 - docker container name
#       arg2 - command to run
_EX_exec() {

  local cmd=${2:-bash}

  containerrt=$(CU_containerrt) || err || return

  read -rt 0.1
  if [[ ${containerrt} == "podman" ]]; then
    exec podman exec -ti "$1" "${cmd}"
  elif [[ ${containerrt} == "docker" ]]; then
    exec docker exec -ti "$1" "${cmd}"
  fi
}

# Initialise EX
_EX_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# DC - Delete Cluster

# _DC is an associative array that holds data specific to deleting a cluster.
declare -A _DC

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR STOP TRUE

# Getters/Setters -------------------------------------------------------------

# DC_set_clustername setter sets the cluster name to be deleted. This is
# called by the parser, via a callback in _DC_new.
DC_set_clustername() {
  _DC[clustername]="$1"
}

# Public Functions ------------------------------------------------------------

# DC_process_options checks if arg1 is in a list of valid delete cluster
# options. This function is called by the parser, via a callback in _DC_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
DC_process_options() {

  case "$1" in
  -h | --help)
    DC_usage
    return "${STOP}"
    ;;
  *)
    DC_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# DC_usage outputs help text for the create cluster component.
# It is called by PA_usage(), via a callback in _DC_new.
# Args: None expected.
DC_usage() {

  cat <<'EnD'
DELETE subcommands are:
 
  cluster - Delete a local kubernetes cluster.
 
delete cluster options:
 
 Format:
  delete cluster NAME
  NAME        - The name of the cluster to delete

EnD
}

# DC_run starts the delete cluster process.
# Args: None expected.
DC_run() {

  _DC_sanity_checks || return

  # Mutate functions make system changes.

  declare -i numnodes=0
  local id ids r

  numnodes=$(CU_get_cluster_size "${_DC[clustername]}") || return

  [[ ${numnodes} -eq 0 ]] && {
    printf '\nERROR: No cluster exists with name, "%s". Aborting.\n\n' \
      "${_DC[clustername]}" >"${STDERR}"
    return "${ERROR}"
  }

  ids=$(CU_get_cluster_container_ids "${_DC[clustername]}") || return

  printf 'The following containers will be deleted:\n\n'

  GC_set_showheader "${TRUE}"
  GC_set_clustername "${_DC[clustername]}"
  GC_run "${_DC[clustername]}" || return

  printf "\nAre you sure you want to delete the cluster? (y/N) >"

  read -r ans

  [[ ${ans} != "y" ]] && {
    printf '\nCancelling by user request.\n'
    return "${OK}"
  }

  printf '\n'

  for id in ${ids}; do
    UT_run_with_progress \
      "    Deleting id, '${id}' from cluster '${_DC[clustername]}'." \
      _DC_delete "${id}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n\n' >"${STDERR}"
      err
      return "${r}"
    }
  done

  printf '\n'
}

# Private Functions -----------------------------------------------------------

# _DC_new sets the initial values for the _DC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_DC_new() {
  _DC[clustername]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "delete" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "deletecluster" "ARG1" ""
  PA_add_state "ARG1" "deletecluster" "END" "DC_set_clustername"

  # Set up the parser's option callbacks
  PA_add_option_callback "delete" "DC_process_options" || return
  PA_add_option_callback "deletecluster" "DC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "delete" "DC_usage" || return
  PA_add_usage_callback "deletecluster" "DC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "deletecluster" "DC_run"
}

# DC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before DC_run is called.
# Args: None expected.
_DC_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    DC_usage
    exit "${OK}"
  fi

  if [[ -z ${_DC[clustername]} ]]; then
    DC_usage
    printf 'Please provide the Cluster NAME to delete.\n' >"${STDERR}"
    return "${ERROR}"
  fi
}

# _DC_delete stops and removes a docker container.
# Args: arg1 - docker id to delete.
_DC_delete() {

  docker stop -t 5 "${id}"
  docker rm "${id}" || err
}

# Initialise _DC
_DC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE K8SVERSION

# Getters/Setters -------------------------------------------------------------

# CC_set_clustername setter sets the clustername array item.
CC_clustername() {
  printf '%s' "${_CC[clustername]}"
}

# CC_publish getter outputs the publish array item.
CC_publish() {
  printf '%s' "${_CC[publish]}"
}

# CC-withlb getter outputs the withlb array item.
CC_withlb() {
  printf '%s' "${_CC[withlb]}"
}

# CC_set_clustername setter sets the clustername array item.
CC_set_clustername() {
  _CC[clustername]="$1"
}

# CC_set_nummasters setter sets the nummasters array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_nummasters() {
  _CC[nummasters]="$1"
}

# CC_set_numworkers setter sets the numworkers array item.
# This function is called by the parser, via a callback in _CC_new.
CC_set_numworkers() {
  _CC[numworkers]="$1"
}

# Public Functions ------------------------------------------------------------

# CC_process_options checks if arg1 is in a list of valid create cluster
# options. This function is called by the parser.
# Args: arg1 - the option to check.
#       arg2 - value of the option to be set, optional. This depends on the
#              type of option. For example, '--masters' should be sent
#              with a value but boolean options, like 'skiplbsetup' should not.
CC_process_options() {

  case "$1" in
  -h | --help)
    CC_usage
    return "${STOP}"
    ;;
  --skiplbsetup)
    _CC[skiplbsetup]="${TRUE}"
    return
    ;;
  --k8sver)
    _CC[k8sver]="$2"
    return "$(PA_shift)"
    ;;
  --with-lb)
    _CC[withlb]="${TRUE}"
    return
    ;;
  --skipmastersetup)
    _CC[skipmastersetup]="${TRUE}"
    return
    ;;
  --skipworkersetup)
    _CC[skipworkersetup]="${TRUE}"
    return
    ;;
  --masters)
    _CC[nummasters]="$2"
    return "$(PA_shift)"
    ;;
  --workers)
    _CC[numworkers]="$2"
    return "$(PA_shift)"
    ;;
  --tailf)
    _CC[tailf]="${TRUE}"
    return "${OK}"
    ;;
  --publish)
    _CC[publish]="${TRUE}"
    return
    ;;
  *)
    CC_usage
    printf 'ERROR: "%s" is not a valid "create" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# CC_usage outputs help text for the create cluster component.  It is called in
# this file and by PA_usage(), via a callback set in _CC_new.
# Args: None expected.
CC_usage() {

  cat <<'EnD'
CREATE subcommands are:
 
  cluster - Create a local kubernetes cluster.
 
create cluster [flags] options:
 
 Format:
  create cluster NAME [ [NUM_MASTERS] [NUM_WORKERS] ]
  NAME        - The name of the cluster. This will be used as
                the prefix in the name for newly created
                docker containers.
  NUM_MASTERS - The number of master containers.
  NUM_WORKERS - The number of worker containers. If NUM_WORKERS is
                zero then the 'node-role.kubernetes.io/master' taint
                will be removed from master nodes so that pods are
                schedulable.
 
 Flags:
  --skipmastersetup - Create the master container but don't set it
         up. Useful for manually installing kubernetes. Kubeadm, 
         kubelet and kubectl will be installed at the requested 
         version. With this option the worker will also be skipped.
         See also '--k8sver' flag.
  --skipworkersetup - The same as '--skipmastersetup', but skips
         setting up the worker only.
  --with-lb - Add a haproxy load balancer. The software will be installed
         and set up to reverse proxy to the master node(s), unless
         --skiplbsetup is used.
  --k8sver VERSION - Unimplemented.
  --masters NUM - The number of master containers to create.
  --workers NUM - The number of worker containers to create. When workers
                  is zero then the master node taint will be removed from
                  master nodes so that pods are schedulable on those nodes.
  --tailf - Show the log output whilst creating the cluster.
  --publish - Publish port 6443 for the master node, or the load balancer if
              it's enabled, for external kubectl access to the cluster. The IP
              address of the default route interface is added to the cert.


EnD
}

# CC_run creates the kubernetes cluster.
# Args: None expected.
CC_run() {

  _CC_sanity_checks || return

  [[ ${_CC[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  declare -i numnodes=0

  numnodes=$(CU_get_cluster_size "${_CC[clustername]}") || return

  [[ ${numnodes} -gt 0 ]] && {
    printf '\nERROR: Cluster, "%s", exists! Aborting.\n\n' "${_CC[clustername]}" \
      >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_create_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_create_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[withlb]} -eq ${TRUE} ]] && {
    _CC_setup_lb_node "${_CC[nummasters]}" || return
  }

  [[ ${_CC[nummasters]} -gt 0 ]] && {
    _CC_setup_master_nodes "${_CC[nummasters]}" || return
  }

  [[ ${_CC[numworkers]} -gt 0 ]] && {
    _CC_create_worker_nodes "${_CC[numworkers]}" || return
  }

  printf '\n'

  [[ -z ${_CC[skipmastersetup]} ]] && {
    printf 'Cluster, "%s", can be accessed using:\n\n' "${_CC[clustername]}"
    printf 'export KUBECONFIG=/var/tmp/admin-%s.conf\n\n' "${_CC[clustername]}"
  }

  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CC_new sets the initial values for the _CC associative array and sets up the
# parser ready for processing the command line arguments, options and usage.
# Args: None expected.
_CC_new() {
  _CC[tailf]="${FALSE}"
  _CC[skipmastersetup]=
  _CC[skipworkersetup]=
  _CC[skiplbsetup]=
  _CC[withlb]=
  _CC[clustername]=
  _CC[nummasters]=0
  _CC[numworkers]=0
  _CC[publish]=0
  _CC[k8sver]="${K8SVERSION}"

  # Program the parser's state machine
  PA_add_state "COMMAND" "create" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "createcluster" "ARG2" ""

  # Support for the legacy style of create (less to type):
  PA_add_state "ARG1" "createcluster" "ARG2" "CC_set_clustername"
  PA_add_state "ARG2" "createcluster" "ARG3" "CC_set_nummasters"
  PA_add_state "ARG3" "createcluster" "END" "CC_set_numworkers"

  # Set up the parser's option callbacks
  PA_add_option_callback "create" "CC_process_options" || return
  PA_add_option_callback "createcluster" "CC_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "create" "CC_usage" || return
  PA_add_usage_callback "createcluster" "CC_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "createcluster" "CC_run"
  PA_add_run_callback "createclusters" "CC_run"
}

# CC_sanity_checks is expected to run some quick and simple checks to see if it
# has it's main requirements before CC_run is called.
# Args: None expected.
_CC_sanity_checks() {

  declare -i host_max=0 cpus=0 should_be=0

  if [[ -z $(PA_subcommand) ]]; then
    CC_usage
    exit "${OK}"
  fi

  if [[ -z ${_CC[clustername]} ]]; then
    CC_usage
    printf 'Please provide the Cluster NAME to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[nummasters]} || ${_CC[nummasters]} -le 0 ]]; then
    CC_usage
    printf 'Please provide the number of Masters to create. Must be 1 or more.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ -z ${_CC[numworkers]} ]]; then
    CC_usage
    printf 'Please provide the number of Workers to create.\n' >"${STDERR}"
    return "${ERROR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/sys/net/nf_conntrack_max ]]; then
    host_max=$(cat /proc/sys/net/nf_conntrack_max)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    host_max=$(podman machine ssh cat /proc/sys/net/nf_conntrack_max)
  else
    printf '\nWARNING: /proc/sys/net/nf_conntrack_max not found.\n' >"${STDERR}"
    printf '         kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  if [[ $(CU_podmantype) == "native" && -e /proc/cpuinfo ]]; then
    cpus=$(grep -cw ^processor /proc/cpuinfo)
  elif [[ $(CU_podmantype) == "machine" ]]; then
    # Lazily assuming the file exists
    cpus=$(podman machine ssh cat /proc/cpuinfo | grep -cw ^processor)
  else
    printf '\nWARNING: /proc/cpuinfo not found.\n' >"${STDERR}"
    printf '         I have no idea how many CPUs I have\n' >"${STDERR}"
    printf '         and kube-proxy may not work.\n\n' >"${STDERR}"
  fi

  # These are the default values that kube-proxy expects:
  # conntrack:
  #   max: null
  #   maxPerCore: 32768
  #   min: 131072
  if [[ $((32768*cpus)) -lt 131072 ]]; then
    should_be=131072
  else
    should_be=$((32768*cpus))
  fi
  if [[ ${should_be} -ne $host_max ]]; then
    printf '\nERROR: /proc/sys/net/nf_conntrack_max should be set to %d.\n' \
      "${should_be}" >"${STDERR}"
    printf '     kube-proxy will not start with an incorrect nf_conntrack_max.\n' >"${STDERR}"
    printf '     To fix this, run the following command:\n\n' >"${STDERR}"
    if [[ ${_CU[podmantype]} == "native" ]]; then
      printf '       sudo sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
    elif [[ ${_CU[podmantype]} == "machine" ]]; then
      printf '       podman machine ssh sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
      printf '     If the above command fails, you may have to recreate the podman machine, for example:\n\n' >"${STDERR}"
      tput setaf 1 # red
      printf '     WARNING: The following commands will destroy your podman machine and all its data.\n' >"${STDERR}"
      printf '              All existing pods and containers will be gone.\n\n' >"${STDERR}"
      tput sgr0 # reset
      printf '       podman machine stop\n' >"${STDERR}"
      printf '       podman machine rm\n' >"${STDERR}"
      printf '       podman machine init --now --rootful --user-mode-networing\n' >"${STDERR}"
      printf '       podman machine ssh modprobe nf_conntrack\n' >"${STDERR}"
      printf '       podman machine ssh sysctl -w net.netfilter.nf_conntrack_max=%d\n\n' \
        "${should_be}" >"${STDERR}"
    else
      printf 'Internal ERROR. Invalid podman type.\n' >"${STDERR}"
      return "${ERROR}"
    fi
    
    printf 'Press ENTER to continue or CTRL-C to abort.\n' >"${STDERR}"
    read -r
    printf '\n' >"${STDERR}"
  fi
}

# _CC_create_master_nodes creates the master node containers.
# Args: arg1 - number of master nodes to create
_CC_create_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating master container, '${_CC[clustername]}-master-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-master-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }
  done

  return "${OK}"
}

# _CC_setup_master_nodes sets up the master node containers.
# Args: arg1 - number of master nodes to create
_CC_setup_master_nodes() {

  declare -i int=0 r

  local labelkey runlogfile lbaddr hostaddr
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-master-${int}'" \
      _CC_set_up_master_node "${_CC[clustername]}-master-${int}"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  done

  # For now, copy admin.conf from master to /var/tmp/admin-CLUSTERNAME.conf

  if [[ -z ${_CC[skipmastersetup]} ]]; then
    if [[ ${_CC[publish]} -eq ${TRUE} ]]; then
      # On MacOS we need to use localhost, on linux use the host IP
      if [[ $(CU_podmantype) == "native" ]]; then
        hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
      else
        hostaddr="localhost"
      fi
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${hostaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    elif [[ ${_CC[withlb]} -eq ${TRUE} ]]; then
      lbaddr=$(CU_get_container_ip "${_CC[clustername]}-lb") || err || return
      docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
        "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      sed -i 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${lbaddr}"'\2#' \
        "/var/tmp/admin-${_CC[clustername]}.conf"
    else
      [[ -n ${_CC[skipmastersetup]} ]] || {
        docker cp "${_CC[clustername]}-master-1:/etc/kubernetes/admin.conf" \
          "/var/tmp/admin-${_CC[clustername]}.conf" >/dev/null || err || return
      }
    fi

    chmod 666 "/var/tmp/admin-${_CC[clustername]}.conf" || {
      printf 'ERROR: Could not "chown 666 /var/tmp/admin-%s.conf"' "${_CC[clustername]}"
      err || return
    }
  fi

  return "${OK}"
}

# _CC_set_up_master_node calls the correct set up function based on the version
# Args: arg1 - the container ID to set up
_CC_set_up_master_node() {

  case "${_CC[k8sver]}" in
  "1.30.0" | "1.30.1" | "1.31.1")
    _CC_set_up_master_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# _CC_get_master_join_details uses 'docker exec' or 'podman exec' to run a
# script on the master to get CA hash, a token, and the master IP.  The caller
# can eval the output of this function to set the variables: cahash, token, and
# masterip. See also:
# https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-join/#token-based-discovery-with-ca-pinning
# Args: arg1 - id/name of master container
_CC_get_master_join_details() {

  local joinvarsfile master1ip

  joinvarsfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  master1ip=$(CU_get_container_ip "${_CC[clustername]}-master-1") || err || return

  cat <<EnD >"${joinvarsfile}"
#!/bin/bash
set -e

sed 's#\(server: https://\)[0-9.]*\(:.*\)#\1'"${master1ip}"'\2#' \
  /etc/kubernetes/super-admin.conf >/etc/kubernetes/admin2.conf

cahash=\$(openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | \
        openssl rsa -pubin -outform der 2>/dev/null | \
        openssl dgst -sha256 -hex | sed 's/^.* //')
token=\$(kubeadm token create --kubeconfig=/etc/kubernetes/admin2.conf 2>/dev/null)
ip=\$(ip ro get 8.8.8.8 | cut -d" " -f 7)

printf 'cahash=%s\ntoken=%s\nmasterip=%s' "\$cahash" "\$token" "\$ip"

exit 0
EnD

  docker cp "${joinvarsfile}" "$1":/root/joinvars.sh 2>"${STDERR}" ||
    err || return
  rm -f "${joinvarsfile}" 2>"${STDERR}" || err || return

  [[ -z ${_CC[skipworkersetup]} ]] && {
    docker exec "$1" bash /root/joinvars.sh 2>"${STDERR}" || err || return
  }

  return "${OK}"
}

# _CC_create_lb_node creates the load balancer node container.
# Args: None expected.
_CC_create_lb_node() {

  local labelkey runlogfile
  labelkey=$(CU_labelkey) || err || return

  # Create container
  UT_run_with_progress \
    "    Creating load balancer container, '${_CC[clustername]}-lb'" \
    CU_create_container \
    "${_CC[clustername]}-lb" \
    "${labelkey}=${_CC[clustername]}" \
    "${_CC[k8sver]}"

  [[ ${r} -ne 0 ]] && {
    runlogfile=$(UT_runlogfile) || err || return
    printf '\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
    printf '%s\n' "${runlogfile}" >"${STDERR}"
    return "${ERROR}"
  }

  return "${OK}"
}

# _CC_setup_lb_node sets up the load balancer node container.
# Args: None expected.
_CC_setup_lb_node() {

  local runlogfile

  # Set up
  [[ -z ${_CC[skiplbsetup]} ]] && {
    UT_run_with_progress \
      "    Setting up '${_CC[clustername]}-lb'" \
      _CC_set_up_lb_node_real "${_CC[clustername]}-lb"
    r=$?

    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
      printf '%s\n' "${runlogfile}" >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _CC_set_up_lb_node_real sets up the lb node.
# Args: arg1 - the container ID to set up
_CC_set_up_lb_node_real() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masteriplist=
  nl=
  gotamaster="${FALSE}"
  for idx in $(seq 1 "${_CC[nummasters]}"); do
    ip=$(CU_get_container_ip "${_CC[clustername]}-master-${idx}") || continue
    gotamaster="${TRUE}"
    masteriplist="${masteriplist}${nl}    server master-${idx} ${ip}:6443 check fall 3 rise 2"
    nl='\n'
  done

  [[ ${gotamaster} == "${FALSE}" ]] && {
    printf 'ERROR: Did not manage to get an IP address for any master nodes\n'
    err || return
  }

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

systemctl stop kubelet crio
systemctl disable kubelet crio

apt -y install haproxy

INTERNAL_IP=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")

cat <<EOF | tee /etc/haproxy/haproxy.cfg 
frontend kubernetes
    bind \$INTERNAL_IP:6443
    option tcplog
    mode tcp
    default_backend kubernetes-master-nodes
backend kubernetes-master-nodes
    mode tcp
    balance roundrobin
    option tcp-check
\$(echo -e "${masteriplist}")
EOF

systemctl restart haproxy
systemctl enable haproxy

EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# _CC_create_worker_nodes creates the worker nodes.
# Args: arg1 - number of worker nodes to create
_CC_create_worker_nodes() {

  local cahash token t masterip
  declare -i int=0

  [[ -n ${_CC[skipmastersetup]} ]] || {
    # Runs a script on master node to get details
    t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1") || {
      printf '\nERROR: Problem with "_CC_get_master_join_details".\n\n' >"${STDERR}"
      return "${ERROR}"
    }

    # Sets cahash, token, and masterip:
    eval "${t}"
  }

  local labelkey
  labelkey=$(CU_labelkey) || err || return

  for int in $(seq 1 "$1"); do
    UT_run_with_progress \
      "    Creating worker container, '${_CC[clustername]}-worker-${int}'" \
      CU_create_container \
      "${_CC[clustername]}-worker-${int}" \
      "${labelkey}=${_CC[clustername]}" \
      "${_CC[k8sver]}"
    r=$?
    [[ ${r} -ne 0 ]] && {
      runlogfile=$(UT_runlogfile) || err || return
      printf '\n'
      cat "${runlogfile}" >"${STDERR}"
      printf '\nERROR: Docker failed.\n' >"${STDERR}"
      return "${ERROR}"
    }

    [[ -n ${_CC[skipworkersetup]} || -n ${_CC[skipmastersetup]} ]] || {
      UT_run_with_progress \
        "    Setting up '${_CC[clustername]}-worker-${int}'" \
        _CC_set_up_worker_node "${_CC[clustername]}-worker-${int}" \
        "${cahash}" "${token}" "${masterip}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n' >"${STDERR}"
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Set up failed. See above, and also in the file:' >"${STDERR}"
        printf '%s\n' "${runlogfile}" >"${STDERR}"
        return "${ERROR}"
      }

      UT_run_with_progress \
        "    Waiting for system to become ready" \
        _CC_wait_for_cluster \
        "${_CC[clustername]}-master-1" \
        "${_CC[clustername]}-worker-${int}"
      r=$?
      [[ ${r} -ne 0 ]] && {
        runlogfile=$(UT_runlogfile) || err || return
        printf '\n'
        cat "${runlogfile}" >"${STDERR}"
        printf '\nERROR: Wait timed out.\n' >"${STDERR}"
        return "${ERROR}"
      }
    }
  done

  return "${OK}"
}

# _CC_wait_for_cluster runs a `kubectl` command in the master-1 container,
# which doesn't exit until the all pods are fully up and running before it
# returns.
# Args: arg1 - the master container name to log into
#       arg2 - the worker container name to wait for
_CC_wait_for_cluster() {

  local setupfile nl idx masteriplist

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  cat <<'EnD' >"${setupfile}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
found=0
for i in $(seq 1 20); do
  if kubectl get pods &>/dev/null; then
    found=1
    break
  fi
  sleep 1
done
[[ $found == 0 ]] && {
  printf '# kubectl get pods\n'
  kubectl get pods
  printf '\nWaited for 20 seconds for kubectl to work.\n'
  printf 'Kubectl cannot contact master. Aborting.\n'
  exit 1
}
counter=0
while ! kubectl get nodes | grep -qs "$1"; do
  ((counter++))
  [[ ${counter} -gt 60 ]] && {
    printf '# kubectl get nodes\n'
    kubectl get nodes
    printf '\nWaited for 2 minutes for node to appear in master. Aborting.\n'
    exit 1
  }
  sleep 2
done
counter=0
while kubectl get pods -A | tail -n +2 | awk '{ print $3; }' | grep -qs 0; do
  ((counter++))
  [[ ${counter} -gt 120 ]] && {
    printf '# kubectl get pods -A\n'
    kubectl get pods -A
    printf '\nWaited for 3 minutes for pods to be ready. Aborting.\n'
    exit 1
  }
  sleep 2
done
exit 0
EnD

  docker cp "${setupfile}" "$1":/root/wait.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/wait.sh "$2" || err
}

# _CC_set_up_worker_node calls the correct set up function based on the version.
# Args: arg1 - the container ID to set up
#       arg2 - the CA hash
#       arg3 - the token
#       arg4 - the master IP
_CC_set_up_worker_node() {

  case "${_CC[k8sver]}" in
  "1.30.0" | "1.30.1" | "1.31.1")
    _CC_set_up_worker_node_v1_30_0 "$@"
    ;;
  *)
    printf 'ERROR: Version not found, "%s".\n' "${_CC[k8sver]}" >"${STDERR}"
    err || return
    ;;
  esac
}

# Initialise _CC
_CC_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CC - Create Cluster - versions file

# CC is an associative array that holds data specific to creating a cluster.
declare -A _CC

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR TRUE

# _CC_set_up_master_node_v1_30_0 uses kubeadm to set up the master node.
# Args: arg1 - the container to set up.
_CC_set_up_master_node_v1_30_0() {

  local setupfile lbaddr certSANs="{}" certkey masternum t lbip
  # Set by _CC_get_master_join_details:
  local cahash token masterip

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  masternum="${1##*-}" # <- eg. for xxx-master-1, masternum=1

  if [[ ${_CC[skipmastersetup]} != "${TRUE}" ]]; then

    if [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -eq 1 ]]; then

      # This is the first master node

      # Sets cahash, token, and masterip:
      lbip=$(CU_get_container_ip "${_CC[clustername]}-lb")
      lbaddr=", '${lbip}'"
      uploadcerts="--upload-certs"
      certkey="CertificateKey: f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07"

    elif [[ ${_CC[withlb]} == "${TRUE}" && ${masternum} -ne 1 ]]; then

      # This is not the first master node, so join with the master
      # https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/

      # Keep trying to get join details until apiserver is ready or we run out of tries
      for try in $(seq 1 9); do
        # Runs a script on master node to get join details
        t=$(_CC_get_master_join_details "${_CC[clustername]}-master-1")
        retval=$?
        [[ ${retval} -eq 0 ]] && break
        [[ ${try} -eq 9 ]] && {
          printf '\nERROR: Problem with "_CC_get_master_join_details". Tried %d times\n\n' "${try}" \
            >"${STDERR}"
          return "${ERROR}"
        }
        sleep 5
      done
      eval "${t}"
    fi
  fi

  # Always set certSANs for the host whether we need it or not
  hostaddr=$(ip ro get 8.8.8.8 | cut -d" " -f 7) || err || return
  certSANs="
  certSANs: [ '${hostaddr}'${lbaddr}, '127.0.0.1', 'localhost' ]"

  # Write the file regardless, so the user can use it if required

  cat <<EnD >"${setupfile}"
# Disable ipv6
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1

# Use a custom configuration. Default config created from kubeadm with:
#   kubeadm config print init-defaults
# then edited.

ipaddr=\$(ip ro get default 8.8.8.8 | head -n 1 | cut -f 7 -d " ")
podsubnet="10.244.0.0/16"
servicesubnet="10.96.0.0/16"

cat <<EOF >kubeadm-init-defaults.yaml
apiVersion: kubeadm.k8s.io/v1beta4
bootstrapTokens:
- groups:
  - system:bootstrappers:kubeadm:default-node-token
  token: abcdef.0123456789abcdef
  ttl: 24h0m0s
  usages:
  - signing
  - authentication
kind: InitConfiguration
${certkey}
localAPIEndpoint:
  advertiseAddress: \$ipaddr
  bindPort: 6443
nodeRegistration:
  criSocket: unix:///var/run/crio/crio.sock
  imagePullPolicy: IfNotPresent
  imagePullSerial: true
  name: $1
  taints:
  - effect: NoSchedule
    key: node-role.kubernetes.io/control-plane
timeouts:
  controlPlaneComponentHealthCheck: 4m0s
  discovery: 5m0s
  etcdAPICall: 2m0s
  kubeletHealthCheck: 4m0s
  kubernetesAPICall: 1m0s
  tlsBootstrap: 5m0s
  upgradeManifests: 5m0s
---
apiServer: ${certSANs}
apiVersion: kubeadm.k8s.io/v1beta4
caCertificateValidityPeriod: 87600h0m0s
certificateValidityPeriod: 8760h0m0s
certificatesDir: /etc/kubernetes/pki
clusterName: ${_CC[clustername]}-cluster
controlPlaneEndpoint: ${lbaddr:-\$ipaddr}:6443
controllerManager: {}
dns: {}
encryptionAlgorithm: RSA-2048
etcd:
  local:
    dataDir: /var/lib/etcd
imageRepository: registry.k8s.io
kind: ClusterConfiguration
networking:
  dnsDomain: cluster.local
  podSubnet: \${podsubnet}
  serviceSubnet: \${servicesubnet}
proxy: {}
scheduler: {}
EOF

mkdir -p /mok
cp kubeadm-init-defaults.yaml /mok/kubeadm.yaml

if [[ -z "${masterip}" ]]; then
  # Run the preflight phase
  kubeadm init \\
    --ignore-preflight-errors Swap \\
    --config=kubeadm-init-defaults.yaml \\
    phase preflight

  # Set up the kubelet
  kubeadm init phase kubelet-start

  # Edit the kubelet configuration file
  echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
  sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

  # Tell kubeadm to carry on from here
  kubeadm init \\
    --config=kubeadm-init-defaults.yaml \\
    --ignore-preflight-errors Swap \\
    ${uploadcerts} \\
    --skip-phases=preflight,kubelet-start

  export KUBECONFIG=/etc/kubernetes/super-admin.conf

  # Flannel - 10.244.0.0./16
  kubectl apply -f /root/kube-flannel.yml
else
  kubeadm join ${masterip}:6443 \\
    --ignore-preflight-errors Swap \\
    --control-plane \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --certificate-key f8802e114ef118304e561c3acd4d0b543adc226b7a27f675f56564185ffe0c07
fi

systemctl enable kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  # Run the file
  [[ -z ${_CC[skipmastersetup]} ]] && {
    docker exec "$1" bash /root/setup.sh || err || return

    # Remove the taint if we're setting up a single node cluster

    [[ ${_CC[numworkers]} -eq 0 ]] && {

      removetaint=$(mktemp -p /var/tmp) || {
        printf 'ERROR: mktmp failed.\n' >"${STDERR}"
        return "${ERROR}"
      }

      # Write the file
      cat <<'EnD' >"${removetaint}"
export KUBECONFIG=/etc/kubernetes/super-admin.conf
kubectl taint nodes --all node-role.kubernetes.io/control-plane:NoSchedule-
EnD

      docker cp "${removetaint}" "$1":/root/removetaint.sh || err || {
        rm -f "${removetaint}"
        return "${ERROR}"
      }

      # Run the file
      docker exec "$1" bash /root/removetaint.sh || err
    }
  }

  return "${OK}"
}

# _CC_set_up_worker_node_v1_30_0 uses kubeadm to set up the worker node.
# Args: arg1 - the container to set up.
_CC_set_up_worker_node_v1_30_0() {

  local setupfile cahash="$2" token="$3" masterip="$4"

  setupfile=$(mktemp -p /var/tmp) || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    return "${ERROR}"
  }

  if [[ ${_CC[withlb]} == "${TRUE}" ]]; then
    masterip=$(CU_get_container_ip "${_CC[clustername]}-lb") || return
  fi

  cat <<EnD >"${setupfile}"
# Wait for the master API to become ready
while true; do
  curl -k https://${masterip}:6443/
  [[ \$? -eq 0 ]] && break
  sleep 1
done

# Do the preflight tests (ignoring swap error)
kubeadm join \\
  phase preflight \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    --ignore-preflight-errors Swap \\
    ${masterip}:6443

# Set up the kubelet
kubeadm join \\
  phase kubelet-start \\
    --token ${token} \\
    --discovery-token-ca-cert-hash sha256:${cahash} \\
    ${masterip}:6443 &

while true; do
  [[ -e /var/lib/kubelet/config.yaml ]] && break
    sleep 1
  done

# Edit the kubelet configuration file
echo "failSwapOn: false" >>/var/lib/kubelet/config.yaml
sed -i 's/cgroupDriver: systemd/cgroupDriver: cgroupfs/' /var/lib/kubelet/config.yaml

systemctl enable --now kubelet
EnD

  docker cp "${setupfile}" "$1":/root/setup.sh 2>"${STDERR}" || err || {
    rm -f "${setupfile}"
    return "${ERROR}"
  }

  docker exec "$1" bash /root/setup.sh || err
}

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# CU - Container Utilities

# _CU is an associative array that holds data specific to container utils.
declare -A _CU

# Declare externally defined variables ----------------------------------------

declare OK ERROR STDERR

# Getters/Setters -------------------------------------------------------------

# CU_containerrt getter outputs the container runtime (podman or docker)
# that has been chosen.
CU_containerrt() {
  printf '%s' "${_CU[containerrt]}"
}

# CU_imgprefix getter outputs the prefix to be used with docker build. For
# podman it is 'localhost/'. For docker it is empty.
CU_imgprefix() {
  printf '%s' "${_CU[imgprefix]}"
}

# CU_labelkey getter outputs the key value of the label that is applied to all
# cluster member's container labels for podman or docker.
CU_labelkey() {
  printf '%s' "${_CU[labelkey]}"
}

# CU_podmantype getter outputs the container runtime type (native or machine).
CU_podmantype() {
  printf '%s' "${_CU[podmantype]}"
}

# Public Functions ------------------------------------------------------------

# CU_cleanup removes artifacts that were created during execution. Currently
# this does nothing and this function could be deleted.
CU_cleanup() { :; }

# CU_get_cluster_container_ids outputs just the container IDs, one per line
# for any MOK cluster, unless arg1 is set, in which case just the IDs
# for the requested cluster name are output.
# Args: arg1 - The cluster name, optional.
CU_get_cluster_container_ids() {

  local value output

  [[ -n $1 ]] && value="=$1"

  output=$(docker ps -a -f label="${_CU[labelkey]}${value}" -q) || {
    printf 'ERROR: %s command failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  output=$(printf '%s' "${output}" | sed 's/$//')

  printf '%s' "${output}"

  return "${OK}"
}

# CU_get_cluster_size searches for an existing cluster using labels and outputs
# the number of containers in that cluster. All cluster nodes are labelled with
# "${_CU[labelkey]}=${CC[clustername]}"
# Args: arg1 - The cluster name to search for.
CU_get_cluster_size() {

  local output
  declare -a nodes

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Cluster name cannot be empty.\n' >"${STDERR}"
    err || return
  }

  output=$(CU_get_cluster_container_ids "$1") || err || return

  # readarray will read null as an array item so don't run
  # through readarray if it's null
  [[ -z ${output} ]] && {
    printf '0'
    return "${OK}"
  }

  # read the nodes array and delete blank lines
  readarray -t nodes <<<"${output}"

  printf '%d' "${#nodes[*]}"
}

# CU_get_container_ip outputs the IP address of the container.
# Args: arg1 - docker container id or container name to query.
CU_get_container_ip() {

  local info

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  info=$(CU_get_container_info "$1") || return
  JSONPath '.[0].NetworkSettings.Networks.*.IPAddress' -b <<<"${info}" ||
    err || return
}

# CU_get_container_info uses 'docker/podman inspect $id' to output
# container details.
# Args: arg1 - docker container id
CU_get_container_info() {

  [[ -z ${1} ]] && {
    printf 'INTERNAL ERROR: Container ID (arg1) cannot be empty.\n' >"${STDERR}"
    err || return
  }

  docker inspect "$1" || {
    printf 'ERROR: %s inspect failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_create_container creates and runs a container with settings suitable for
# running privileged containers that can manipulate cgroups.
# Args: arg1 - The string used to set the name and hostname.
#       arg2 - The label to assign to the container.
#       arg3 - The k8s base image version to use.
CU_create_container() {

  local imagename img allimgs systemd_always clustername parg pval

  [[ -z $1 || -z $2 || -z $3 ]] && {
    printf 'INTERNAL ERROR: Neither arg1, arg2 nor arg3 can be empty.\n' \
      >"${STDERR}"
    err || return
  }

  img=$(BI_baseimagename) || err || return

  local imglocal="${_CU[imgprefix]}local/${img}-v${3}"
  local imgremote="myownkind/${img}-v${3}"

  # Prefer a locally built container over one downloaded from a registry
  allimgs=$(docker images | tail -n +2) || {
    printf 'ERROR: %s returned an error\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }

  if echo "${allimgs}" | grep -qs "${imglocal}"; then
    imagename="${imglocal}"
  elif echo "${allimgs}" | grep -qs "${imgremote}"; then
    imagename="${imgremote}"
  else
    cat <<EnD
ERROR: No container base image found. Use either:

  $ mok build image
OR
  $ mok build image --get-prebuilt-image

Then try running 'mok create ...' again.
EnD
    return "${ERROR}"
  fi

  clustername=$(CC_clustername) || err || return

  if [[ ${_CU[containerrt]} == "podman" ]];
  then 
    docker network exists "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  else
    docker network inspect "${clustername}_network" >/dev/null 2>&1
    create_network=$?
  fi

  [[ ${create_network} -ne 0 ]] && {
    docker network create "${clustername}_network" || {
      printf 'ERROR: docker network create failed\n' >"${STDERR}"
      err || return
    }
  }

  # Docker does not have the --systemd option
  [[ ${_CU[containerrt]} == "podman" ]] && systemd_always="--systemd=always"

  [[ $(CC_publish) == "${TRUE}" ]] && {
    if [[ $(CC_withlb) == "${TRUE}" ]]; then
      if echo "$1" | grep -qs -- '-lb$'; then
        parg='-p'
        pval='6443:6443'
      fi
    else
      if echo "$1" | grep -qs -- '-master-1$'; then
        parg='-p'
        pval='6443:6443'
      fi
    fi
  }

  docker run --privileged ${systemd_always} \
    --network "${clustername}_network" \
    -v /lib/modules:/lib/modules:ro \
    --detach ${parg} ${pval} \
    --name "$1" \
    --hostname "$1" \
    --label "$2" \
    "${imagename}" \
    /usr/local/bin/entrypoint /lib/systemd/systemd log-level=info unit=sysinit.target || {
    printf 'ERROR: %s run failed\n' "${_CU[containerrt]}" >"${STDERR}"
    err || return
  }
}

# CU_podman_or_docker checks to see if docker and/or podman are installed and
# sets the imgprefix and containerrt array members accordingly. It also defines
# the docker function to run the detected container runtime. Podman is
# preferred if both are installed.
# Args: No args expected.
CU_podman_or_docker() {
  if type podman &>/dev/null; then
    _CU[imgprefix]="localhost/"
    _CU[containerrt]="podman"
    _CU_podman_checks || return

    # Override docker() to run podman
    # shellcheck disable=SC2317
    docker() {
      podman "$@"
    }
  elif type docker &>/dev/null; then
    _CU[imgprefix]=""
    _CU[containerrt]="docker"
    _CU_docker_checks || return
  else
    printf 'ERROR: Neither "podman" nor "docker" were found.\n' \
      >"${STDERR}"
    printf 'Please install one of "podman" or "docker".\nAborting.\n' \
      >"${STDERR}"
    return "${ERROR}"
  fi
  return "${OK}"
}

# Private Functions -----------------------------------------------------------

# _CU_docker_checks checks to see if the current user has permission to write
# to the docker socket. If not, it prints an error message and exits.
# Args: No args expected.
_CU_docker_checks() {
  if docker ps >/dev/stdout 2>&1 | grep -qs 'docker.sock.*permission denied'; then
    cat <<EnD >"${STDERR}"
Not enough permissions to write to 'docker.sock'.

Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  fi

  return "${OK}"
}

# _CU_podman_checks sets the _CU[podmantype] member to "native" or "machine"
# depending on whether this is linux or macos. We assume linux won't be using
# a podman machine, and macos will always be using a podman machine.
# Args: No args expected.
_CU_podman_checks() {
  local info running

  if [[ -e /proc/sys/kernel/hostname ]]; then
    # We're on linux
    _CU[podmantype]="native"
    _CU_podman_native_checks || return
  elif [[ -d /System/Library/CoreServices ]]; then
    # We're on macOS
    [[ $(id -u) -eq 0 ]] && {
      printf 'ERROR: Cannot run mok as root on macOS.\n' >"${STDERR}"
      exit "${ERROR}"
    }

    info=$(podman machine list --format json) || err || return
    running=$(JSONPath -b '..Running' <<<"${info}") || err || return

    if [[ ${running} == "true" ]]; then
      _CU[podmantype]="machine"
    else
      printf 'ERROR: Podman machine is not running. Aborting.\n' >"${STDERR}"
      exit "${ERROR}"
    fi

    # shellcheck disable=SC2317
    ip() {
      podman machine ssh ip "$@"
    }
  else
    printf 'ERROR: Unknown OS. Aborting.\n' >"${STDERR}"
    exit "${ERROR}"
  fi
}

# _CU_podman_native_checks checks to see if the current user is root. If not,
# it prints an error message and exits.
# Args: No args expected.
_CU_podman_native_checks() {
  [[ $(id -u) -ne 0 ]] && {
    cat <<EnD >"${STDERR}"
Please use 'sudo' to run this command.

$ sudo mok $(MA_program_args)

Or set up an alias, for example:

$ alias mok="sudo mok"

Then run the command again.
EnD
    exit "${ERROR}"
  }
}

# _CU_new sets the initial values for the Container Utils associative array.
# Args: None expected.
_CU_new() {
  _CU[imgprefix]=
  _CU[labelkey]="MokCluster"
  _CU[containerrt]=

  # _CU[podmantype] will only be set only if _CU[containerrt]=podman.
  # podmantype will be "native" or "machine".
  _CU[podmantype]=
}

# Initialise _CU
_CU_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
# shellcheck shell=bash disable=SC2148
# BI - Build Image

# _BI is an associative array that holds data specific to building an image.
declare -A _BI

# Declare externally defined variables ----------------------------------------

# Defined in GL (globals.sh)
declare OK ERROR STDERR STOP TRUE FALSE

# Getters/Setters -------------------------------------------------------------

# BI_setflag_useprebuiltimage setter sets the useprebuiltimage array item.
# This is called by the parser, via a callback in _BI_new.
BI_setflag_useprebuiltimage() {
  _BI[useprebuiltimage]="$1"
}

# BI_baseimagename getter outputs the value of the _BI[baseimagename].
# Args: None expected.
BI_baseimagename() {
  printf '%s' "${_BI[baseimagename]}"
}

# Public Functions ------------------------------------------------------------

# BI_usage outputs help text for the build image component.
# It is called by PA_usage(), via a callback in _BI_new.
# Args: None expected.
BI_usage() {

  # NOTE: This flag to be added back in the future
  # --get-prebuilt-image - Instead of building a 'node' image
  #        locally, download it from a container registry instead.

  cat <<'EnD'
BUILD subcommands are:
 
  image - Creates the docker 'mok-image' container image.
 
build image options:
 
 Format:
  build image

 Flags:
  --tailf - Show the build output whilst building.

EnD
}

# BI_cleanup removes temporary files created during the build.
# This function is called by the 'MA_cleanup' trap only.
# Args: None expected.
BI_cleanup() {
  [[ -e ${_BI[dockerbuildtmpdir]} ]] &&
    [[ ${_BI[dockerbuildtmpdir]} == "/var/tmp/"* ]] && {
    rm -rf "${_BI[dockerbuildtmpdir]}" || {
      printf 'ERROR: "rm -rf %s" failed.\n' "${_BI[dockerbuildtmpdir]}" \
        >"${STDERR}"
      err || return
    }
  }
}

# BI_check_valid_options checks if arg1 is in a list of valid build image
# options. This function is called by the parser, via a callback in _BI_new.
# Args: arg1 - the option to check.
#       arg2 - value of the item to be set, optional
BI_process_options() {

  case "$1" in
  -h | --help)
    BI_usage
    return "${STOP}"
    ;;
  --tailf)
    _BI[tailf]="${TRUE}"
    return "${OK}"
    ;;
  # NOTE: This flag to be added back in the future
  # --get-prebuilt-image)
  #   _BI[useprebuiltimage]="${TRUE}"
  #   return "${OK}"
  #   ;;
  *)
    BI_usage
    printf 'ERROR: "%s" is not a valid "build" option.\n' "${1}" \
      >"${STDERR}"
    return "${ERROR}"
    ;;
  esac
}

# BI_run builds the base image used for masters and workers.
# This function is called in main.sh.
# Args: None expected.
BI_run() {

  _BI_sanity_checks || return

  [[ ${_BI[tailf]} == "${TRUE}" ]] && {
    UT_set_tailf "${TRUE}" || err || return
  }

  local retval=0
  _BI_build_container_image
  retval=$?

  if [[ ${retval} -eq ${OK} ]]; then
    : # We only need the tick - no text
  else
    printf 'Image build failed\n' >"${STDERR}"
    err
  fi

  return "${retval}"
}

# Private Functions -----------------------------------------------------------

# _BI_new resets the initial values for the _BI associative array.
# Args: None expected.
_BI_new() {
  _BI[tailf]="${FALSE}"
  _BI[baseimagename]="mok-image"
  _BI[useprebuiltimage]="${FALSE}"
  _BI[dockerbuildtmpdir]=

  # Program the parser's state machine
  PA_add_state "COMMAND" "build" "SUBCOMMAND" ""
  PA_add_state "SUBCOMMAND" "buildimage" "END" ""

  # Set up the parser's option callbacks
  PA_add_option_callback "build" "BI_process_options" || return
  PA_add_option_callback "buildimage" "BI_process_options" || return

  # Set up the parser's usage callbacks
  PA_add_usage_callback "build" "BI_usage" || return
  PA_add_usage_callback "buildimage" "BI_usage" || return

  # Set up the parser's run callbacks
  PA_add_run_callback "buildimage" "BI_run"
}

# BI_sanity_checks is expected to run some quick and simple checks to
# see if it has all it's key components. For build image this does nothing.
# This function should not be deleted as it is called in main.sh.
# Args: None expected.
_BI_sanity_checks() {

  if [[ -z $(PA_subcommand) ]]; then
    BI_usage
    exit "${OK}"
  fi
}

# _BI_build_container_image creates the docker build directory in
# dockerbuildtmpdir then calls docker build to build the image.
# Args: No args expected.
_BI_build_container_image() {

  local cmd retval tagname buildargs text buildtype

  _BI_create_docker_build_dir || return

  buildargs=$(_BI_get_build_args_for_latest) || return
  tagname="${_BI[baseimagename]}-v${K8SVERSION}"

  local imgprefix
  imgprefix=$(CU_imgprefix) || err || return
  if [[ ${_BI[useprebuiltimage]} == "${FALSE}" ]]; then
    buildtype="create"
    cmd="docker build \
      -t "${imgprefix}local/${tagname}" \
      --force-rm \
      ${buildargs} \
      ${_BI[dockerbuildtmpdir]}/${_BI[baseimagename]}"
    text="Creating"
  else
    buildtype="download"
    cmd="docker pull myownkind/${tagname}"
    text="Downloading"
  fi

  UT_run_with_progress \
    "    ${text} base image, '${tagname}'" "${cmd}"

  retval=$?
  [[ ${retval} -ne ${OK} ]] && {
    local runlogfile
    runlogfile=$(UT_runlogfile) || err || return
    printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
    cat "${runlogfile}" >"${STDERR}"
    printf '\n' >"${STDERR}"
    return "${ERROR}"
  }

  [[ ${buildtype} == "create" ]] && {
    cmd="_BI_modify_container_image"

    UT_run_with_progress \
      "    Modifying base image (pulling kubernetes images)" "${cmd}"

    retval=$?
    [[ ${retval} -ne ${OK} ]] && {
      local runlogfile
      runlogfile=$(UT_runlogfile) || err || return
      printf 'ERROR: Docker returned an error, shown below\n\n' >"${STDERR}"
      cat "${runlogfile}" >"${STDERR}"
      printf '\n' >"${STDERR}"
      return "${ERROR}"
    }
  }

  return "${OK}"
}

# _BI_modify_container_image starts a container suitable for running kubernetes
# components (since the docker/podman build environment isn't suitable), makes
# some modifications and then 'commits' the image. The modifications allow
# `mok create ...` to complete more quickly.
# Args: No args expected.
_BI_modify_container_image() {

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify &>/dev/null
  docker rm mok-build-modify &>/dev/null

  CC_set_clustername "build" || err || return

  # Start container
  CU_create_container "mok-build-modify" "mok-build-modify" "${K8SVERSION}" ||
    return

  # Wait for crio to become ready
  printf '\n\n ** WAITING FOR CRIO TO BECOME READY **\n\n'
  while ! docker exec mok-build-modify systemctl status crio; do
    sleep 1
    [[ ${counter} -gt 10 ]] && {
      printf '\nERROR: CRI-O did not start after %d tries.\n' "${counter}"
      err || return
    }
    ((counter++))
  done

  # Modify container
  docker exec mok-build-modify kubeadm config images pull \
    --kubernetes-version "${K8SVERSION}" || err || return

  # Stop container
  docker stop -t 5 "mok-build-modify"

  # Write image
  local imgprefix tagname
  imgprefix=$(CU_imgprefix) || err || return
  tagname="${_BI[baseimagename]}-v${K8SVERSION}"
  docker commit mok-build-modify "${imgprefix}local/${tagname}" || err || return

  # Delete container, just in case it was left behind
  docker stop -t 5 mok-build-modify
  docker rm mok-build-modify || err || return

  return "${OK}"
}

# _BI_get_build_args_for_latest sets the buildargs variable that is added
# to the 'podman build ...' command line.  Only the latest version is built
# from scratch.  Earlier versions are downloaded using '--get-prebuilt-image'.
# Args: None expected
_BI_get_build_args_for_latest() {

  local buildargs

  buildargs="--build-arg GO_VERSION=${GO_VERSION}"

  printf '%s' "${buildargs}"
}

# _BI_create_docker_build_dir creates a docker build directory in
# /var/tmp/tmp.XXXXXXXX
# Args: None expected
_BI_create_docker_build_dir() {

  _BI[dockerbuildtmpdir]="$(mktemp -d -p /var/tmp)" || {
    printf 'ERROR: mktmp failed.\n' >"${STDERR}"
    err || return
  }

  # The following comments should not be removed or changed.
  # embed-dockerfile.sh adds a base64 encoded tarball and
  # unpacking code between them.

  #mok-image-tarball-start 
  cat <<EnD | base64 -d | tar xz -C "${_BI[dockerbuildtmpdir]}" 
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
EnD
  #mok-image-tarball-end
}

# Initialise _BI
_BI_new || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
#!/usr/bin/env bash

declare -A JSONPath

JSONPath_new() {
  JSONPath[DEBUG]=0
  JSONPath[INCLEMPTY]=0
  JSONPath[NOCASE]=0
  JSONPath[WHOLEWORD]=0
  JSONPath[FILE]=
  JSONPath[NO_HEAD]=0
  JSONPath[NORMALIZE_SOLIDUS]=0
  JSONPath[BRIEF]=0
  JSONPath[PASSTHROUGH]=0
  JSONPath[JSON]=0
  JSONPath[MULTIPASS]=0
  JSONPath[FLATTEN]=0
  JSONPath[STDINFILE]=/var/tmp/JSONPath.$$.stdin
  JSONPath[STDINFILE2]=/var/tmp/JSONPath.$$.stdin2
  JSONPath[PASSFILE]=/var/tmp/JSONPath.$$.pass1
  declare -a INDEXMATCH_QUERY
}

# JSONPath reads JSON from stdin and applies a JSON Path query.
# Args: arg1-N - command line arguments to be parsed.
JSONPath() {

  JSONPath_sanity_checks
  JSONPath_parse_options "$@"

  trap JSONPath_cleanup EXIT

  if [[ ${QUERY} == *'?(@'* ]]; then
    # This will be a multipass query

    [[ -n ${JSONPath[FILE]} ]] && JSONPath[STDINFILE]=${JSONPath[FILE]}
    [[ -z ${JSONPath[FILE]} ]] && cat >"${JSONPath[STDINFILE]}"

    while true; do
      JSONPath_tokenize_path
      JSONPath_create_filter

      JSONPath_tokenize | JSONPath_parse | JSONPath_filter |
        JSONPath_indexmatcher >"${JSONPath[PASSFILE]}" <"${JSONPath[STDINFILE]}"

      [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && {
        # replace filter expression with index sequence
        SET=$(sed -rn 's/.*[[,"]+([0-9]+)[],].*/\1/p' "${JSONPath[PASSFILE]}" | tr '\n' ,)
        SET=${SET%,}
        #QUERY=$(sed "s/?(@[^)]\+)/${SET}/" <<<"${QUERY}")
        # Testing:
        QUERY="${QUERY//\?\(@*)/${SET}}"
        [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "QUERY=${QUERY}" >/dev/stderr
        JSONPath_reset
        continue
      }

      JSONPath_flatten | JSONPath_json | JSONPath_brief <<<"${JSONPath[PASSFILE]}"

      break
    done

  else

    JSONPath_tokenize_path
    JSONPath_create_filter

    if [[ ${JSONPath[PASSTHROUGH]} -eq 1 ]]; then
      JSONPath[JSON]=1
      JSONPath_flatten | JSONPath_json
    elif [[ -z ${JSONPath[FILE]} ]]; then
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten | JSONPath_json | JSONPath_brief
    else
      JSONPath_tokenize | JSONPath_parse | JSONPath_filter | JSONPath_indexmatcher | JSONPath_flatten <"${JSONPath[FILE]}"
      JSONPath_json | JSONPath_brief
    fi

  fi
}

JSONPath_sanity_checks() {

  local binary

  # Reset some vars
  for binary in gawk grep sed; do
    if ! command -v "${binary}" >&/dev/null; then
      echo "ERROR: ${binary} binary not found in path. Aborting."
      exit 1
    fi
  done
}

JSONPath_reset() {

  # Reset some vars
  declare -a INDEXMATCH_QUERY
  PATHTOKENS=
  FILTER=
  OPERATOR=
  RHS=
  JSONPath[MULTIPASS]=0
}

JSONPath_cleanup() {

  [[ -e ${JSONPath[PASSFILE]} ]] && rm -f "${PASSFILE}"
  [[ -e ${JSONPath[STDINFILE2]} ]] && rm -f "${JSONPath[STDINFILE2]}"
  [[ -z ${JSONPath[FILE]} && -e ${JSONPath[STDINFILE]} ]] &&
    rm -f "${JSONPath[STDINFILE]}"
}

JSONPath_usage() {

  echo
  echo "Usage: JSONPath.sh [-b] [j] [-h] [-f FILE] [pattern]"
  echo
  echo "pattern - the JSONPath query. Defaults to '$.*' if not supplied."
  echo "-b      - Brief. Only show values."
  echo "-j      - JSON output."
  echo "-u      - Strip unnecessary leading path elements."
  echo "-i      - Case insensitive."
  echo "-p      - Pass-through to the JSON parser."
  echo "-w      - Match whole words only (for filter script expression)."
  echo "-f FILE - Read a FILE instead of stdin."
  echo "-h      - This help text."
  echo
}

JSONPath_parse_options() {

  set -- "$@"
  local ARGN=$#
  while [[ ${ARGN} -ne 0 ]]; do
    case $1 in
    -h)
      JSONPath_usage
      exit 0
      ;;
    -f)
      shift
      JSONPath[FILE]=$1
      ;;
    -i)
      JSONPath[NOCASE]=1
      ;;
    -j)
      JSONPath[JSON]=1
      ;;
    -n)
      JSONPath[NO_HEAD]=1
      ;;
    -b)
      JSONPath[BRIEF]=1
      ;;
    -u)
      JSONPath[FLATTEN]=1
      ;;
    -p)
      JSONPath[PASSTHROUGH]=1
      ;;
    -w)
      JSONPath[WHOLEWORD]=1
      ;;
    -s)
      JSONPath[NORMALIZE_SOLIDUS]=1
      ;;
    *)
      QUERY=$1
      ;;
    esac
    shift 1
    ARGN=$((ARGN - 1))
  done
  [[ -z ${QUERY} ]] && QUERY='$.*'
}

JSONPath_awk_egrep() {
  local pattern_string=$1

  gawk '{
    while ($0) {
      start=match($0, pattern);
      token=substr($0, start, RLENGTH);
      print token;
      $0=substr($0, start+RLENGTH);
    }
  }' pattern="${pattern_string}"
}

JSONPath_tokenize() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    ESCAPE='(\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
    ESCAPE='(\\\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
    CHAR='[^[:cntrl:]"\\\\]'
  fi

  local STRING="\"${CHAR}*(${ESCAPE}${CHAR}*)*\""
  local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'
  local KEYWORD='null|false|true'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  ${GREP} "${STRING}|${NUMBER}|${KEYWORD}|${SPACE}|." | grep -Ev "^${SPACE}$"
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

JSONPath_tokenize_path() {

  local GREP
  local ESCAPE
  local CHAR

  if echo "test string" | grep -Eao --color=never "test" >/dev/null 2>&1; then
    GREP='grep -Eao --color=never'
  else
    GREP='grep -Eao'
  fi

  if echo "test string" | grep -Eo "test" >/dev/null 2>&1; then
    CHAR='[^[:cntrl:]"\\]'
  else
    GREP=JSONPath_awk_egrep
  fi

  local WILDCARD='\*'
  local WORD='[ A-Za-z0-9_-]*'
  local INDEX="\\[${WORD}(:${WORD}){0,2}\\]"
  local INDEXALL='\[\*\]'
  local STRING="[\\\"'][^[:cntrl:]\\\"']*[\\\"']"
  local SET="\\[(${WORD}|${STRING})(,(${WORD}|${STRING}))*\\]"
  local FILTER='\?\(@[^)]+'
  local DEEPSCAN='\.\.'
  local SPACE='[[:space:]]+'

  # Force zsh to expand $A into multiple words
  local is_wordsplit_disabled
  is_wordsplit_disabled=$(unsetopt 2>/dev/null | grep -c '^shwordsplit$')
  if [[ ${is_wordsplit_disabled} != 0 ]]; then setopt shwordsplit; fi
  readarray -t PATHTOKENS < <(echo "${QUERY}" |
    ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
    grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$")
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    echo "grep -Eo '${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|.'" >/dev/stderr
    echo -n "TOKENISED QUERY="
    echo "${QUERY}" |
      ${GREP} "${INDEX}|${STRING}|${WORD}|${WILDCARD}|${FILTER}|${DEEPSCAN}|${SET}|${INDEXALL}|." |
      grep -Ev "^${SPACE}$|^\\.$|^\[$|^\]$|^'$|^\\\$$|^\)$" >/dev/stderr
  }
  if [[ ${is_wordsplit_disabled} != 0 ]]; then unsetopt shwordsplit; fi
}

# JSONPath_create_filter creates the filter from the user's query.
# Filter works in a single pass through the data, unless a filter (script)
#  expression is used, in which case two passes are required (MULTIPASS=1).
JSONPath_create_filter() {

  local len=${#PATHTOKENS[*]}

  local -i i=0
  local a query="^\[" comma=
  while [[ i -lt len ]]; do
    case "${PATHTOKENS[i]}" in
    '"')
      :
      ;;
    '..')
      query+="${comma}[^]]*"
      comma=
      ;;
    '[*]')
      query+="${comma}[^,]*"
      comma=","
      ;;
    '*')
      query+="${comma}(\"[^\"]*\"|[0-9]+[^],]*)"
      comma=","
      ;;
    '?(@'*)
      a=${PATHTOKENS[i]#?(@.}
      elem="${a%%[<>=!]*}"
      rhs="${a##*[<>=!]}"
      a="${a#${elem}}"
      elem="${elem//./[\",.]+}" # Allows child node matching
      operator="${a%${rhs}}"
      [[ -z ${operator} ]] && {
        operator="=="
        rhs=
      }
      if [[ ${rhs} == *'"'* || ${rhs} == *"'"* ]]; then
        case ${operator} in
        '==' | '=')
          OPERATOR=
          if [[ ${elem} == '?(@' ]]; then
            # To allow search on @.property such as:
            #   $..book[?(@.title==".*Book 1.*")]
            query+="${comma}[0-9]+[],][[:space:]\"]*${rhs//\"/}"
          else
            # To allow search on @ (this node) such as:
            #   $..reviews[?(@==".*Fant.*")]
            query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs//\"/}"
          fi
          FILTER="${query}"
          ;;
        '>=' | '>')
          OPERATOR=">"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=' | '<')
          OPERATOR="<"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      else
        case ${operator} in
        '==' | '=')
          OPERATOR=
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*${rhs}"
          FILTER="${query}"
          ;;
        '>=')
          OPERATOR="-ge"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '>')
          OPERATOR="-gt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<=')
          OPERATOR="-le"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        '<')
          OPERATOR="-lt"
          RHS="${rhs}"
          query+="${comma}[0-9]+,\"${elem}\"[],][[:space:]\"]*"
          FILTER="${query}"
          ;;
        *) return 1 ;;
        esac
      fi
      JSONPath[MULTIPASS]=1
      ;;
    "["*)
      if [[ ${PATHTOKENS[i]} =~ , ]]; then
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          # converts only one comma: s/("[^"]+),([^"]+")/\1`\2/g;s/"//g
          #a=$(echo $a | sed 's/\([[:alpha:]]*\)/"\1"/g')
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        fi
        query+="${comma}(${a//,/|})"
      elif [[ ${PATHTOKENS[i]} =~ : ]]; then
        if ! [[ ${PATHTOKENS[i]} =~ [0-9][0-9] || ${PATHTOKENS[i]} =~ :] ]]; then
          if [[ ${PATHTOKENS[i]#*:} =~ : ]]; then
            INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
            query+="${comma}[^,]*"
          else
            # Index in the range of 0-9 can be handled by regex
            query+="${comma}$(echo "${PATHTOKENS[i]}" |
              gawk '/:/ { a=substr($0,0,index($0,":")-1);
                         b=substr($0,index($0,":")+1,index($0,"]")-index($0,":")-1);
                         if(b>0) { print a ":" b-1 "]" };
                         if(b<=0) { print a ":]" } }' |
              sed 's/\([0-9]\):\([0-9]\)/\1-\2/;
                       s/\[:\([0-9]\)/[0-\1/;
                       s/\([0-9]\):\]/\1-9999999]/')"
          fi
        else
          INDEXMATCH_QUERY+=("${PATHTOKENS[i]}")
          query+="${comma}[^,]*"
        fi
      else
        a=${PATHTOKENS[i]#[}
        a=${a%]}
        if [[ ${a} =~ [[:alpha:]] ]]; then
          a=$(echo "${a}" | sed -r "s/[\"']//g;s/([^,]*)/\"\1\"/g")
        else
          [[ ${i} -gt 0 ]] && comma=","
        fi
        query+="${comma}${a}"
      fi
      comma=","
      ;;
    *)
      PATHTOKENS[i]=${PATHTOKENS[i]//\'/\"}
      query+="${comma}\"${PATHTOKENS[i]//\"/}\""
      comma=","
      ;;
    esac
    i=$((i + 1))
  done

  [[ -z ${FILTER} ]] && FILTER="${query}[],]"
  [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
}

JSONPath_parse_array() {

  local index=0
  local ary=''
  read -r token
  case "${token}" in
  ']') ;;

  *)
    while :; do
      JSONPath_parse_value "$1" "${index}"
      index=$((index + 1))
      ary="${ary}""${value}"
      read -r token
      case "${token}" in
      ']') break ;;
      ',') ary="${ary}," ;;
      *) JSONPath_throw "EXPECTED , or ] GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_object() {

  local key
  local obj=''
  read -r token
  case "${token}" in
  '}') ;;

  *)
    while :; do
      case "${token}" in
      '"'*'"') key=${token} ;;
      *) JSONPath_throw "EXPECTED string GOT ${token:-EOF}" ;;
      esac
      read -r token
      case "${token}" in
      ':') ;;
      *) JSONPath_throw "EXPECTED : GOT ${token:-EOF}" ;;
      esac
      read -r token
      JSONPath_parse_value "$1" "${key}"
      obj="${obj}${key}:${value}"
      read -r token
      case "${token}" in
      '}') break ;;
      ',') obj="${obj}," ;;
      *) JSONPath_throw "EXPECTED , or } GOT ${token:-EOF}" ;;
      esac
      read -r token
    done
    ;;
  esac
  value=
  :
}

JSONPath_parse_value() {

  local jpath="${1:+$1,}$2" isleaf=0 isempty=0 print=0
  case "${token}" in
  '{') JSONPath_parse_object "${jpath}" ;;
  '[') JSONPath_parse_array "${jpath}" ;;
    # At this point, the only valid single-character tokens are digits.
  '' | [!0-9]) JSONPath_throw "EXPECTED value GOT ${token:-EOF}" ;;
  *)
    value=${token}
    # if asked, replace solidus ("\/") in json strings with normalized value: "/"
    # Testing:
    #[ "${JSONPath[NORMALIZE_SOLIDUS]}" -eq 1 ] && value=$(echo "${value}" | sed 's#\\/#/#g')
    [[ ${JSONPath[NORMALIZE_SOLIDUS]} -eq 1 ]] && value=$(${value//\\\///})
    isleaf=1
    [[ ${value} == '""' ]] && isempty=1
    ;;
  esac
  [[ -z ${JSONPath[INCLEMPTY]} ]] && [[ ${value} == '' ]] && return
  [[ ${JSONPath[NO_HEAD]} -eq 1 ]] && [[ -z ${jpath} ]] && return

  [[ ${isleaf} -eq 1 ]] && [[ ${isempty} -eq 0 ]] && print=1
  [[ ${print} -eq 1 ]] && printf "[%s]\t%s\n" "${jpath}" "${value}"
  :
}

JSONPath_flatten() {

  local path a prevpath pathlen

  if [[ ${JSONPath[FLATTEN]} -eq 1 ]]; then
    cat >"${JSONPath[STDINFILE2]}"

    highest=9999

    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      [[ -z ${prevpath} ]] && {
        prevpath=("${path[@]}")
        highest=$((${#path[*]} - 1))
        continue
      }

      pathlen=$((${#path[*]} - 1))

      for i in $(seq 0 "${pathlen}"); do
        [[ ${path[i]} != "${prevpath[i]}" ]] && {
          high=${i}
          break
        }
      done

      [[ ${high} -lt ${highest} ]] && highest=${high}

      prevpath=("${path[@]}")
    done <"${JSONPath[STDINFILE2]}"

    if [[ ${highest} -gt 0 ]]; then
      sed -r 's/\[(([0-9]+|"[^"]+")[],]){'$((highest))'}(.*)/[\3/' \
        "${JSONPath[STDINFILE2]}"
    else
      cat "${JSONPath[STDINFILE2]}"
    fi
  else
    cat
  fi
}

# JSONPath_indexmatcher is for double digit or greater indexes match each line
# individually Single digit indexes are handled more efficiently by regex
JSONPath_indexmatcher() {

  local a b

  [[ ${JSONPath[DEBUG]} -eq 1 ]] && {
    for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
      echo "INDEXMATCH_QUERY[${i}]=${INDEXMATCH_QUERY[i]}" >/dev/stderr
    done
  }

  matched=1

  step=
  if [[ ${#INDEXMATCH_QUERY[*]} -gt 0 ]]; then
    while read -r line; do
      for i in $(seq 0 $((${#INDEXMATCH_QUERY[*]} - 1))); do
        [[ ${INDEXMATCH_QUERY[i]#*:} =~ : ]] && {
          step=${INDEXMATCH_QUERY[i]##*:}
          step=${step%]}
          INDEXMATCH_QUERY[i]="${INDEXMATCH_QUERY[i]%:*}]"
        }
        q=${INDEXMATCH_QUERY[i]:1:-1} # <- strip '[' and ']'
        a=${q%:*}                     # <- number before ':'
        b=${q#*:}                     # <- number after ':'
        [[ -z ${b} ]] && b=99999999999
        readarray -t num < <((grep -Eo '[0-9]+[],]' | tr -d ,]) <<<"${line}")
        if [[ ${num[i]} -ge ${a} && ${num[i]} -lt ${b} && matched -eq 1 ]]; then
          matched=1
          [[ ${i} -eq $((${#INDEXMATCH_QUERY[*]} - 1)) ]] && {
            if [[ ${step} -gt 1 ]]; then
              [[ $(((num[i] - a) % step)) -eq 0 ]] && {
                [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
                echo "${line}"
              }
            else
              [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo -n "(${a},${b},${num[i]}) " >/dev/stderr
              echo "${line}"
            fi
          }
        else
          matched=0
          continue
        fi
      done
      matched=1
    done
  else
    cat -
  fi
}

JSONPath_brief() {
  # Only show the value

  if [[ ${JSONPath[BRIEF]} -eq 1 ]]; then
    sed 's/^[^\t]*\t//;s/^"//;s/"$//;'
  else
    cat
  fi
}

JSONPath_json() {
  # Turn output into JSON

  local a tab="$'\t'"
  local UP=1 DOWN=2 SAME=3
  local prevpathlen=-1 prevpath=() path a
  declare -a closers

  if [[ ${JSONPath[JSON]} -eq 0 ]]; then
    cat -
  else
    while read -r line; do
      a=${line#[}
      a=${a%%]*}
      readarray -t path < <(grep -o "[^,]*" <<<"${a}")
      value=${line#*${tab}}

      # Not including the object itself (last item)
      pathlen=$((${#path[*]} - 1))

      # General direction

      direction=${SAME}
      [[ ${pathlen} -gt ${prevpathlen} ]] && direction=${DOWN}
      [[ ${pathlen} -lt ${prevpathlen} ]] && direction=${UP}

      # Handle jumps UP the tree (close previous paths)

      [[ ${prevpathlen} != -1 ]] && {
        for i in $(seq 0 $((pathlen - 1))); do
          [[ ${prevpath[i]} == "${path[i]}" ]] && continue
          [[ ${path[i]} != '"'* ]] && {
            # Testing double quotes:
            a="(${!arrays[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                arrays[k]=
              done
            }
            a="(${!comma[*]})"
            [[ -n ${a} ]] && {
              for k in $(seq $((i + 1)) "${a[-1]}"); do
                comma[k]=
              done
            }
            for j in $(seq $((prevpathlen)) -1 $((i + 2))); do
              arrays[j]=
              [[ -n ${closers[j]} ]] && {
                indent=$((j * 4))
                printf "\n%${indent}s${closers[j]}" ""
                unset "closers[j]"
                comma[j]=
              }
            done
            direction=${DOWN}
            break
          }
          direction=${DOWN}
          for j in $(seq $((prevpathlen)) -1 $((i + 1))); do
            arrays[j]=
            [[ -n ${closers[j]} ]] && {
              indent=$((j * 4))
              printf "\n%${indent}s${closers[j]}" ""
              unset "closers[j]"
              comma[j]=
            }
          done
          a="(${!arrays[*]})"
          [[ -n ${a} ]] && {
            for k in $(seq "${i}" "${a[-1]}"); do
              arrays[k]=
            done
          }
          break
        done
      }

      [[ ${direction} -eq ${UP} ]] && {
        [[ ${prevpathlen} != -1 ]] && comma[prevpathlen]=
        for i in $(seq $((prevpathlen + 1)) -1 $((pathlen + 1))); do
          arrays[i]=
          [[ -n ${closers[i]} ]] && {
            indent=$((i * 4))
            printf "\n%${indent}s${closers[i]}" ""
            unset "closers[i]"
            comma[i]=
          }
        done
        a="(${!arrays[*]})"
        [[ -n ${a} ]] && {
          for k in $(seq "${i}" "${a[-1]}"); do
            arrays[k]=
          done
        }
      }

      # Opening braces (the path leading up to the key)

      broken=
      for i in $(seq 0 $((pathlen - 1))); do
        [[ -z ${broken} && ${prevpath[i]} == "${path[i]}" ]] && continue
        [[ -z ${broken} ]] && {
          broken=${i}
          [[ ${prevpathlen} -ne -1 ]] && broken=$((i + 1))
        }
        if [[ ${path[i]} == '"'* ]]; then
          # Object
          [[ ${i} -ge ${broken} ]] && {
            indent=$((i * 4))
            printf "${comma[i]}%${indent}s{\n" ""
            closers[i]='}'
            comma[i]=
          }
          indent=$(((i + 1) * 4))
          printf "${comma[i]}%${indent}s${path[i]}:\n" ""
          comma[i]=",\n"
        else
          # Array
          if [[ ${arrays[i]} != 1 ]]; then
            indent=$((i * 4))
            printf "%${indent}s" ""
            echo "["
            closers[i]=']'
            arrays[i]=1
            comma[i]=
          else
            indent=$(((i + 1) * 4))
            printf "\n%${indent}s${closers[i - 1]}" ""
            direction=${DOWN}
            comma[i + 1]=",\n"
          fi
        fi
      done

      # keys & values

      if [[ ${path[-1]} == '"'* ]]; then
        # Object
        [[ ${direction} -eq ${DOWN} ]] && {
          indent=$((pathlen * 4))
          printf "${comma[pathlen]}%${indent}s{\n" ""
          closers[pathlen]='}'
          comma[pathlen]=
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${path[-1]}:${value}"
        comma[pathlen]=",\n"
      else
        # Array
        [[ ${arrays[i]} != 1 ]] && {
          indent=$(((pathlen - 0) * 4))
          printf "%${indent}s[\n" ""
          closers[pathlen]=']'
          comma[pathlen]=
          arrays[i]=1
        }
        indent=$(((pathlen + 1) * 4))
        printf "${comma[pathlen]}%${indent}s" ""
        echo -n "${value}"
        comma[pathlen]=",\n"
      fi

      prevpath=("${path[@]}")
      prevpathlen=${pathlen}
    done

    # closing braces

    for i in $(seq $((pathlen)) -1 0); do
      indent=$((i * 4))
      printf "\n%${indent}s${closers[i]}" ""
    done
    echo
  fi
}

JSONPath_filter() {
  # Apply the query filter

  local a tab=$'\t' v

  [[ ${JSONPath[NOCASE]} -eq 1 ]] && opts+="i"
  [[ ${JSONPath[WHOLEWORD]} -eq 1 ]] && opts+="w"
  if [[ -z ${OPERATOR} ]]; then
    [[ ${JSONPath[MULTIPASS]} -eq 1 ]] && FILTER="${FILTER}[\"]?$"
    grep "-E${opts}" "${FILTER}"
    [[ ${JSONPath[DEBUG]} -eq 1 ]] && echo "FILTER=${FILTER}" >/dev/stderr
  else
    grep "-E${opts}" "${FILTER}" |
      while read -r line; do
        v=${line#*${tab}}
        case ${OPERATOR} in
        '-ge')
          if gawk '{exit !($1>=$2)}' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-gt')
          if gawk '{exit !($1>$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-le')
          if gawk '{exit !($1<=$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '-lt')
          if gawk '{exit !($1<$2) }' <<<"${v} ${RHS}"; then echo "${line}"; fi
          ;;
        '>')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} > ${RHS,,} ]] && echo "${line}"
          ;;
        '<')
          v=${v#\"}
          v=${v%\"}
          RHS=${RHS#\"}
          RHS=${RHS%\"}
          [[ ${v,,} < ${RHS,,} ]] && echo "${line}"
          ;;
        *) return 1 ;;
        esac
      done
  fi
}

JSONPath_parse() {
  # Parses json

  read -r token
  JSONPath_parse_value
  read -r token
  case "${token}" in
  '') ;;
  *)
    JSONPath_throw "EXPECTED EOF GOT ${token}"
    exit 1
    ;;
  esac
}

JSONPath_throw() {
  echo "$*" >&2
  exit 1
}

JSONPath_new || exit 1

# vi: expandtab sw=2 ts=2
# shellcheck shell=bash disable=SC2148
# MA - execution starts here

# MA is an associative array that holds data specific to this file
declare -A _MA

# Defined in GL (globals.sh)
declare OK ERROR STOP STDERR TRUE

# Getters/Setters -------------------------------------------------------------

# MA_program_args getter outputs the program arguments sent by the user.
MA_program_args() {
  printf '%s' "${_MA[program_args]}"
}

# Public Functions ------------------------------------------------------------

# main is the start point for this application.
# Args: arg1-N - the command line arguments entered by the user.
MA_main() {
  local retval="${OK}"

  CU_podman_or_docker

  trap MA_cleanup EXIT
  MA_sanity_checks || return
  PA_run "$@" || retval=$?

  exit "${retval}"
}

# MA_version outputs the version information the exits.
MA_version() {
  printf 'Version: %s\n' "${MOKVERSION}"
  exit "${OK}"
}

# MA_process_global_options is called by the parser when a global option is
# encountered for processing.
# Args: arg1 - the global option that was found.
MA_process_global_options() {
  case "$1" in
  -h | --help)
    PA_usage
    return "${STOP}"
    ;;
  -p | --plain)
    UT_set_plain "${TRUE}"
    ;;
  *)
    printf 'INTERNAL ERROR: Invalid global option, "%s".' "$1"
    return "${ERROR}"
    ;;
  esac
}

# MA_cleanup is called from an EXIT trap only, when the program exits, and
# calls every other function matching the pattern '^.._cleanup'.
# Args: No args expected.
MA_cleanup() {
  local retval="${OK}" funcs func
  funcs=$(declare -F | awk '{print $NF;}' | grep '^.._cleanup')
  for func in ${funcs}; do
    [[ ${func} == "${FUNCNAME[0]}" ]] && continue
    eval "${func}" || retval=$?
  done
  return "${retval}"
}

# MA_sanity_checks is expected to run some quick and simple checks to
# see if key components are available before MA_main is called.
# Args: No args expected.
MA_sanity_checks() {

  local binary

  if [[ ${_CU[podmantype]} == "native" ]]; then
    binaries="gawk tac column tput grep sed ip cut"
  else
    binaries="gawk tac column tput grep sed cut"
  fi

  for binary in ${binaries}; do
    if ! command -v "${binary}" >&/dev/null; then
      printf 'ERROR: "%s" binary not found in path. Aborting.' "${binary}" \
        >"${STDERR}"
      return "${ERROR}"
    fi
  done

  # Disable terminal escapes (colours) if stdout is not a terminal
  [ -t 1 ] || UT_disable_colours
}

# MA_usage outputs help text for all components then quits with no error.  This
# is registered as a callback in the Parser, see _MA_new
# Args: None expected.
MA_usage() {

  cat <<'EnD'
Usage: mok [-h] <command> [subcommand] [ARGS...]
 
Global options:
  --help
  -h     - This help text
  --plain
  -p     - Plain output. No colours or animations.
 
Where command can be one of:
  create  - Add item(s) to the system.
  delete  - Delete item(s) from the system.
  build   - Build item(s) used by the system.
  get     - Get details about items in the system.
  exec    - 'Log in' to the container.
  version - Display version information.

For help on a specific command, run:
  mok <command> --help
EnD
}

# MA_new sets the initial values for the _MA associative array
_MA_new() {
  _MA[program_args]="$*"

  # Program the parser's state machine
  PA_add_state "COMMAND" "version" "END" "MA_version"

  # Set up the parser's option callbacks
  PA_add_option_callback "" "MA_process_global_options"

  # Set up the parser's usage callbacks
  PA_add_usage_callback "" "MA_usage"
}

# Initialise _MA
_MA_new "$@" || exit 1

# vim helpers -----------------------------------------------------------------
#include globals.sh
# vim:ft=sh:sw=2:et:ts=2:
if [ "$0" = "${BASH_SOURCE[0]}" ] || [ -z "${BASH_SOURCE[0]}" ]; then
  MA_main "$@"
fi
